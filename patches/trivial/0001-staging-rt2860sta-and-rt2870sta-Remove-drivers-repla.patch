From fefecc6989b4b24276797270c0e229c07be02ad3 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Fri, 8 Apr 2011 20:33:25 -0500
Subject: [PATCH] staging: rt2860sta and rt2870sta: Remove drivers replaced in
 net/wireless

The staging driver rt2860sta is replaced by mainline driver rt2800pci, and
rt2870sta is replaced by rt2800usb. As a result, the staging drivers are
deleted.

Modified, to Revert for v3.0.6

Tweaked-by: Robert Nelson <robertcnelson@gmail.com>

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
---
 drivers/staging/Kconfig                      |    4 -
 drivers/staging/Makefile                     |    2 -
 drivers/staging/rt2860/Kconfig               |   10 -
 drivers/staging/rt2860/Makefile              |   52 -
 drivers/staging/rt2860/TODO                  |   16 -
 drivers/staging/rt2860/ap.h                  |   68 -
 drivers/staging/rt2860/chip/mac_pci.h        |  355 --
 drivers/staging/rt2860/chip/mac_usb.h        |  345 --
 drivers/staging/rt2860/chip/rt2860.h         |   54 -
 drivers/staging/rt2860/chip/rt2870.h         |   46 -
 drivers/staging/rt2860/chip/rt3070.h         |   67 -
 drivers/staging/rt2860/chip/rt3090.h         |   72 -
 drivers/staging/rt2860/chip/rt30xx.h         |   47 -
 drivers/staging/rt2860/chip/rtmp_mac.h       | 1308 ------
 drivers/staging/rt2860/chip/rtmp_phy.h       |  516 ---
 drivers/staging/rt2860/chips/rt3070.c        |  169 -
 drivers/staging/rt2860/chips/rt3090.c        |  121 -
 drivers/staging/rt2860/chips/rt30xx.c        |  516 ---
 drivers/staging/rt2860/chlist.h              |  113 -
 drivers/staging/rt2860/common/action.c       |  606 ---
 drivers/staging/rt2860/common/action.h       |   56 -
 drivers/staging/rt2860/common/ba_action.c    | 1650 -------
 drivers/staging/rt2860/common/cmm_aes.c      | 1311 ------
 drivers/staging/rt2860/common/cmm_asic.c     | 2565 -----------
 drivers/staging/rt2860/common/cmm_cfg.c      |  258 --
 drivers/staging/rt2860/common/cmm_data.c     | 2361 ----------
 drivers/staging/rt2860/common/cmm_data_pci.c | 1096 -----
 drivers/staging/rt2860/common/cmm_data_usb.c |  951 ----
 drivers/staging/rt2860/common/cmm_info.c     |  955 ----
 drivers/staging/rt2860/common/cmm_mac_pci.c  | 1661 -------
 drivers/staging/rt2860/common/cmm_mac_usb.c  | 1162 -----
 drivers/staging/rt2860/common/cmm_sanity.c   | 1205 -----
 drivers/staging/rt2860/common/cmm_sync.c     |  718 ---
 drivers/staging/rt2860/common/cmm_tkip.c     |  833 ----
 drivers/staging/rt2860/common/cmm_wep.c      |  473 --
 drivers/staging/rt2860/common/cmm_wpa.c      | 3010 -------------
 drivers/staging/rt2860/common/crypt_hmac.c   |  187 -
 drivers/staging/rt2860/common/crypt_md5.c    |  339 --
 drivers/staging/rt2860/common/crypt_sha2.c   |  269 --
 drivers/staging/rt2860/common/dfs.c          |   68 -
 drivers/staging/rt2860/common/ee_efuse.c     |  351 --
 drivers/staging/rt2860/common/ee_prom.c      |  197 -
 drivers/staging/rt2860/common/eeprom.c       |   91 -
 drivers/staging/rt2860/common/mlme.c         | 6068 --------------------------
 drivers/staging/rt2860/common/rt_channel.c   | 1705 --------
 drivers/staging/rt2860/common/rt_rf.c        |  187 -
 drivers/staging/rt2860/common/rtmp_init.c    | 3536 ---------------
 drivers/staging/rt2860/common/rtmp_mcu.c     |  336 --
 drivers/staging/rt2860/common/rtmp_timer.c   |  302 --
 drivers/staging/rt2860/common/spectrum.c     | 2205 ----------
 drivers/staging/rt2860/crypt_hmac.h          |   65 -
 drivers/staging/rt2860/crypt_md5.h           |   73 -
 drivers/staging/rt2860/crypt_sha2.h          |   73 -
 drivers/staging/rt2860/dfs.h                 |   39 -
 drivers/staging/rt2860/eeprom.h              |   67 -
 drivers/staging/rt2860/iface/rtmp_pci.h      |   80 -
 drivers/staging/rt2860/iface/rtmp_usb.h      |  196 -
 drivers/staging/rt2860/mlme.h                | 1050 -----
 drivers/staging/rt2860/oid.h                 |  779 ----
 drivers/staging/rt2860/pci_main_dev.c        | 1192 -----
 drivers/staging/rt2860/rt_config.h           |   71 -
 drivers/staging/rt2860/rt_linux.c            | 1367 ------
 drivers/staging/rt2860/rt_linux.h            |  835 ----
 drivers/staging/rt2860/rt_main_dev.c         |  736 ----
 drivers/staging/rt2860/rt_pci_rbus.c         |  837 ----
 drivers/staging/rt2860/rt_usb.c              |  794 ----
 drivers/staging/rt2860/rtmp.h                | 4332 ------------------
 drivers/staging/rt2860/rtmp_chip.h           |  258 --
 drivers/staging/rt2860/rtmp_ckipmic.h        |   63 -
 drivers/staging/rt2860/rtmp_def.h            | 1427 ------
 drivers/staging/rt2860/rtmp_dot11.h          |  100 -
 drivers/staging/rt2860/rtmp_iface.h          |   75 -
 drivers/staging/rt2860/rtmp_mcu.h            |   49 -
 drivers/staging/rt2860/rtmp_os.h             |   90 -
 drivers/staging/rt2860/rtmp_timer.h          |  148 -
 drivers/staging/rt2860/rtmp_type.h           |   89 -
 drivers/staging/rt2860/rtusb_io.h            |  185 -
 drivers/staging/rt2860/spectrum.h            |  189 -
 drivers/staging/rt2860/spectrum_def.h        |  202 -
 drivers/staging/rt2860/sta/assoc.c           | 1602 -------
 drivers/staging/rt2860/sta/auth.c            |  517 ---
 drivers/staging/rt2860/sta/auth_rsp.c        |  142 -
 drivers/staging/rt2860/sta/connect.c         | 2613 -----------
 drivers/staging/rt2860/sta/rtmp_data.c       | 2552 -----------
 drivers/staging/rt2860/sta/sanity.c          |  362 --
 drivers/staging/rt2860/sta/sync.c            | 1968 ---------
 drivers/staging/rt2860/sta/wpa.c             |  374 --
 drivers/staging/rt2860/sta_ioctl.c           | 2912 ------------
 drivers/staging/rt2860/usb_main_dev.c        |  927 ----
 drivers/staging/rt2860/wpa.h                 |  390 --
 drivers/staging/rt2870/Kconfig               |    9 -
 drivers/staging/rt2870/Makefile              |   55 -
 drivers/staging/rt2870/TODO                  |   17 -
 drivers/staging/rt2870/aironet.h             |    1 -
 drivers/staging/rt2870/ap.h                  |    1 -
 drivers/staging/rt2870/chips/rt3070.c        |    1 -
 drivers/staging/rt2870/chips/rt30xx.c        |    1 -
 drivers/staging/rt2870/chlist.h              |    1 -
 drivers/staging/rt2870/common/acction.c      |    1 -
 drivers/staging/rt2870/common/action.c       |    1 -
 drivers/staging/rt2870/common/action.h       |    1 -
 drivers/staging/rt2870/common/ba_action.c    |    1 -
 drivers/staging/rt2870/common/cmm_aes.c      |    1 -
 drivers/staging/rt2870/common/cmm_asic.c     |    1 -
 drivers/staging/rt2870/common/cmm_cfg.c      |    1 -
 drivers/staging/rt2870/common/cmm_data.c     |    1 -
 drivers/staging/rt2870/common/cmm_data_usb.c |    1 -
 drivers/staging/rt2870/common/cmm_info.c     |    1 -
 drivers/staging/rt2870/common/cmm_mac_usb.c  |    1 -
 drivers/staging/rt2870/common/cmm_profile.c  |    1 -
 drivers/staging/rt2870/common/cmm_sanity.c   |    1 -
 drivers/staging/rt2870/common/cmm_sync.c     |    1 -
 drivers/staging/rt2870/common/cmm_tkip.c     |    1 -
 drivers/staging/rt2870/common/cmm_wep.c      |    1 -
 drivers/staging/rt2870/common/cmm_wpa.c      |    1 -
 drivers/staging/rt2870/common/crypt_hmac.c   |    1 -
 drivers/staging/rt2870/common/crypt_md5.c    |    1 -
 drivers/staging/rt2870/common/crypt_sha2.c   |    1 -
 drivers/staging/rt2870/common/dfs.c          |    1 -
 drivers/staging/rt2870/common/ee_efuse.c     |    1 -
 drivers/staging/rt2870/common/eeprom.c       |    1 -
 drivers/staging/rt2870/common/md5.c          |    1 -
 drivers/staging/rt2870/common/mlme.c         |    1 -
 drivers/staging/rt2870/common/rt_channel.c   |    1 -
 drivers/staging/rt2870/common/rt_rf.c        |    1 -
 drivers/staging/rt2870/common/rtmp_init.c    |    1 -
 drivers/staging/rt2870/common/rtmp_mcu.c     |    1 -
 drivers/staging/rt2870/common/rtmp_timer.c   |    1 -
 drivers/staging/rt2870/common/rtmp_tkip.c    |    1 -
 drivers/staging/rt2870/common/rtmp_wep.c     |    1 -
 drivers/staging/rt2870/common/rtusb_bulk.c   | 1232 ------
 drivers/staging/rt2870/common/rtusb_data.c   |  262 --
 drivers/staging/rt2870/common/rtusb_io.c     | 2104 ---------
 drivers/staging/rt2870/common/spectrum.c     |    1 -
 drivers/staging/rt2870/dfs.h                 |    1 -
 drivers/staging/rt2870/md5.h                 |    1 -
 drivers/staging/rt2870/mlme.h                |    1 -
 drivers/staging/rt2870/oid.h                 |    1 -
 drivers/staging/rt2870/rt28xx.h              |    1 -
 drivers/staging/rt2870/rt_config.h           |    1 -
 drivers/staging/rt2870/rt_linux.c            |    1 -
 drivers/staging/rt2870/rt_linux.h            |    1 -
 drivers/staging/rt2870/rt_main_dev.c         |    1 -
 drivers/staging/rt2870/rt_profile.c          |    1 -
 drivers/staging/rt2870/rt_usb.c              |    1 -
 drivers/staging/rt2870/rtmp.h                |    1 -
 drivers/staging/rt2870/rtmp_ckipmic.h        |    1 -
 drivers/staging/rt2870/rtmp_def.h            |    1 -
 drivers/staging/rt2870/rtmp_type.h           |    1 -
 drivers/staging/rt2870/spectrum.h            |    1 -
 drivers/staging/rt2870/spectrum_def.h        |    1 -
 drivers/staging/rt2870/sta/aironet.c         |    1 -
 drivers/staging/rt2870/sta/assoc.c           |    1 -
 drivers/staging/rt2870/sta/auth.c            |    1 -
 drivers/staging/rt2870/sta/auth_rsp.c        |    1 -
 drivers/staging/rt2870/sta/connect.c         |    1 -
 drivers/staging/rt2870/sta/rtmp_data.c       |    1 -
 drivers/staging/rt2870/sta/sanity.c          |    1 -
 drivers/staging/rt2870/sta/sync.c            |    1 -
 drivers/staging/rt2870/sta/wpa.c             |    1 -
 drivers/staging/rt2870/sta_ioctl.c           |    1 -
 drivers/staging/rt2870/usb_main_dev.c        |    1 -
 drivers/staging/rt2870/wpa.h                 |    1 -
 163 files changed, 0 insertions(+), 74159 deletions(-)
 delete mode 100644 drivers/staging/rt2860/Kconfig
 delete mode 100644 drivers/staging/rt2860/Makefile
 delete mode 100644 drivers/staging/rt2860/TODO
 delete mode 100644 drivers/staging/rt2860/ap.h
 delete mode 100644 drivers/staging/rt2860/chip/mac_pci.h
 delete mode 100644 drivers/staging/rt2860/chip/mac_usb.h
 delete mode 100644 drivers/staging/rt2860/chip/rt2860.h
 delete mode 100644 drivers/staging/rt2860/chip/rt2870.h
 delete mode 100644 drivers/staging/rt2860/chip/rt3070.h
 delete mode 100644 drivers/staging/rt2860/chip/rt3090.h
 delete mode 100644 drivers/staging/rt2860/chip/rt30xx.h
 delete mode 100644 drivers/staging/rt2860/chip/rtmp_mac.h
 delete mode 100644 drivers/staging/rt2860/chip/rtmp_phy.h
 delete mode 100644 drivers/staging/rt2860/chips/rt3070.c
 delete mode 100644 drivers/staging/rt2860/chips/rt3090.c
 delete mode 100644 drivers/staging/rt2860/chips/rt30xx.c
 delete mode 100644 drivers/staging/rt2860/chlist.h
 delete mode 100644 drivers/staging/rt2860/common/action.c
 delete mode 100644 drivers/staging/rt2860/common/action.h
 delete mode 100644 drivers/staging/rt2860/common/ba_action.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_aes.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_asic.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_cfg.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_data.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_data_pci.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_data_usb.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_info.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_mac_pci.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_mac_usb.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_sanity.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_sync.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_tkip.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_wep.c
 delete mode 100644 drivers/staging/rt2860/common/cmm_wpa.c
 delete mode 100644 drivers/staging/rt2860/common/crypt_hmac.c
 delete mode 100644 drivers/staging/rt2860/common/crypt_md5.c
 delete mode 100644 drivers/staging/rt2860/common/crypt_sha2.c
 delete mode 100644 drivers/staging/rt2860/common/dfs.c
 delete mode 100644 drivers/staging/rt2860/common/ee_efuse.c
 delete mode 100644 drivers/staging/rt2860/common/ee_prom.c
 delete mode 100644 drivers/staging/rt2860/common/eeprom.c
 delete mode 100644 drivers/staging/rt2860/common/mlme.c
 delete mode 100644 drivers/staging/rt2860/common/rt_channel.c
 delete mode 100644 drivers/staging/rt2860/common/rt_rf.c
 delete mode 100644 drivers/staging/rt2860/common/rtmp_init.c
 delete mode 100644 drivers/staging/rt2860/common/rtmp_mcu.c
 delete mode 100644 drivers/staging/rt2860/common/rtmp_timer.c
 delete mode 100644 drivers/staging/rt2860/common/spectrum.c
 delete mode 100644 drivers/staging/rt2860/crypt_hmac.h
 delete mode 100644 drivers/staging/rt2860/crypt_md5.h
 delete mode 100644 drivers/staging/rt2860/crypt_sha2.h
 delete mode 100644 drivers/staging/rt2860/dfs.h
 delete mode 100644 drivers/staging/rt2860/eeprom.h
 delete mode 100644 drivers/staging/rt2860/iface/rtmp_pci.h
 delete mode 100644 drivers/staging/rt2860/iface/rtmp_usb.h
 delete mode 100644 drivers/staging/rt2860/mlme.h
 delete mode 100644 drivers/staging/rt2860/oid.h
 delete mode 100644 drivers/staging/rt2860/pci_main_dev.c
 delete mode 100644 drivers/staging/rt2860/rt_config.h
 delete mode 100644 drivers/staging/rt2860/rt_linux.c
 delete mode 100644 drivers/staging/rt2860/rt_linux.h
 delete mode 100644 drivers/staging/rt2860/rt_main_dev.c
 delete mode 100644 drivers/staging/rt2860/rt_pci_rbus.c
 delete mode 100644 drivers/staging/rt2860/rt_usb.c
 delete mode 100644 drivers/staging/rt2860/rtmp.h
 delete mode 100644 drivers/staging/rt2860/rtmp_chip.h
 delete mode 100644 drivers/staging/rt2860/rtmp_ckipmic.h
 delete mode 100644 drivers/staging/rt2860/rtmp_def.h
 delete mode 100644 drivers/staging/rt2860/rtmp_dot11.h
 delete mode 100644 drivers/staging/rt2860/rtmp_iface.h
 delete mode 100644 drivers/staging/rt2860/rtmp_mcu.h
 delete mode 100644 drivers/staging/rt2860/rtmp_os.h
 delete mode 100644 drivers/staging/rt2860/rtmp_timer.h
 delete mode 100644 drivers/staging/rt2860/rtmp_type.h
 delete mode 100644 drivers/staging/rt2860/rtusb_io.h
 delete mode 100644 drivers/staging/rt2860/spectrum.h
 delete mode 100644 drivers/staging/rt2860/spectrum_def.h
 delete mode 100644 drivers/staging/rt2860/sta/assoc.c
 delete mode 100644 drivers/staging/rt2860/sta/auth.c
 delete mode 100644 drivers/staging/rt2860/sta/auth_rsp.c
 delete mode 100644 drivers/staging/rt2860/sta/connect.c
 delete mode 100644 drivers/staging/rt2860/sta/rtmp_data.c
 delete mode 100644 drivers/staging/rt2860/sta/sanity.c
 delete mode 100644 drivers/staging/rt2860/sta/sync.c
 delete mode 100644 drivers/staging/rt2860/sta/wpa.c
 delete mode 100644 drivers/staging/rt2860/sta_ioctl.c
 delete mode 100644 drivers/staging/rt2860/usb_main_dev.c
 delete mode 100644 drivers/staging/rt2860/wpa.h
 delete mode 100644 drivers/staging/rt2870/Kconfig
 delete mode 100644 drivers/staging/rt2870/Makefile
 delete mode 100644 drivers/staging/rt2870/TODO
 delete mode 100644 drivers/staging/rt2870/aironet.h
 delete mode 100644 drivers/staging/rt2870/ap.h
 delete mode 100644 drivers/staging/rt2870/chips/rt3070.c
 delete mode 100644 drivers/staging/rt2870/chips/rt30xx.c
 delete mode 100644 drivers/staging/rt2870/chlist.h
 delete mode 100644 drivers/staging/rt2870/common/acction.c
 delete mode 100644 drivers/staging/rt2870/common/action.c
 delete mode 100644 drivers/staging/rt2870/common/action.h
 delete mode 100644 drivers/staging/rt2870/common/ba_action.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_aes.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_asic.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_cfg.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_data.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_data_usb.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_info.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_mac_usb.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_profile.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_sanity.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_sync.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_tkip.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_wep.c
 delete mode 100644 drivers/staging/rt2870/common/cmm_wpa.c
 delete mode 100644 drivers/staging/rt2870/common/crypt_hmac.c
 delete mode 100644 drivers/staging/rt2870/common/crypt_md5.c
 delete mode 100644 drivers/staging/rt2870/common/crypt_sha2.c
 delete mode 100644 drivers/staging/rt2870/common/dfs.c
 delete mode 100644 drivers/staging/rt2870/common/ee_efuse.c
 delete mode 100644 drivers/staging/rt2870/common/eeprom.c
 delete mode 100644 drivers/staging/rt2870/common/md5.c
 delete mode 100644 drivers/staging/rt2870/common/mlme.c
 delete mode 100644 drivers/staging/rt2870/common/rt_channel.c
 delete mode 100644 drivers/staging/rt2870/common/rt_rf.c
 delete mode 100644 drivers/staging/rt2870/common/rtmp_init.c
 delete mode 100644 drivers/staging/rt2870/common/rtmp_mcu.c
 delete mode 100644 drivers/staging/rt2870/common/rtmp_timer.c
 delete mode 100644 drivers/staging/rt2870/common/rtmp_tkip.c
 delete mode 100644 drivers/staging/rt2870/common/rtmp_wep.c
 delete mode 100644 drivers/staging/rt2870/common/rtusb_bulk.c
 delete mode 100644 drivers/staging/rt2870/common/rtusb_data.c
 delete mode 100644 drivers/staging/rt2870/common/rtusb_io.c
 delete mode 100644 drivers/staging/rt2870/common/spectrum.c
 delete mode 100644 drivers/staging/rt2870/dfs.h
 delete mode 100644 drivers/staging/rt2870/md5.h
 delete mode 100644 drivers/staging/rt2870/mlme.h
 delete mode 100644 drivers/staging/rt2870/oid.h
 delete mode 100644 drivers/staging/rt2870/rt28xx.h
 delete mode 100644 drivers/staging/rt2870/rt_config.h
 delete mode 100644 drivers/staging/rt2870/rt_linux.c
 delete mode 100644 drivers/staging/rt2870/rt_linux.h
 delete mode 100644 drivers/staging/rt2870/rt_main_dev.c
 delete mode 100644 drivers/staging/rt2870/rt_profile.c
 delete mode 100644 drivers/staging/rt2870/rt_usb.c
 delete mode 100644 drivers/staging/rt2870/rtmp.h
 delete mode 100644 drivers/staging/rt2870/rtmp_ckipmic.h
 delete mode 100644 drivers/staging/rt2870/rtmp_def.h
 delete mode 100644 drivers/staging/rt2870/rtmp_type.h
 delete mode 100644 drivers/staging/rt2870/spectrum.h
 delete mode 100644 drivers/staging/rt2870/spectrum_def.h
 delete mode 100644 drivers/staging/rt2870/sta/aironet.c
 delete mode 100644 drivers/staging/rt2870/sta/assoc.c
 delete mode 100644 drivers/staging/rt2870/sta/auth.c
 delete mode 100644 drivers/staging/rt2870/sta/auth_rsp.c
 delete mode 100644 drivers/staging/rt2870/sta/connect.c
 delete mode 100644 drivers/staging/rt2870/sta/rtmp_data.c
 delete mode 100644 drivers/staging/rt2870/sta/sanity.c
 delete mode 100644 drivers/staging/rt2870/sta/sync.c
 delete mode 100644 drivers/staging/rt2870/sta/wpa.c
 delete mode 100644 drivers/staging/rt2870/sta_ioctl.c
 delete mode 100644 drivers/staging/rt2870/usb_main_dev.c
 delete mode 100644 drivers/staging/rt2870/wpa.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index ec9421a..196284d 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -50,10 +50,6 @@ source "drivers/staging/echo/Kconfig"
 
 source "drivers/staging/brcm80211/Kconfig"
 
-source "drivers/staging/rt2860/Kconfig"
-
-source "drivers/staging/rt2870/Kconfig"
-
 source "drivers/staging/comedi/Kconfig"
 
 source "drivers/staging/olpc_dcon/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index b5e2f3a..fa41b9c 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -18,8 +18,6 @@ obj-$(CONFIG_PRISM2_USB)	+= wlan-ng/
 obj-$(CONFIG_ECHO)		+= echo/
 obj-$(CONFIG_BRCMSMAC)		+= brcm80211/
 obj-$(CONFIG_BRCMFMAC)		+= brcm80211/
-obj-$(CONFIG_RT2860)		+= rt2860/
-obj-$(CONFIG_RT2870)		+= rt2870/
 obj-$(CONFIG_COMEDI)		+= comedi/
 obj-$(CONFIG_FB_OLPC_DCON)	+= olpc_dcon/
 obj-$(CONFIG_ASUS_OLED)		+= asus_oled/
diff --git a/drivers/staging/rt2860/Kconfig b/drivers/staging/rt2860/Kconfig
deleted file mode 100644
index f3a7e47..0000000
--- a/drivers/staging/rt2860/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-config RT2860
-	tristate "Ralink 2860/3090 wireless support"
-	depends on PCI && X86 && WLAN
-	select WIRELESS_EXT
-	select WEXT_PRIV
-	select CRC_CCITT
-	select FW_LOADER
-	---help---
-	  This is an experimental driver for the Ralink 2860 and 3090
-	  wireless chips.
diff --git a/drivers/staging/rt2860/Makefile b/drivers/staging/rt2860/Makefile
deleted file mode 100644
index 6dd0aa5..0000000
--- a/drivers/staging/rt2860/Makefile
+++ /dev/null
@@ -1,52 +0,0 @@
-obj-$(CONFIG_RT2860)	+= rt2860sta.o
-
-# TODO: all of these should be removed
-ccflags-y := -DLINUX -DAGGREGATION_SUPPORT -DPIGGYBACK_SUPPORT -DWMM_SUPPORT
-ccflags-y += -DRTMP_MAC_PCI -DRTMP_PCI_SUPPORT -DRT2860
-ccflags-y += -DRTMP_RF_RW_SUPPORT -DRTMP_EFUSE_SUPPORT -DRT30xx -DRT3090
-ccflags-y += -DDBG
-
-rt2860sta-y :=	\
-	common/crypt_md5.o	\
-	common/crypt_sha2.o	\
-	common/crypt_hmac.o	\
-	common/mlme.o		\
-	common/cmm_wep.o	\
-	common/action.o		\
-	common/cmm_data.o	\
-	common/rtmp_init.o	\
-	common/cmm_tkip.o	\
-	common/cmm_aes.o	\
-	common/cmm_sync.o	\
-	common/eeprom.o		\
-	common/cmm_sanity.o	\
-	common/cmm_info.o	\
-	common/cmm_cfg.o	\
-	common/cmm_wpa.o	\
-	common/dfs.o		\
-	common/spectrum.o	\
-	common/rtmp_timer.o	\
-	common/rt_channel.o	\
-	common/cmm_asic.o	\
-	sta/assoc.o		\
-	sta/auth.o		\
-	sta/auth_rsp.o		\
-	sta/sync.o		\
-	sta/sanity.o		\
-	sta/rtmp_data.o		\
-	sta/connect.o		\
-	sta/wpa.o		\
-	rt_linux.o		\
-	rt_main_dev.o		\
-	sta_ioctl.o		\
-	common/ba_action.o	\
-	pci_main_dev.o		\
-	rt_pci_rbus.o		\
-	common/cmm_mac_pci.o	\
-	common/cmm_data_pci.o	\
-	common/ee_prom.o	\
-	common/rtmp_mcu.o	\
-	common/ee_efuse.o	\
-	chips/rt30xx.o		\
-	common/rt_rf.o		\
-	chips/rt3090.o
diff --git a/drivers/staging/rt2860/TODO b/drivers/staging/rt2860/TODO
deleted file mode 100644
index 8e2f6ee..0000000
--- a/drivers/staging/rt2860/TODO
+++ /dev/null
@@ -1,16 +0,0 @@
-I'm hesitant to add a TODO file here, as the wireless developers would
-really have people help them out on the "clean" rt2860 driver that can
-be found at the http://rt2x00.serialmonkey.com/ site.
-
-But, if you wish to clean up this driver instead, here's a short list of
-things that need to be done to get it into a more mergable shape:
-
-TODO:
-	- checkpatch.pl clean
-	- sparse clean
-	- port to in-kernel 80211 stack and common rt2x00 infrastructure
-	- review by the wireless developer community
-
-Please send any patches or complaints about this driver to Greg
-Kroah-Hartman <greg@kroah.com> and don't bother the upstream wireless
-kernel developers about it, they want nothing to do with it.
diff --git a/drivers/staging/rt2860/ap.h b/drivers/staging/rt2860/ap.h
deleted file mode 100644
index 2737c0c..0000000
--- a/drivers/staging/rt2860/ap.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-Module Name:
-ap.h
-
-Abstract:
-Miniport generic portion header file
-
-Revision History:
-Who         When          What
---------    ----------    ----------------------------------------------
-Paul Lin    08-01-2002    created
-James Tan   09-06-2002    modified (Revise NTCRegTable)
-John Chang  12-22-2004    modified for RT2561/2661. merge with STA driver
-*/
-#ifndef __AP_H__
-#define __AP_H__
-
-/* ap_wpa.c */
-void WpaStateMachineInit(struct rt_rtmp_adapter *pAd,
-			 struct rt_state_machine *Sm,
-			 OUT STATE_MACHINE_FUNC Trans[]);
-
-#ifdef RTMP_MAC_USB
-void BeaconUpdateExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3);
-#endif /* RTMP_MAC_USB // */
-
-void RTMPSetPiggyBack(struct rt_rtmp_adapter *pAd, IN BOOLEAN bPiggyBack);
-
-void MacTableReset(struct rt_rtmp_adapter *pAd);
-
-struct rt_mac_table_entry *MacTableInsertEntry(struct rt_rtmp_adapter *pAd,
-				     u8 *pAddr,
-				     u8 apidx, IN BOOLEAN CleanAll);
-
-BOOLEAN MacTableDeleteEntry(struct rt_rtmp_adapter *pAd,
-			    u16 wcid, u8 *pAddr);
-
-struct rt_mac_table_entry *MacTableLookup(struct rt_rtmp_adapter *pAd,
-								u8 *pAddr);
-
-#endif /* __AP_H__ */
diff --git a/drivers/staging/rt2860/chip/mac_pci.h b/drivers/staging/rt2860/chip/mac_pci.h
deleted file mode 100644
index b8868a5..0000000
--- a/drivers/staging/rt2860/chip/mac_pci.h
+++ /dev/null
@@ -1,355 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	mac_pci.h
-
-    Abstract:
-
-    Revision History:
-    Who          	When            What
-    Justin P. Mattock	11/07/2010	Fix some typos
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __MAC_PCI_H__
-#define __MAC_PCI_H__
-
-#include "../rtmp_type.h"
-#include "rtmp_mac.h"
-#include "rtmp_phy.h"
-#include "../rtmp_iface.h"
-#include "../rtmp_dot11.h"
-
-/* */
-/* Device ID & Vendor ID related definitions, */
-/* NOTE: you should not add the new VendorID/DeviceID here unless you know for sure what chip it belongs too. */
-/* */
-#define NIC_PCI_VENDOR_ID		0x1814
-#define PCIBUS_INTEL_VENDOR	0x8086
-
-#if !defined(PCI_CAP_ID_EXP)
-#define PCI_CAP_ID_EXP			    0x10
-#endif
-#if !defined(PCI_EXP_LNKCTL)
-#define PCI_EXP_LNKCTL			    0x10
-#endif
-#if !defined(PCI_CLASS_BRIDGE_PCI)
-#define PCI_CLASS_BRIDGE_PCI		0x0604
-#endif
-
-#define TXINFO_SIZE						0
-#define RTMP_PKT_TAIL_PADDING			0
-#define fRTMP_ADAPTER_NEED_STOP_TX	0
-
-#define AUX_CTRL           0x10c
-
-/* */
-/* TX descriptor format, Tx     ring, Mgmt Ring */
-/* */
-struct PACKED rt_txd {
-	/* Word 0 */
-	u32 SDPtr0;
-	/* Word 1 */
-	u32 SDLen1:14;
-	u32 LastSec1:1;
-	u32 Burst:1;
-	u32 SDLen0:14;
-	u32 LastSec0:1;
-	u32 DMADONE:1;
-	/*Word2 */
-	u32 SDPtr1;
-	/*Word3 */
-	u32 rsv2:24;
-	u32 WIV:1;		/* Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correct position */
-	u32 QSEL:2;		/* select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA */
-	u32 rsv:2;
-	u32 TCO:1;		/* */
-	u32 UCO:1;		/* */
-	u32 ICO:1;		/* */
-};
-
-/* */
-/* Rx descriptor format, Rx Ring */
-/* */
-typedef struct PACKED rt_rxd {
-	/* Word 0 */
-	u32 SDP0;
-	/* Word 1 */
-	u32 SDL1:14;
-	u32 Rsv:2;
-	u32 SDL0:14;
-	u32 LS0:1;
-	u32 DDONE:1;
-	/* Word 2 */
-	u32 SDP1;
-	/* Word 3 */
-	u32 BA:1;
-	u32 DATA:1;
-	u32 NULLDATA:1;
-	u32 FRAG:1;
-	u32 U2M:1;		/* 1: this RX frame is unicast to me */
-	u32 Mcast:1;		/* 1: this is a multicast frame */
-	u32 Bcast:1;		/* 1: this is a broadcast frame */
-	u32 MyBss:1;		/* 1: this frame belongs to the same BSSID */
-	u32 Crc:1;		/* 1: CRC error */
-	u32 CipherErr:2;	/* 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid */
-	u32 AMSDU:1;		/* rx with 802.3 header, not 802.11 header. */
-	u32 HTC:1;
-	u32 RSSI:1;
-	u32 L2PAD:1;
-	u32 AMPDU:1;
-	u32 Decrypted:1;	/* this frame is being decrypted. */
-	u32 PlcpSignal:1;	/* To be moved */
-	u32 PlcpRssil:1;	/* To be moved */
-	u32 Rsv1:13;
-} RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
-
-typedef union _TX_ATTENUATION_CTRL_STRUC {
-	struct {
-		unsigned long RF_ISOLATION_ENABLE:1;
-		unsigned long Reserve2:7;
-		unsigned long PCIE_PHY_TX_ATTEN_VALUE:3;
-		unsigned long PCIE_PHY_TX_ATTEN_EN:1;
-		unsigned long Reserve1:20;
-	} field;
-
-	unsigned long word;
-} TX_ATTENUATION_CTRL_STRUC, *PTX_ATTENUATION_CTRL_STRUC;
-
-/* ----------------- EEPROM Related MACRO ----------------- */
-
-/* 8051 firmware image for RT2860 - base address = 0x4000 */
-#define FIRMWARE_IMAGE_BASE     0x2000
-#define MAX_FIRMWARE_IMAGE_SIZE 0x2000	/* 8kbyte */
-
-/* ----------------- Frimware Related MACRO ----------------- */
-#define RTMP_WRITE_FIRMWARE(_pAd, _pFwImage, _FwLen)			\
-	do {								\
-		unsigned long	_i, _firm;					\
-		RTMP_IO_WRITE32(_pAd, PBF_SYS_CTRL, 0x10000);		\
-									\
-		for (_i = 0; _i < _FwLen; _i += 4) {				\
-				_firm = _pFwImage[_i] +				\
-			   (_pFwImage[_i+3] << 24) +			\
-			   (_pFwImage[_i+2] << 16) +			\
-			   (_pFwImage[_i+1] << 8);			\
-			RTMP_IO_WRITE32(_pAd, FIRMWARE_IMAGE_BASE + _i, _firm);	\
-		}							\
-		RTMP_IO_WRITE32(_pAd, PBF_SYS_CTRL, 0x00000);		\
-		RTMP_IO_WRITE32(_pAd, PBF_SYS_CTRL, 0x00001);		\
-									\
-		/* initialize BBP R/W access agent */			\
-		RTMP_IO_WRITE32(_pAd, H2M_BBP_AGENT, 0);		\
-		RTMP_IO_WRITE32(_pAd, H2M_MAILBOX_CSR, 0);		\
-	} while (0)
-
-/* ----------------- TX Related MACRO ----------------- */
-#define RTMP_START_DEQUEUE(pAd, QueIdx, irqFlags)		do {} while (0)
-#define RTMP_STOP_DEQUEUE(pAd, QueIdx, irqFlags)		do {} while (0)
-
-#define RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk, freeNum, pPacket) \
-		((freeNum) >= (unsigned long)(pTxBlk->TotalFragNum + RTMP_GET_PACKET_FRAGMENTS(pPacket) + 3))	/* rough estimate we will use 3 more descriptor. */
-#define RTMP_RELEASE_DESC_RESOURCE(pAd, QueIdx)			do {} while (0)
-
-#define NEED_QUEUE_BACK_FOR_AGG(pAd, QueIdx, freeNum, _TxFrameType) \
-		(((freeNum != (TX_RING_SIZE-1)) && \
-		(pAd->TxSwQueue[QueIdx].Number == 0)) || (freeNum < 3))
-
-#define HAL_KickOutMgmtTx(_pAd, _QueIdx, _pPacket, _pSrcBufVA, _SrcBufLen)	\
-			RtmpPCIMgmtKickOut(_pAd, _QueIdx, _pPacket, _pSrcBufVA, _SrcBufLen)
-
-#define HAL_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)	\
-				/* RtmpPCI_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber) */
-
-#define HAL_WriteTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)	\
-			RtmpPCI_WriteSingleTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)
-
-#define HAL_WriteFragTxResource(pAd, pTxBlk, fragNum, pFreeNumber) \
-			RtmpPCI_WriteFragTxResource(pAd, pTxBlk, fragNum, pFreeNumber)
-
-#define HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, pFreeNumber) \
-			RtmpPCI_WriteMultiTxResource(pAd, pTxBlk, frameNum, pFreeNumber)
-
-#define HAL_FinalWriteTxResource(_pAd, _pTxBlk, _TotalMPDUSize, _FirstTxIdx)	\
-			RtmpPCI_FinalWriteTxResource(_pAd, _pTxBlk, _TotalMPDUSize, _FirstTxIdx)
-
-#define HAL_LastTxIdx(_pAd, _QueIdx, _LastTxIdx) \
-				/*RtmpPCIDataLastTxIdx(_pAd, _QueIdx,_LastTxIdx) */
-
-#define HAL_KickOutTx(_pAd, _pTxBlk, _QueIdx)	\
-			RTMP_IO_WRITE32((_pAd), TX_CTX_IDX0+((_QueIdx)*0x10), (_pAd)->TxRing[(_QueIdx)].TxCpuIdx)
-/*			RtmpPCIDataKickOut(_pAd, _pTxBlk, _QueIdx)*/
-
-#define HAL_KickOutNullFrameTx(_pAd, _QueIdx, _pNullFrame, _frameLen)	\
-			MiniportMMRequest(_pAd, _QueIdx, _pNullFrame, _frameLen)
-
-#define GET_TXRING_FREENO(_pAd, _QueIdx) \
-	(_pAd->TxRing[_QueIdx].TxSwFreeIdx > _pAd->TxRing[_QueIdx].TxCpuIdx)	? \
-			(_pAd->TxRing[_QueIdx].TxSwFreeIdx - _pAd->TxRing[_QueIdx].TxCpuIdx - 1) \
-			 :	\
-			(_pAd->TxRing[_QueIdx].TxSwFreeIdx + TX_RING_SIZE - _pAd->TxRing[_QueIdx].TxCpuIdx - 1);
-
-#define GET_MGMTRING_FREENO(_pAd) \
-	(_pAd->MgmtRing.TxSwFreeIdx > _pAd->MgmtRing.TxCpuIdx)	? \
-			(_pAd->MgmtRing.TxSwFreeIdx - _pAd->MgmtRing.TxCpuIdx - 1) \
-			 :	\
-			(_pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE - _pAd->MgmtRing.TxCpuIdx - 1);
-
-/* ----------------- RX Related MACRO ----------------- */
-
-/* ----------------- ASIC Related MACRO ----------------- */
-/* reset MAC of a station entry to 0x000000000000 */
-#define RTMP_STA_ENTRY_MAC_RESET(pAd, Wcid)	\
-	AsicDelWcidTab(pAd, Wcid);
-
-/* add this entry into ASIC RX WCID search table */
-#define RTMP_STA_ENTRY_ADD(pAd, pEntry)		\
-	AsicUpdateRxWCIDTable(pAd, pEntry->Aid, pEntry->Addr);
-
-/* add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
-/* Set MAC register value according operation mode */
-#define RTMP_UPDATE_PROTECT(pAd)	\
-	AsicUpdateProtect(pAd, 0, (ALLN_SETPROTECT), TRUE, 0);
-/* end johnli */
-
-/* remove Pair-wise key material from ASIC */
-#define RTMP_STA_ENTRY_KEY_DEL(pAd, BssIdx, Wcid)	\
-	AsicRemovePairwiseKeyEntry(pAd, BssIdx, (u8)Wcid);
-
-/* add Client security information into ASIC WCID table and IVEIV table */
-#define RTMP_STA_SECURITY_INFO_ADD(pAd, apidx, KeyID, pEntry)		\
-	RTMPAddWcidAttributeEntry(pAd, apidx, KeyID,			\
-							pAd->SharedKey[apidx][KeyID].CipherAlg, pEntry);
-
-#define RTMP_SECURITY_KEY_ADD(pAd, apidx, KeyID, pEntry)		\
-	{	/* update pairwise key information to ASIC Shared Key Table */	\
-		AsicAddSharedKeyEntry(pAd, apidx, KeyID,					\
-						  pAd->SharedKey[apidx][KeyID].CipherAlg,		\
-						  pAd->SharedKey[apidx][KeyID].Key,				\
-						  pAd->SharedKey[apidx][KeyID].TxMic,			\
-						  pAd->SharedKey[apidx][KeyID].RxMic);			\
-		/* update ASIC WCID attribute table and IVEIV table */			\
-		RTMPAddWcidAttributeEntry(pAd, apidx, KeyID,					\
-						  pAd->SharedKey[apidx][KeyID].CipherAlg,		\
-						  pEntry); }
-
-/* Insert the BA bitmap to ASIC for the Wcid entry */
-#define RTMP_ADD_BA_SESSION_TO_ASIC(_pAd, _Aid, _TID)	\
-		do {					\
-			u32 _Value = 0, _Offset;					\
-			_Offset = MAC_WCID_BASE + (_Aid) * HW_WCID_ENTRY_SIZE + 4;	\
-			RTMP_IO_READ32((_pAd), _Offset, &_Value);\
-			_Value |= (0x10000<<(_TID));	\
-			RTMP_IO_WRITE32((_pAd), _Offset, _Value);\
-		} while (0)
-
-/* Remove the BA bitmap from ASIC for the Wcid entry */
-/*              bitmap field starts at 0x10000 in ASIC WCID table */
-#define RTMP_DEL_BA_SESSION_FROM_ASIC(_pAd, _Wcid, _TID)				\
-		do {								\
-			u32 _Value = 0, _Offset;				\
-			_Offset = MAC_WCID_BASE + (_Wcid) * HW_WCID_ENTRY_SIZE + 4;	\
-			RTMP_IO_READ32((_pAd), _Offset, &_Value);			\
-			_Value &= (~(0x10000 << (_TID)));				\
-			RTMP_IO_WRITE32((_pAd), _Offset, _Value);			\
-		} while (0)
-
-/* ----------------- Interface Related MACRO ----------------- */
-
-/* */
-/* Enable & Disable NIC interrupt via writing interrupt mask register */
-/* Since it use ADAPTER structure, it have to be put after structure definition. */
-/* */
-#define RTMP_ASIC_INTERRUPT_DISABLE(_pAd)		\
-	do {			\
-		RTMP_IO_WRITE32((_pAd), INT_MASK_CSR, 0x0);     /* 0: disable */	\
-		RTMP_CLEAR_FLAG((_pAd), fRTMP_ADAPTER_INTERRUPT_ACTIVE);		\
-	} while (0)
-
-#define RTMP_ASIC_INTERRUPT_ENABLE(_pAd)\
-	do {				\
-		RTMP_IO_WRITE32((_pAd), INT_MASK_CSR, (_pAd)->int_enable_reg /*DELAYINTMASK*/);     /* 1:enable */	\
-		RTMP_SET_FLAG((_pAd), fRTMP_ADAPTER_INTERRUPT_ACTIVE);	\
-	} while (0)
-
-#define RTMP_IRQ_INIT(pAd)	\
-	{	pAd->int_enable_reg = ((DELAYINTMASK) |		\
-					(RxINT|TxDataInt|TxMgmtInt)) & ~(0x03);	\
-		pAd->int_disable_mask = 0;						\
-		pAd->int_pending = 0; }
-
-#define RTMP_IRQ_ENABLE(pAd)					\
-	{	/* clear garbage ints */			\
-		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, 0xffffffff);\
-		RTMP_ASIC_INTERRUPT_ENABLE(pAd); }
-
-/* ----------------- MLME Related MACRO ----------------- */
-#define RTMP_MLME_HANDLER(pAd)			MlmeHandler(pAd)
-
-#define RTMP_MLME_PRE_SANITY_CHECK(pAd)
-
-#define RTMP_MLME_STA_QUICK_RSP_WAKE_UP(pAd)	\
-		RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, 100);
-
-#define RTMP_MLME_RESET_STATE_MACHINE(pAd)	\
-		MlmeRestartStateMachine(pAd)
-
-#define RTMP_HANDLE_COUNTER_MEASURE(_pAd, _pEntry)\
-		HandleCounterMeasure(_pAd, _pEntry)
-
-/* ----------------- Power Save Related MACRO ----------------- */
-#define RTMP_PS_POLL_ENQUEUE(pAd)				EnqueuePsPoll(pAd)
-
-/* For RTMPPCIePowerLinkCtrlRestore () function */
-#define RESTORE_HALT		1
-#define RESTORE_WAKEUP		2
-#define RESTORE_CLOSE           3
-
-#define PowerSafeCID		1
-#define PowerRadioOffCID	2
-#define PowerWakeCID		3
-#define CID0MASK		0x000000ff
-#define CID1MASK		0x0000ff00
-#define CID2MASK		0x00ff0000
-#define CID3MASK		0xff000000
-
-#define RTMP_STA_FORCE_WAKEUP(pAd, bFromTx) \
-    RT28xxPciStaAsicForceWakeup(pAd, bFromTx);
-
-#define RTMP_STA_SLEEP_THEN_AUTO_WAKEUP(pAd, TbttNumToNextWakeUp) \
-    RT28xxPciStaAsicSleepThenAutoWakeup(pAd, TbttNumToNextWakeUp);
-
-#define RTMP_SET_PSM_BIT(_pAd, _val) \
-	MlmeSetPsmBit(_pAd, _val);
-
-#define RTMP_MLME_RADIO_ON(pAd) \
-    RT28xxPciMlmeRadioOn(pAd);
-
-#define RTMP_MLME_RADIO_OFF(pAd) \
-    RT28xxPciMlmeRadioOFF(pAd);
-
-#endif /*__MAC_PCI_H__ // */
diff --git a/drivers/staging/rt2860/chip/mac_usb.h b/drivers/staging/rt2860/chip/mac_usb.h
deleted file mode 100644
index e8158fb..0000000
--- a/drivers/staging/rt2860/chip/mac_usb.h
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-		mac_usb.h
-
-    Abstract:
-
-    Revision History:
-    Who          	When            What
-    Justin P. Mattock	11/07/2010	Fix a typo
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __MAC_USB_H__
-#define __MAC_USB_H__
-
-#include "../rtmp_type.h"
-#include "rtmp_mac.h"
-#include "rtmp_phy.h"
-#include "../rtmp_iface.h"
-#include "../rtmp_dot11.h"
-
-#define USB_CYC_CFG				0x02a4
-
-#define BEACON_RING_SIZE		2
-#define MGMTPIPEIDX			0	/* EP6 is highest priority */
-
-#define RTMP_PKT_TAIL_PADDING	11	/* 3(max 4 byte padding) + 4 (last packet padding) + 4 (MaxBulkOutsize align padding) */
-
-#define fRTMP_ADAPTER_NEED_STOP_TX		\
-		(fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_HALT_IN_PROGRESS |	\
-		 fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_BULKOUT_RESET | \
-		 fRTMP_ADAPTER_RADIO_OFF | fRTMP_ADAPTER_REMOVE_IN_PROGRESS)
-
-/* */
-/* RXINFO appends at the end of each rx packet. */
-/* */
-#define RXINFO_SIZE				4
-#define RT2870_RXDMALEN_FIELD_SIZE	4
-
-typedef struct PACKED rt_rxinfo {
-	u32 BA:1;
-	u32 DATA:1;
-	u32 NULLDATA:1;
-	u32 FRAG:1;
-	u32 U2M:1;		/* 1: this RX frame is unicast to me */
-	u32 Mcast:1;		/* 1: this is a multicast frame */
-	u32 Bcast:1;		/* 1: this is a broadcast frame */
-	u32 MyBss:1;		/* 1: this frame belongs to the same BSSID */
-	u32 Crc:1;		/* 1: CRC error */
-	u32 CipherErr:2;	/* 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid */
-	u32 AMSDU:1;		/* rx with 802.3 header, not 802.11 header. */
-	u32 HTC:1;
-	u32 RSSI:1;
-	u32 L2PAD:1;
-	u32 AMPDU:1;		/* To be moved */
-	u32 Decrypted:1;
-	u32 PlcpRssil:1;
-	u32 CipherAlg:1;
-	u32 LastAMSDU:1;
-	u32 PlcpSignal:12;
-} RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
-
-/* */
-/* TXINFO */
-/* */
-#define TXINFO_SIZE				4
-
-struct rt_txinfo {
-	/* Word 0 */
-	u32 USBDMATxPktLen:16;	/*used ONLY in USB bulk Aggregation,  Total byte counts of all sub-frame. */
-	u32 rsv:8;
-	u32 WIV:1;		/* Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correct position */
-	u32 QSEL:2;		/* select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA */
-	u32 SwUseLastRound:1;	/* Software use. */
-	u32 rsv2:2;		/* Software use. */
-	u32 USBDMANextVLD:1;	/*used ONLY in USB bulk Aggregation, NextValid */
-	u32 USBDMATxburst:1;	/*used ONLY in USB bulk Aggre. Force USB DMA transmit frame from current selected endpoint */
-};
-
-/* */
-/* Management ring buffer format */
-/* */
-struct rt_mgmt {
-	BOOLEAN Valid;
-	u8 *pBuffer;
-	unsigned long Length;
-};
-
-/*////////////////////////////////////////////////////////////////////////// */
-/* The struct rt_tx_buffer structure forms the transmitted USB packet to the device */
-/*////////////////////////////////////////////////////////////////////////// */
-struct rt_tx_buffer {
-	union {
-		u8 WirelessPacket[TX_BUFFER_NORMSIZE];
-		struct rt_header_802_11 NullFrame;
-		struct rt_pspoll_frame PsPollPacket;
-		struct rt_rts_frame RTSFrame;
-	} field;
-	u8 Aggregation[4];	/*Buffer for save Aggregation size. */
-};
-
-struct rt_httx_buffer {
-	union {
-		u8 WirelessPacket[MAX_TXBULK_SIZE];
-		struct rt_header_802_11 NullFrame;
-		struct rt_pspoll_frame PsPollPacket;
-		struct rt_rts_frame RTSFrame;
-	} field;
-	u8 Aggregation[4];	/*Buffer for save Aggregation size. */
-};
-
-/* used to track driver-generated write irps */
-struct rt_tx_context {
-	void *pAd;		/*Initialized in MiniportInitialize */
-	PURB pUrb;		/*Initialized in MiniportInitialize */
-	PIRP pIrp;		/*used to cancel pending bulk out. */
-	/*Initialized in MiniportInitialize */
-	struct rt_tx_buffer *TransferBuffer;	/*Initialized in MiniportInitialize */
-	unsigned long BulkOutSize;
-	u8 BulkOutPipeId;
-	u8 SelfIdx;
-	BOOLEAN InUse;
-	BOOLEAN bWaitingBulkOut;	/* at least one packet is in this TxContext, ready for making IRP anytime. */
-	BOOLEAN bFullForBulkOut;	/* all tx buffer are full , so waiting for tx bulkout. */
-	BOOLEAN IRPPending;
-	BOOLEAN LastOne;
-	BOOLEAN bAggregatible;
-	u8 Header_802_3[LENGTH_802_3];
-	u8 Rsv[2];
-	unsigned long DataOffset;
-	u32 TxRate;
-	dma_addr_t data_dma;	/* urb dma on linux */
-
-};
-
-/* used to track driver-generated write irps */
-struct rt_ht_tx_context {
-	void *pAd;		/*Initialized in MiniportInitialize */
-	PURB pUrb;		/*Initialized in MiniportInitialize */
-	PIRP pIrp;		/*used to cancel pending bulk out. */
-	/*Initialized in MiniportInitialize */
-	struct rt_httx_buffer *TransferBuffer;	/*Initialized in MiniportInitialize */
-	unsigned long BulkOutSize;	/* Indicate the total bulk-out size in bytes in one bulk-transmission */
-	u8 BulkOutPipeId;
-	BOOLEAN IRPPending;
-	BOOLEAN LastOne;
-	BOOLEAN bCurWriting;
-	BOOLEAN bRingEmpty;
-	BOOLEAN bCopySavePad;
-	u8 SavedPad[8];
-	u8 Header_802_3[LENGTH_802_3];
-	unsigned long CurWritePosition;	/* Indicate the buffer offset which packet will be inserted start from. */
-	unsigned long CurWriteRealPos;	/* Indicate the buffer offset which packet now are writing to. */
-	unsigned long NextBulkOutPosition;	/* Indicate the buffer start offset of a bulk-transmission */
-	unsigned long ENextBulkOutPosition;	/* Indicate the buffer end offset of a bulk-transmission */
-	u32 TxRate;
-	dma_addr_t data_dma;	/* urb dma on linux */
-};
-
-/* */
-/* Structure to keep track of receive packets and buffers to indicate */
-/* receive data to the protocol. */
-/* */
-struct rt_rx_context {
-	u8 *TransferBuffer;
-	void *pAd;
-	PIRP pIrp;		/*used to cancel pending bulk in. */
-	PURB pUrb;
-	/*These 2 Boolean shouldn't both be 1 at the same time. */
-	unsigned long BulkInOffset;	/* number of packets waiting for reordering . */
-/*      BOOLEAN                         ReorderInUse;   // At least one packet in this buffer are in reordering buffer and wait for receive indication */
-	BOOLEAN bRxHandling;	/* Notify this packet is being process now. */
-	BOOLEAN InUse;		/* USB Hardware Occupied. Wait for USB HW to put packet. */
-	BOOLEAN Readable;	/* Receive Complete back. OK for driver to indicate receiving packet. */
-	BOOLEAN IRPPending;	/* TODO: To be removed */
-	atomic_t IrpLock;
-	spinlock_t RxContextLock;
-	dma_addr_t data_dma;	/* urb dma on linux */
-};
-
-/******************************************************************************
-
-	USB Frimware Related MACRO
-
-******************************************************************************/
-/* 8051 firmware image for usb - use last-half base address = 0x3000 */
-#define FIRMWARE_IMAGE_BASE			0x3000
-#define MAX_FIRMWARE_IMAGE_SIZE		0x1000	/* 4kbyte */
-
-#define RTMP_WRITE_FIRMWARE(_pAd, _pFwImage, _FwLen)		\
-	RTUSBFirmwareWrite(_pAd, _pFwImage, _FwLen)
-
-/******************************************************************************
-
-	USB TX Related MACRO
-
-******************************************************************************/
-#define RTMP_START_DEQUEUE(pAd, QueIdx, irqFlags)				\
-			do {													\
-				RTMP_IRQ_LOCK(&pAd->DeQueueLock[QueIdx], irqFlags);		\
-				if (pAd->DeQueueRunning[QueIdx]) {						\
-					RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags); \
-					DBGPRINT(RT_DEBUG_OFF, ("DeQueueRunning[%d]= TRUE!\n", QueIdx));		\
-					continue;											\
-				} else {												\
-					pAd->DeQueueRunning[QueIdx] = TRUE;					\
-					RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags);\
-				}														\
-			} while (0)
-
-#define RTMP_STOP_DEQUEUE(pAd, QueIdx, irqFlags)						\
-			do {													\
-				RTMP_IRQ_LOCK(&pAd->DeQueueLock[QueIdx], irqFlags);		\
-				pAd->DeQueueRunning[QueIdx] = FALSE;					\
-				RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags);	\
-			} while (0)
-
-#define	RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk, freeNum, pPacket) \
-		(RTUSBFreeDescriptorRequest(pAd, pTxBlk->QueIdx, (pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket))) == NDIS_STATUS_SUCCESS)
-
-#define RTMP_RELEASE_DESC_RESOURCE(pAd, QueIdx)			\
-		do {} while (0)
-
-#define NEED_QUEUE_BACK_FOR_AGG(_pAd, _QueIdx, _freeNum, _TxFrameType)		\
-		((_TxFrameType == TX_RALINK_FRAME) && \
-		(RTUSBNeedQueueBackForAgg(_pAd, _QueIdx)))
-
-#define HAL_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)	\
-		RtmpUSB_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)
-
-#define HAL_WriteTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)	\
-		RtmpUSB_WriteSingleTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)
-
-#define HAL_WriteFragTxResource(pAd, pTxBlk, fragNum, pFreeNumber) \
-		RtmpUSB_WriteFragTxResource(pAd, pTxBlk, fragNum, pFreeNumber)
-
-#define HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, pFreeNumber)	\
-		RtmpUSB_WriteMultiTxResource(pAd, pTxBlk, frameNum, pFreeNumber)
-
-#define HAL_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, TxIdx)	\
-		RtmpUSB_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, TxIdx)
-
-#define HAL_LastTxIdx(pAd, QueIdx, TxIdx) \
-				/*RtmpUSBDataLastTxIdx(pAd, QueIdx,TxIdx) */
-
-#define HAL_KickOutTx(pAd, pTxBlk, QueIdx)	\
-			RtmpUSBDataKickOut(pAd, pTxBlk, QueIdx)
-
-#define HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen)	\
-			RtmpUSBMgmtKickOut(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen)
-
-#define HAL_KickOutNullFrameTx(_pAd, _QueIdx, _pNullFrame, _frameLen)	\
-			RtmpUSBNullFrameKickOut(_pAd, _QueIdx, _pNullFrame, _frameLen)
-
-#define GET_TXRING_FREENO(_pAd, _QueIdx)	(_QueIdx)	/*(_pAd->TxRing[_QueIdx].TxSwFreeIdx) */
-#define GET_MGMTRING_FREENO(_pAd)			(_pAd->MgmtRing.TxSwFreeIdx)
-
-/* ----------------- RX Related MACRO ----------------- */
-
-/*
-  *	Device Hardware Interface Related MACRO
-  */
-#define RTMP_IRQ_INIT(pAd)				do {} while (0)
-#define RTMP_IRQ_ENABLE(pAd)			do {} while (0)
-
-/*
-  *	MLME Related MACRO
-  */
-#define RTMP_MLME_HANDLER(pAd)			RTUSBMlmeUp(pAd)
-
-#define RTMP_MLME_PRE_SANITY_CHECK(pAd)								\
-	{	if ((pAd->CommonCfg.bHardwareRadio == TRUE) &&					\
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&		\
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))) {	\
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_CHECK_GPIO, NULL, 0); } }
-
-#define RTMP_MLME_STA_QUICK_RSP_WAKE_UP(pAd)	\
-	{	RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_QKERIODIC_EXECUT, NULL, 0);	\
-		RTUSBMlmeUp(pAd); }
-
-#define RTMP_MLME_RESET_STATE_MACHINE(pAd)	\
-	{	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_RESET_CONF, 0, NULL);	\
-		RTUSBMlmeUp(pAd); }
-
-#define RTMP_HANDLE_COUNTER_MEASURE(_pAd, _pEntry)		\
-	{	RTUSBEnqueueInternalCmd(_pAd, CMDTHREAD_802_11_COUNTER_MEASURE, _pEntry, sizeof(struct rt_mac_table_entry));	\
-		RTUSBMlmeUp(_pAd);									\
-	}
-
-/*
-  *	Power Save Related MACRO
-  */
-#define RTMP_PS_POLL_ENQUEUE(pAd)						\
-	{	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);	\
-		RTUSBKickBulkOut(pAd); }
-
-#define RTMP_STA_FORCE_WAKEUP(_pAd, bFromTx) \
-	RT28xxUsbStaAsicForceWakeup(_pAd, bFromTx);
-
-#define RTMP_STA_SLEEP_THEN_AUTO_WAKEUP(pAd, TbttNumToNextWakeUp) \
-    RT28xxUsbStaAsicSleepThenAutoWakeup(pAd, TbttNumToNextWakeUp);
-
-#define RTMP_SET_PSM_BIT(_pAd, _val) \
-	{\
-		if ((_pAd)->StaCfg.WindowsPowerMode == Ndis802_11PowerModeFast_PSP) \
-			MlmeSetPsmBit(_pAd, _val);\
-		else { \
-			u16 _psm_val; \
-			_psm_val = _val; \
-			RTUSBEnqueueInternalCmd(_pAd, CMDTHREAD_SET_PSM_BIT, &(_psm_val), sizeof(u16)); \
-		} \
-	}
-
-#define RTMP_MLME_RADIO_ON(pAd) \
-    RT28xxUsbMlmeRadioOn(pAd);
-
-#define RTMP_MLME_RADIO_OFF(pAd) \
-    RT28xxUsbMlmeRadioOFF(pAd);
-
-#endif /*__MAC_USB_H__ // */
diff --git a/drivers/staging/rt2860/chip/rt2860.h b/drivers/staging/rt2860/chip/rt2860.h
deleted file mode 100644
index f30b808..0000000
--- a/drivers/staging/rt2860/chip/rt2860.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-#ifndef __RT2860_H__
-#define __RT2860_H__
-
-#include "mac_pci.h"
-
-#ifndef RTMP_PCI_SUPPORT
-#error "For RT2860, you should define the compile flag -DRTMP_PCI_SUPPORT"
-#endif
-
-#ifndef RTMP_MAC_PCI
-#error "For RT2880, you should define the compile flag -DRTMP_MAC_PCI"
-#endif
-
-/* */
-/* Device ID & Vendor ID, these values should match EEPROM value */
-/* */
-#define NIC2860_PCI_DEVICE_ID	0x0601
-#define NIC2860_PCIe_DEVICE_ID	0x0681
-#define NIC2760_PCI_DEVICE_ID	0x0701	/* 1T/2R Cardbus ??? */
-#define NIC2790_PCIe_DEVICE_ID  0x0781	/* 1T/2R miniCard */
-
-#define VEN_AWT_PCIe_DEVICE_ID	0x1059
-#define VEN_AWT_PCI_VENDOR_ID		0x1A3B
-
-#define EDIMAX_PCI_VENDOR_ID		0x1432
-
-#endif /*__RT2860_H__ // */
diff --git a/drivers/staging/rt2860/chip/rt2870.h b/drivers/staging/rt2860/chip/rt2870.h
deleted file mode 100644
index 8263f1b..0000000
--- a/drivers/staging/rt2860/chip/rt2870.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-#ifndef __RT2870_H__
-#define __RT2870_H__
-
-#ifdef RT2870
-
-#ifndef RTMP_USB_SUPPORT
-#error "For RT2870, you should define the compile flag -DRTMP_USB_SUPPORT"
-#endif
-
-#ifndef RTMP_MAC_USB
-#error "For RT2870, you should define the compile flag -DRTMP_MAC_USB"
-#endif
-
-#include "../rtmp_type.h"
-#include "mac_usb.h"
-
-/*#define RTMP_CHIP_NAME                "RT2870" */
-
-#endif /* RT2870 // */
-#endif /*__RT2870_H__ // */
diff --git a/drivers/staging/rt2860/chip/rt3070.h b/drivers/staging/rt2860/chip/rt3070.h
deleted file mode 100644
index 172ce70..0000000
--- a/drivers/staging/rt2860/chip/rt3070.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rt3070.h
-
-    Abstract:
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __RT3070_H__
-#define __RT3070_H__
-
-#ifdef RT3070
-
-#ifndef RTMP_USB_SUPPORT
-#error "For RT3070, you should define the compile flag -DRTMP_USB_SUPPORT"
-#endif
-
-#ifndef RTMP_MAC_USB
-#error "For RT3070, you should define the compile flag -DRTMP_MAC_USB"
-#endif
-
-#ifndef RTMP_RF_RW_SUPPORT
-#error "For RT3070, you should define the compile flag -DRTMP_RF_RW_SUPPORT"
-#endif
-
-#ifndef RT30xx
-#error "For RT3070, you should define the compile flag -DRT30xx"
-#endif
-
-#include "mac_usb.h"
-#include "rt30xx.h"
-
-/* */
-/* Device ID & Vendor ID, these values should match EEPROM value */
-/* */
-
-#endif /* RT3070 // */
-
-#endif /*__RT3070_H__ // */
diff --git a/drivers/staging/rt2860/chip/rt3090.h b/drivers/staging/rt2860/chip/rt3090.h
deleted file mode 100644
index 102b938..0000000
--- a/drivers/staging/rt2860/chip/rt3090.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rt3090.h
-
-    Abstract:
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __RT3090_H__
-#define __RT3090_H__
-
-#ifdef RT3090
-
-#ifndef RTMP_PCI_SUPPORT
-#error "For RT3090, you should define the compile flag -DRTMP_PCI_SUPPORT"
-#endif
-
-#ifndef RTMP_MAC_PCI
-#error "For RT3090, you should define the compile flag -DRTMP_MAC_PCI"
-#endif
-
-#ifndef RTMP_RF_RW_SUPPORT
-#error "For RT3090, you should define the compile flag -DRTMP_RF_RW_SUPPORT"
-#endif
-
-#ifndef RT30xx
-#error "For RT3090, you should define the compile flag -DRT30xx"
-#endif
-
-#define PCIE_PS_SUPPORT
-
-#include "mac_pci.h"
-#include "rt30xx.h"
-
-/* */
-/* Device ID & Vendor ID, these values should match EEPROM value */
-/* */
-#define NIC3090_PCIe_DEVICE_ID  0x3090	/* 1T/1R miniCard */
-#define NIC3091_PCIe_DEVICE_ID  0x3091	/* 1T/2R miniCard */
-#define NIC3092_PCIe_DEVICE_ID  0x3092	/* 2T/2R miniCard */
-
-#endif /* RT3090 // */
-
-#endif /*__RT3090_H__ // */
diff --git a/drivers/staging/rt2860/chip/rt30xx.h b/drivers/staging/rt2860/chip/rt30xx.h
deleted file mode 100644
index 02e1d72..0000000
--- a/drivers/staging/rt2860/chip/rt30xx.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rt30xx.h
-
-    Abstract:
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __RT30XX_H__
-#define __RT30XX_H__
-
-#ifdef RT30xx
-
-extern struct rt_reg_pair RT30xx_RFRegTable[];
-extern u8 NUM_RF_REG_PARMS;
-
-#endif /* RT30xx // */
-
-#endif /*__RT30XX_H__ // */
diff --git a/drivers/staging/rt2860/chip/rtmp_mac.h b/drivers/staging/rt2860/chip/rtmp_mac.h
deleted file mode 100644
index 3d1e491..0000000
--- a/drivers/staging/rt2860/chip/rtmp_mac.h
+++ /dev/null
@@ -1,1308 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_mac.h
-
-	Abstract:
-	Ralink Wireless Chip MAC related definition & structures
-
-	Revision History:
-	Who			When		  What
-	Justin P. Mattock	11/07/2010	  Fix a comments, and typos
-	--------	----------	  ----------------------------------------------
-*/
-
-#ifndef __RTMP_MAC_H__
-#define __RTMP_MAC_H__
-
-/* ================================================================================= */
-/* TX / RX ring descriptor format */
-/* ================================================================================= */
-
-/* the first 24-byte in TXD is called TXINFO and will be DMAed to MAC block through TXFIFO. */
-/* MAC block uses this TXINFO to control the transmission behavior of this frame. */
-#define FIFO_MGMT                 0
-#define FIFO_HCCA                 1
-#define FIFO_EDCA                 2
-
-/* */
-/* TXD Wireless Information format for Tx ring and Mgmt Ring */
-/* */
-/*txop : for txop mode */
-/* 0:txop for the MPDU frame will be handles by ASIC by register */
-/* 1/2/3:the MPDU frame is send after PIFS/backoff/SIFS */
-struct PACKED rt_txwi {
-	/* Word 0 */
-	/* ex: 00 03 00 40 means txop = 3, PHYMODE = 1 */
-	u32 FRAG:1;		/* 1 to inform TKIP engine this is a fragment. */
-	u32 MIMOps:1;	/* the remote peer is in dynamic MIMO-PS mode */
-	u32 CFACK:1;
-	u32 TS:1;
-
-	u32 AMPDU:1;
-	u32 MpduDensity:3;
-	u32 txop:2;		/*FOR "THIS" frame. 0:HT TXOP rule , 1:PIFS TX ,2:Backoff, 3:sifs only when previous frame exchange is successful. */
-	u32 rsv:6;
-
-	u32 MCS:7;
-	u32 BW:1;		/*channel bandwidth 20MHz or 40 MHz */
-	u32 ShortGI:1;
-	u32 STBC:2;		/* 1: STBC support MCS =0-7,   2,3 : RESERVE */
-	u32 Ifs:1;		/* */
-/*      u32          rsv2:2; //channel bandwidth 20MHz or 40 MHz */
-	u32 rsv2:1;
-	u32 TxBF:1;		/* 3*3 */
-	u32 PHYMODE:2;
-	/* Word1 */
-	/* ex:  1c ff 38 00 means ACK=0, BAWinSize=7, MPDUtotalByteCount = 0x38 */
-	u32 ACK:1;
-	u32 NSEQ:1;
-	u32 BAWinSize:6;
-	u32 WirelessCliID:8;
-	u32 MPDUtotalByteCount:12;
-	u32 PacketId:4;
-	/*Word2 */
-	u32 IV;
-	/*Word3 */
-	u32 EIV;
-};
-
-/* */
-/* RXWI wireless information format, in PBF. invisible in driver. */
-/* */
-struct PACKED rt_rxwi {
-	/* Word 0 */
-	u32 WirelessCliID:8;
-	u32 KeyIndex:2;
-	u32 BSSID:3;
-	u32 UDF:3;
-	u32 MPDUtotalByteCount:12;
-	u32 TID:4;
-	/* Word 1 */
-	u32 FRAG:4;
-	u32 SEQUENCE:12;
-	u32 MCS:7;
-	u32 BW:1;
-	u32 ShortGI:1;
-	u32 STBC:2;
-	u32 rsv:3;
-	u32 PHYMODE:2;	/* 1: this RX frame is unicast to me */
-	/*Word2 */
-	u32 RSSI0:8;
-	u32 RSSI1:8;
-	u32 RSSI2:8;
-	u32 rsv1:8;
-	/*Word3 */
-	u32 SNR0:8;
-	u32 SNR1:8;
-	u32 FOFFSET:8;	/* RT35xx */
-	u32 rsv2:8;
-	/*u32                rsv2:16; */
-};
-
-/* ================================================================================= */
-/* Register format */
-/* ================================================================================= */
-
-/* */
-/* SCH/DMA registers - base address 0x0200 */
-/* */
-/* INT_SOURCE_CSR: Interrupt source register. Write one to clear corresponding bit */
-/* */
-#define DMA_CSR0		0x200
-#define INT_SOURCE_CSR		0x200
-typedef union _INT_SOURCE_CSR_STRUC {
-	struct {
-		u32 RxDelayINT:1;
-		u32 TxDelayINT:1;
-		u32 RxDone:1;
-		u32 Ac0DmaDone:1;	/*4 */
-		u32 Ac1DmaDone:1;
-		u32 Ac2DmaDone:1;
-		u32 Ac3DmaDone:1;
-		u32 HccaDmaDone:1;	/* bit7 */
-		u32 MgmtDmaDone:1;
-		u32 MCUCommandINT:1;	/*bit 9 */
-		u32 RxTxCoherent:1;
-		u32 TBTTInt:1;
-		u32 PreTBTT:1;
-		u32 TXFifoStatusInt:1;	/*FIFO Statistics is full, sw should read 0x171c */
-		u32 AutoWakeup:1;	/*bit14 */
-		u32 GPTimer:1;
-		u32 RxCoherent:1;	/*bit16 */
-		u32 TxCoherent:1;
-		u32: 14;
-	} field;
-	u32 word;
-} INT_SOURCE_CSR_STRUC, *PINT_SOURCE_CSR_STRUC;
-
-/* */
-/* INT_MASK_CSR:   Interrupt MASK register.   1: the interrupt is mask OFF */
-/* */
-#define INT_MASK_CSR        0x204
-typedef union _INT_MASK_CSR_STRUC {
-	struct {
-		u32 RXDelay_INT_MSK:1;
-		u32 TxDelay:1;
-		u32 RxDone:1;
-		u32 Ac0DmaDone:1;
-		u32 Ac1DmaDone:1;
-		u32 Ac2DmaDone:1;
-		u32 Ac3DmaDone:1;
-		u32 HccaDmaDone:1;
-		u32 MgmtDmaDone:1;
-		u32 MCUCommandINT:1;
-		u32: 20;
-		u32 RxCoherent:1;
-		u32 TxCoherent:1;
-	} field;
-	u32 word;
-} INT_MASK_CSR_STRUC, *PINT_MASK_CSR_STRUC;
-
-#define WPDMA_GLO_CFG	0x208
-typedef union _WPDMA_GLO_CFG_STRUC {
-	struct {
-		u32 EnableTxDMA:1;
-		u32 TxDMABusy:1;
-		u32 EnableRxDMA:1;
-		u32 RxDMABusy:1;
-		u32 WPDMABurstSIZE:2;
-		u32 EnTXWriteBackDDONE:1;
-		u32 BigEndian:1;
-		u32 RXHdrScater:8;
-		u32 HDR_SEG_LEN:16;
-	} field;
-	u32 word;
-} WPDMA_GLO_CFG_STRUC, *PWPDMA_GLO_CFG_STRUC;
-
-#define WPDMA_RST_IDX	0x20c
-typedef union _WPDMA_RST_IDX_STRUC {
-	struct {
-		u32 RST_DTX_IDX0:1;
-		u32 RST_DTX_IDX1:1;
-		u32 RST_DTX_IDX2:1;
-		u32 RST_DTX_IDX3:1;
-		u32 RST_DTX_IDX4:1;
-		u32 RST_DTX_IDX5:1;
-		u32 rsv:10;
-		u32 RST_DRX_IDX0:1;
-		u32: 15;
-	} field;
-	u32 word;
-} WPDMA_RST_IDX_STRUC, *PWPDMA_RST_IDX_STRUC;
-#define DELAY_INT_CFG  0x0210
-typedef union _DELAY_INT_CFG_STRUC {
-	struct {
-		u32 RXMAX_PTIME:8;
-		u32 RXMAX_PINT:7;
-		u32 RXDLY_INT_EN:1;
-		u32 TXMAX_PTIME:8;
-		u32 TXMAX_PINT:7;
-		u32 TXDLY_INT_EN:1;
-	} field;
-	u32 word;
-} DELAY_INT_CFG_STRUC, *PDELAY_INT_CFG_STRUC;
-#define WMM_AIFSN_CFG   0x0214
-typedef union _AIFSN_CSR_STRUC {
-	struct {
-		u32 Aifsn0:4;	/* for AC_BE */
-		u32 Aifsn1:4;	/* for AC_BK */
-		u32 Aifsn2:4;	/* for AC_VI */
-		u32 Aifsn3:4;	/* for AC_VO */
-		u32 Rsv:16;
-	} field;
-	u32 word;
-} AIFSN_CSR_STRUC, *PAIFSN_CSR_STRUC;
-/* */
-/* CWMIN_CSR: CWmin for each EDCA AC */
-/* */
-#define WMM_CWMIN_CFG   0x0218
-typedef union _CWMIN_CSR_STRUC {
-	struct {
-		u32 Cwmin0:4;	/* for AC_BE */
-		u32 Cwmin1:4;	/* for AC_BK */
-		u32 Cwmin2:4;	/* for AC_VI */
-		u32 Cwmin3:4;	/* for AC_VO */
-		u32 Rsv:16;
-	} field;
-	u32 word;
-} CWMIN_CSR_STRUC, *PCWMIN_CSR_STRUC;
-
-/* */
-/* CWMAX_CSR: CWmin for each EDCA AC */
-/* */
-#define WMM_CWMAX_CFG   0x021c
-typedef union _CWMAX_CSR_STRUC {
-	struct {
-		u32 Cwmax0:4;	/* for AC_BE */
-		u32 Cwmax1:4;	/* for AC_BK */
-		u32 Cwmax2:4;	/* for AC_VI */
-		u32 Cwmax3:4;	/* for AC_VO */
-		u32 Rsv:16;
-	} field;
-	u32 word;
-} CWMAX_CSR_STRUC, *PCWMAX_CSR_STRUC;
-
-/* */
-/* AC_TXOP_CSR0: AC_BK/AC_BE TXOP register */
-/* */
-#define WMM_TXOP0_CFG    0x0220
-typedef union _AC_TXOP_CSR0_STRUC {
-	struct {
-		u16 Ac0Txop;	/* for AC_BK, in unit of 32us */
-		u16 Ac1Txop;	/* for AC_BE, in unit of 32us */
-	} field;
-	u32 word;
-} AC_TXOP_CSR0_STRUC, *PAC_TXOP_CSR0_STRUC;
-
-/* */
-/* AC_TXOP_CSR1: AC_VO/AC_VI TXOP register */
-/* */
-#define WMM_TXOP1_CFG    0x0224
-typedef union _AC_TXOP_CSR1_STRUC {
-	struct {
-		u16 Ac2Txop;	/* for AC_VI, in unit of 32us */
-		u16 Ac3Txop;	/* for AC_VO, in unit of 32us */
-	} field;
-	u32 word;
-} AC_TXOP_CSR1_STRUC, *PAC_TXOP_CSR1_STRUC;
-
-#define RINGREG_DIFF			0x10
-#define GPIO_CTRL_CFG    0x0228	/*MAC_CSR13 */
-#define MCU_CMD_CFG    0x022c
-#define TX_BASE_PTR0     0x0230	/*AC_BK base address */
-#define TX_MAX_CNT0      0x0234
-#define TX_CTX_IDX0       0x0238
-#define TX_DTX_IDX0      0x023c
-#define TX_BASE_PTR1     0x0240	/*AC_BE base address */
-#define TX_MAX_CNT1      0x0244
-#define TX_CTX_IDX1       0x0248
-#define TX_DTX_IDX1      0x024c
-#define TX_BASE_PTR2     0x0250	/*AC_VI base address */
-#define TX_MAX_CNT2      0x0254
-#define TX_CTX_IDX2       0x0258
-#define TX_DTX_IDX2      0x025c
-#define TX_BASE_PTR3     0x0260	/*AC_VO base address */
-#define TX_MAX_CNT3      0x0264
-#define TX_CTX_IDX3       0x0268
-#define TX_DTX_IDX3      0x026c
-#define TX_BASE_PTR4     0x0270	/*HCCA base address */
-#define TX_MAX_CNT4      0x0274
-#define TX_CTX_IDX4       0x0278
-#define TX_DTX_IDX4      0x027c
-#define TX_BASE_PTR5     0x0280	/*MGMT base address */
-#define  TX_MAX_CNT5     0x0284
-#define TX_CTX_IDX5       0x0288
-#define TX_DTX_IDX5      0x028c
-#define TX_MGMTMAX_CNT      TX_MAX_CNT5
-#define TX_MGMTCTX_IDX       TX_CTX_IDX5
-#define TX_MGMTDTX_IDX      TX_DTX_IDX5
-#define RX_BASE_PTR     0x0290	/*RX base address */
-#define RX_MAX_CNT      0x0294
-#define RX_CRX_IDX       0x0298
-#define RX_DRX_IDX      0x029c
-
-#define USB_DMA_CFG      0x02a0
-typedef union _USB_DMA_CFG_STRUC {
-	struct {
-		u32 RxBulkAggTOut:8;	/*Rx Bulk Aggregation TimeOut  in unit of 33ns */
-		u32 RxBulkAggLmt:8;	/*Rx Bulk Aggregation Limit  in unit of 256 bytes */
-		u32 phyclear:1;	/*phy watch dog enable. write 1 */
-		u32 rsv:2;
-		u32 TxClear:1;	/*Clear USB DMA TX path */
-		u32 TxopHalt:1;	/*Halt TXOP count down when TX buffer is full. */
-		u32 RxBulkAggEn:1;	/*Enable Rx Bulk Aggregation */
-		u32 RxBulkEn:1;	/*Enable USB DMA Rx */
-		u32 TxBulkEn:1;	/*Enable USB DMA Tx */
-		u32 EpoutValid:6;	/*OUT endpoint data valid */
-		u32 RxBusy:1;	/*USB DMA RX FSM busy */
-		u32 TxBusy:1;	/*USB DMA TX FSM busy */
-	} field;
-	u32 word;
-} USB_DMA_CFG_STRUC, *PUSB_DMA_CFG_STRUC;
-
-/* */
-/*  3  PBF  registers */
-/* */
-/* */
-/* Most are for debug. Driver doesn't touch PBF register. */
-#define PBF_SYS_CTRL	 0x0400
-#define PBF_CFG                 0x0408
-#define PBF_MAX_PCNT	 0x040C
-#define PBF_CTRL		0x0410
-#define PBF_INT_STA	 0x0414
-#define PBF_INT_ENA	 0x0418
-#define TXRXQ_PCNT	 0x0438
-#define PBF_DBG			 0x043c
-#define PBF_CAP_CTRL     0x0440
-
-#ifdef RT30xx
-#ifdef RTMP_EFUSE_SUPPORT
-/* eFuse registers */
-#define EFUSE_CTRL				0x0580
-#define EFUSE_DATA0				0x0590
-#define EFUSE_DATA1				0x0594
-#define EFUSE_DATA2				0x0598
-#define EFUSE_DATA3				0x059c
-#endif /* RTMP_EFUSE_SUPPORT // */
-#endif /* RT30xx // */
-
-#define OSC_CTRL		0x5a4
-#define PCIE_PHY_TX_ATTENUATION_CTRL	0x05C8
-#define LDO_CFG0				0x05d4
-#define GPIO_SWITCH				0x05dc
-
-/* */
-/*  4  MAC  registers */
-/* */
-/* */
-/*  4.1 MAC SYSTEM  configuration registers (offset:0x1000) */
-/* */
-#define MAC_CSR0            0x1000
-typedef union _ASIC_VER_ID_STRUC {
-	struct {
-		u16 ASICRev;	/* reversion  : 0 */
-		u16 ASICVer;	/* version : 2860 */
-	} field;
-	u32 word;
-} ASIC_VER_ID_STRUC, *PASIC_VER_ID_STRUC;
-#define MAC_SYS_CTRL            0x1004	/*MAC_CSR1 */
-#define MAC_ADDR_DW0				0x1008	/* MAC ADDR DW0 */
-#define MAC_ADDR_DW1			 0x100c	/* MAC ADDR DW1 */
-/* */
-/* MAC_CSR2: STA MAC register 0 */
-/* */
-typedef union _MAC_DW0_STRUC {
-	struct {
-		u8 Byte0;	/* MAC address byte 0 */
-		u8 Byte1;	/* MAC address byte 1 */
-		u8 Byte2;	/* MAC address byte 2 */
-		u8 Byte3;	/* MAC address byte 3 */
-	} field;
-	u32 word;
-} MAC_DW0_STRUC, *PMAC_DW0_STRUC;
-
-/* */
-/* MAC_CSR3: STA MAC register 1 */
-/* */
-typedef union _MAC_DW1_STRUC {
-	struct {
-		u8 Byte4;	/* MAC address byte 4 */
-		u8 Byte5;	/* MAC address byte 5 */
-		u8 U2MeMask;
-		u8 Rsvd1;
-	} field;
-	u32 word;
-} MAC_DW1_STRUC, *PMAC_DW1_STRUC;
-
-#define MAC_BSSID_DW0				0x1010	/* MAC BSSID DW0 */
-#define MAC_BSSID_DW1				0x1014	/* MAC BSSID DW1 */
-
-/* */
-/* MAC_CSR5: BSSID register 1 */
-/* */
-typedef union _MAC_CSR5_STRUC {
-	struct {
-		u8 Byte4;	/* BSSID byte 4 */
-		u8 Byte5;	/* BSSID byte 5 */
-		u16 BssIdMask:2;	/* 0: one BSSID, 10: 4 BSSID,  01: 2 BSSID , 11: 8BSSID */
-		u16 MBssBcnNum:3;
-		u16 Rsvd:11;
-	} field;
-	u32 word;
-} MAC_CSR5_STRUC, *PMAC_CSR5_STRUC;
-
-#define MAX_LEN_CFG              0x1018	/* rt2860b max 16k bytes. bit12:13 Maximum PSDU length (power factor) 0:2^13, 1:2^14, 2:2^15, 3:2^16 */
-#define BBP_CSR_CFG			0x101c	/* */
-/* */
-/* BBP_CSR_CFG: BBP serial control register */
-/* */
-typedef union _BBP_CSR_CFG_STRUC {
-	struct {
-		u32 Value:8;	/* Register     value to program into BBP */
-		u32 RegNum:8;	/* Selected     BBP     register */
-		u32 fRead:1;	/* 0: Write BBP, 1: Read BBP */
-		u32 Busy:1;	/* 1: ASIC is busy execute BBP programming. */
-		u32 BBP_PAR_DUR:1;	/* 0: 4 MAC clock cycles  1: 8 MAC clock cycles */
-		u32 BBP_RW_MODE:1;	/* 0: use serial mode  1:parallel */
-		u32: 12;
-	} field;
-	u32 word;
-} BBP_CSR_CFG_STRUC, *PBBP_CSR_CFG_STRUC;
-#define RF_CSR_CFG0			0x1020
-/* */
-/* RF_CSR_CFG: RF control register */
-/* */
-typedef union _RF_CSR_CFG0_STRUC {
-	struct {
-		u32 RegIdAndContent:24;	/* Register value to program into BBP */
-		u32 bitwidth:5;	/* Selected BBP register */
-		u32 StandbyMode:1;	/* 0: high when stand by 1: low when standby */
-		u32 Sel:1;	/* 0:RF_LE0 activate  1:RF_LE1 activate */
-		u32 Busy:1;	/* 0: idle 1: 8busy */
-	} field;
-	u32 word;
-} RF_CSR_CFG0_STRUC, *PRF_CSR_CFG0_STRUC;
-#define RF_CSR_CFG1			0x1024
-typedef union _RF_CSR_CFG1_STRUC {
-	struct {
-		u32 RegIdAndContent:24;	/* Register value to program into BBP */
-		u32 RFGap:5;	/* Gap between BB_CONTROL_RF and RF_LE. 0: 3 system clock cycle (37.5usec) 1: 5 system clock cycle (62.5usec) */
-		u32 rsv:7;	/* 0: idle 1: 8busy */
-	} field;
-	u32 word;
-} RF_CSR_CFG1_STRUC, *PRF_CSR_CFG1_STRUC;
-#define RF_CSR_CFG2			0x1028	/* */
-typedef union _RF_CSR_CFG2_STRUC {
-	struct {
-		u32 RegIdAndContent:24;	/* Register value to program into BBP */
-		u32 rsv:8;	/* 0: idle 1: 8busy */
-	} field;
-	u32 word;
-} RF_CSR_CFG2_STRUC, *PRF_CSR_CFG2_STRUC;
-#define LED_CFG				0x102c	/*  MAC_CSR14 */
-typedef union _LED_CFG_STRUC {
-	struct {
-		u32 OnPeriod:8;	/* blinking on period unit 1ms */
-		u32 OffPeriod:8;	/* blinking off period unit 1ms */
-		u32 SlowBlinkPeriod:6;	/* slow blinking period. unit:1ms */
-		u32 rsv:2;
-		u32 RLedMode:2;	/* red Led Mode 0: off1: blinking upon TX2: periodic slow blinking3: always on */
-		u32 GLedMode:2;	/* green Led Mode */
-		u32 YLedMode:2;	/* yellow Led Mode */
-		u32 LedPolar:1;	/* Led Polarity.  0: active low1: active high */
-		u32: 1;
-	} field;
-	u32 word;
-} LED_CFG_STRUC, *PLED_CFG_STRUC;
-/* */
-/*  4.2 MAC TIMING  configuration registers (offset:0x1100) */
-/* */
-#define XIFS_TIME_CFG             0x1100	/* MAC_CSR8  MAC_CSR9 */
-typedef union _IFS_SLOT_CFG_STRUC {
-	struct {
-		u32 CckmSifsTime:8;	/*  unit 1us. Applied after CCK RX/TX */
-		u32 OfdmSifsTime:8;	/*  unit 1us. Applied after OFDM RX/TX */
-		u32 OfdmXifsTime:4;	/*OFDM SIFS. unit 1us. Applied after OFDM RX when MAC doesn't reference BBP signal BBRXEND */
-		u32 EIFS:9;	/*  unit 1us */
-		u32 BBRxendEnable:1;	/*  reference RXEND signal to begin XIFS defer */
-		u32 rsv:2;
-	} field;
-	u32 word;
-} IFS_SLOT_CFG_STRUC, *PIFS_SLOT_CFG_STRUC;
-
-#define BKOFF_SLOT_CFG             0x1104	/*  mac_csr9 last 8 bits */
-#define NAV_TIME_CFG             0x1108	/* NAV  (MAC_CSR15) */
-#define CH_TIME_CFG             0x110C	/* Count as channel busy */
-#define PBF_LIFE_TIMER             0x1110	/*TX/RX MPDU timestamp timer (free run)Unit: 1us */
-#define BCN_TIME_CFG             0x1114	/* TXRX_CSR9 */
-
-#define BCN_OFFSET0				0x042C
-#define BCN_OFFSET1				0x0430
-
-/* */
-/* BCN_TIME_CFG : Synchronization control register */
-/* */
-typedef union _BCN_TIME_CFG_STRUC {
-	struct {
-		u32 BeaconInterval:16;	/* in unit of 1/16 TU */
-		u32 bTsfTicking:1;	/* Enable TSF auto counting */
-		u32 TsfSyncMode:2;	/* Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode */
-		u32 bTBTTEnable:1;
-		u32 bBeaconGen:1;	/* Enable beacon generator */
-		u32: 3;
-		u32 TxTimestampCompensate:8;
-	} field;
-	u32 word;
-} BCN_TIME_CFG_STRUC, *PBCN_TIME_CFG_STRUC;
-#define TBTT_SYNC_CFG            0x1118	/* txrx_csr10 */
-#define TSF_TIMER_DW0             0x111C	/* Local TSF timer lsb 32 bits. Read-only */
-#define TSF_TIMER_DW1             0x1120	/* msb 32 bits. Read-only. */
-#define TBTT_TIMER		0x1124	/* TImer remains till next TBTT. Read-only.  TXRX_CSR14 */
-#define INT_TIMER_CFG			0x1128	/* */
-#define INT_TIMER_EN			0x112c	/*  GP-timer and pre-tbtt Int enable */
-#define CH_IDLE_STA			0x1130	/*  channel idle time */
-#define CH_BUSY_STA			0x1134	/*  channle busy time */
-/* */
-/*  4.2 MAC POWER  configuration registers (offset:0x1200) */
-/* */
-#define MAC_STATUS_CFG             0x1200	/* old MAC_CSR12 */
-#define PWR_PIN_CFG             0x1204	/* old MAC_CSR12 */
-#define AUTO_WAKEUP_CFG             0x1208	/* old MAC_CSR10 */
-/* */
-/* AUTO_WAKEUP_CFG: Manual power control / status register */
-/* */
-typedef union _AUTO_WAKEUP_STRUC {
-	struct {
-		u32 AutoLeadTime:8;
-		u32 NumofSleepingTbtt:7;	/* ForceWake has high privilege than PutToSleep when both set */
-		u32 EnableAutoWakeup:1;	/* 0:sleep, 1:awake */
-		u32: 16;
-	} field;
-	u32 word;
-} AUTO_WAKEUP_STRUC, *PAUTO_WAKEUP_STRUC;
-/* */
-/*  4.3 MAC TX  configuration registers (offset:0x1300) */
-/* */
-
-#define EDCA_AC0_CFG	0x1300	/*AC_TXOP_CSR0 0x3474 */
-#define EDCA_AC1_CFG	0x1304
-#define EDCA_AC2_CFG	0x1308
-#define EDCA_AC3_CFG	0x130c
-typedef union _EDCA_AC_CFG_STRUC {
-	struct {
-		u32 AcTxop:8;	/*  in unit of 32us */
-		u32 Aifsn:4;	/* # of slot time */
-		u32 Cwmin:4;	/* */
-		u32 Cwmax:4;	/*unit power of 2 */
-		u32: 12;	/* */
-	} field;
-	u32 word;
-} EDCA_AC_CFG_STRUC, *PEDCA_AC_CFG_STRUC;
-
-#define EDCA_TID_AC_MAP	0x1310
-#define TX_PWR_CFG_0	0x1314
-#define TX_PWR_CFG_1	0x1318
-#define TX_PWR_CFG_2	0x131C
-#define TX_PWR_CFG_3	0x1320
-#define TX_PWR_CFG_4	0x1324
-#define TX_PIN_CFG		0x1328
-#define TX_BAND_CFG	0x132c	/* 0x1 use upper 20MHz. 0 juse lower 20MHz */
-#define TX_SW_CFG0		0x1330
-#define TX_SW_CFG1		0x1334
-#define TX_SW_CFG2		0x1338
-#define TXOP_THRES_CFG		0x133c
-#define TXOP_CTRL_CFG		0x1340
-#define TX_RTS_CFG		0x1344
-
-typedef union _TX_RTS_CFG_STRUC {
-	struct {
-		u32 AutoRtsRetryLimit:8;
-		u32 RtsThres:16;	/* unit:byte */
-		u32 RtsFbkEn:1;	/* enable rts rate fallback */
-		u32 rsv:7;	/* 1: HT non-STBC control frame enable */
-	} field;
-	u32 word;
-} TX_RTS_CFG_STRUC, *PTX_RTS_CFG_STRUC;
-#define TX_TIMEOUT_CFG	0x1348
-typedef union _TX_TIMEOUT_CFG_STRUC {
-	struct {
-		u32 rsv:4;
-		u32 MpduLifeTime:4;	/*  expiration time = 2^(9+MPDU LIFE TIME)  us */
-		u32 RxAckTimeout:8;	/* unit:slot. Used for TX precedure */
-		u32 TxopTimeout:8;	/*TXOP timeout value for TXOP truncation.  It is recommended that (SLOT_TIME) > (TX_OP_TIMEOUT) > (RX_ACK_TIMEOUT) */
-		u32 rsv2:8;	/* 1: HT non-STBC control frame enable */
-	} field;
-	u32 word;
-} TX_TIMEOUT_CFG_STRUC, *PTX_TIMEOUT_CFG_STRUC;
-#define TX_RTY_CFG	0x134c
-typedef union PACKED _TX_RTY_CFG_STRUC {
-	struct {
-		u32 ShortRtyLimit:8;	/* short retry limit */
-		u32 LongRtyLimit:8;	/* long retry limit */
-		u32 LongRtyThre:12;	/* Long retry threshold */
-		u32 NonAggRtyMode:1;	/* Non-Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer */
-		u32 AggRtyMode:1;	/* Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer */
-		u32 TxautoFBEnable:1;	/* Tx retry PHY rate auto fallback enable */
-		u32 rsv:1;	/* 1: HT non-STBC control frame enable */
-	} field;
-	u32 word;
-} TX_RTY_CFG_STRUC, *PTX_RTY_CFG_STRUC;
-#define TX_LINK_CFG	0x1350
-typedef union PACKED _TX_LINK_CFG_STRUC {
-	struct PACKED {
-		u32 RemoteMFBLifeTime:8;	/*remote MFB life time. unit : 32us */
-		u32 MFBEnable:1;	/*  TX apply remote MFB 1:enable */
-		u32 RemoteUMFSEnable:1;	/*  remote unsolicit  MFB enable.  0: not apply remote remote unsolicit (MFS=7) */
-		u32 TxMRQEn:1;	/*  MCS request TX enable */
-		u32 TxRDGEn:1;	/* RDG TX enable */
-		u32 TxCFAckEn:1;	/*   Piggyback CF-ACK enable */
-		u32 rsv:3;	/* */
-		u32 RemotMFB:8;	/*  remote MCS feedback */
-		u32 RemotMFS:8;	/*remote MCS feedback sequence number */
-	} field;
-	u32 word;
-} TX_LINK_CFG_STRUC, *PTX_LINK_CFG_STRUC;
-#define HT_FBK_CFG0	0x1354
-typedef union PACKED _HT_FBK_CFG0_STRUC {
-	struct {
-		u32 HTMCS0FBK:4;
-		u32 HTMCS1FBK:4;
-		u32 HTMCS2FBK:4;
-		u32 HTMCS3FBK:4;
-		u32 HTMCS4FBK:4;
-		u32 HTMCS5FBK:4;
-		u32 HTMCS6FBK:4;
-		u32 HTMCS7FBK:4;
-	} field;
-	u32 word;
-} HT_FBK_CFG0_STRUC, *PHT_FBK_CFG0_STRUC;
-#define HT_FBK_CFG1	0x1358
-typedef union _HT_FBK_CFG1_STRUC {
-	struct {
-		u32 HTMCS8FBK:4;
-		u32 HTMCS9FBK:4;
-		u32 HTMCS10FBK:4;
-		u32 HTMCS11FBK:4;
-		u32 HTMCS12FBK:4;
-		u32 HTMCS13FBK:4;
-		u32 HTMCS14FBK:4;
-		u32 HTMCS15FBK:4;
-	} field;
-	u32 word;
-} HT_FBK_CFG1_STRUC, *PHT_FBK_CFG1_STRUC;
-#define LG_FBK_CFG0	0x135c
-typedef union _LG_FBK_CFG0_STRUC {
-	struct {
-		u32 OFDMMCS0FBK:4;	/*initial value is 0 */
-		u32 OFDMMCS1FBK:4;	/*initial value is 0 */
-		u32 OFDMMCS2FBK:4;	/*initial value is 1 */
-		u32 OFDMMCS3FBK:4;	/*initial value is 2 */
-		u32 OFDMMCS4FBK:4;	/*initial value is 3 */
-		u32 OFDMMCS5FBK:4;	/*initial value is 4 */
-		u32 OFDMMCS6FBK:4;	/*initial value is 5 */
-		u32 OFDMMCS7FBK:4;	/*initial value is 6 */
-	} field;
-	u32 word;
-} LG_FBK_CFG0_STRUC, *PLG_FBK_CFG0_STRUC;
-#define LG_FBK_CFG1		0x1360
-typedef union _LG_FBK_CFG1_STRUC {
-	struct {
-		u32 CCKMCS0FBK:4;	/*initial value is 0 */
-		u32 CCKMCS1FBK:4;	/*initial value is 0 */
-		u32 CCKMCS2FBK:4;	/*initial value is 1 */
-		u32 CCKMCS3FBK:4;	/*initial value is 2 */
-		u32 rsv:16;
-	} field;
-	u32 word;
-} LG_FBK_CFG1_STRUC, *PLG_FBK_CFG1_STRUC;
-
-/*======================================================= */
-/*================ Protection Paramater================================ */
-/*======================================================= */
-#define CCK_PROT_CFG	0x1364	/*CCK Protection */
-#define ASIC_SHORTNAV		1
-#define ASIC_longNAV		2
-#define ASIC_RTS		1
-#define ASIC_CTS		2
-typedef union _PROT_CFG_STRUC {
-	struct {
-		u32 ProtectRate:16;	/*Protection control frame rate for CCK TX(RTS/CTS/CFEnd). */
-		u32 ProtectCtrl:2;	/*Protection control frame type for CCK TX. 1:RTS/CTS, 2:CTS-to-self, 0:None, 3:rsv */
-		u32 ProtectNav:2;	/*TXOP protection type for CCK TX. 0:None, 1:ShortNAVprotect,  2:LongNAVProtect, 3:rsv */
-		u32 TxopAllowCck:1;	/*CCK TXOP allowance.0:disallow. */
-		u32 TxopAllowOfdm:1;	/*CCK TXOP allowance.0:disallow. */
-		u32 TxopAllowMM20:1;	/*CCK TXOP allowance. 0:disallow. */
-		u32 TxopAllowMM40:1;	/*CCK TXOP allowance.0:disallow. */
-		u32 TxopAllowGF20:1;	/*CCK TXOP allowance.0:disallow. */
-		u32 TxopAllowGF40:1;	/*CCK TXOP allowance.0:disallow. */
-		u32 RTSThEn:1;	/*RTS threshold enable on CCK TX */
-		u32 rsv:5;
-	} field;
-	u32 word;
-} PROT_CFG_STRUC, *PPROT_CFG_STRUC;
-
-#define OFDM_PROT_CFG	0x1368	/*OFDM Protection */
-#define MM20_PROT_CFG	0x136C	/*MM20 Protection */
-#define MM40_PROT_CFG	0x1370	/*MM40 Protection */
-#define GF20_PROT_CFG	0x1374	/*GF20 Protection */
-#define GF40_PROT_CFG	0x1378	/*GR40 Protection */
-#define EXP_CTS_TIME	0x137C	/* */
-#define EXP_ACK_TIME	0x1380	/* */
-
-/* */
-/*  4.4 MAC RX configuration registers (offset:0x1400) */
-/* */
-#define RX_FILTR_CFG	0x1400	/*TXRX_CSR0 */
-#define AUTO_RSP_CFG	0x1404	/*TXRX_CSR4 */
-/* */
-/* TXRX_CSR4: Auto-Responder/ */
-/* */
-typedef union _AUTO_RSP_CFG_STRUC {
-	struct {
-		u32 AutoResponderEnable:1;
-		u32 BACAckPolicyEnable:1;	/* 0:long, 1:short preamble */
-		u32 CTS40MMode:1;	/* Response CTS 40MHz duplicate mode */
-		u32 CTS40MRef:1;	/* Response CTS 40MHz duplicate mode */
-		u32 AutoResponderPreamble:1;	/* 0:long, 1:short preamble */
-		u32 rsv:1;	/* Power bit value in conrtrol frame */
-		u32 DualCTSEn:1;	/* Power bit value in conrtrol frame */
-		u32 AckCtsPsmBit:1;	/* Power bit value in conrtrol frame */
-		u32: 24;
-	} field;
-	u32 word;
-} AUTO_RSP_CFG_STRUC, *PAUTO_RSP_CFG_STRUC;
-
-#define LEGACY_BASIC_RATE	0x1408	/*  TXRX_CSR5           0x3054 */
-#define HT_BASIC_RATE		0x140c
-#define HT_CTRL_CFG		0x1410
-#define SIFS_COST_CFG		0x1414
-#define RX_PARSER_CFG		0x1418	/*Set NAV for all received frames */
-
-/* */
-/*  4.5 MAC Security configuration (offset:0x1500) */
-/* */
-#define TX_SEC_CNT0		0x1500	/* */
-#define RX_SEC_CNT0		0x1504	/* */
-#define CCMP_FC_MUTE		0x1508	/* */
-/* */
-/*  4.6 HCCA/PSMP (offset:0x1600) */
-/* */
-#define TXOP_HLDR_ADDR0		0x1600
-#define TXOP_HLDR_ADDR1		0x1604
-#define TXOP_HLDR_ET		0x1608
-#define QOS_CFPOLL_RA_DW0		0x160c
-#define QOS_CFPOLL_A1_DW1		0x1610
-#define QOS_CFPOLL_QC		0x1614
-/* */
-/*  4.7 MAC Statistis registers (offset:0x1700) */
-/* */
-#define RX_STA_CNT0		0x1700	/* */
-#define RX_STA_CNT1		0x1704	/* */
-#define RX_STA_CNT2		0x1708	/* */
-
-/* */
-/* RX_STA_CNT0_STRUC: RX PLCP error count & RX CRC error count */
-/* */
-typedef union _RX_STA_CNT0_STRUC {
-	struct {
-		u16 CrcErr;
-		u16 PhyErr;
-	} field;
-	u32 word;
-} RX_STA_CNT0_STRUC, *PRX_STA_CNT0_STRUC;
-
-/* */
-/* RX_STA_CNT1_STRUC: RX False CCA count & RX long frame count */
-/* */
-typedef union _RX_STA_CNT1_STRUC {
-	struct {
-		u16 FalseCca;
-		u16 PlcpErr;
-	} field;
-	u32 word;
-} RX_STA_CNT1_STRUC, *PRX_STA_CNT1_STRUC;
-
-/* */
-/* RX_STA_CNT2_STRUC: */
-/* */
-typedef union _RX_STA_CNT2_STRUC {
-	struct {
-		u16 RxDupliCount;
-		u16 RxFifoOverflowCount;
-	} field;
-	u32 word;
-} RX_STA_CNT2_STRUC, *PRX_STA_CNT2_STRUC;
-#define TX_STA_CNT0		0x170C	/* */
-/* */
-/* STA_CSR3: TX Beacon count */
-/* */
-typedef union _TX_STA_CNT0_STRUC {
-	struct {
-		u16 TxFailCount;
-		u16 TxBeaconCount;
-	} field;
-	u32 word;
-} TX_STA_CNT0_STRUC, *PTX_STA_CNT0_STRUC;
-#define TX_STA_CNT1		0x1710	/* */
-/* */
-/* TX_STA_CNT1: TX tx count */
-/* */
-typedef union _TX_STA_CNT1_STRUC {
-	struct {
-		u16 TxSuccess;
-		u16 TxRetransmit;
-	} field;
-	u32 word;
-} TX_STA_CNT1_STRUC, *PTX_STA_CNT1_STRUC;
-#define TX_STA_CNT2		0x1714	/* */
-/* */
-/* TX_STA_CNT2: TX tx count */
-/* */
-typedef union _TX_STA_CNT2_STRUC {
-	struct {
-		u16 TxZeroLenCount;
-		u16 TxUnderFlowCount;
-	} field;
-	u32 word;
-} TX_STA_CNT2_STRUC, *PTX_STA_CNT2_STRUC;
-#define TX_STA_FIFO		0x1718	/* */
-/* */
-/* TX_STA_FIFO_STRUC: TX Result for specific PID status fifo register */
-/* */
-typedef union PACKED _TX_STA_FIFO_STRUC {
-	struct {
-		u32 bValid:1;	/* 1:This register contains a valid TX result */
-		u32 PidType:4;
-		u32 TxSuccess:1;	/* Tx No retry success */
-		u32 TxAggre:1;	/* Tx Retry Success */
-		u32 TxAckRequired:1;	/* Tx fail */
-		u32 wcid:8;	/*wireless client index */
-/*              u32          SuccessRate:16; //include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16. */
-		u32 SuccessRate:13;	/*include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16. */
-		u32 TxBF:1;
-		u32 Reserve:2;
-	} field;
-	u32 word;
-} TX_STA_FIFO_STRUC, *PTX_STA_FIFO_STRUC;
-/* Debug counter */
-#define TX_AGG_CNT	0x171c
-typedef union _TX_AGG_CNT_STRUC {
-	struct {
-		u16 NonAggTxCount;
-		u16 AggTxCount;
-	} field;
-	u32 word;
-} TX_AGG_CNT_STRUC, *PTX_AGG_CNT_STRUC;
-/* Debug counter */
-#define TX_AGG_CNT0	0x1720
-typedef union _TX_AGG_CNT0_STRUC {
-	struct {
-		u16 AggSize1Count;
-		u16 AggSize2Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT0_STRUC, *PTX_AGG_CNT0_STRUC;
-/* Debug counter */
-#define TX_AGG_CNT1	0x1724
-typedef union _TX_AGG_CNT1_STRUC {
-	struct {
-		u16 AggSize3Count;
-		u16 AggSize4Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT1_STRUC, *PTX_AGG_CNT1_STRUC;
-#define TX_AGG_CNT2	0x1728
-typedef union _TX_AGG_CNT2_STRUC {
-	struct {
-		u16 AggSize5Count;
-		u16 AggSize6Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT2_STRUC, *PTX_AGG_CNT2_STRUC;
-/* Debug counter */
-#define TX_AGG_CNT3	0x172c
-typedef union _TX_AGG_CNT3_STRUC {
-	struct {
-		u16 AggSize7Count;
-		u16 AggSize8Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT3_STRUC, *PTX_AGG_CNT3_STRUC;
-/* Debug counter */
-#define TX_AGG_CNT4	0x1730
-typedef union _TX_AGG_CNT4_STRUC {
-	struct {
-		u16 AggSize9Count;
-		u16 AggSize10Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT4_STRUC, *PTX_AGG_CNT4_STRUC;
-#define TX_AGG_CNT5	0x1734
-typedef union _TX_AGG_CNT5_STRUC {
-	struct {
-		u16 AggSize11Count;
-		u16 AggSize12Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT5_STRUC, *PTX_AGG_CNT5_STRUC;
-#define TX_AGG_CNT6		0x1738
-typedef union _TX_AGG_CNT6_STRUC {
-	struct {
-		u16 AggSize13Count;
-		u16 AggSize14Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT6_STRUC, *PTX_AGG_CNT6_STRUC;
-#define TX_AGG_CNT7		0x173c
-typedef union _TX_AGG_CNT7_STRUC {
-	struct {
-		u16 AggSize15Count;
-		u16 AggSize16Count;
-	} field;
-	u32 word;
-} TX_AGG_CNT7_STRUC, *PTX_AGG_CNT7_STRUC;
-#define MPDU_DENSITY_CNT		0x1740
-typedef union _MPDU_DEN_CNT_STRUC {
-	struct {
-		u16 TXZeroDelCount;	/*TX zero length delimiter count */
-		u16 RXZeroDelCount;	/*RX zero length delimiter count */
-	} field;
-	u32 word;
-} MPDU_DEN_CNT_STRUC, *PMPDU_DEN_CNT_STRUC;
-/* */
-/* TXRX control registers - base address 0x3000 */
-/* */
-/* rt2860b  UNKNOWN reg use R/O Reg Addr 0x77d0 first.. */
-#define TXRX_CSR1           0x77d0
-
-/* */
-/* Security key table memory, base address = 0x1000 */
-/* */
-#define MAC_WCID_BASE		0x1800	/*8-bytes(use only 6-bytes) * 256 entry = */
-#define HW_WCID_ENTRY_SIZE   8
-#define PAIRWISE_KEY_TABLE_BASE     0x4000	/* 32-byte * 256-entry =  -byte */
-#define HW_KEY_ENTRY_SIZE           0x20
-#define PAIRWISE_IVEIV_TABLE_BASE     0x6000	/* 8-byte * 256-entry =  -byte */
-#define MAC_IVEIV_TABLE_BASE     0x6000	/* 8-byte * 256-entry =  -byte */
-#define HW_IVEIV_ENTRY_SIZE   8
-#define MAC_WCID_ATTRIBUTE_BASE     0x6800	/* 4-byte * 256-entry =  -byte */
-#define HW_WCID_ATTRI_SIZE   4
-#define WCID_RESERVED			0x6bfc
-#define SHARED_KEY_TABLE_BASE       0x6c00	/* 32-byte * 16-entry = 512-byte */
-#define SHARED_KEY_MODE_BASE       0x7000	/* 32-byte * 16-entry = 512-byte */
-#define HW_SHARED_KEY_MODE_SIZE   4
-#define SHAREDKEYTABLE			0
-#define PAIRWISEKEYTABLE			1
-
-typedef union _SHAREDKEY_MODE_STRUC {
-	struct {
-		u32 Bss0Key0CipherAlg:3;
-		u32: 1;
-		u32 Bss0Key1CipherAlg:3;
-		u32: 1;
-		u32 Bss0Key2CipherAlg:3;
-		u32: 1;
-		u32 Bss0Key3CipherAlg:3;
-		u32: 1;
-		u32 Bss1Key0CipherAlg:3;
-		u32: 1;
-		u32 Bss1Key1CipherAlg:3;
-		u32: 1;
-		u32 Bss1Key2CipherAlg:3;
-		u32: 1;
-		u32 Bss1Key3CipherAlg:3;
-		u32: 1;
-	} field;
-	u32 word;
-} SHAREDKEY_MODE_STRUC, *PSHAREDKEY_MODE_STRUC;
-
-/* 8-byte per entry, 64-entry for pairwise key table */
-struct rt_hw_wcid_entry {
-	u8 Address[6];
-	u8 Rsv[2];
-};
-
-/* ================================================================================= */
-/* WCID  format */
-/* ================================================================================= */
-/*7.1   WCID  ENTRY  format  : 8bytes */
-struct rt_wcid_entry {
-	u8 RXBABitmap7;	/* bit0 for TID8, bit7 for TID 15 */
-	u8 RXBABitmap0;	/* bit0 for TID0, bit7 for TID 7 */
-	u8 MAC[6];		/* 0 for shared key table.  1 for pairwise key table */
-};
-
-/*8.1.1 SECURITY  KEY  format  : 8DW */
-/* 32-byte per entry, total 16-entry for shared key table, 64-entry for pairwise key table */
-struct rt_hw_key_entry {
-	u8 Key[16];
-	u8 TxMic[8];
-	u8 RxMic[8];
-};
-
-/*8.1.2 IV/EIV  format  : 2DW */
-
-/*8.1.3 RX attribute entry format  : 1DW */
-struct rt_mac_attribute {
-	u32 KeyTab:1;	/* 0 for shared key table.  1 for pairwise key table */
-	u32 PairKeyMode:3;
-	u32 BSSIDIdx:3;	/*multipleBSS index for the WCID */
-	u32 RXWIUDF:3;
-	u32 rsv:22;
-};
-
-/* ================================================================================= */
-/* HOST-MCU communication data structure */
-/* ================================================================================= */
-
-/* */
-/* H2M_MAILBOX_CSR: Host-to-MCU Mailbox */
-/* */
-typedef union _H2M_MAILBOX_STRUC {
-	struct {
-		u32 LowByte:8;
-		u32 HighByte:8;
-		u32 CmdToken:8;
-		u32 Owner:8;
-	} field;
-	u32 word;
-} H2M_MAILBOX_STRUC, *PH2M_MAILBOX_STRUC;
-
-/* */
-/* M2H_CMD_DONE_CSR: MCU-to-Host command complete indication */
-/* */
-typedef union _M2H_CMD_DONE_STRUC {
-	struct {
-		u32 CmdToken0;
-		u32 CmdToken1;
-		u32 CmdToken2;
-		u32 CmdToken3;
-	} field;
-	u32 word;
-} M2H_CMD_DONE_STRUC, *PM2H_CMD_DONE_STRUC;
-
-/*NAV_TIME_CFG :NAV */
-typedef union _NAV_TIME_CFG_STRUC {
-	struct {
-		u8 Sifs;	/* in unit of 1-us */
-		u8 SlotTime;	/* in unit of 1-us */
-		u16 Eifs:9;	/* in unit of 1-us */
-		u16 ZeroSifs:1;	/* Applied zero SIFS timer after OFDM RX 0: disable */
-		u16 rsv:6;
-	} field;
-	u32 word;
-} NAV_TIME_CFG_STRUC, *PNAV_TIME_CFG_STRUC;
-
-/* */
-/* RX_FILTR_CFG:  /RX configuration register */
-/* */
-typedef union _RX_FILTR_CFG_STRUC {
-	struct {
-		u32 DropCRCErr:1;	/* Drop CRC error */
-		u32 DropPhyErr:1;	/* Drop physical error */
-		u32 DropNotToMe:1;	/* Drop not to me unicast frame */
-		u32 DropNotMyBSSID:1;	/* Drop fram ToDs bit is true */
-
-		u32 DropVerErr:1;	/* Drop version error frame */
-		u32 DropMcast:1;	/* Drop multicast frames */
-		u32 DropBcast:1;	/* Drop broadcast frames */
-		u32 DropDuplicate:1;	/* Drop duplicate frame */
-
-		u32 DropCFEndAck:1;	/* Drop Ps-Poll */
-		u32 DropCFEnd:1;	/* Drop Ps-Poll */
-		u32 DropAck:1;	/* Drop Ps-Poll */
-		u32 DropCts:1;	/* Drop Ps-Poll */
-
-		u32 DropRts:1;	/* Drop Ps-Poll */
-		u32 DropPsPoll:1;	/* Drop Ps-Poll */
-		u32 DropBA:1;	/* */
-		u32 DropBAR:1;	/* */
-
-		u32 DropRsvCntlType:1;
-		u32: 15;
-	} field;
-	u32 word;
-} RX_FILTR_CFG_STRUC, *PRX_FILTR_CFG_STRUC;
-
-/* */
-/* PHY_CSR4: RF serial control register */
-/* */
-typedef union _PHY_CSR4_STRUC {
-	struct {
-		u32 RFRegValue:24;	/* Register     value (include register id)     serial out to RF/IF     chip. */
-		u32 NumberOfBits:5;	/* Number of bits used in RFRegValue (I:20,     RFMD:22) */
-		u32 IFSelect:1;	/* 1: select IF to program,     0: select RF to program */
-		u32 PLL_LD:1;	/* RF PLL_LD status */
-		u32 Busy:1;	/* 1: ASIC is busy execute RF programming. */
-	} field;
-	u32 word;
-} PHY_CSR4_STRUC, *PPHY_CSR4_STRUC;
-
-/* */
-/* SEC_CSR5: shared key table security mode register */
-/* */
-typedef union _SEC_CSR5_STRUC {
-	struct {
-		u32 Bss2Key0CipherAlg:3;
-		u32: 1;
-		u32 Bss2Key1CipherAlg:3;
-		u32: 1;
-		u32 Bss2Key2CipherAlg:3;
-		u32: 1;
-		u32 Bss2Key3CipherAlg:3;
-		u32: 1;
-		u32 Bss3Key0CipherAlg:3;
-		u32: 1;
-		u32 Bss3Key1CipherAlg:3;
-		u32: 1;
-		u32 Bss3Key2CipherAlg:3;
-		u32: 1;
-		u32 Bss3Key3CipherAlg:3;
-		u32: 1;
-	} field;
-	u32 word;
-} SEC_CSR5_STRUC, *PSEC_CSR5_STRUC;
-
-/* */
-/* HOST_CMD_CSR: For HOST to interrupt embedded processor */
-/* */
-typedef union _HOST_CMD_CSR_STRUC {
-	struct {
-		u32 HostCommand:8;
-		u32 Rsv:24;
-	} field;
-	u32 word;
-} HOST_CMD_CSR_STRUC, *PHOST_CMD_CSR_STRUC;
-
-/* */
-/* AIFSN_CSR: AIFSN for each EDCA AC */
-/* */
-
-/* */
-/* E2PROM_CSR: EEPROM control register */
-/* */
-typedef union _E2PROM_CSR_STRUC {
-	struct {
-		u32 Reload:1;	/* Reload EEPROM content, write one to reload, self-cleared. */
-		u32 EepromSK:1;
-		u32 EepromCS:1;
-		u32 EepromDI:1;
-		u32 EepromDO:1;
-		u32 Type:1;	/* 1: 93C46, 0:93C66 */
-		u32 LoadStatus:1;	/* 1:loading, 0:done */
-		u32 Rsvd:25;
-	} field;
-	u32 word;
-} E2PROM_CSR_STRUC, *PE2PROM_CSR_STRUC;
-
-/* */
-/* QOS_CSR0: TXOP holder address0 register */
-/* */
-typedef union _QOS_CSR0_STRUC {
-	struct {
-		u8 Byte0;	/* MAC address byte 0 */
-		u8 Byte1;	/* MAC address byte 1 */
-		u8 Byte2;	/* MAC address byte 2 */
-		u8 Byte3;	/* MAC address byte 3 */
-	} field;
-	u32 word;
-} QOS_CSR0_STRUC, *PQOS_CSR0_STRUC;
-
-/* */
-/* QOS_CSR1: TXOP holder address1 register */
-/* */
-typedef union _QOS_CSR1_STRUC {
-	struct {
-		u8 Byte4;	/* MAC address byte 4 */
-		u8 Byte5;	/* MAC address byte 5 */
-		u8 Rsvd0;
-		u8 Rsvd1;
-	} field;
-	u32 word;
-} QOS_CSR1_STRUC, *PQOS_CSR1_STRUC;
-
-#define	RF_CSR_CFG	0x500
-typedef union _RF_CSR_CFG_STRUC {
-	struct {
-		u32 RF_CSR_DATA:8;	/* DATA */
-		u32 TESTCSR_RFACC_REGNUM:5;	/* RF register ID */
-		u32 Rsvd2:3;	/* Reserved */
-		u32 RF_CSR_WR:1;	/* 0: read  1: write */
-		u32 RF_CSR_KICK:1;	/* kick RF register read/write */
-		u32 Rsvd1:14;	/* Reserved */
-	} field;
-	u32 word;
-} RF_CSR_CFG_STRUC, *PRF_CSR_CFG_STRUC;
-
-/* */
-/* Other on-chip shared memory space, base = 0x2000 */
-/* */
-
-/* CIS space - base address = 0x2000 */
-#define HW_CIS_BASE             0x2000
-
-/* Carrier-sense CTS frame base address. It's where mac stores carrier-sense frame for carrier-sense function. */
-#define HW_CS_CTS_BASE			0x7700
-/* DFS CTS frame base address. It's where mac stores CTS frame for DFS. */
-#define HW_DFS_CTS_BASE			0x7780
-#define HW_CTS_FRAME_SIZE		0x80
-
-/* 2004-11-08 john - since NULL frame won't be that long (256 byte). We steal 16 tail bytes */
-/* to save debugging settings */
-#define HW_DEBUG_SETTING_BASE   0x77f0	/* 0x77f0~0x77ff total 16 bytes */
-#define HW_DEBUG_SETTING_BASE2   0x7770	/* 0x77f0~0x77ff total 16 bytes */
-
-/* In order to support maximum 8 MBSS and its maximum length is 512 for each beacon */
-/* Three section discontinue memory segments will be used. */
-/* 1. The original region for BCN 0~3 */
-/* 2. Extract memory from FCE table for BCN 4~5 */
-/* 3. Extract memory from Pair-wise key table for BCN 6~7 */
-/*        It occupied those memory of wcid 238~253 for BCN 6 */
-/*                                                    and wcid 222~237 for BCN 7 */
-#define HW_BEACON_MAX_SIZE      0x1000	/* unit: byte */
-#define HW_BEACON_BASE0         0x7800
-#define HW_BEACON_BASE1         0x7A00
-#define HW_BEACON_BASE2         0x7C00
-#define HW_BEACON_BASE3         0x7E00
-#define HW_BEACON_BASE4         0x7200
-#define HW_BEACON_BASE5         0x7400
-#define HW_BEACON_BASE6         0x5DC0
-#define HW_BEACON_BASE7         0x5BC0
-
-#define HW_BEACON_MAX_COUNT     8
-#define HW_BEACON_OFFSET		0x0200
-#define HW_BEACON_CONTENT_LEN	(HW_BEACON_OFFSET - TXWI_SIZE)
-
-/* HOST-MCU shared memory - base address = 0x2100 */
-#define HOST_CMD_CSR		0x404
-#define H2M_MAILBOX_CSR         0x7010
-#define H2M_MAILBOX_CID         0x7014
-#define H2M_MAILBOX_STATUS      0x701c
-#define H2M_INT_SRC             0x7024
-#define H2M_BBP_AGENT           0x7028
-#define M2H_CMD_DONE_CSR        0x000c
-#define MCU_TXOP_ARRAY_BASE     0x000c	/* TODO: to be provided by Albert */
-#define MCU_TXOP_ENTRY_SIZE     32	/* TODO: to be provided by Albert */
-#define MAX_NUM_OF_TXOP_ENTRY   16	/* TODO: must be same with 8051 firmware */
-#define MCU_MBOX_VERSION        0x01	/* TODO: to be confirmed by Albert */
-#define MCU_MBOX_VERSION_OFFSET 5	/* TODO: to be provided by Albert */
-
-/* */
-/* Host DMA registers - base address 0x200 .  TX0-3=EDCAQid0-3, TX4=HCCA, TX5=MGMT, */
-/* */
-/* */
-/*  DMA RING DESCRIPTOR */
-/* */
-#define E2PROM_CSR          0x0004
-#define IO_CNTL_CSR         0x77d0
-
-/* ================================================================ */
-/* Tx / Rx / Mgmt ring descriptor definition */
-/* ================================================================ */
-
-/* the following PID values are used to mark outgoing frame type in TXD->PID so that */
-/* proper TX statistics can be collected based on these categories */
-/* b3-2 of PID field - */
-#define PID_MGMT			0x05
-#define PID_BEACON			0x0c
-#define PID_DATA_NORMALUCAST		0x02
-#define PID_DATA_AMPDU		0x04
-#define PID_DATA_NO_ACK		0x08
-#define PID_DATA_NOT_NORM_ACK		0x03
-/* value domain of pTxD->HostQId (4-bit: 0~15) */
-#define QID_AC_BK               1	/* meet ACI definition in 802.11e */
-#define QID_AC_BE               0	/* meet ACI definition in 802.11e */
-#define QID_AC_VI               2
-#define QID_AC_VO               3
-#define QID_HCCA                4
-#define NUM_OF_TX_RING          4
-#define QID_MGMT                13
-#define QID_RX                  14
-#define QID_OTHER               15
-
-#endif /* __RTMP_MAC_H__ // */
diff --git a/drivers/staging/rt2860/chip/rtmp_phy.h b/drivers/staging/rt2860/chip/rtmp_phy.h
deleted file mode 100644
index a52221f..0000000
--- a/drivers/staging/rt2860/chip/rtmp_phy.h
+++ /dev/null
@@ -1,516 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_phy.h
-
-	Abstract:
-	Ralink Wireless Chip PHY(BBP/RF) related definition & structures
-
-	Revision History:
-	Who			When		  What
-	--------	----------	  ----------------------------------------------
-*/
-
-#ifndef __RTMP_PHY_H__
-#define __RTMP_PHY_H__
-
-/*
-	RF sections
-*/
-#define RF_R00			0
-#define RF_R01			1
-#define RF_R02			2
-#define RF_R03			3
-#define RF_R04			4
-#define RF_R05			5
-#define RF_R06			6
-#define RF_R07			7
-#define RF_R08			8
-#define RF_R09			9
-#define RF_R10			10
-#define RF_R11			11
-#define RF_R12			12
-#define RF_R13			13
-#define RF_R14			14
-#define RF_R15			15
-#define RF_R16			16
-#define RF_R17			17
-#define RF_R18			18
-#define RF_R19			19
-#define RF_R20			20
-#define RF_R21			21
-#define RF_R22			22
-#define RF_R23			23
-#define RF_R24			24
-#define RF_R25			25
-#define RF_R26			26
-#define RF_R27			27
-#define RF_R28			28
-#define RF_R29			29
-#define RF_R30			30
-#define RF_R31			31
-
-/* value domain of pAd->RfIcType */
-#define RFIC_2820                   1	/* 2.4G 2T3R */
-#define RFIC_2850                   2	/* 2.4G/5G 2T3R */
-#define RFIC_2720                   3	/* 2.4G 1T2R */
-#define RFIC_2750                   4	/* 2.4G/5G 1T2R */
-#define RFIC_3020                   5	/* 2.4G 1T1R */
-#define RFIC_2020                   6	/* 2.4G B/G */
-#define RFIC_3021                   7	/* 2.4G 1T2R */
-#define RFIC_3022                   8	/* 2.4G 2T2R */
-#define RFIC_3052                   9	/* 2.4G/5G 2T2R */
-
-/*
-	BBP sections
-*/
-#define BBP_R0			0	/* version */
-#define BBP_R1			1	/* TSSI */
-#define BBP_R2			2	/* TX configure */
-#define BBP_R3			3
-#define BBP_R4			4
-#define BBP_R5			5
-#define BBP_R6			6
-#define BBP_R14			14	/* RX configure */
-#define BBP_R16			16
-#define BBP_R17			17	/* RX sensibility */
-#define BBP_R18			18
-#define BBP_R21			21
-#define BBP_R22			22
-#define BBP_R24			24
-#define BBP_R25			25
-#define BBP_R26			26
-#define BBP_R27			27
-#define BBP_R31			31
-#define BBP_R49			49	/*TSSI */
-#define BBP_R50			50
-#define BBP_R51			51
-#define BBP_R52			52
-#define BBP_R55			55
-#define BBP_R62			62	/* Rx SQ0 Threshold HIGH */
-#define BBP_R63			63
-#define BBP_R64			64
-#define BBP_R65			65
-#define BBP_R66			66
-#define BBP_R67			67
-#define BBP_R68			68
-#define BBP_R69			69
-#define BBP_R70			70	/* Rx AGC SQ CCK Xcorr threshold */
-#define BBP_R73			73
-#define BBP_R75			75
-#define BBP_R77			77
-#define BBP_R78			78
-#define BBP_R79			79
-#define BBP_R80			80
-#define BBP_R81			81
-#define BBP_R82			82
-#define BBP_R83			83
-#define BBP_R84			84
-#define BBP_R86			86
-#define BBP_R91			91
-#define BBP_R92			92
-#define BBP_R94			94	/* Tx Gain Control */
-#define BBP_R103		103
-#define BBP_R105		105
-#define BBP_R106		106
-#define BBP_R113		113
-#define BBP_R114		114
-#define BBP_R115		115
-#define BBP_R116		116
-#define BBP_R117		117
-#define BBP_R118		118
-#define BBP_R119		119
-#define BBP_R120		120
-#define BBP_R121		121
-#define BBP_R122		122
-#define BBP_R123		123
-#ifdef RT30xx
-#define BBP_R138		138	/* add by johnli, RF power sequence setup, ADC dynamic on/off control */
-#endif /* RT30xx // */
-
-#define BBPR94_DEFAULT	0x06	/* Add 1 value will gain 1db */
-
-/* */
-/* BBP & RF are using indirect access. Before write any value into it. */
-/* We have to make sure there is no outstanding command pending via checking busy bit. */
-/* */
-#define MAX_BUSY_COUNT  100	/* Number of retry before failing access BBP & RF indirect register */
-
-/*#define PHY_TR_SWITCH_TIME          5  // usec */
-
-/*#define BBP_R17_LOW_SENSIBILITY     0x50 */
-/*#define BBP_R17_MID_SENSIBILITY     0x41 */
-/*#define BBP_R17_DYNAMIC_UP_BOUND    0x40 */
-
-#define RSSI_FOR_VERY_LOW_SENSIBILITY   -35
-#define RSSI_FOR_LOW_SENSIBILITY		-58
-#define RSSI_FOR_MID_LOW_SENSIBILITY	-80
-#define RSSI_FOR_MID_SENSIBILITY		-90
-
-/*****************************************************************************
-	RF register Read/Write marco definition
- *****************************************************************************/
-#ifdef RTMP_MAC_PCI
-#define RTMP_RF_IO_WRITE32(_A, _V)                  \
-{											\
-	if ((_A)->bPCIclkOff == FALSE) {				\
-		PHY_CSR4_STRUC  _value;                          \
-		unsigned long           _busyCnt = 0;                    \
-											\
-		do {                                            \
-			RTMP_IO_READ32((_A), RF_CSR_CFG0, &_value.word);  \
-			if (_value.field.Busy == IDLE)               \
-				break;                                  \
-			_busyCnt++;                                  \
-		} while (_busyCnt < MAX_BUSY_COUNT);			\
-		if (_busyCnt < MAX_BUSY_COUNT) {			\
-			RTMP_IO_WRITE32((_A), RF_CSR_CFG0, (_V));          \
-		}                                               \
-	}								\
-}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-#define RTMP_RF_IO_WRITE32(_A, _V)                 RTUSBWriteRFRegister(_A, _V)
-#endif /* RTMP_MAC_USB // */
-
-#ifdef RT30xx
-#define RTMP_RF_IO_READ8_BY_REG_ID(_A, _I, _pV)    RT30xxReadRFRegister(_A, _I, _pV)
-#define RTMP_RF_IO_WRITE8_BY_REG_ID(_A, _I, _V)    RT30xxWriteRFRegister(_A, _I, _V)
-#endif /* RT30xx // */
-
-/*****************************************************************************
-	BBP register Read/Write marco definitions.
-	we read/write the bbp value by register's ID.
-	Generate PER to test BA
- *****************************************************************************/
-#ifdef RTMP_MAC_PCI
-/*
-	basic marco for BBP read operation.
-	_pAd: the data structure pointer of struct rt_rtmp_adapter
-	_bbpID : the bbp register ID
-	_pV: data pointer used to save the value of queried bbp register.
-	_bViaMCU: if we need access the bbp via the MCU.
-*/
-#define RTMP_BBP_IO_READ8(_pAd, _bbpID, _pV, _bViaMCU)			\
-	do {								\
-		BBP_CSR_CFG_STRUC  BbpCsr;				\
-		int   _busyCnt, _secCnt, _regID;			\
-									\
-		_regID = ((_bViaMCU) == TRUE ? H2M_BBP_AGENT : BBP_CSR_CFG); \
-		for (_busyCnt = 0; _busyCnt < MAX_BUSY_COUNT; _busyCnt++) { \
-			RTMP_IO_READ32(_pAd, _regID, &BbpCsr.word);	\
-			if (BbpCsr.field.Busy == BUSY)                  \
-				continue;                               \
-			BbpCsr.word = 0;                                \
-			BbpCsr.field.fRead = 1;                         \
-			BbpCsr.field.BBP_RW_MODE = 1;                   \
-			BbpCsr.field.Busy = 1;                          \
-			BbpCsr.field.RegNum = _bbpID;                   \
-			RTMP_IO_WRITE32(_pAd, _regID, BbpCsr.word);     \
-			if ((_bViaMCU) == TRUE) {			\
-			    AsicSendCommandToMcu(_pAd, 0x80, 0xff, 0x0, 0x0); \
-			    RTMPusecDelay(1000);	\
-			}						\
-			for (_secCnt = 0; _secCnt < MAX_BUSY_COUNT; _secCnt++) { \
-				RTMP_IO_READ32(_pAd, _regID, &BbpCsr.word); \
-				if (BbpCsr.field.Busy == IDLE)		\
-					break;				\
-			}						\
-			if ((BbpCsr.field.Busy == IDLE) &&		\
-				(BbpCsr.field.RegNum == _bbpID)) {	\
-				*(_pV) = (u8)BbpCsr.field.Value;	\
-				break;					\
-			}						\
-		}							\
-		if (BbpCsr.field.Busy == BUSY) {			\
-			DBGPRINT_ERR("BBP(viaMCU=%d) read R%d fail\n", (_bViaMCU), _bbpID);	\
-			*(_pV) = (_pAd)->BbpWriteLatch[_bbpID];               \
-			if ((_bViaMCU) == TRUE) {			\
-				RTMP_IO_READ32(_pAd, _regID, &BbpCsr.word);				\
-				BbpCsr.field.Busy = 0;                          \
-				RTMP_IO_WRITE32(_pAd, _regID, BbpCsr.word);				\
-			}				\
-		}													\
-	} while (0)
-
-/*
-	This marco used for the BBP read operation which didn't need via MCU.
-*/
-#define BBP_IO_READ8_BY_REG_ID(_A, _I, _pV)			\
-	RTMP_BBP_IO_READ8((_A), (_I), (_pV), FALSE)
-
-/*
-	This marco used for the BBP read operation which need via MCU.
-	But for some chipset which didn't have mcu (e.g., RBUS based chipset), we
-	will use this function too and didn't access the bbp register via the MCU.
-*/
-/* Read BBP register by register's ID. Generate PER to test BA */
-#define RTMP_BBP_IO_READ8_BY_REG_ID(_A, _I, _pV)						\
-{																		\
-	BBP_CSR_CFG_STRUC	BbpCsr;											\
-	int					i, k;			\
-	BOOLEAN					brc;			\
-	BbpCsr.field.Busy = IDLE;			\
-	if ((IS_RT3090((_A)) || IS_RT3572((_A)) || IS_RT3390((_A)))  \
-		&& ((_A)->StaCfg.PSControl.field.rt30xxPowerMode == 3)	\
-		&& ((_A)->StaCfg.PSControl.field.EnableNewPS == TRUE)	\
-		&& ((_A)->bPCIclkOff == FALSE)	\
-		&& ((_A)->brt30xxBanMcuCmd == FALSE)) {			\
-		for (i = 0; i < MAX_BUSY_COUNT; i++) {			\
-			RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word); \
-			if (BbpCsr.field.Busy == BUSY) {		\
-				continue;				\
-			}						\
-			BbpCsr.word = 0;				\
-			BbpCsr.field.fRead = 1;				\
-			BbpCsr.field.BBP_RW_MODE = 1;			\
-			BbpCsr.field.Busy = 1;				\
-			BbpCsr.field.RegNum = _I;			\
-			RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word); \
-			brc = AsicSendCommandToMcu(_A, 0x80, 0xff, 0x0, 0x0); \
-			if (brc == TRUE) {				\
-				for (k = 0; k < MAX_BUSY_COUNT; k++) {	\
-					RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word); \
-					if (BbpCsr.field.Busy == IDLE)	\
-						break;			\
-				}					\
-				if ((BbpCsr.field.Busy == IDLE) &&	\
-					(BbpCsr.field.RegNum == _I)) {	\
-					*(_pV) = (u8)BbpCsr.field.Value; \
-					break;				\
-				}					\
-			} else {					\
-				BbpCsr.field.Busy = 0;											\
-				RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word);				\
-			}																\
-		}																	\
-	}	\
-	else if (!((IS_RT3090((_A)) || IS_RT3572((_A)) || IS_RT3390((_A))) && ((_A)->StaCfg.PSControl.field.rt30xxPowerMode == 3)	\
-		&& ((_A)->StaCfg.PSControl.field.EnableNewPS == TRUE))	\
-		&& ((_A)->bPCIclkOff == FALSE)) {			\
-		for (i = 0; i < MAX_BUSY_COUNT; i++) {			\
-			RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word); \
-			if (BbpCsr.field.Busy == BUSY) {		\
-				continue;				\
-			}						\
-			BbpCsr.word = 0;				\
-			BbpCsr.field.fRead = 1;				\
-			BbpCsr.field.BBP_RW_MODE = 1;			\
-			BbpCsr.field.Busy = 1;				\
-			BbpCsr.field.RegNum = _I;			\
-			RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word); \
-			AsicSendCommandToMcu(_A, 0x80, 0xff, 0x0, 0x0);	\
-			for (k = 0; k < MAX_BUSY_COUNT; k++) {		\
-				RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word); \
-				if (BbpCsr.field.Busy == IDLE)		\
-					break;				\
-			}						\
-			if ((BbpCsr.field.Busy == IDLE) &&		\
-				(BbpCsr.field.RegNum == _I)) {		\
-				*(_pV) = (u8)BbpCsr.field.Value;	\
-				break;					\
-			}						\
-		}							\
-	} else {							\
-		DBGPRINT_ERR(" , brt30xxBanMcuCmd = %d, Read BBP %d \n", (_A)->brt30xxBanMcuCmd, (_I));	\
-		*(_pV) = (_A)->BbpWriteLatch[_I];			\
-	}								\
-	if ((BbpCsr.field.Busy == BUSY) || ((_A)->bPCIclkOff == TRUE)) { \
-		DBGPRINT_ERR("BBP read R%d=0x%x fail\n", _I, BbpCsr.word); \
-		*(_pV) = (_A)->BbpWriteLatch[_I];			\
-	}								\
-}
-
-/*
-	basic marco for BBP write operation.
-	_pAd: the data structure pointer of struct rt_rtmp_adapter
-	_bbpID : the bbp register ID
-	_pV: data used to save the value of queried bbp register.
-	_bViaMCU: if we need access the bbp via the MCU.
-*/
-#define RTMP_BBP_IO_WRITE8(_pAd, _bbpID, _pV, _bViaMCU)			\
-	do {								\
-		BBP_CSR_CFG_STRUC  BbpCsr;                             \
-		int             _busyCnt, _regID;			\
-									\
-		_regID = ((_bViaMCU) == TRUE ? H2M_BBP_AGENT : BBP_CSR_CFG);	\
-		for (_busyCnt = 0; _busyCnt < MAX_BUSY_COUNT; _busyCnt++) { \
-			RTMP_IO_READ32((_pAd), BBP_CSR_CFG, &BbpCsr.word);     \
-			if (BbpCsr.field.Busy == BUSY)			\
-				continue;				\
-			BbpCsr.word = 0;				\
-			BbpCsr.field.fRead = 0;				\
-			BbpCsr.field.BBP_RW_MODE = 1;			\
-			BbpCsr.field.Busy = 1;				\
-			BbpCsr.field.Value = _pV;			\
-			BbpCsr.field.RegNum = _bbpID;			\
-			RTMP_IO_WRITE32((_pAd), BBP_CSR_CFG, BbpCsr.word); \
-			if ((_bViaMCU) == TRUE) {			\
-				AsicSendCommandToMcu(_pAd, 0x80, 0xff, 0x0, 0x0); \
-				if ((_pAd)->OpMode == OPMODE_AP)	\
-					RTMPusecDelay(1000);		\
-			}						\
-			(_pAd)->BbpWriteLatch[_bbpID] = _pV;		\
-			break;						\
-		}							\
-		if (_busyCnt == MAX_BUSY_COUNT) {			\
-			DBGPRINT_ERR("BBP write R%d fail\n", _bbpID);	\
-			if ((_bViaMCU) == TRUE) {			\
-				RTMP_IO_READ32(_pAd, H2M_BBP_AGENT, &BbpCsr.word);	\
-				BbpCsr.field.Busy = 0;			\
-				RTMP_IO_WRITE32(_pAd, H2M_BBP_AGENT, BbpCsr.word);	\
-			}						\
-		}							\
-	} while (0)
-
-/*
-	This marco used for the BBP write operation which didn't need via MCU.
-*/
-#define BBP_IO_WRITE8_BY_REG_ID(_A, _I, _pV)			\
-	RTMP_BBP_IO_WRITE8((_A), (_I), (_pV), FALSE)
-
-/*
-	This marco used for the BBP write operation which need via MCU.
-	But for some chipset which didn't have mcu (e.g., RBUS based chipset), we
-	will use this function too and didn't access the bbp register via the MCU.
-*/
-/* Write BBP register by register's ID & value */
-#define RTMP_BBP_IO_WRITE8_BY_REG_ID(_A, _I, _V)			\
-{									\
-	BBP_CSR_CFG_STRUC	BbpCsr;					\
-	int					BusyCnt = 0;		\
-	BOOLEAN					brc;			\
-	if (_I < MAX_NUM_OF_BBP_LATCH) {				\
-		if ((IS_RT3090((_A)) || IS_RT3572((_A)) || IS_RT3390((_A))) \
-			&& ((_A)->StaCfg.PSControl.field.rt30xxPowerMode == 3)	\
-			&& ((_A)->StaCfg.PSControl.field.EnableNewPS == TRUE)	\
-			&& ((_A)->bPCIclkOff == FALSE)	\
-			&& ((_A)->brt30xxBanMcuCmd == FALSE)) {		\
-			if (_A->AccessBBPFailCount > 20) {		\
-				AsicResetBBPAgent(_A);			\
-				_A->AccessBBPFailCount = 0;		\
-			}						\
-			for (BusyCnt = 0; BusyCnt < MAX_BUSY_COUNT; BusyCnt++) { \
-				RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word);				\
-				if (BbpCsr.field.Busy == BUSY)									\
-					continue;													\
-				BbpCsr.word = 0;												\
-				BbpCsr.field.fRead = 0;											\
-				BbpCsr.field.BBP_RW_MODE = 1;									\
-				BbpCsr.field.Busy = 1;											\
-				BbpCsr.field.Value = _V;										\
-				BbpCsr.field.RegNum = _I;										\
-				RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word);				\
-				brc = AsicSendCommandToMcu(_A, 0x80, 0xff, 0x0, 0x0);					\
-				if (brc == TRUE) {			\
-					(_A)->BbpWriteLatch[_I] = _V;									\
-				} else {				\
-					BbpCsr.field.Busy = 0;											\
-					RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word);				\
-				}																\
-				break;															\
-			}																	\
-		}																	\
-		else if (!((IS_RT3090((_A)) || IS_RT3572((_A)) || IS_RT3390((_A))) \
-			&& ((_A)->StaCfg.PSControl.field.rt30xxPowerMode == 3)	\
-			&& ((_A)->StaCfg.PSControl.field.EnableNewPS == TRUE))	\
-			&& ((_A)->bPCIclkOff == FALSE)) { 		\
-			if (_A->AccessBBPFailCount > 20) {		\
-				AsicResetBBPAgent(_A);			\
-				_A->AccessBBPFailCount = 0;		\
-			}						\
-			for (BusyCnt = 0; BusyCnt < MAX_BUSY_COUNT; BusyCnt++) { \
-				RTMP_IO_READ32(_A, H2M_BBP_AGENT, &BbpCsr.word);				\
-				if (BbpCsr.field.Busy == BUSY)									\
-					continue;													\
-				BbpCsr.word = 0;												\
-				BbpCsr.field.fRead = 0;											\
-				BbpCsr.field.BBP_RW_MODE = 1;									\
-				BbpCsr.field.Busy = 1;											\
-				BbpCsr.field.Value = _V;										\
-				BbpCsr.field.RegNum = _I;										\
-				RTMP_IO_WRITE32(_A, H2M_BBP_AGENT, BbpCsr.word);				\
-				AsicSendCommandToMcu(_A, 0x80, 0xff, 0x0, 0x0);					\
-				(_A)->BbpWriteLatch[_I] = _V;									\
-				break;															\
-			}																	\
-		} else {						\
-			DBGPRINT_ERR("  brt30xxBanMcuCmd = %d. Write BBP %d \n",  (_A)->brt30xxBanMcuCmd, (_I));	\
-		}																	\
-		if ((BusyCnt == MAX_BUSY_COUNT) || ((_A)->bPCIclkOff == TRUE)) { \
-			if (BusyCnt == MAX_BUSY_COUNT)				\
-				(_A)->AccessBBPFailCount++;					\
-			DBGPRINT_ERR("BBP write R%d=0x%x fail. BusyCnt= %d.bPCIclkOff = %d. \n", _I, BbpCsr.word, BusyCnt, (_A)->bPCIclkOff);	\
-		}																	\
-	} else {							\
-		DBGPRINT_ERR("****** BBP_Write_Latch Buffer exceeds max boundary ****** \n");	\
-	}																		\
-}
-#endif /* RTMP_MAC_PCI // */
-
-#ifdef RTMP_MAC_USB
-#define RTMP_BBP_IO_READ8_BY_REG_ID(_A, _I, _pV)   RTUSBReadBBPRegister(_A, _I, _pV)
-#define RTMP_BBP_IO_WRITE8_BY_REG_ID(_A, _I, _V)   RTUSBWriteBBPRegister(_A, _I, _V)
-
-#define BBP_IO_WRITE8_BY_REG_ID(_A, _I, _V)			RTUSBWriteBBPRegister(_A, _I, _V)
-#define BBP_IO_READ8_BY_REG_ID(_A, _I, _pV)		RTUSBReadBBPRegister(_A, _I, _pV)
-#endif /* RTMP_MAC_USB // */
-
-#ifdef RT30xx
-#define RTMP_ASIC_MMPS_DISABLE(_pAd)							\
-	do {															\
-		u32 _macData; \
-		u8 _bbpData = 0; \
-		/* disable MMPS BBP control register */						\
-		RTMP_BBP_IO_READ8_BY_REG_ID(_pAd, BBP_R3, &_bbpData);	\
-		_bbpData &= ~(0x04);	/*bit 2*/								\
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(_pAd, BBP_R3, _bbpData);	\
-																\
-		/* disable MMPS MAC control register */						\
-		RTMP_IO_READ32(_pAd, 0x1210, &_macData);				\
-		_macData &= ~(0x09);	/*bit 0, 3*/							\
-		RTMP_IO_WRITE32(_pAd, 0x1210, _macData);				\
-	} while (0)
-
-#define RTMP_ASIC_MMPS_ENABLE(_pAd)							\
-	do {															\
-		u32 _macData; \
-		u8 _bbpData = 0; \
-		/* enable MMPS BBP control register */						\
-		RTMP_BBP_IO_READ8_BY_REG_ID(_pAd, BBP_R3, &_bbpData);	\
-		_bbpData |= (0x04);	/*bit 2*/								\
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(_pAd, BBP_R3, _bbpData);	\
-																\
-		/* enable MMPS MAC control register */						\
-		RTMP_IO_READ32(_pAd, 0x1210, &_macData);				\
-		_macData |= (0x09);	/*bit 0, 3*/							\
-		RTMP_IO_WRITE32(_pAd, 0x1210, _macData);				\
-	} while (0)
-
-#endif /* RT30xx // */
-
-#endif /* __RTMP_PHY_H__ // */
diff --git a/drivers/staging/rt2860/chips/rt3070.c b/drivers/staging/rt2860/chips/rt3070.c
deleted file mode 100644
index 3a17fd1..0000000
--- a/drivers/staging/rt2860/chips/rt3070.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rt3070.c
-
-	Abstract:
-	Specific funcitons and variables for RT3070
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#ifdef RT3070
-
-#include "../rt_config.h"
-
-#ifndef RTMP_RF_RW_SUPPORT
-#error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-void NICInitRT3070RFRegisters(struct rt_rtmp_adapter *pAd)
-{
-	int i;
-	u8 RFValue;
-
-	/* Driver must read EEPROM to get RfIcType before initial RF registers */
-	/* Initialize RF register to default value */
-	if (IS_RT3070(pAd) || IS_RT3071(pAd)) {
-		/* Init RF calibration */
-		/* Driver should toggle RF R30 bit7 before init RF registers */
-		u32 RfReg = 0;
-		u32 data;
-
-		RT30xxReadRFRegister(pAd, RF_R30, (u8 *)&RfReg);
-		RfReg |= 0x80;
-		RT30xxWriteRFRegister(pAd, RF_R30, (u8)RfReg);
-		RTMPusecDelay(1000);
-		RfReg &= 0x7F;
-		RT30xxWriteRFRegister(pAd, RF_R30, (u8)RfReg);
-
-		/* Initialize RF register to default value */
-		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
-			RT30xxWriteRFRegister(pAd,
-					      RT30xx_RFRegTable[i].Register,
-					      RT30xx_RFRegTable[i].Value);
-		}
-
-		/* add by johnli */
-		if (IS_RT3070(pAd)) {
-			/* */
-			/* The DAC issue(LDO_CFG0) has been fixed in RT3070(F). */
-			/* The voltage raising patch is no longer needed for RT3070(F) */
-			/* */
-			if ((pAd->MACVersion & 0xffff) < 0x0201) {
-				/*  Update MAC 0x05D4 from 01xxxxxx to 0Dxxxxxx (voltage 1.2V to 1.35V) for RT3070 to improve yield rate */
-				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
-				data = ((data & 0xF0FFFFFF) | 0x0D000000);
-				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
-			}
-		} else if (IS_RT3071(pAd)) {
-			/* Driver should set RF R6 bit6 on before init RF registers */
-			RT30xxReadRFRegister(pAd, RF_R06, (u8 *)&RfReg);
-			RfReg |= 0x40;
-			RT30xxWriteRFRegister(pAd, RF_R06, (u8)RfReg);
-
-			/* init R31 */
-			RT30xxWriteRFRegister(pAd, RF_R31, 0x14);
-
-			/* RT3071 version E has fixed this issue */
-			if ((pAd->NicConfig2.field.DACTestBit == 1)
-			    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-				/* patch tx EVM issue temporarily */
-				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
-				data = ((data & 0xE0FFFFFF) | 0x0D000000);
-				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
-			} else {
-				RTMP_IO_READ32(pAd, LDO_CFG0, &data);
-				data = ((data & 0xE0FFFFFF) | 0x01000000);
-				RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
-			}
-
-			/* patch LNA_PE_G1 failed issue */
-			RTUSBReadMACRegister(pAd, GPIO_SWITCH, &data);
-			data &= ~(0x20);
-			RTUSBWriteMACRegister(pAd, GPIO_SWITCH, data);
-		}
-		/*For RF filter Calibration */
-		RTMPFilterCalibration(pAd);
-
-		/* Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration() */
-		/* */
-		/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
-		/* Raising RF voltage is no longer needed for RT3070(F) */
-		/* */
-		if ((IS_RT3070(pAd)) && ((pAd->MACVersion & 0xffff) < 0x0201)) {
-			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
-		} else if ((IS_RT3071(pAd))
-			   && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
-		}
-		/* set led open drain enable */
-		RTUSBReadMACRegister(pAd, OPT_14, &data);
-		data |= 0x01;
-		RTUSBWriteMACRegister(pAd, OPT_14, data);
-
-		/* move from RT30xxLoadRFNormalModeSetup because it's needed for both RT3070 and RT3071 */
-		/* TX_LO1_en, RF R17 register Bit 3 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
-		RFValue &= (~0x08);
-		/* to fix rx long range issue */
-		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
-			if ((IS_RT3071(pAd)
-			     && ((pAd->MACVersion & 0xffff) >= 0x0211))
-			    || IS_RT3070(pAd)) {
-				RFValue |= 0x20;
-			}
-		}
-		/* set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h */
-		if (pAd->TxMixerGain24G >= 1) {
-			RFValue &= (~0x7);	/* clean bit [2:0] */
-			RFValue |= pAd->TxMixerGain24G;
-		}
-		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
-
-		if (IS_RT3071(pAd)) {
-			/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
-			RT30xxLoadRFNormalModeSetup(pAd);
-		} else if (IS_RT3070(pAd)) {
-			/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
-			/* LDORF_VC, RF R27 register Bit 2 to 0 */
-			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-			/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
-			/* Raising RF voltage is no longer needed for RT3070(F) */
-			if ((pAd->MACVersion & 0xffff) < 0x0201)
-				RFValue = (RFValue & (~0x77)) | 0x3;
-			else
-				RFValue = (RFValue & (~0x77));
-			RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
-			/* end johnli */
-		}
-	}
-
-}
-#endif /* RT3070 // */
diff --git a/drivers/staging/rt2860/chips/rt3090.c b/drivers/staging/rt2860/chips/rt3090.c
deleted file mode 100644
index 334720e..0000000
--- a/drivers/staging/rt2860/chips/rt3090.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rt3090.c
-
-	Abstract:
-	Specific functions and variables for RT3070
-
-	Revision History:
-	Who         		When            What
-	Justin P. Mattock	11/07/2010	Fix a typo
-	--------    ----------    ----------------------------------------------
-*/
-
-#ifdef RT3090
-
-#include "../rt_config.h"
-
-#ifndef RTMP_RF_RW_SUPPORT
-#error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-void NICInitRT3090RFRegisters(struct rt_rtmp_adapter *pAd)
-{
-	int i;
-	/* Driver must read EEPROM to get RfIcType before initial RF registers */
-	/* Initialize RF register to default value */
-	if (IS_RT3090(pAd)) {
-		/* Init RF calibration */
-		/* Driver should toggle RF R30 bit7 before init RF registers */
-		u8 RfReg;
-		u32 data;
-
-		RT30xxReadRFRegister(pAd, RF_R30, (u8 *)&RfReg);
-		RfReg |= 0x80;
-		RT30xxWriteRFRegister(pAd, RF_R30, (u8)RfReg);
-		RTMPusecDelay(1000);
-		RfReg &= 0x7F;
-		RT30xxWriteRFRegister(pAd, RF_R30, (u8)RfReg);
-
-		/* init R24, R31 */
-		RT30xxWriteRFRegister(pAd, RF_R24, 0x0F);
-		RT30xxWriteRFRegister(pAd, RF_R31, 0x0F);
-
-		/* RT309x version E has fixed this issue */
-		if ((pAd->NicConfig2.field.DACTestBit == 1)
-		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-			/* patch tx EVM issue temporarily */
-			RTMP_IO_READ32(pAd, LDO_CFG0, &data);
-			data = ((data & 0xE0FFFFFF) | 0x0D000000);
-			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
-		} else {
-			RTMP_IO_READ32(pAd, LDO_CFG0, &data);
-			data = ((data & 0xE0FFFFFF) | 0x01000000);
-			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
-		}
-
-		/* patch LNA_PE_G1 failed issue */
-		RTMP_IO_READ32(pAd, GPIO_SWITCH, &data);
-		data &= ~(0x20);
-		RTMP_IO_WRITE32(pAd, GPIO_SWITCH, data);
-
-		/* Initialize RF register to default value */
-		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
-			RT30xxWriteRFRegister(pAd,
-					      RT30xx_RFRegTable[i].Register,
-					      RT30xx_RFRegTable[i].Value);
-		}
-
-		/* Driver should set RF R6 bit6 on before calibration */
-		RT30xxReadRFRegister(pAd, RF_R06, (u8 *)&RfReg);
-		RfReg |= 0x40;
-		RT30xxWriteRFRegister(pAd, RF_R06, (u8)RfReg);
-
-		/*For RF filter Calibration */
-		RTMPFilterCalibration(pAd);
-
-		/* Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration() */
-		if ((pAd->MACVersion & 0xffff) < 0x0211)
-			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
-
-		/* set led open drain enable */
-		RTMP_IO_READ32(pAd, OPT_14, &data);
-		data |= 0x01;
-		RTMP_IO_WRITE32(pAd, OPT_14, data);
-
-		/* set default antenna as main */
-		if (pAd->RfIcType == RFIC_3020)
-			AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt);
-
-		/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
-		RT30xxLoadRFNormalModeSetup(pAd);
-	}
-
-}
-
-#endif /* RT3090 // */
diff --git a/drivers/staging/rt2860/chips/rt30xx.c b/drivers/staging/rt2860/chips/rt30xx.c
deleted file mode 100644
index 354debf..0000000
--- a/drivers/staging/rt2860/chips/rt30xx.c
+++ /dev/null
@@ -1,516 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rt30xx.c
-
-	Abstract:
-	Specific functions and variables for RT30xx.
-
-	Revision History:
-	Who         		When            What
-	Justin P. Mattock	11/07/2010	Fix some typos
-	--------    ----------    ----------------------------------------------
-*/
-
-#ifdef RT30xx
-
-#ifndef RTMP_RF_RW_SUPPORT
-#error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-#include "../rt_config.h"
-
-/* */
-/* RF register initialization set */
-/* */
-struct rt_reg_pair RT30xx_RFRegTable[] = {
-	{RF_R04, 0x40}
-	,
-	{RF_R05, 0x03}
-	,
-	{RF_R06, 0x02}
-	,
-	{RF_R07, 0x60}
-	,
-	{RF_R09, 0x0F}
-	,
-	{RF_R10, 0x41}
-	,
-	{RF_R11, 0x21}
-	,
-	{RF_R12, 0x7B}
-	,
-	{RF_R14, 0x90}
-	,
-	{RF_R15, 0x58}
-	,
-	{RF_R16, 0xB3}
-	,
-	{RF_R17, 0x92}
-	,
-	{RF_R18, 0x2C}
-	,
-	{RF_R19, 0x02}
-	,
-	{RF_R20, 0xBA}
-	,
-	{RF_R21, 0xDB}
-	,
-	{RF_R24, 0x16}
-	,
-	{RF_R25, 0x01}
-	,
-	{RF_R29, 0x1F}
-	,
-};
-
-u8 NUM_RF_REG_PARMS = (sizeof(RT30xx_RFRegTable) / sizeof(struct rt_reg_pair));
-
-/* Antenna diversity use GPIO3 and EESK pin for control */
-/* Antenna and EEPROM access are both using EESK pin, */
-/* Therefor we should avoid accessing EESK at the same time */
-/* Then restore antenna after EEPROM access */
-/* The original name of this function is AsicSetRxAnt(), now change to */
-/*void AsicSetRxAnt( */
-void RT30xxSetRxAnt(struct rt_rtmp_adapter *pAd, u8 Ant)
-{
-	u32 Value;
-#ifdef RTMP_MAC_PCI
-	u32 x;
-#endif
-
-	if ((pAd->EepromAccess) ||
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) ||
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		return;
-	}
-	/* the antenna selection is through firmware and MAC register(GPIO3) */
-	if (Ant == 0) {
-		/* Main antenna */
-#ifdef RTMP_MAC_PCI
-		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-		x |= (EESK);
-		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-#else
-		AsicSendCommandToMcu(pAd, 0x73, 0xFF, 0x1, 0x0);
-#endif /* RTMP_MAC_PCI // */
-
-		RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);
-		Value &= ~(0x0808);
-		RTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("AsicSetRxAnt, switch to main antenna\n"));
-	} else {
-		/* Aux antenna */
-#ifdef RTMP_MAC_PCI
-		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-		x &= ~(EESK);
-		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-#else
-		AsicSendCommandToMcu(pAd, 0x73, 0xFF, 0x0, 0x0);
-#endif /* RTMP_MAC_PCI // */
-		RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);
-		Value &= ~(0x0808);
-		Value |= 0x08;
-		RTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("AsicSetRxAnt, switch to aux antenna\n"));
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		For RF filter calibration purpose
-
-	Arguments:
-		pAd                          Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-void RTMPFilterCalibration(struct rt_rtmp_adapter *pAd)
-{
-	u8 R55x = 0, value, FilterTarget = 0x1E, BBPValue = 0;
-	u32 loop = 0, count = 0, loopcnt = 0, ReTry = 0;
-	u8 RF_R24_Value = 0;
-
-	/* Give bbp filter initial value */
-	pAd->Mlme.CaliBW20RfR24 = 0x1F;
-	pAd->Mlme.CaliBW40RfR24 = 0x2F;	/*Bit[5] must be 1 for BW 40 */
-
-	do {
-		if (loop == 1) {	/*BandWidth = 40 MHz */
-			/* Write 0x27 to RF_R24 to program filter */
-			RF_R24_Value = 0x27;
-			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-				FilterTarget = 0x15;
-			else
-				FilterTarget = 0x19;
-
-			/* when calibrate BW40, BBP mask must set to BW40. */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-			BBPValue &= (~0x18);
-			BBPValue |= (0x10);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-
-			/* set to BW40 */
-			RT30xxReadRFRegister(pAd, RF_R31, &value);
-			value |= 0x20;
-			RT30xxWriteRFRegister(pAd, RF_R31, value);
-		} else {	/*BandWidth = 20 MHz */
-			/* Write 0x07 to RF_R24 to program filter */
-			RF_R24_Value = 0x07;
-			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-				FilterTarget = 0x13;
-			else
-				FilterTarget = 0x16;
-
-			/* set to BW20 */
-			RT30xxReadRFRegister(pAd, RF_R31, &value);
-			value &= (~0x20);
-			RT30xxWriteRFRegister(pAd, RF_R31, value);
-		}
-
-		/* Write 0x01 to RF_R22 to enable baseband loopback mode */
-		RT30xxReadRFRegister(pAd, RF_R22, &value);
-		value |= 0x01;
-		RT30xxWriteRFRegister(pAd, RF_R22, value);
-
-		/* Write 0x00 to BBP_R24 to set power & frequency of passband test tone */
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0);
-
-		do {
-			/* Write 0x90 to BBP_R25 to transmit test tone */
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
-
-			RTMPusecDelay(1000);
-			/* Read BBP_R55[6:0] for received power, set R55x = BBP_R55[6:0] */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R55, &value);
-			R55x = value & 0xFF;
-
-		} while ((ReTry++ < 100) && (R55x == 0));
-
-		/* Write 0x06 to BBP_R24 to set power & frequency of stopband test tone */
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0x06);
-
-		while (TRUE) {
-			/* Write 0x90 to BBP_R25 to transmit test tone */
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
-
-			/*We need to wait for calibration */
-			RTMPusecDelay(1000);
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R55, &value);
-			value &= 0xFF;
-			if ((R55x - value) < FilterTarget) {
-				RF_R24_Value++;
-			} else if ((R55x - value) == FilterTarget) {
-				RF_R24_Value++;
-				count++;
-			} else {
-				break;
-			}
-
-			/* prevent infinite loop; causes driver hang. */
-			if (loopcnt++ > 100) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("RTMPFilterCalibration - can't find a valid value, loopcnt=%d stop calibrating",
-					  loopcnt));
-				break;
-			}
-			/* Write RF_R24 to program filter */
-			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-		}
-
-		if (count > 0) {
-			RF_R24_Value = RF_R24_Value - ((count) ? (1) : (0));
-		}
-		/* Store for future usage */
-		if (loopcnt < 100) {
-			if (loop++ == 0) {
-				/*BandWidth = 20 MHz */
-				pAd->Mlme.CaliBW20RfR24 = (u8)RF_R24_Value;
-			} else {
-				/*BandWidth = 40 MHz */
-				pAd->Mlme.CaliBW40RfR24 = (u8)RF_R24_Value;
-				break;
-			}
-		} else
-			break;
-
-		RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-
-		/* reset count */
-		count = 0;
-	} while (TRUE);
-
-	/* */
-	/* Set back to initial state */
-	/* */
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0);
-
-	RT30xxReadRFRegister(pAd, RF_R22, &value);
-	value &= ~(0x01);
-	RT30xxWriteRFRegister(pAd, RF_R22, value);
-
-	/* set BBP back to BW20 */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-	BBPValue &= (~0x18);
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPFilterCalibration - CaliBW20RfR24=0x%x, CaliBW40RfR24=0x%x\n",
-		  pAd->Mlme.CaliBW20RfR24, pAd->Mlme.CaliBW40RfR24));
-}
-
-/* add by johnli, RF power sequence setup */
-/*
-	==========================================================================
-	Description:
-
-	Load RF normal operation-mode setup
-
-	==========================================================================
- */
-void RT30xxLoadRFNormalModeSetup(struct rt_rtmp_adapter *pAd)
-{
-	u8 RFValue;
-
-	/* RX0_PD & TX0_PD, RF R1 register Bit 2 & Bit 3 to 0 and RF_BLOCK_en,RX1_PD & TX1_PD, Bit0, Bit 4 & Bit5 to 1 */
-	RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
-	RFValue = (RFValue & (~0x0C)) | 0x31;
-	RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
-
-	/* TX_LO2_en, RF R15 register Bit 3 to 0 */
-	RT30xxReadRFRegister(pAd, RF_R15, &RFValue);
-	RFValue &= (~0x08);
-	RT30xxWriteRFRegister(pAd, RF_R15, RFValue);
-
-	/* move to NICInitRT30xxRFRegisters
-	   // TX_LO1_en, RF R17 register Bit 3 to 0
-	   RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
-	   RFValue &= (~0x08);
-	   // to fix rx long range issue
-	   if (((pAd->MACVersion & 0xffff) >= 0x0211) && (pAd->NicConfig2.field.ExternalLNAForG == 0))
-	   {
-	   RFValue |= 0x20;
-	   }
-	   // set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
-	   if (pAd->TxMixerGain24G >= 2)
-	   {
-	   RFValue &= (~0x7);  // clean bit [2:0]
-	   RFValue |= pAd->TxMixerGain24G;
-	   }
-	   RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
-	 */
-
-	/* RX_LO1_en, RF R20 register Bit 3 to 0 */
-	RT30xxReadRFRegister(pAd, RF_R20, &RFValue);
-	RFValue &= (~0x08);
-	RT30xxWriteRFRegister(pAd, RF_R20, RFValue);
-
-	/* RX_LO2_en, RF R21 register Bit 3 to 0 */
-	RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
-	RFValue &= (~0x08);
-	RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
-
-	/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
-	/* LDORF_VC, RF R27 register Bit 2 to 0 */
-	RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-	/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
-	/* Raising RF voltage is no longer needed for RT3070(F) */
-	if (IS_RT3090(pAd)) {	/* RT309x and RT3071/72 */
-		if ((pAd->MACVersion & 0xffff) < 0x0211)
-			RFValue = (RFValue & (~0x77)) | 0x3;
-		else
-			RFValue = (RFValue & (~0x77));
-		RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
-	}
-	/* end johnli */
-}
-
-/*
-	==========================================================================
-	Description:
-
-	Load RF sleep-mode setup
-
-	==========================================================================
- */
-void RT30xxLoadRFSleepModeSetup(struct rt_rtmp_adapter *pAd)
-{
-	u8 RFValue;
-	u32 MACValue;
-
-#ifdef RTMP_MAC_USB
-	if (!IS_RT3572(pAd))
-#endif /* RTMP_MAC_USB // */
-	{
-		/* RF_BLOCK_en. RF R1 register Bit 0 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
-		RFValue &= (~0x01);
-		RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
-
-		/* VCO_IC, RF R7 register Bit 4 & Bit 5 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
-		RFValue &= (~0x30);
-		RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
-
-		/* Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R09, &RFValue);
-		RFValue &= (~0x0E);
-		RT30xxWriteRFRegister(pAd, RF_R09, RFValue);
-
-		/* RX_CTB_en, RF R21 register Bit 7 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
-		RFValue &= (~0x80);
-		RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
-	}
-
-	if (IS_RT3090(pAd) ||	/* IS_RT3090 including RT309x and RT3071/72 */
-	    IS_RT3572(pAd) ||
-	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
-#ifdef RTMP_MAC_USB
-		if (!IS_RT3572(pAd))
-#endif /* RTMP_MAC_USB // */
-		{
-			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-			RFValue |= 0x77;
-			RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
-		}
-
-		RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
-		MACValue |= 0x1D000000;
-		RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	Reverse RF sleep-mode setup
-
-	==========================================================================
- */
-void RT30xxReverseRFSleepModeSetup(struct rt_rtmp_adapter *pAd)
-{
-	u8 RFValue;
-	u32 MACValue;
-
-#ifdef RTMP_MAC_USB
-	if (!IS_RT3572(pAd))
-#endif /* RTMP_MAC_USB // */
-	{
-		/* RF_BLOCK_en, RF R1 register Bit 0 to 1 */
-		RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
-		RFValue |= 0x01;
-		RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
-
-		/* VCO_IC, RF R7 register Bit 4 & Bit 5 to 1 */
-		RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
-		RFValue |= 0x20;
-		RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
-
-		/* Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 1 */
-		RT30xxReadRFRegister(pAd, RF_R09, &RFValue);
-		RFValue |= 0x0E;
-		RT30xxWriteRFRegister(pAd, RF_R09, RFValue);
-
-		/* RX_CTB_en, RF R21 register Bit 7 to 1 */
-		RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
-		RFValue |= 0x80;
-		RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
-	}
-
-	if (IS_RT3090(pAd) ||	/* IS_RT3090 including RT309x and RT3071/72 */
-	    IS_RT3572(pAd) ||
-	    IS_RT3390(pAd) ||
-	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
-#ifdef RTMP_MAC_USB
-		if (!IS_RT3572(pAd))
-#endif /* RTMP_MAC_USB // */
-		{
-			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-			if ((pAd->MACVersion & 0xffff) < 0x0211)
-				RFValue = (RFValue & (~0x77)) | 0x3;
-			else
-				RFValue = (RFValue & (~0x77));
-			RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
-		}
-		/* RT3071 version E has fixed this issue */
-		if ((pAd->NicConfig2.field.DACTestBit == 1)
-		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-			/* patch tx EVM issue temporarily */
-			RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
-			MACValue = ((MACValue & 0xE0FFFFFF) | 0x0D000000);
-			RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
-		} else {
-			RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
-			MACValue = ((MACValue & 0xE0FFFFFF) | 0x01000000);
-			RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
-		}
-	}
-
-	if (IS_RT3572(pAd))
-		RT30xxWriteRFRegister(pAd, RF_R08, 0x80);
-}
-
-/* end johnli */
-
-void RT30xxHaltAction(struct rt_rtmp_adapter *pAd)
-{
-	u32 TxPinCfg = 0x00050F0F;
-
-	/* */
-	/* Turn off LNA_PE or TRSW_POL */
-	/* */
-	if (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd)) {
-		if ((IS_RT3071(pAd) || IS_RT3572(pAd))
-#ifdef RTMP_EFUSE_SUPPORT
-		    && (pAd->bUseEfuse)
-#endif /* RTMP_EFUSE_SUPPORT // */
-		    ) {
-			TxPinCfg &= 0xFFFBF0F0;	/* bit18 off */
-		} else {
-			TxPinCfg &= 0xFFFFF0F0;
-		}
-
-		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
-	}
-}
-
-#endif /* RT30xx // */
diff --git a/drivers/staging/rt2860/chlist.h b/drivers/staging/rt2860/chlist.h
deleted file mode 100644
index 1231e69..0000000
--- a/drivers/staging/rt2860/chlist.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	chlist.c
-
-	Abstract:
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-	Fonchi Wu   2007-12-19    created
-*/
-
-#ifndef __CHLIST_H__
-#define __CHLIST_H__
-
-#include "rtmp_type.h"
-#include "rtmp_def.h"
-
-#define ODOR			0
-#define IDOR			1
-#define BOTH			2
-
-#define BAND_5G         0
-#define BAND_24G        1
-#define BAND_BOTH       2
-
-struct rt_ch_desp {
-	u8 FirstChannel;
-	u8 NumOfCh;
-	char MaxTxPwr;		/* dBm */
-	u8 Geography;	/* 0:out door, 1:in door, 2:both */
-	BOOLEAN DfsReq;		/* Dfs require, 0: No, 1: yes. */
-};
-
-struct rt_ch_region {
-	u8 CountReg[3];
-	u8 DfsType;		/* 0: CE, 1: FCC, 2: JAP, 3:JAP_W53, JAP_W56 */
-	struct rt_ch_desp ChDesp[10];
-};
-
-extern struct rt_ch_region ChRegion[];
-
-struct rt_ch_freq_map {
-	u16 channel;
-	u16 freqKHz;
-};
-
-extern struct rt_ch_freq_map CH_HZ_ID_MAP[];
-extern int CH_HZ_ID_MAP_NUM;
-
-#define     MAP_CHANNEL_ID_TO_KHZ(_ch, _khz)		\
-		do {							\
-			int _chIdx;					\
-			for (_chIdx = 0; _chIdx < CH_HZ_ID_MAP_NUM; _chIdx++) {\
-				if ((_ch) == CH_HZ_ID_MAP[_chIdx].channel) { \
-					(_khz) = CH_HZ_ID_MAP[_chIdx].freqKHz * 1000;\
-					break;				\
-				}					\
-			}						\
-			if (_chIdx == CH_HZ_ID_MAP_NUM)	\
-				(_khz) = 2412000;		\
-		} while (0)
-
-#define     MAP_KHZ_TO_CHANNEL_ID(_khz, _ch)                 \
-		do {							\
-			int _chIdx;				\
-			for (_chIdx = 0; _chIdx < CH_HZ_ID_MAP_NUM; _chIdx++) {\
-				if ((_khz) == CH_HZ_ID_MAP[_chIdx].freqKHz) {\
-					(_ch) = CH_HZ_ID_MAP[_chIdx].channel; \
-					break;			\
-				}					\
-			}						\
-			if (_chIdx == CH_HZ_ID_MAP_NUM)			\
-				(_ch) = 1;				\
-		} while (0)
-
-void BuildChannelListEx(struct rt_rtmp_adapter *pAd);
-
-void BuildBeaconChList(struct rt_rtmp_adapter *pAd,
-		       u8 *pBuf, unsigned long *pBufLen);
-
-void N_ChannelCheck(struct rt_rtmp_adapter *pAd);
-
-void N_SetCenCh(struct rt_rtmp_adapter *pAd);
-
-u8 GetCuntryMaxTxPwr(struct rt_rtmp_adapter *pAd, u8 channel);
-
-#endif /* __CHLIST_H__ */
diff --git a/drivers/staging/rt2860/common/action.c b/drivers/staging/rt2860/common/action.c
deleted file mode 100644
index 56ad236..0000000
--- a/drivers/staging/rt2860/common/action.c
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	action.c
-
-    Abstract:
-    Handle association related requests either from WSTA or from local MLME
-
-    Revision History:
-    Who         When          What
-    --------    ----------    ----------------------------------------------
-	Jan Lee		2006	  	created for rt2860
- */
-
-#include "../rt_config.h"
-#include "action.h"
-
-static void ReservedAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-/*
-    ==========================================================================
-    Description:
-        association state machine init, including state transition and timer init
-    Parameters:
-        S - pointer to the association state machine
-    Note:
-        The state machine looks like the following
-
-                                    ASSOC_IDLE
-        MT2_MLME_DISASSOC_REQ    mlme_disassoc_req_action
-        MT2_PEER_DISASSOC_REQ    peer_disassoc_action
-        MT2_PEER_ASSOC_REQ       drop
-        MT2_PEER_REASSOC_REQ     drop
-        MT2_CLS3ERR              cls3err_action
-    ==========================================================================
- */
-void ActionStateMachineInit(struct rt_rtmp_adapter *pAd,
-			    struct rt_state_machine *S,
-			    OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(S, (STATE_MACHINE_FUNC *) Trans, MAX_ACT_STATE,
-			 MAX_ACT_MSG, (STATE_MACHINE_FUNC) Drop, ACT_IDLE,
-			 ACT_MACHINE_BASE);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_SPECTRUM_CATE,
-			      (STATE_MACHINE_FUNC) PeerSpectrumAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_QOS_CATE,
-			      (STATE_MACHINE_FUNC) PeerQOSAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_DLS_CATE,
-			      (STATE_MACHINE_FUNC) ReservedAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_BA_CATE,
-			      (STATE_MACHINE_FUNC) PeerBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_HT_CATE,
-			      (STATE_MACHINE_FUNC) PeerHTAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ADD_BA_CATE,
-			      (STATE_MACHINE_FUNC) MlmeADDBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ORI_DELBA_CATE,
-			      (STATE_MACHINE_FUNC) MlmeDELBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_REC_DELBA_CATE,
-			      (STATE_MACHINE_FUNC) MlmeDELBAAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_PUBLIC_CATE,
-			      (STATE_MACHINE_FUNC) PeerPublicAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_RM_CATE,
-			      (STATE_MACHINE_FUNC) PeerRMAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_QOS_CATE,
-			      (STATE_MACHINE_FUNC) MlmeQOSAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_DLS_CATE,
-			      (STATE_MACHINE_FUNC) MlmeDLSAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_ACT_INVALID,
-			      (STATE_MACHINE_FUNC) MlmeInvalidAction);
-}
-
-void MlmeADDBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_addba_req *pInfo;
-	u8 Addr[6];
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long Idx;
-	struct rt_frame_addba_req Frame;
-	unsigned long FrameLen;
-	struct rt_ba_ori_entry *pBAEntry = NULL;
-
-	pInfo = (struct rt_mlme_addba_req *)Elem->Msg;
-	NdisZeroMemory(&Frame, sizeof(struct rt_frame_addba_req));
-
-	if (MlmeAddBAReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr)) {
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BA - MlmeADDBAAction() allocate memory failed \n"));
-			return;
-		}
-		/* 1. find entry */
-		Idx =
-		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
-		if (Idx == 0) {
-			MlmeFreeMemory(pAd, pOutBuffer);
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("BA - MlmeADDBAAction() can't find BAOriEntry \n"));
-			return;
-		} else {
-			pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-		}
-
-		{
-			if (ADHOC_ON(pAd))
-				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr,
-					      pAd->CurrentAddress,
-					      pAd->CommonCfg.Bssid);
-			else
-				ActHeaderInit(pAd, &Frame.Hdr,
-					      pAd->CommonCfg.Bssid,
-					      pAd->CurrentAddress,
-					      pInfo->pAddr);
-		}
-
-		Frame.Category = CATEGORY_BA;
-		Frame.Action = ADDBA_REQ;
-		Frame.BaParm.AMSDUSupported = 0;
-		Frame.BaParm.BAPolicy = IMMED_BA;
-		Frame.BaParm.TID = pInfo->TID;
-		Frame.BaParm.BufSize = pInfo->BaBufSize;
-		Frame.Token = pInfo->Token;
-		Frame.TimeOutValue = pInfo->TimeOutValue;
-		Frame.BaStartSeq.field.FragNum = 0;
-		Frame.BaStartSeq.field.StartSeq =
-		    pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];
-
-		*(u16 *) (&Frame.BaParm) =
-		    cpu2le16(*(u16 *) (&Frame.BaParm));
-		Frame.TimeOutValue = cpu2le16(Frame.TimeOutValue);
-		Frame.BaStartSeq.word = cpu2le16(Frame.BaStartSeq.word);
-
-		MakeOutgoingFrame(pOutBuffer, &FrameLen,
-				  sizeof(struct rt_frame_addba_req), &Frame, END_OF_ARGS);
-
-		MiniportMMRequest(pAd,
-				  (MGMT_USE_QUEUE_FLAG |
-				   MapUserPriorityToAccessCategory[pInfo->TID]),
-				  pOutBuffer, FrameLen);
-
-		MlmeFreeMemory(pAd, pOutBuffer);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BA - Send ADDBA request. StartSeq = %x,  FrameLen = %ld. BufSize = %d\n",
-			  Frame.BaStartSeq.field.StartSeq, FrameLen,
-			  Frame.BaParm.BufSize));
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-        send DELBA and delete BaEntry if any
-    Parametrs:
-        Elem - MLME message struct rt_mlme_delba_req
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void MlmeDELBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_delba_req *pInfo;
-	u8 *pOutBuffer = NULL;
-	u8 *pOutBuffer2 = NULL;
-	int NStatus;
-	unsigned long Idx;
-	struct rt_frame_delba_req Frame;
-	unsigned long FrameLen;
-	struct rt_frame_bar FrameBar;
-
-	pInfo = (struct rt_mlme_delba_req *)Elem->Msg;
-	/* must send back DELBA */
-	NdisZeroMemory(&Frame, sizeof(struct rt_frame_delba_req));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==> MlmeDELBAAction(), Initiator(%d) \n", pInfo->Initiator));
-
-	if (MlmeDelBAReqSanity(pAd, Elem->Msg, Elem->MsgLen)) {
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("BA - MlmeDELBAAction() allocate memory failed 1. \n"));
-			return;
-		}
-
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			MlmeFreeMemory(pAd, pOutBuffer);
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("BA - MlmeDELBAAction() allocate memory failed 2. \n"));
-			return;
-		}
-		/* SEND BAR (Send BAR to refresh peer reordering buffer.) */
-		Idx =
-		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
-
-		BarHeaderInit(pAd, &FrameBar,
-			      pAd->MacTab.Content[pInfo->Wcid].Addr,
-			      pAd->CurrentAddress);
-
-		FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.BarControl.TID = pInfo->TID;	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.BarControl.ACKPolicy = IMMED_BA;	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.BarControl.Compressed = 1;	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.BarControl.MTID = 0;	/* make sure sequence not clear in DEL funciton. */
-
-		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
-				  sizeof(struct rt_frame_bar), &FrameBar, END_OF_ARGS);
-		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer2, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer2);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BA - MlmeDELBAAction() . Send BAR to refresh peer reordering buffer \n"));
-
-		/* SEND DELBA FRAME */
-		FrameLen = 0;
-
-		{
-			if (ADHOC_ON(pAd))
-				ActHeaderInit(pAd, &Frame.Hdr,
-					      pAd->MacTab.Content[pInfo->Wcid].
-					      Addr, pAd->CurrentAddress,
-					      pAd->CommonCfg.Bssid);
-			else
-				ActHeaderInit(pAd, &Frame.Hdr,
-					      pAd->CommonCfg.Bssid,
-					      pAd->CurrentAddress,
-					      pAd->MacTab.Content[pInfo->Wcid].
-					      Addr);
-		}
-
-		Frame.Category = CATEGORY_BA;
-		Frame.Action = DELBA;
-		Frame.DelbaParm.Initiator = pInfo->Initiator;
-		Frame.DelbaParm.TID = pInfo->TID;
-		Frame.ReasonCode = 39;	/* Time Out */
-		*(u16 *) (&Frame.DelbaParm) =
-		    cpu2le16(*(u16 *) (&Frame.DelbaParm));
-		Frame.ReasonCode = cpu2le16(Frame.ReasonCode);
-
-		MakeOutgoingFrame(pOutBuffer, &FrameLen,
-				  sizeof(struct rt_frame_delba_req), &Frame, END_OF_ARGS);
-		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BA - MlmeDELBAAction() . 3 DELBA sent. Initiator(%d)\n",
-			  pInfo->Initiator));
-	}
-}
-
-void MlmeQOSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-void MlmeDLSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-void MlmeInvalidAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	/*u8 *                  pOutBuffer = NULL; */
-	/*Return the receiving frame except the MSB of category filed set to 1.  7.3.1.11 */
-}
-
-void PeerQOSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-void PeerBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Action = Elem->Msg[LENGTH_802_11 + 1];
-
-	switch (Action) {
-	case ADDBA_REQ:
-		PeerAddBAReqAction(pAd, Elem);
-		break;
-	case ADDBA_RESP:
-		PeerAddBARspAction(pAd, Elem);
-		break;
-	case DELBA:
-		PeerDelBAAction(pAd, Elem);
-		break;
-	}
-}
-
-void PeerPublicAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return;
-}
-
-static void ReservedAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Category;
-
-	if (Elem->MsgLen <= LENGTH_802_11) {
-		return;
-	}
-
-	Category = Elem->Msg[LENGTH_802_11];
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Rcv reserved category(%d) Action Frame\n", Category));
-	hex_dump("Reserved Action Frame", &Elem->Msg[0], Elem->MsgLen);
-}
-
-void PeerRMAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	return;
-}
-
-static void respond_ht_information_exchange_action(struct rt_rtmp_adapter *pAd,
-						   struct rt_mlme_queue_elem *Elem)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-	struct rt_frame_ht_info HTINFOframe, *pFrame;
-	u8 *pAddr;
-
-	/* 2. Always send back ADDBA Response */
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ACTION - respond_ht_information_exchange_action() allocate memory failed \n"));
-		return;
-	}
-	/* get RA */
-	pFrame = (struct rt_frame_ht_info *) & Elem->Msg[0];
-	pAddr = pFrame->Hdr.Addr2;
-
-	NdisZeroMemory(&HTINFOframe, sizeof(struct rt_frame_ht_info));
-	/* 2-1. Prepare ADDBA Response frame. */
-	{
-		if (ADHOC_ON(pAd))
-			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr,
-				      pAd->CurrentAddress,
-				      pAd->CommonCfg.Bssid);
-		else
-			ActHeaderInit(pAd, &HTINFOframe.Hdr,
-				      pAd->CommonCfg.Bssid, pAd->CurrentAddress,
-				      pAddr);
-	}
-
-	HTINFOframe.Category = CATEGORY_HT;
-	HTINFOframe.Action = HT_INFO_EXCHANGE;
-	HTINFOframe.HT_Info.Request = 0;
-	HTINFOframe.HT_Info.Forty_MHz_Intolerant =
-	    pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant;
-	HTINFOframe.HT_Info.STA_Channel_Width =
-	    pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth;
-
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  sizeof(struct rt_frame_ht_info), &HTINFOframe, END_OF_ARGS);
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-}
-
-void PeerHTAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Action = Elem->Msg[LENGTH_802_11 + 1];
-
-	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return;
-
-	switch (Action) {
-	case NOTIFY_BW_ACTION:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ACTION - HT Notify Channel bandwidth action----> \n"));
-
-		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
-			/* Note, this is to patch DIR-1353 AP. When the AP set to Wep, it will use legacy mode. But AP still keeps */
-			/* sending BW_Notify Action frame, and cause us to linkup and linkdown. */
-			/* In legacy mode, don't need to parse HT action frame. */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ACTION -Ignore HT Notify Channel BW when link as legacy mode. BW = %d---> \n",
-				  Elem->Msg[LENGTH_802_11 + 2]));
-			break;
-		}
-
-		if (Elem->Msg[LENGTH_802_11 + 2] == 0)	/* 7.4.8.2. if value is 1, keep the same as supported channel bandwidth. */
-			pAd->MacTab.Content[Elem->Wcid].HTPhyMode.field.BW = 0;
-
-		break;
-	case SMPS_ACTION:
-		/* 7.3.1.25 */
-		DBGPRINT(RT_DEBUG_TRACE, ("ACTION - SMPS action----> \n"));
-		if (((Elem->Msg[LENGTH_802_11 + 2] & 0x1) == 0)) {
-			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_ENABLE;
-		} else if (((Elem->Msg[LENGTH_802_11 + 2] & 0x2) == 0)) {
-			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_STATIC;
-		} else {
-			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_DYNAMIC;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Aid(%d) MIMO PS = %d\n", Elem->Wcid,
-			  pAd->MacTab.Content[Elem->Wcid].MmpsMode));
-		/* rt2860c : add something for smps change. */
-		break;
-
-	case SETPCO_ACTION:
-		break;
-	case MIMO_CHA_MEASURE_ACTION:
-		break;
-	case HT_INFO_EXCHANGE:
-		{
-			struct rt_ht_information_octet *pHT_info;
-
-			pHT_info =
-			    (struct rt_ht_information_octet *) & Elem->Msg[LENGTH_802_11 +
-								 2];
-			/* 7.4.8.10 */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ACTION - HT Information Exchange action----> \n"));
-			if (pHT_info->Request) {
-				respond_ht_information_exchange_action(pAd,
-								       Elem);
-			}
-		}
-		break;
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		Retry sending ADDBA Reqest.
-
-	IRQL = DISPATCH_LEVEL
-
-	Parametrs:
-	p8023Header: if this is already 802.3 format, p8023Header is NULL
-
-	Return	: TRUE if put into rx reordering buffer, shouldn't indicaterxhere.
-				FALSE , then continue indicaterx at this moment.
-	==========================================================================
- */
-void ORIBATimerTimeout(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_mac_table_entry *pEntry;
-	int i, total;
-	u8 TID;
-
-	total = pAd->MacTab.Size * NUM_OF_TID;
-
-	for (i = 1; ((i < MAX_LEN_OF_BA_ORI_TABLE) && (total > 0)); i++) {
-		if (pAd->BATable.BAOriEntry[i].ORI_BA_Status == Originator_Done) {
-			pEntry =
-			    &pAd->MacTab.Content[pAd->BATable.BAOriEntry[i].
-						 Wcid];
-			TID = pAd->BATable.BAOriEntry[i].TID;
-
-			ASSERT(pAd->BATable.BAOriEntry[i].Wcid <
-			       MAX_LEN_OF_MAC_TABLE);
-		}
-		total--;
-	}
-}
-
-void SendRefreshBAR(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry)
-{
-	struct rt_frame_bar FrameBar;
-	unsigned long FrameLen;
-	int NStatus;
-	u8 *pOutBuffer = NULL;
-	u16 Sequence;
-	u8 i, TID;
-	u16 idx;
-	struct rt_ba_ori_entry *pBAEntry;
-
-	for (i = 0; i < NUM_OF_TID; i++) {
-		idx = pEntry->BAOriWcidArray[i];
-		if (idx == 0) {
-			continue;
-		}
-		pBAEntry = &pAd->BATable.BAOriEntry[idx];
-
-		if (pBAEntry->ORI_BA_Status == Originator_Done) {
-			TID = pBAEntry->TID;
-
-			ASSERT(pBAEntry->Wcid < MAX_LEN_OF_MAC_TABLE);
-
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-			if (NStatus != NDIS_STATUS_SUCCESS) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("BA - MlmeADDBAAction() allocate memory failed \n"));
-				return;
-			}
-
-			Sequence = pEntry->TxSeq[TID];
-
-			BarHeaderInit(pAd, &FrameBar, pEntry->Addr,
-				      pAd->CurrentAddress);
-
-			FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL function. */
-			FrameBar.StartingSeq.field.StartSeq = Sequence;	/* make sure sequence not clear in DEL funciton. */
-			FrameBar.BarControl.TID = TID;	/* make sure sequence not clear in DEL funciton. */
-
-			MakeOutgoingFrame(pOutBuffer, &FrameLen,
-					  sizeof(struct rt_frame_bar), &FrameBar,
-					  END_OF_ARGS);
-			/*if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET))) */
-			if (1)	/* Now we always send BAR. */
-			{
-				/*MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen); */
-				MiniportMMRequest(pAd,
-						  (MGMT_USE_QUEUE_FLAG |
-						   MapUserPriorityToAccessCategory
-						   [TID]), pOutBuffer,
-						  FrameLen);
-
-			}
-			MlmeFreeMemory(pAd, pOutBuffer);
-		}
-	}
-}
-
-void ActHeaderInit(struct rt_rtmp_adapter *pAd,
-		   struct rt_header_802_11 * pHdr80211,
-		   u8 *Addr1, u8 *Addr2, u8 *Addr3)
-{
-	NdisZeroMemory(pHdr80211, sizeof(struct rt_header_802_11));
-	pHdr80211->FC.Type = BTYPE_MGMT;
-	pHdr80211->FC.SubType = SUBTYPE_ACTION;
-
-	COPY_MAC_ADDR(pHdr80211->Addr1, Addr1);
-	COPY_MAC_ADDR(pHdr80211->Addr2, Addr2);
-	COPY_MAC_ADDR(pHdr80211->Addr3, Addr3);
-}
-
-void BarHeaderInit(struct rt_rtmp_adapter *pAd,
-		   struct rt_frame_bar * pCntlBar, u8 *pDA, u8 *pSA)
-{
-	NdisZeroMemory(pCntlBar, sizeof(struct rt_frame_bar));
-	pCntlBar->FC.Type = BTYPE_CNTL;
-	pCntlBar->FC.SubType = SUBTYPE_BLOCK_ACK_REQ;
-	pCntlBar->BarControl.MTID = 0;
-	pCntlBar->BarControl.Compressed = 1;
-	pCntlBar->BarControl.ACKPolicy = 0;
-
-	pCntlBar->Duration =
-	    16 + RTMPCalcDuration(pAd, RATE_1, sizeof(struct rt_frame_ba));
-
-	COPY_MAC_ADDR(pCntlBar->Addr1, pDA);
-	COPY_MAC_ADDR(pCntlBar->Addr2, pSA);
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert Category and action code into the action frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. category code of the frame.
-		4. action code of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void InsertActField(struct rt_rtmp_adapter *pAd,
-		    u8 *pFrameBuf,
-		    unsigned long *pFrameLen, u8 Category, u8 ActCode)
-{
-	unsigned long TempLen;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &Category, 1, &ActCode, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
diff --git a/drivers/staging/rt2860/common/action.h b/drivers/staging/rt2860/common/action.h
deleted file mode 100644
index 974f8b8..0000000
--- a/drivers/staging/rt2860/common/action.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	aironet.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name		Date			Modification logs
-	Paul Lin	04-06-15		Initial
-*/
-
-#ifndef	__ACTION_H__
-#define	__ACTION_H__
-
-struct PACKED rt_ht_information_octet {
-	u8 Request:1;
-	u8 Forty_MHz_Intolerant:1;
-	u8 STA_Channel_Width:1;
-	u8 Reserved:5;
-};
-
-struct PACKED rt_frame_ht_info {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	struct rt_ht_information_octet HT_Info;
-};
-
-#endif /* __ACTION_H__ */
diff --git a/drivers/staging/rt2860/common/ba_action.c b/drivers/staging/rt2860/common/ba_action.c
deleted file mode 100644
index 133bc1b..0000000
--- a/drivers/staging/rt2860/common/ba_action.c
+++ /dev/null
@@ -1,1650 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-#include "../rt_config.h"
-#include <linux/kernel.h>
-
-#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	/*1                        // initial sequence number of BA session */
-
-#define ORI_SESSION_MAX_RETRY	8
-#define ORI_BA_SESSION_TIMEOUT	(2000)	/* ms */
-#define REC_BA_SESSION_IDLE_TIMEOUT	(1000)	/* ms */
-
-#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	/* system ticks -- 100 ms */
-#define MAX_REORDERING_PACKET_TIMEOUT	((3000 * OS_HZ)/1000)	/* system ticks -- 100 ms */
-
-#define RESET_RCV_SEQ		(0xFFFF)
-
-static void ba_mpdu_blk_free(struct rt_rtmp_adapter *pAd,
-			     struct reordering_mpdu *mpdu_blk);
-
-struct rt_ba_ori_entry *BATableAllocOriEntry(struct rt_rtmp_adapter *pAd, u16 * Idx);
-
-struct rt_ba_rec_entry *BATableAllocRecEntry(struct rt_rtmp_adapter *pAd, u16 * Idx);
-
-void BAOriSessionSetupTimeout(void *SystemSpecific1,
-			      void *FunctionContext,
-			      void *SystemSpecific2,
-			      void *SystemSpecific3);
-
-void BARecSessionIdleTimeout(void *SystemSpecific1,
-			     void *FunctionContext,
-			     void *SystemSpecific2,
-			     void *SystemSpecific3);
-
-BUILD_TIMER_FUNCTION(BAOriSessionSetupTimeout);
-BUILD_TIMER_FUNCTION(BARecSessionIdleTimeout);
-
-#define ANNOUNCE_REORDERING_PACKET(_pAd, _mpdu_blk)	\
-			Announce_Reordering_Packet(_pAd, _mpdu_blk);
-
-void BA_MaxWinSizeReasign(struct rt_rtmp_adapter *pAd,
-			  struct rt_mac_table_entry *pEntryPeer, u8 * pWinSize)
-{
-	u8 MaxSize;
-
-	if (pAd->MACVersion >= RALINK_2883_VERSION)	/* 3*3 */
-	{
-		if (pAd->MACVersion >= RALINK_3070_VERSION) {
-			if (pEntryPeer->WepStatus !=
-			    Ndis802_11EncryptionDisabled)
-				MaxSize = 7;	/* for non-open mode */
-			else
-				MaxSize = 13;
-		} else
-			MaxSize = 31;
-	} else if (pAd->MACVersion >= RALINK_2880E_VERSION)	/* 2880 e */
-	{
-		if (pEntryPeer->WepStatus != Ndis802_11EncryptionDisabled)
-			MaxSize = 7;	/* for non-open mode */
-		else
-			MaxSize = 13;
-	} else
-		MaxSize = 7;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("ba> Win Size = %d, Max Size = %d\n",
-				  *pWinSize, MaxSize));
-
-	if ((*pWinSize) > MaxSize) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ba> reassign max win size from %d to %d\n",
-			  *pWinSize, MaxSize));
-
-		*pWinSize = MaxSize;
-	}
-}
-
-void Announce_Reordering_Packet(struct rt_rtmp_adapter *pAd,
-				IN struct reordering_mpdu *mpdu)
-{
-	void *pPacket;
-
-	pPacket = mpdu->pPacket;
-
-	if (mpdu->bAMSDU) {
-		ASSERT(0);
-		BA_Reorder_AMSDU_Announce(pAd, pPacket);
-	} else {
-		/* */
-		/* pass this 802.3 packet to upper layer or forward this packet to WM directly */
-		/* */
-
-		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket,
-						 RTMP_GET_PACKET_IF(pPacket));
-	}
-}
-
-/*
- * Insert a reordering mpdu into sorted linked list by sequence no.
- */
-BOOLEAN ba_reordering_mpdu_insertsorted(struct reordering_list *list,
-					struct reordering_mpdu *mpdu)
-{
-
-	struct reordering_mpdu **ppScan = &list->next;
-
-	while (*ppScan != NULL) {
-		if (SEQ_SMALLER((*ppScan)->Sequence, mpdu->Sequence, MAXSEQ)) {
-			ppScan = &(*ppScan)->next;
-		} else if ((*ppScan)->Sequence == mpdu->Sequence) {
-			/* give up this duplicated frame */
-			return (FALSE);
-		} else {
-			/* find position */
-			break;
-		}
-	}
-
-	mpdu->next = *ppScan;
-	*ppScan = mpdu;
-	list->qlen++;
-	return TRUE;
-}
-
-/*
- * caller lock critical section if necessary
- */
-static inline void ba_enqueue(struct reordering_list *list,
-			      struct reordering_mpdu *mpdu_blk)
-{
-	list->qlen++;
-	mpdu_blk->next = list->next;
-	list->next = mpdu_blk;
-}
-
-/*
- * caller lock critical section if necessary
- */
-static inline struct reordering_mpdu *ba_dequeue(struct reordering_list *list)
-{
-	struct reordering_mpdu *mpdu_blk = NULL;
-
-	ASSERT(list);
-
-	if (list->qlen) {
-		list->qlen--;
-		mpdu_blk = list->next;
-		if (mpdu_blk) {
-			list->next = mpdu_blk->next;
-			mpdu_blk->next = NULL;
-		}
-	}
-	return mpdu_blk;
-}
-
-static inline struct reordering_mpdu *ba_reordering_mpdu_dequeue(struct
-								 reordering_list
-								 *list)
-{
-	return (ba_dequeue(list));
-}
-
-static inline struct reordering_mpdu *ba_reordering_mpdu_probe(struct
-							       reordering_list
-							       *list)
-{
-	ASSERT(list);
-
-	return (list->next);
-}
-
-/*
- * free all resource for reordering mechanism
- */
-void ba_reordering_resource_release(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_ba_table *Tab;
-	struct rt_ba_rec_entry *pBAEntry;
-	struct reordering_mpdu *mpdu_blk;
-	int i;
-
-	Tab = &pAd->BATable;
-
-	/* I.  release all pending reordering packet */
-	NdisAcquireSpinLock(&pAd->BATabLock);
-	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
-		pBAEntry = &Tab->BARecEntry[i];
-		if (pBAEntry->REC_BA_Status != Recipient_NONE) {
-			while ((mpdu_blk =
-				ba_reordering_mpdu_dequeue(&pBAEntry->list))) {
-				ASSERT(mpdu_blk->pPacket);
-				RELEASE_NDIS_PACKET(pAd, mpdu_blk->pPacket,
-						    NDIS_STATUS_FAILURE);
-				ba_mpdu_blk_free(pAd, mpdu_blk);
-			}
-		}
-	}
-	NdisReleaseSpinLock(&pAd->BATabLock);
-
-	ASSERT(pBAEntry->list.qlen == 0);
-	/* II. free memory of reordering mpdu table */
-	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
-	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);
-	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
-}
-
-/*
- * Allocate all resource for reordering mechanism
- */
-BOOLEAN ba_reordering_resource_init(struct rt_rtmp_adapter *pAd, int num)
-{
-	int i;
-	u8 *mem;
-	struct reordering_mpdu *mpdu_blk;
-	struct reordering_list *freelist;
-
-	/* allocate spinlock */
-	NdisAllocateSpinLock(&pAd->mpdu_blk_pool.lock);
-
-	/* initialize freelist */
-	freelist = &pAd->mpdu_blk_pool.freelist;
-	freelist->next = NULL;
-	freelist->qlen = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Allocate %d memory for BA reordering\n",
-		  (u32)(num * sizeof(struct reordering_mpdu))));
-
-	/* allocate number of mpdu_blk memory */
-	os_alloc_mem(pAd, (u8 **) & mem,
-		     (num * sizeof(struct reordering_mpdu)));
-
-	pAd->mpdu_blk_pool.mem = mem;
-
-	if (mem == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Can't Allocate Memory for BA Reordering\n"));
-		return (FALSE);
-	}
-
-	/* build mpdu_blk free list */
-	for (i = 0; i < num; i++) {
-		/* get mpdu_blk */
-		mpdu_blk = (struct reordering_mpdu *)mem;
-		/* initial mpdu_blk */
-		NdisZeroMemory(mpdu_blk, sizeof(struct reordering_mpdu));
-		/* next mpdu_blk */
-		mem += sizeof(struct reordering_mpdu);
-		/* insert mpdu_blk into freelist */
-		ba_enqueue(freelist, mpdu_blk);
-	}
-
-	return (TRUE);
-}
-
-/*static int blk_count=0; // sample take off, no use */
-
-static struct reordering_mpdu *ba_mpdu_blk_alloc(struct rt_rtmp_adapter *pAd)
-{
-	struct reordering_mpdu *mpdu_blk;
-
-	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
-	mpdu_blk = ba_dequeue(&pAd->mpdu_blk_pool.freelist);
-	if (mpdu_blk) {
-/*              blk_count++; */
-		/* reset mpdu_blk */
-		NdisZeroMemory(mpdu_blk, sizeof(struct reordering_mpdu));
-	}
-	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
-	return mpdu_blk;
-}
-
-static void ba_mpdu_blk_free(struct rt_rtmp_adapter *pAd,
-			     struct reordering_mpdu *mpdu_blk)
-{
-	ASSERT(mpdu_blk);
-
-	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
-/*      blk_count--; */
-	ba_enqueue(&pAd->mpdu_blk_pool.freelist, mpdu_blk);
-	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
-}
-
-static u16 ba_indicate_reordering_mpdus_in_order(struct rt_rtmp_adapter *pAd,
-						    struct rt_ba_rec_entry *pBAEntry,
-						    u16 StartSeq)
-{
-	struct reordering_mpdu *mpdu_blk;
-	u16 LastIndSeq = RESET_RCV_SEQ;
-
-	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-
-	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list))) {
-		/* find in-order frame */
-		if (!SEQ_STEPONE(mpdu_blk->Sequence, StartSeq, MAXSEQ)) {
-			break;
-		}
-		/* dequeue in-order frame from reodering list */
-		mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list);
-		/* pass this frame up */
-		ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
-		/* move to next sequence */
-		StartSeq = mpdu_blk->Sequence;
-		LastIndSeq = StartSeq;
-		/* free mpdu_blk */
-		ba_mpdu_blk_free(pAd, mpdu_blk);
-	}
-
-	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-
-	/* update last indicated sequence */
-	return LastIndSeq;
-}
-
-static void ba_indicate_reordering_mpdus_le_seq(struct rt_rtmp_adapter *pAd,
-						struct rt_ba_rec_entry *pBAEntry,
-						u16 Sequence)
-{
-	struct reordering_mpdu *mpdu_blk;
-
-	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list))) {
-		/* find in-order frame */
-		if ((mpdu_blk->Sequence == Sequence)
-		    || SEQ_SMALLER(mpdu_blk->Sequence, Sequence, MAXSEQ)) {
-			/* dequeue in-order frame from reodering list */
-			mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list);
-			/* pass this frame up */
-			ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
-			/* free mpdu_blk */
-			ba_mpdu_blk_free(pAd, mpdu_blk);
-		} else {
-			break;
-		}
-	}
-	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-}
-
-static void ba_refresh_reordering_mpdus(struct rt_rtmp_adapter *pAd,
-					struct rt_ba_rec_entry *pBAEntry)
-{
-	struct reordering_mpdu *mpdu_blk;
-
-	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-
-	/* dequeue in-order frame from reodering list */
-	while ((mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list))) {
-		/* pass this frame up */
-		ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
-
-		pBAEntry->LastIndSeq = mpdu_blk->Sequence;
-		ba_mpdu_blk_free(pAd, mpdu_blk);
-
-		/* update last indicated sequence */
-	}
-	ASSERT(pBAEntry->list.qlen == 0);
-	pBAEntry->LastIndSeq = RESET_RCV_SEQ;
-	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-}
-
-/*static */
-void ba_flush_reordering_timeout_mpdus(struct rt_rtmp_adapter *pAd,
-				       struct rt_ba_rec_entry *pBAEntry,
-				       unsigned long Now32)
-{
-	u16 Sequence;
-
-/*      if ((RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+REORDERING_PACKET_TIMEOUT)) && */
-/*               (pBAEntry->list.qlen > ((pBAEntry->BAWinSize*7)/8))) //|| */
-/*              (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(10*REORDERING_PACKET_TIMEOUT))) && */
-/*               (pBAEntry->list.qlen > (pBAEntry->BAWinSize/8))) */
-	if (RTMP_TIME_AFTER
-	    ((unsigned long)Now32,
-	     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
-			     (MAX_REORDERING_PACKET_TIMEOUT / 6)))
-	    && (pBAEntry->list.qlen > 1)
-	    ) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("timeout[%d] (%08lx-%08lx = %d > %d): %x, flush all!\n ",
-			  pBAEntry->list.qlen, Now32,
-			  (pBAEntry->LastIndSeqAtTimer),
-			  (int)((long)Now32 -
-				(long)(pBAEntry->LastIndSeqAtTimer)),
-			  MAX_REORDERING_PACKET_TIMEOUT, pBAEntry->LastIndSeq));
-		ba_refresh_reordering_mpdus(pAd, pBAEntry);
-		pBAEntry->LastIndSeqAtTimer = Now32;
-	} else
-	    if (RTMP_TIME_AFTER
-		((unsigned long)Now32,
-		 (unsigned long)(pBAEntry->LastIndSeqAtTimer +
-				 (REORDERING_PACKET_TIMEOUT)))
-		&& (pBAEntry->list.qlen > 0)
-	    ) {
-		/* */
-		/* force LastIndSeq to shift to LastIndSeq+1 */
-		/* */
-		Sequence = (pBAEntry->LastIndSeq + 1) & MAXSEQ;
-		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
-		pBAEntry->LastIndSeqAtTimer = Now32;
-		pBAEntry->LastIndSeq = Sequence;
-		/* */
-		/* indicate in-order mpdus */
-		/* */
-		Sequence =
-		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
-							  Sequence);
-		if (Sequence != RESET_RCV_SEQ) {
-			pBAEntry->LastIndSeq = Sequence;
-		}
-
-		DBGPRINT(RT_DEBUG_OFF,
-			 ("%x, flush one!\n", pBAEntry->LastIndSeq));
-
-	}
-}
-
-/*
- * generate ADDBA request to
- * set up BA agreement
- */
-void BAOriSessionSetUp(struct rt_rtmp_adapter *pAd,
-		       struct rt_mac_table_entry *pEntry,
-		       u8 TID,
-		       u16 TimeOut,
-		       unsigned long DelayTime, IN BOOLEAN isForced)
-{
-	/*struct rt_mlme_addba_req AddbaReq; */
-	struct rt_ba_ori_entry *pBAEntry = NULL;
-	u16 Idx;
-	BOOLEAN Cancelled;
-
-	if ((pAd->CommonCfg.BACapability.field.AutoBA != TRUE)
-	    && (isForced == FALSE))
-		return;
-
-	/* if this entry is limited to use legacy tx mode, it doesn't generate BA. */
-	if (RTMPStaFixedTxMode(pAd, pEntry) != FIXED_TXMODE_HT)
-		return;
-
-	if ((pEntry->BADeclineBitmap & (1 << TID)) && (isForced == FALSE)) {
-		/* try again after 3 secs */
-		DelayTime = 3000;
-/*              DBGPRINT(RT_DEBUG_TRACE, ("DeCline BA from Peer\n")); */
-/*              return; */
-	}
-
-	Idx = pEntry->BAOriWcidArray[TID];
-	if (Idx == 0) {
-		/* allocate a BA session */
-		pBAEntry = BATableAllocOriEntry(pAd, &Idx);
-		if (pBAEntry == NULL) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ADDBA - MlmeADDBAAction() allocate BA session failed \n"));
-			return;
-		}
-	} else {
-		pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-	}
-
-	if (pBAEntry->ORI_BA_Status >= Originator_WaitRes) {
-		return;
-	}
-
-	pEntry->BAOriWcidArray[TID] = Idx;
-
-	/* Initialize BA session */
-	pBAEntry->ORI_BA_Status = Originator_WaitRes;
-	pBAEntry->Wcid = pEntry->Aid;
-	pBAEntry->BAWinSize = pAd->CommonCfg.BACapability.field.RxBAWinLimit;
-	pBAEntry->Sequence = BA_ORI_INIT_SEQ;
-	pBAEntry->Token = 1;	/* (2008-01-21) Jan Lee recommends it - this token can't be 0 */
-	pBAEntry->TID = TID;
-	pBAEntry->TimeOutValue = TimeOut;
-	pBAEntry->pAdapter = pAd;
-
-	if (!(pEntry->TXBAbitmap & (1 << TID))) {
-		RTMPInitTimer(pAd, &pBAEntry->ORIBATimer,
-			      GET_TIMER_FUNCTION(BAOriSessionSetupTimeout),
-			      pBAEntry, FALSE);
-	} else
-		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
-
-	/* set timer to send ADDBA request */
-	RTMPSetTimer(&pBAEntry->ORIBATimer, DelayTime);
-}
-
-void BAOriSessionAdd(struct rt_rtmp_adapter *pAd,
-		     struct rt_mac_table_entry *pEntry, struct rt_frame_addba_rsp * pFrame)
-{
-	struct rt_ba_ori_entry *pBAEntry = NULL;
-	BOOLEAN Cancelled;
-	u8 TID;
-	u16 Idx;
-	u8 *pOutBuffer2 = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-	struct rt_frame_bar FrameBar;
-
-	TID = pFrame->BaParm.TID;
-	Idx = pEntry->BAOriWcidArray[TID];
-	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-
-	/* Start fill in parameters. */
-	if ((Idx != 0) && (pBAEntry->TID == TID)
-	    && (pBAEntry->ORI_BA_Status == Originator_WaitRes)) {
-		pBAEntry->BAWinSize =
-		    min(pBAEntry->BAWinSize, ((u8)pFrame->BaParm.BufSize));
-		BA_MaxWinSizeReasign(pAd, pEntry, &pBAEntry->BAWinSize);
-
-		pBAEntry->TimeOutValue = pFrame->TimeOutValue;
-		pBAEntry->ORI_BA_Status = Originator_Done;
-		pAd->BATable.numDoneOriginator++;
-
-		/* reset sequence number */
-		pBAEntry->Sequence = BA_ORI_INIT_SEQ;
-		/* Set Bitmap flag. */
-		pEntry->TXBAbitmap |= (1 << TID);
-		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
-
-		pBAEntry->ORIBATimer.TimerValue = 0;	/*pFrame->TimeOutValue; */
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s : TXBAbitmap = %x, BAWinSize = %d, TimeOut = %ld\n",
-			  __func__, pEntry->TXBAbitmap, pBAEntry->BAWinSize,
-			  pBAEntry->ORIBATimer.TimerValue));
-
-		/* SEND BAR ; */
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BA - BAOriSessionAdd() allocate memory failed \n"));
-			return;
-		}
-
-		BarHeaderInit(pAd, &FrameBar,
-			      pAd->MacTab.Content[pBAEntry->Wcid].Addr,
-			      pAd->CurrentAddress);
-
-		FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL function. */
-		FrameBar.StartingSeq.field.StartSeq = pBAEntry->Sequence;	/* make sure sequence not clear in DEL funciton. */
-		FrameBar.BarControl.TID = pBAEntry->TID;	/* make sure sequence not clear in DEL funciton. */
-		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
-				  sizeof(struct rt_frame_bar), &FrameBar, END_OF_ARGS);
-		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer2, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer2);
-
-		if (pBAEntry->ORIBATimer.TimerValue)
-			RTMPSetTimer(&pBAEntry->ORIBATimer, pBAEntry->ORIBATimer.TimerValue);	/* in mSec */
-	}
-}
-
-BOOLEAN BARecSessionAdd(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_frame_addba_req * pFrame)
-{
-	struct rt_ba_rec_entry *pBAEntry = NULL;
-	BOOLEAN Status = TRUE;
-	BOOLEAN Cancelled;
-	u16 Idx;
-	u8 TID;
-	u8 BAWinSize;
-	/*u32                  Value; */
-	/*u32                    offset; */
-
-	ASSERT(pEntry);
-
-	/* find TID */
-	TID = pFrame->BaParm.TID;
-
-	BAWinSize =
-	    min(((u8)pFrame->BaParm.BufSize),
-		(u8)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
-
-	/* Intel patch */
-	if (BAWinSize == 0) {
-		BAWinSize = 64;
-	}
-
-	Idx = pEntry->BARecWcidArray[TID];
-
-	if (Idx == 0) {
-		pBAEntry = BATableAllocRecEntry(pAd, &Idx);
-	} else {
-		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-		/* flush all pending reordering mpdus */
-		ba_refresh_reordering_mpdus(pAd, pBAEntry);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s(%ld): Idx = %d, BAWinSize(req %d) = %d\n", __func__,
-		  pAd->BATable.numAsRecipient, Idx, pFrame->BaParm.BufSize,
-		  BAWinSize));
-
-	/* Start fill in parameters. */
-	if (pBAEntry != NULL) {
-		ASSERT(pBAEntry->list.qlen == 0);
-
-		pBAEntry->REC_BA_Status = Recipient_HandleRes;
-		pBAEntry->BAWinSize = BAWinSize;
-		pBAEntry->Wcid = pEntry->Aid;
-		pBAEntry->TID = TID;
-		pBAEntry->TimeOutValue = pFrame->TimeOutValue;
-		pBAEntry->REC_BA_Status = Recipient_Accept;
-		/* initial sequence number */
-		pBAEntry->LastIndSeq = RESET_RCV_SEQ;	/*pFrame->BaStartSeq.field.StartSeq; */
-
-		DBGPRINT(RT_DEBUG_OFF,
-			 ("Start Seq = %08x\n",
-			  pFrame->BaStartSeq.field.StartSeq));
-
-		if (pEntry->RXBAbitmap & (1 << TID)) {
-			RTMPCancelTimer(&pBAEntry->RECBATimer, &Cancelled);
-		} else {
-			RTMPInitTimer(pAd, &pBAEntry->RECBATimer,
-				      GET_TIMER_FUNCTION
-				      (BARecSessionIdleTimeout), pBAEntry,
-				      TRUE);
-		}
-
-		/* Set Bitmap flag. */
-		pEntry->RXBAbitmap |= (1 << TID);
-		pEntry->BARecWcidArray[TID] = Idx;
-
-		pEntry->BADeclineBitmap &= ~(1 << TID);
-
-		/* Set BA session mask in WCID table. */
-		RTMP_ADD_BA_SESSION_TO_ASIC(pAd, pEntry->Aid, TID);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MACEntry[%d]RXBAbitmap = 0x%x. BARecWcidArray=%d\n",
-			  pEntry->Aid, pEntry->RXBAbitmap,
-			  pEntry->BARecWcidArray[TID]));
-	} else {
-		Status = FALSE;
-		DBGPRINT(RT_DEBUG_TRACE,
-			("Can't Accept ADDBA for %pM TID = %d\n",
-				pEntry->Addr, TID));
-	}
-	return (Status);
-}
-
-struct rt_ba_rec_entry *BATableAllocRecEntry(struct rt_rtmp_adapter *pAd, u16 * Idx)
-{
-	int i;
-	struct rt_ba_rec_entry *pBAEntry = NULL;
-
-	NdisAcquireSpinLock(&pAd->BATabLock);
-
-	if (pAd->BATable.numAsRecipient >= MAX_BARECI_SESSION) {
-		DBGPRINT(RT_DEBUG_OFF, ("BA Recipeint Session (%ld) > %d\n",
-					pAd->BATable.numAsRecipient,
-					MAX_BARECI_SESSION));
-		goto done;
-	}
-	/* reserve idx 0 to identify BAWcidArray[TID] as empty */
-	for (i = 1; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
-		pBAEntry = &pAd->BATable.BARecEntry[i];
-		if ((pBAEntry->REC_BA_Status == Recipient_NONE)) {
-			/* get one */
-			pAd->BATable.numAsRecipient++;
-			pBAEntry->REC_BA_Status = Recipient_USED;
-			*Idx = i;
-			break;
-		}
-	}
-
-done:
-	NdisReleaseSpinLock(&pAd->BATabLock);
-	return pBAEntry;
-}
-
-struct rt_ba_ori_entry *BATableAllocOriEntry(struct rt_rtmp_adapter *pAd, u16 * Idx)
-{
-	int i;
-	struct rt_ba_ori_entry *pBAEntry = NULL;
-
-	NdisAcquireSpinLock(&pAd->BATabLock);
-
-	if (pAd->BATable.numAsOriginator >= (MAX_LEN_OF_BA_ORI_TABLE)) {
-		goto done;
-	}
-	/* reserve idx 0 to identify BAWcidArray[TID] as empty */
-	for (i = 1; i < MAX_LEN_OF_BA_ORI_TABLE; i++) {
-		pBAEntry = &pAd->BATable.BAOriEntry[i];
-		if ((pBAEntry->ORI_BA_Status == Originator_NONE)) {
-			/* get one */
-			pAd->BATable.numAsOriginator++;
-			pBAEntry->ORI_BA_Status = Originator_USED;
-			pBAEntry->pAdapter = pAd;
-			*Idx = i;
-			break;
-		}
-	}
-
-done:
-	NdisReleaseSpinLock(&pAd->BATabLock);
-	return pBAEntry;
-}
-
-void BATableFreeOriEntry(struct rt_rtmp_adapter *pAd, unsigned long Idx)
-{
-	struct rt_ba_ori_entry *pBAEntry = NULL;
-	struct rt_mac_table_entry *pEntry;
-
-	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE))
-		return;
-
-	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-
-	if (pBAEntry->ORI_BA_Status != Originator_NONE) {
-		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
-		pEntry->BAOriWcidArray[pBAEntry->TID] = 0;
-
-		NdisAcquireSpinLock(&pAd->BATabLock);
-		if (pBAEntry->ORI_BA_Status == Originator_Done) {
-			pAd->BATable.numDoneOriginator -= 1;
-			pEntry->TXBAbitmap &= (~(1 << (pBAEntry->TID)));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BATableFreeOriEntry numAsOriginator= %ld\n",
-				  pAd->BATable.numAsRecipient));
-			/* Erase Bitmap flag. */
-		}
-
-		ASSERT(pAd->BATable.numAsOriginator != 0);
-
-		pAd->BATable.numAsOriginator -= 1;
-
-		pBAEntry->ORI_BA_Status = Originator_NONE;
-		pBAEntry->Token = 0;
-		NdisReleaseSpinLock(&pAd->BATabLock);
-	}
-}
-
-void BATableFreeRecEntry(struct rt_rtmp_adapter *pAd, unsigned long Idx)
-{
-	struct rt_ba_rec_entry *pBAEntry = NULL;
-	struct rt_mac_table_entry *pEntry;
-
-	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_REC_TABLE))
-		return;
-
-	pBAEntry = &pAd->BATable.BARecEntry[Idx];
-
-	if (pBAEntry->REC_BA_Status != Recipient_NONE) {
-		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
-		pEntry->BARecWcidArray[pBAEntry->TID] = 0;
-
-		NdisAcquireSpinLock(&pAd->BATabLock);
-
-		ASSERT(pAd->BATable.numAsRecipient != 0);
-
-		pAd->BATable.numAsRecipient -= 1;
-
-		pBAEntry->REC_BA_Status = Recipient_NONE;
-		NdisReleaseSpinLock(&pAd->BATabLock);
-	}
-}
-
-void BAOriSessionTearDown(struct rt_rtmp_adapter *pAd,
-			  u8 Wcid,
-			  u8 TID,
-			  IN BOOLEAN bPassive, IN BOOLEAN bForceSend)
-{
-	unsigned long Idx = 0;
-	struct rt_ba_ori_entry *pBAEntry;
-	BOOLEAN Cancelled;
-
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
-		return;
-	}
-	/* */
-	/* Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID). */
-	/* */
-	Idx = pAd->MacTab.Content[Wcid].BAOriWcidArray[TID];
-	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE)) {
-		if (bForceSend == TRUE) {
-			/* force send specified TID DelBA */
-			struct rt_mlme_delba_req DelbaReq;
-			struct rt_mlme_queue_elem *Elem =
-				kmalloc(sizeof(struct rt_mlme_queue_elem),
-					MEM_ALLOC_FLAG);
-			if (Elem != NULL) {
-				NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-				NdisZeroMemory(Elem, sizeof(struct rt_mlme_queue_elem));
-
-				COPY_MAC_ADDR(DelbaReq.Addr,
-					      pAd->MacTab.Content[Wcid].Addr);
-				DelbaReq.Wcid = Wcid;
-				DelbaReq.TID = TID;
-				DelbaReq.Initiator = ORIGINATOR;
-				Elem->MsgLen = sizeof(DelbaReq);
-				NdisMoveMemory(Elem->Msg, &DelbaReq,
-					       sizeof(DelbaReq));
-				MlmeDELBAAction(pAd, Elem);
-				kfree(Elem);
-			} else {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("%s(bForceSend):alloc memory failed!\n",
-					  __func__));
-			}
-		}
-
-		return;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
-
-	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, ORI_BA_Status = %d \n", Idx,
-		  Wcid, TID, pBAEntry->ORI_BA_Status));
-	/* */
-	/* Prepare DelBA action frame and send to the peer. */
-	/* */
-	if ((bPassive == FALSE) && (TID == pBAEntry->TID)
-	    && (pBAEntry->ORI_BA_Status == Originator_Done)) {
-		struct rt_mlme_delba_req DelbaReq;
-		struct rt_mlme_queue_elem *Elem =
-			kmalloc(sizeof(struct rt_mlme_queue_elem),
-				MEM_ALLOC_FLAG);
-		if (Elem != NULL) {
-			NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-			NdisZeroMemory(Elem, sizeof(struct rt_mlme_queue_elem));
-
-			COPY_MAC_ADDR(DelbaReq.Addr,
-				      pAd->MacTab.Content[Wcid].Addr);
-			DelbaReq.Wcid = Wcid;
-			DelbaReq.TID = pBAEntry->TID;
-			DelbaReq.Initiator = ORIGINATOR;
-			Elem->MsgLen = sizeof(DelbaReq);
-			NdisMoveMemory(Elem->Msg, &DelbaReq, sizeof(DelbaReq));
-			MlmeDELBAAction(pAd, Elem);
-			kfree(Elem);
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s():alloc memory failed!\n", __func__));
-			return;
-		}
-	}
-	RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
-	BATableFreeOriEntry(pAd, Idx);
-
-	if (bPassive) {
-		/*BAOriSessionSetUp(pAd, &pAd->MacTab.Content[Wcid], TID, 0, 10000, TRUE); */
-	}
-}
-
-void BARecSessionTearDown(struct rt_rtmp_adapter *pAd,
-			  u8 Wcid, u8 TID, IN BOOLEAN bPassive)
-{
-	unsigned long Idx = 0;
-	struct rt_ba_rec_entry *pBAEntry;
-
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
-		return;
-	}
-	/* */
-	/*  Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID). */
-	/* */
-	Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-	if (Idx == 0)
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
-
-	pBAEntry = &pAd->BATable.BARecEntry[Idx];
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, REC_BA_Status = %d \n", Idx,
-		  Wcid, TID, pBAEntry->REC_BA_Status));
-	/* */
-	/* Prepare DelBA action frame and send to the peer. */
-	/* */
-	if ((TID == pBAEntry->TID)
-	    && (pBAEntry->REC_BA_Status == Recipient_Accept)) {
-		struct rt_mlme_delba_req DelbaReq;
-		BOOLEAN Cancelled;
-		/*unsigned long   offset; */
-		/*u32  VALUE; */
-
-		RTMPCancelTimer(&pBAEntry->RECBATimer, &Cancelled);
-
-		/* */
-		/* 1. Send DELBA Action Frame */
-		/* */
-		if (bPassive == FALSE) {
-			struct rt_mlme_queue_elem *Elem =
-				kmalloc(sizeof(struct rt_mlme_queue_elem),
-					MEM_ALLOC_FLAG);
-			if (Elem != NULL) {
-				NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-				NdisZeroMemory(Elem, sizeof(struct rt_mlme_queue_elem));
-
-				COPY_MAC_ADDR(DelbaReq.Addr,
-					      pAd->MacTab.Content[Wcid].Addr);
-				DelbaReq.Wcid = Wcid;
-				DelbaReq.TID = TID;
-				DelbaReq.Initiator = RECIPIENT;
-				Elem->MsgLen = sizeof(DelbaReq);
-				NdisMoveMemory(Elem->Msg, &DelbaReq,
-					       sizeof(DelbaReq));
-				MlmeDELBAAction(pAd, Elem);
-				kfree(Elem);
-			} else {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("%s():alloc memory failed!\n",
-					  __func__));
-				return;
-			}
-		}
-
-		/* */
-		/* 2. Free resource of BA session */
-		/* */
-		/* flush all pending reordering mpdus */
-		ba_refresh_reordering_mpdus(pAd, pBAEntry);
-
-		NdisAcquireSpinLock(&pAd->BATabLock);
-
-		/* Erase Bitmap flag. */
-		pBAEntry->LastIndSeq = RESET_RCV_SEQ;
-		pBAEntry->BAWinSize = 0;
-		/* Erase Bitmap flag at software mactable */
-		pAd->MacTab.Content[Wcid].RXBAbitmap &=
-		    (~(1 << (pBAEntry->TID)));
-		pAd->MacTab.Content[Wcid].BARecWcidArray[TID] = 0;
-
-		RTMP_DEL_BA_SESSION_FROM_ASIC(pAd, Wcid, TID);
-
-		NdisReleaseSpinLock(&pAd->BATabLock);
-
-	}
-
-	BATableFreeRecEntry(pAd, Idx);
-}
-
-void BASessionTearDownALL(struct rt_rtmp_adapter *pAd, u8 Wcid)
-{
-	int i;
-
-	for (i = 0; i < NUM_OF_TID; i++) {
-		BAOriSessionTearDown(pAd, Wcid, i, FALSE, FALSE);
-		BARecSessionTearDown(pAd, Wcid, i, FALSE);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		Retry sending ADDBA Reqest.
-
-	IRQL = DISPATCH_LEVEL
-
-	Parametrs:
-	p8023Header: if this is already 802.3 format, p8023Header is NULL
-
-	Return	: TRUE if put into rx reordering buffer, shouldn't indicaterxhere.
-				FALSE , then continue indicaterx at this moment.
-	==========================================================================
- */
-void BAOriSessionSetupTimeout(void *SystemSpecific1,
-			      void *FunctionContext,
-			      void *SystemSpecific2,
-			      void *SystemSpecific3)
-{
-	struct rt_ba_ori_entry *pBAEntry = (struct rt_ba_ori_entry *)FunctionContext;
-	struct rt_mac_table_entry *pEntry;
-	struct rt_rtmp_adapter *pAd;
-
-	if (pBAEntry == NULL)
-		return;
-
-	pAd = pBAEntry->pAdapter;
-
-	{
-		/* Do nothing if monitor mode is on */
-		if (MONITOR_ON(pAd))
-			return;
-	}
-
-	pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
-
-	if ((pBAEntry->ORI_BA_Status == Originator_WaitRes)
-	    && (pBAEntry->Token < ORI_SESSION_MAX_RETRY)) {
-		struct rt_mlme_addba_req AddbaReq;
-
-		NdisZeroMemory(&AddbaReq, sizeof(AddbaReq));
-		COPY_MAC_ADDR(AddbaReq.pAddr, pEntry->Addr);
-		AddbaReq.Wcid = (u8)(pEntry->Aid);
-		AddbaReq.TID = pBAEntry->TID;
-		AddbaReq.BaBufSize =
-		    pAd->CommonCfg.BACapability.field.RxBAWinLimit;
-		AddbaReq.TimeOutValue = 0;
-		AddbaReq.Token = pBAEntry->Token;
-		MlmeEnqueue(pAd, ACTION_STATE_MACHINE, MT2_MLME_ADD_BA_CATE,
-			    sizeof(struct rt_mlme_addba_req), (void *)& AddbaReq);
-		RTMP_MLME_HANDLER(pAd);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BA Ori Session Timeout(%d) : Send ADD BA again\n",
-			  pBAEntry->Token));
-
-		pBAEntry->Token++;
-		RTMPSetTimer(&pBAEntry->ORIBATimer, ORI_BA_SESSION_TIMEOUT);
-	} else {
-		BATableFreeOriEntry(pAd, pEntry->BAOriWcidArray[pBAEntry->TID]);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		Retry sending ADDBA Reqest.
-
-	IRQL = DISPATCH_LEVEL
-
-	Parametrs:
-	p8023Header: if this is already 802.3 format, p8023Header is NULL
-
-	Return	: TRUE if put into rx reordering buffer, shouldn't indicaterxhere.
-				FALSE , then continue indicaterx at this moment.
-	==========================================================================
- */
-void BARecSessionIdleTimeout(void *SystemSpecific1,
-			     void *FunctionContext,
-			     void *SystemSpecific2, void *SystemSpecific3)
-{
-
-	struct rt_ba_rec_entry *pBAEntry = (struct rt_ba_rec_entry *)FunctionContext;
-	struct rt_rtmp_adapter *pAd;
-	unsigned long Now32;
-
-	if (pBAEntry == NULL)
-		return;
-
-	if ((pBAEntry->REC_BA_Status == Recipient_Accept)) {
-		NdisGetSystemUpTime(&Now32);
-
-		if (RTMP_TIME_AFTER
-		    ((unsigned long)Now32,
-		     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
-				     REC_BA_SESSION_IDLE_TIMEOUT))) {
-			pAd = pBAEntry->pAdapter;
-			/* flush all pending reordering mpdus */
-			ba_refresh_reordering_mpdus(pAd, pBAEntry);
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("%ld: REC BA session Timeout\n", Now32));
-		}
-	}
-}
-
-void PeerAddBAReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	/*      7.4.4.1 */
-	/*unsigned long Idx; */
-	u8 Status = 1;
-	u8 pAddr[6];
-	struct rt_frame_addba_rsp ADDframe;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	struct rt_frame_addba_req * pAddreqFrame = NULL;
-	/*u8         BufSize; */
-	unsigned long FrameLen;
-	unsigned long *ptemp;
-	struct rt_mac_table_entry *pMacEntry;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s ==> (Wcid = %d)\n", __func__, Elem->Wcid));
-
-	/*hex_dump("AddBAReq", Elem->Msg, Elem->MsgLen); */
-
-	/*ADDBA Request from unknown peer, ignore this. */
-	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return;
-
-	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
-	DBGPRINT(RT_DEBUG_TRACE, ("BA - PeerAddBAReqAction----> \n"));
-	ptemp = (unsigned long *)Elem->Msg;
-	/*DBGPRINT_RAW(RT_DEBUG_EMU, ("%08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x\n", *(ptemp), *(ptemp+1), *(ptemp+2), *(ptemp+3), *(ptemp+4), *(ptemp+5), *(ptemp+6), *(ptemp+7), *(ptemp+8))); */
-
-	if (PeerAddBAReqActionSanity(pAd, Elem->Msg, Elem->MsgLen, pAddr)) {
-
-		if ((pAd->CommonCfg.bBADecline == FALSE)
-		    && IS_HT_STA(pMacEntry)) {
-			pAddreqFrame = (struct rt_frame_addba_req *) (&Elem->Msg[0]);
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("Rcv Wcid(%d) AddBAReq\n", Elem->Wcid));
-			if (BARecSessionAdd
-			    (pAd, &pAd->MacTab.Content[Elem->Wcid],
-			     pAddreqFrame))
-				Status = 0;
-			else
-				Status = 38;	/* more parameters have invalid values */
-		} else {
-			Status = 37;	/* the request has been declined. */
-		}
-	}
-
-	if (pAd->MacTab.Content[Elem->Wcid].ValidAsCLI)
-		ASSERT(pAd->MacTab.Content[Elem->Wcid].Sst == SST_ASSOC);
-
-	pAddreqFrame = (struct rt_frame_addba_req *) (&Elem->Msg[0]);
-	/* 2. Always send back ADDBA Response */
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ACTION - PeerBAAction() allocate memory failed \n"));
-		return;
-	}
-
-	NdisZeroMemory(&ADDframe, sizeof(struct rt_frame_addba_rsp));
-
-	/* 2-1. Prepare ADDBA Response frame. */
-	{
-		if (ADHOC_ON(pAd))
-			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr,
-				      pAd->CurrentAddress,
-				      pAd->CommonCfg.Bssid);
-		else
-			ActHeaderInit(pAd, &ADDframe.Hdr, pAd->CommonCfg.Bssid,
-				      pAd->CurrentAddress, pAddr);
-	}
-
-	ADDframe.Category = CATEGORY_BA;
-	ADDframe.Action = ADDBA_RESP;
-	ADDframe.Token = pAddreqFrame->Token;
-	/* What is the Status code??  need to check. */
-	ADDframe.StatusCode = Status;
-	ADDframe.BaParm.BAPolicy = IMMED_BA;
-	ADDframe.BaParm.AMSDUSupported = 0;
-	ADDframe.BaParm.TID = pAddreqFrame->BaParm.TID;
-	ADDframe.BaParm.BufSize =
-	    min(((u8)pAddreqFrame->BaParm.BufSize),
-		(u8)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
-	if (ADDframe.BaParm.BufSize == 0) {
-		ADDframe.BaParm.BufSize = 64;
-	}
-	ADDframe.TimeOutValue = 0;	/*pAddreqFrame->TimeOutValue; */
-
-	*(u16 *) (&ADDframe.BaParm) =
-	    cpu2le16(*(u16 *) (&ADDframe.BaParm));
-	ADDframe.StatusCode = cpu2le16(ADDframe.StatusCode);
-	ADDframe.TimeOutValue = cpu2le16(ADDframe.TimeOutValue);
-
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  sizeof(struct rt_frame_addba_rsp), &ADDframe, END_OF_ARGS);
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s(%d): TID(%d), BufSize(%d) <== \n", __func__, Elem->Wcid,
-		  ADDframe.BaParm.TID, ADDframe.BaParm.BufSize));
-}
-
-void PeerAddBARspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	/*u8         Idx, i; */
-	/*u8 *                  pOutBuffer = NULL; */
-	struct rt_frame_addba_rsp * pFrame = NULL;
-	/*struct rt_ba_ori_entry *pBAEntry; */
-
-	/*ADDBA Response from unknown peer, ignore this. */
-	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s ==> Wcid(%d)\n", __func__, Elem->Wcid));
-
-	/*hex_dump("PeerAddBARspAction()", Elem->Msg, Elem->MsgLen); */
-
-	if (PeerAddBARspActionSanity(pAd, Elem->Msg, Elem->MsgLen)) {
-		pFrame = (struct rt_frame_addba_rsp *) (&Elem->Msg[0]);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("\t\t StatusCode = %d\n", pFrame->StatusCode));
-		switch (pFrame->StatusCode) {
-		case 0:
-			/* I want a BAsession with this peer as an originator. */
-			BAOriSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid],
-					pFrame);
-			break;
-		default:
-			/* check status == USED ??? */
-			BAOriSessionTearDown(pAd, Elem->Wcid,
-					     pFrame->BaParm.TID, TRUE, FALSE);
-			break;
-		}
-		/* Rcv Decline StatusCode */
-		if ((pFrame->StatusCode == 37)
-		    || ((pAd->OpMode == OPMODE_STA) && STA_TGN_WIFI_ON(pAd)
-			&& (pFrame->StatusCode != 0))
-		    ) {
-			pAd->MacTab.Content[Elem->Wcid].BADeclineBitmap |=
-			    1 << pFrame->BaParm.TID;
-		}
-	}
-}
-
-void PeerDelBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	/*u8                         Idx; */
-	/*u8 *                               pOutBuffer = NULL; */
-	struct rt_frame_delba_req * pDelFrame = NULL;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s ==>\n", __func__));
-	/*DELBA Request from unknown peer, ignore this. */
-	if (PeerDelBAActionSanity(pAd, Elem->Wcid, Elem->Msg, Elem->MsgLen)) {
-		pDelFrame = (struct rt_frame_delba_req *) (&Elem->Msg[0]);
-		if (pDelFrame->DelbaParm.Initiator == ORIGINATOR) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BA - PeerDelBAAction----> ORIGINATOR\n"));
-			BARecSessionTearDown(pAd, Elem->Wcid,
-					     pDelFrame->DelbaParm.TID, TRUE);
-		} else {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BA - PeerDelBAAction----> RECIPIENT, Reason = %d\n",
-				  pDelFrame->ReasonCode));
-			/*hex_dump("DelBA Frame", pDelFrame, Elem->MsgLen); */
-			BAOriSessionTearDown(pAd, Elem->Wcid,
-					     pDelFrame->DelbaParm.TID, TRUE,
-					     FALSE);
-		}
-	}
-}
-
-BOOLEAN CntlEnqueueForRecv(struct rt_rtmp_adapter *pAd,
-			   unsigned long Wcid,
-			   unsigned long MsgLen, struct rt_frame_ba_req * pMsg)
-{
-	struct rt_frame_ba_req * pFrame = pMsg;
-	/*PRTMP_REORDERBUF      pBuffer; */
-	/*PRTMP_REORDERBUF      pDmaBuf; */
-	struct rt_ba_rec_entry *pBAEntry;
-	/*BOOLEAN       Result; */
-	unsigned long Idx;
-	/*u8 NumRxPkt; */
-	u8 TID;		/*, i; */
-
-	TID = (u8)pFrame->BARControl.TID;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s(): BAR-Wcid(%ld), Tid (%d)\n", __func__, Wcid, TID));
-	/*hex_dump("BAR", (char *)pFrame, MsgLen); */
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return FALSE;
-
-	/* First check the size, it MUST not exceed the mlme queue size */
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
-		DBGPRINT_ERR("CntlEnqueueForRecv: frame too large, size = %ld \n", MsgLen);
-		return FALSE;
-	} else if (MsgLen != sizeof(struct rt_frame_ba_req)) {
-		DBGPRINT_ERR("CntlEnqueueForRecv: BlockAck Request frame length size = %ld incorrect\n", MsgLen);
-		return FALSE;
-	} else if (MsgLen != sizeof(struct rt_frame_ba_req)) {
-		DBGPRINT_ERR("CntlEnqueueForRecv: BlockAck Request frame length size = %ld incorrect\n", MsgLen);
-		return FALSE;
-	}
-
-	if ((Wcid < MAX_LEN_OF_MAC_TABLE) && (TID < 8)) {
-		/* if this receiving packet is from SA that is in our OriEntry. Since WCID <9 has direct mapping. no need search. */
-		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-	} else {
-		return FALSE;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("BAR(%ld) : Tid (%d) - %04x:%04x\n", Wcid, TID,
-		  pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq));
-
-	if (SEQ_SMALLER
-	    (pBAEntry->LastIndSeq, pFrame->BAStartingSeq.field.StartSeq,
-	     MAXSEQ)) {
-		/*DBGPRINT(RT_DEBUG_TRACE, ("BAR Seq = %x, LastIndSeq = %x\n", pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq)); */
-		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry,
-						    pFrame->BAStartingSeq.field.
-						    StartSeq);
-		pBAEntry->LastIndSeq =
-		    (pFrame->BAStartingSeq.field.StartSeq ==
-		     0) ? MAXSEQ : (pFrame->BAStartingSeq.field.StartSeq - 1);
-	}
-	/*ba_refresh_reordering_mpdus(pAd, pBAEntry); */
-	return TRUE;
-}
-
-/*
-Description : Send PSMP Action frame If PSMP mode switches.
-*/
-void SendPSMPAction(struct rt_rtmp_adapter *pAd, u8 Wcid, u8 Psmp)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	/*unsigned long           Idx; */
-	struct rt_frame_psmp_action Frame;
-	unsigned long FrameLen;
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("BA - MlmeADDBAAction() allocate memory failed \n"));
-		return;
-	}
-
-	ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid,
-		      pAd->CurrentAddress, pAd->MacTab.Content[Wcid].Addr);
-
-	Frame.Category = CATEGORY_HT;
-	Frame.Action = SMPS_ACTION;
-	switch (Psmp) {
-	case MMPS_ENABLE:
-#ifdef RT30xx
-		if (IS_RT30xx(pAd)
-		    && (pAd->Antenna.field.RxPath > 1
-			|| pAd->Antenna.field.TxPath > 1)) {
-			RTMP_ASIC_MMPS_DISABLE(pAd);
-		}
-#endif /* RT30xx // */
-		Frame.Psmp = 0;
-		break;
-	case MMPS_DYNAMIC:
-		Frame.Psmp = 3;
-		break;
-	case MMPS_STATIC:
-#ifdef RT30xx
-		if (IS_RT30xx(pAd)
-		    && (pAd->Antenna.field.RxPath > 1
-			|| pAd->Antenna.field.TxPath > 1)) {
-			RTMP_ASIC_MMPS_ENABLE(pAd);
-		}
-#endif /* RT30xx // */
-		Frame.Psmp = 1;
-		break;
-	}
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  sizeof(struct rt_frame_psmp_action), &Frame, END_OF_ARGS);
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-	DBGPRINT(RT_DEBUG_ERROR, ("HT - SendPSMPAction( %d )  \n", Frame.Psmp));
-}
-
-#define RADIO_MEASUREMENT_REQUEST_ACTION	0
-
-struct PACKED rt_beacon_request {
-	u8 RegulatoryClass;
-	u8 ChannelNumber;
-	u16 RandomInterval;
-	u16 MeasurementDuration;
-	u8 MeasurementMode;
-	u8 BSSID[MAC_ADDR_LEN];
-	u8 ReportingCondition;
-	u8 Threshold;
-	u8 SSIDIE[2];	/* 2 byte */
-};
-
-struct PACKED rt_measurement_req {
-	u8 ID;
-	u8 Length;
-	u8 Token;
-	u8 RequestMode;
-	u8 Type;
-};
-
-void convert_reordering_packet_to_preAMSDU_or_802_3_packet(struct rt_rtmp_adapter *pAd,
-							   struct rt_rx_blk *pRxBlk,
-							   u8
-							   FromWhichBSSID)
-{
-	void *pRxPkt;
-	u8 Header802_3[LENGTH_802_3];
-
-	/* 1. get 802.3 Header */
-	/* 2. remove LLC */
-	/*              a. pointer pRxBlk->pData to payload */
-	/*      b. modify pRxBlk->DataSize */
-
-	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
-
-	ASSERT(pRxBlk->pRxPacket);
-	pRxPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
-
-	SET_OS_PKT_NETDEV(pRxPkt, get_netdev_from_bssid(pAd, FromWhichBSSID));
-	SET_OS_PKT_DATAPTR(pRxPkt, pRxBlk->pData);
-	SET_OS_PKT_LEN(pRxPkt, pRxBlk->DataSize);
-	SET_OS_PKT_DATATAIL(pRxPkt, pRxBlk->pData, pRxBlk->DataSize);
-
-	/* */
-	/* copy 802.3 header, if necessary */
-	/* */
-	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
-		{
-#ifdef LINUX
-			NdisMoveMemory(skb_push(pRxPkt, LENGTH_802_3),
-				       Header802_3, LENGTH_802_3);
-#endif
-		}
-	}
-}
-
-#define INDICATE_LEGACY_OR_AMSDU(_pAd, _pRxBlk, _fromWhichBSSID)		\
-	do																	\
-	{																	\
-    	if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_AMSDU))						\
-    	{																\
-    		Indicate_AMSDU_Packet(_pAd, _pRxBlk, _fromWhichBSSID);		\
-    	}																\
-		else if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_EAP))					\
-		{																\
-			Indicate_EAPOL_Packet(_pAd, _pRxBlk, _fromWhichBSSID);		\
-		}																\
-    	else															\
-    	{																\
-    		Indicate_Legacy_Packet(_pAd, _pRxBlk, _fromWhichBSSID);		\
-    	}																\
-	} while (0);
-
-static void ba_enqueue_reordering_packet(struct rt_rtmp_adapter *pAd,
-					 struct rt_ba_rec_entry *pBAEntry,
-					 struct rt_rx_blk *pRxBlk,
-					 u8 FromWhichBSSID)
-{
-	struct reordering_mpdu *mpdu_blk;
-	u16 Sequence = (u16)pRxBlk->pHeader->Sequence;
-
-	mpdu_blk = ba_mpdu_blk_alloc(pAd);
-	if ((mpdu_blk != NULL) && (!RX_BLK_TEST_FLAG(pRxBlk, fRX_EAP))) {
-		/* Write RxD buffer address & allocated buffer length */
-		NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-
-		mpdu_blk->Sequence = Sequence;
-
-		mpdu_blk->bAMSDU = RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU);
-
-		convert_reordering_packet_to_preAMSDU_or_802_3_packet(pAd,
-								      pRxBlk,
-								      FromWhichBSSID);
-
-		STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
-
-		/* */
-		/* it is necessary for reordering packet to record */
-		/* which BSS it come from */
-		/* */
-		RTMP_SET_PACKET_IF(pRxBlk->pRxPacket, FromWhichBSSID);
-
-		mpdu_blk->pPacket = pRxBlk->pRxPacket;
-
-		if (ba_reordering_mpdu_insertsorted(&pBAEntry->list, mpdu_blk)
-		    == FALSE) {
-			/* had been already within reordering list */
-			/* don't indicate */
-			RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-					    NDIS_STATUS_SUCCESS);
-			ba_mpdu_blk_free(pAd, mpdu_blk);
-		}
-
-		ASSERT((0 <= pBAEntry->list.qlen)
-		       && (pBAEntry->list.qlen <= pBAEntry->BAWinSize));
-		NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 (" (%d) Can't allocate reordering mpdu blk\n",
-			  pBAEntry->list.qlen));
-
-		/*
-		 * flush all pending reordering mpdus
-		 * and receiving mpdu to upper layer
-		 * make tcp/ip to take care reordering mechanism
-		 */
-		/*ba_refresh_reordering_mpdus(pAd, pBAEntry); */
-		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
-
-		pBAEntry->LastIndSeq = Sequence;
-		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		Indicate this packet to upper layer or put it into reordering buffer
-
-	Parametrs:
-		pRxBlk         : carry necessary packet info 802.11 format
-		FromWhichBSSID : the packet received from which BSS
-
-	Return	:
-			  none
-
-	Note    :
-	          the packet queued into reordering buffer need to cover to 802.3 format
-			  or pre_AMSDU format
-	==========================================================================
- */
-
-void Indicate_AMPDU_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	u16 Idx;
-	struct rt_ba_rec_entry *pBAEntry = NULL;
-	u16 Sequence = pRxBlk->pHeader->Sequence;
-	unsigned long Now32;
-	u8 Wcid = pRxBlk->pRxWI->WirelessCliID;
-	u8 TID = pRxBlk->pRxWI->TID;
-
-	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)
-	    && (pRxBlk->DataSize > MAX_RX_PKT_LEN)) {
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	if (Wcid < MAX_LEN_OF_MAC_TABLE) {
-		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-		if (Idx == 0) {
-			/* Rec BA Session had been torn down */
-			INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-			return;
-		}
-		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-	} else {
-		/* impossible ! */
-		ASSERT(0);
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	ASSERT(pBAEntry);
-
-	/* update last rx time */
-	NdisGetSystemUpTime(&Now32);
-
-	pBAEntry->rcvSeq = Sequence;
-
-	ba_flush_reordering_timeout_mpdus(pAd, pBAEntry, Now32);
-	pBAEntry->LastIndSeqAtTimer = Now32;
-
-	/* */
-	/* Reset Last Indicate Sequence */
-	/* */
-	if (pBAEntry->LastIndSeq == RESET_RCV_SEQ) {
-		ASSERT((pBAEntry->list.qlen == 0)
-		       && (pBAEntry->list.next == NULL));
-
-		/* reset rcv sequence of BA session */
-		pBAEntry->LastIndSeq = Sequence;
-		pBAEntry->LastIndSeqAtTimer = Now32;
-		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-		return;
-	}
-
-	/* */
-	/* I. Check if in order. */
-	/* */
-	if (SEQ_STEPONE(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
-		u16 LastIndSeq;
-
-		pBAEntry->LastIndSeq = Sequence;
-		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-		LastIndSeq =
-		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
-							  pBAEntry->LastIndSeq);
-		if (LastIndSeq != RESET_RCV_SEQ) {
-			pBAEntry->LastIndSeq = LastIndSeq;
-		}
-		pBAEntry->LastIndSeqAtTimer = Now32;
-	}
-	/* */
-	/* II. Drop Duplicated Packet */
-	/* */
-	else if (Sequence == pBAEntry->LastIndSeq) {
-
-		/* drop and release packet */
-		pBAEntry->nDropPacket++;
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-	}
-	/* */
-	/* III. Drop Old Received Packet */
-	/* */
-	else if (SEQ_SMALLER(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
-
-		/* drop and release packet */
-		pBAEntry->nDropPacket++;
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-	}
-	/* */
-	/* IV. Receive Sequence within Window Size */
-	/* */
-	else if (SEQ_SMALLER
-		 (Sequence,
-		  (((pBAEntry->LastIndSeq + pBAEntry->BAWinSize + 1)) & MAXSEQ),
-		  MAXSEQ)) {
-		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk,
-					     FromWhichBSSID);
-	}
-	/* */
-	/* V. Receive seq surpasses Win(lastseq + nMSDU). So refresh all reorder buffer */
-	/* */
-	else {
-		long WinStartSeq, TmpSeq;
-
-		TmpSeq = Sequence - (pBAEntry->BAWinSize) - 1;
-		if (TmpSeq < 0) {
-			TmpSeq = (MAXSEQ + 1) + TmpSeq;
-		}
-		WinStartSeq = (TmpSeq + 1) & MAXSEQ;
-		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, WinStartSeq);
-		pBAEntry->LastIndSeq = WinStartSeq;	/*TmpSeq; */
-
-		pBAEntry->LastIndSeqAtTimer = Now32;
-
-		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk,
-					     FromWhichBSSID);
-
-		TmpSeq =
-		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
-							  pBAEntry->LastIndSeq);
-		if (TmpSeq != RESET_RCV_SEQ) {
-			pBAEntry->LastIndSeq = TmpSeq;
-		}
-	}
-}
diff --git a/drivers/staging/rt2860/common/cmm_aes.c b/drivers/staging/rt2860/common/cmm_aes.c
deleted file mode 100644
index d70d229..0000000
--- a/drivers/staging/rt2860/common/cmm_aes.c
+++ /dev/null
@@ -1,1311 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	cmm_aes.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Paul Wu		02-25-02		Initial
-*/
-
-#include	"../rt_config.h"
-
-struct aes_context {
-	u32 erk[64];		/* encryption round keys */
-	u32 drk[64];		/* decryption round keys */
-	int nr;			/* number of rounds */
-};
-
-/*****************************/
-/******** SBOX Table *********/
-/*****************************/
-
-u8 SboxTable[256] = {
-	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
-	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
-	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
-	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
-	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
-	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
-	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
-	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
-	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
-	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
-	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
-	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
-	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
-	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
-	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
-	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
-	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
-	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
-	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
-	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
-	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
-	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
-	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
-	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
-	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
-	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
-	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
-	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
-	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
-	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
-	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
-	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
-};
-
-void xor_32(u8 *a, u8 *b, u8 *out)
-{
-	int i;
-
-	for (i = 0; i < 4; i++) {
-		out[i] = a[i] ^ b[i];
-	}
-}
-
-void xor_128(u8 *a, u8 *b, u8 *out)
-{
-	int i;
-
-	for (i = 0; i < 16; i++) {
-		out[i] = a[i] ^ b[i];
-	}
-}
-
-u8 RTMPCkipSbox(u8 a)
-{
-	return SboxTable[(int)a];
-}
-
-void next_key(u8 *key, int round)
-{
-	u8 rcon;
-	u8 sbox_key[4];
-	u8 rcon_table[12] = {
-		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
-		0x1b, 0x36, 0x36, 0x36
-	};
-
-	sbox_key[0] = RTMPCkipSbox(key[13]);
-	sbox_key[1] = RTMPCkipSbox(key[14]);
-	sbox_key[2] = RTMPCkipSbox(key[15]);
-	sbox_key[3] = RTMPCkipSbox(key[12]);
-
-	rcon = rcon_table[round];
-
-	xor_32(&key[0], sbox_key, &key[0]);
-	key[0] = key[0] ^ rcon;
-
-	xor_32(&key[4], &key[0], &key[4]);
-	xor_32(&key[8], &key[4], &key[8]);
-	xor_32(&key[12], &key[8], &key[12]);
-}
-
-void byte_sub(u8 *in, u8 *out)
-{
-	int i;
-
-	for (i = 0; i < 16; i++) {
-		out[i] = RTMPCkipSbox(in[i]);
-	}
-}
-
-/************************************/
-/* bitwise_xor()                    */
-/* A 128 bit, bitwise exclusive or  */
-/************************************/
-
-void bitwise_xor(unsigned char *ina, unsigned char *inb, unsigned char *out)
-{
-	int i;
-	for (i = 0; i < 16; i++) {
-		out[i] = ina[i] ^ inb[i];
-	}
-}
-
-void shift_row(u8 *in, u8 *out)
-{
-	out[0] = in[0];
-	out[1] = in[5];
-	out[2] = in[10];
-	out[3] = in[15];
-	out[4] = in[4];
-	out[5] = in[9];
-	out[6] = in[14];
-	out[7] = in[3];
-	out[8] = in[8];
-	out[9] = in[13];
-	out[10] = in[2];
-	out[11] = in[7];
-	out[12] = in[12];
-	out[13] = in[1];
-	out[14] = in[6];
-	out[15] = in[11];
-}
-
-void mix_column(u8 *in, u8 *out)
-{
-	int i;
-	u8 add1b[4];
-	u8 add1bf7[4];
-	u8 rotl[4];
-	u8 swap_halfs[4];
-	u8 andf7[4];
-	u8 rotr[4];
-	u8 temp[4];
-	u8 tempb[4];
-
-	for (i = 0; i < 4; i++) {
-		if ((in[i] & 0x80) == 0x80)
-			add1b[i] = 0x1b;
-		else
-			add1b[i] = 0x00;
-	}
-
-	swap_halfs[0] = in[2];	/* Swap halfs */
-	swap_halfs[1] = in[3];
-	swap_halfs[2] = in[0];
-	swap_halfs[3] = in[1];
-
-	rotl[0] = in[3];	/* Rotate left 8 bits */
-	rotl[1] = in[0];
-	rotl[2] = in[1];
-	rotl[3] = in[2];
-
-	andf7[0] = in[0] & 0x7f;
-	andf7[1] = in[1] & 0x7f;
-	andf7[2] = in[2] & 0x7f;
-	andf7[3] = in[3] & 0x7f;
-
-	for (i = 3; i > 0; i--) {	/* logical shift left 1 bit */
-		andf7[i] = andf7[i] << 1;
-		if ((andf7[i - 1] & 0x80) == 0x80) {
-			andf7[i] = (andf7[i] | 0x01);
-		}
-	}
-	andf7[0] = andf7[0] << 1;
-	andf7[0] = andf7[0] & 0xfe;
-
-	xor_32(add1b, andf7, add1bf7);
-
-	xor_32(in, add1bf7, rotr);
-
-	temp[0] = rotr[0];	/* Rotate right 8 bits */
-	rotr[0] = rotr[1];
-	rotr[1] = rotr[2];
-	rotr[2] = rotr[3];
-	rotr[3] = temp[0];
-
-	xor_32(add1bf7, rotr, temp);
-	xor_32(swap_halfs, rotl, tempb);
-	xor_32(temp, tempb, out);
-}
-
-/************************************************/
-/* construct_mic_header1()                      */
-/* Builds the first MIC header block from       */
-/* header fields.                               */
-/************************************************/
-
-void construct_mic_header1(unsigned char *mic_header1,
-			   int header_length, unsigned char *mpdu)
-{
-	mic_header1[0] = (unsigned char)((header_length - 2) / 256);
-	mic_header1[1] = (unsigned char)((header_length - 2) % 256);
-	mic_header1[2] = mpdu[0] & 0xcf;	/* Mute CF poll & CF ack bits */
-	mic_header1[3] = mpdu[1] & 0xc7;	/* Mute retry, more data and pwr mgt bits */
-	mic_header1[4] = mpdu[4];	/* A1 */
-	mic_header1[5] = mpdu[5];
-	mic_header1[6] = mpdu[6];
-	mic_header1[7] = mpdu[7];
-	mic_header1[8] = mpdu[8];
-	mic_header1[9] = mpdu[9];
-	mic_header1[10] = mpdu[10];	/* A2 */
-	mic_header1[11] = mpdu[11];
-	mic_header1[12] = mpdu[12];
-	mic_header1[13] = mpdu[13];
-	mic_header1[14] = mpdu[14];
-	mic_header1[15] = mpdu[15];
-}
-
-/************************************************/
-/* construct_mic_header2()                      */
-/* Builds the last MIC header block from        */
-/* header fields.                               */
-/************************************************/
-
-void construct_mic_header2(unsigned char *mic_header2,
-			   unsigned char *mpdu, int a4_exists, int qc_exists)
-{
-	int i;
-
-	for (i = 0; i < 16; i++)
-		mic_header2[i] = 0x00;
-
-	mic_header2[0] = mpdu[16];	/* A3 */
-	mic_header2[1] = mpdu[17];
-	mic_header2[2] = mpdu[18];
-	mic_header2[3] = mpdu[19];
-	mic_header2[4] = mpdu[20];
-	mic_header2[5] = mpdu[21];
-
-	/* In Sequence Control field, mute sequence numer bits (12-bit) */
-	mic_header2[6] = mpdu[22] & 0x0f;	/* SC */
-	mic_header2[7] = 0x00;	/* mpdu[23]; */
-
-	if ((!qc_exists) && a4_exists) {
-		for (i = 0; i < 6; i++)
-			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
-
-	}
-
-	if (qc_exists && (!a4_exists)) {
-		mic_header2[8] = mpdu[24] & 0x0f;	/* mute bits 15 - 4 */
-		mic_header2[9] = mpdu[25] & 0x00;
-	}
-
-	if (qc_exists && a4_exists) {
-		for (i = 0; i < 6; i++)
-			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
-
-		mic_header2[14] = mpdu[30] & 0x0f;
-		mic_header2[15] = mpdu[31] & 0x00;
-	}
-}
-
-/************************************************/
-/* construct_mic_iv()                           */
-/* Builds the MIC IV from header fields and PN  */
-/************************************************/
-
-void construct_mic_iv(unsigned char *mic_iv,
-		      int qc_exists,
-		      int a4_exists,
-		      unsigned char *mpdu,
-		      unsigned int payload_length, unsigned char *pn_vector)
-{
-	int i;
-
-	mic_iv[0] = 0x59;
-	if (qc_exists && a4_exists)
-		mic_iv[1] = mpdu[30] & 0x0f;	/* QoS_TC           */
-	if (qc_exists && !a4_exists)
-		mic_iv[1] = mpdu[24] & 0x0f;	/* mute bits 7-4    */
-	if (!qc_exists)
-		mic_iv[1] = 0x00;
-	for (i = 2; i < 8; i++)
-		mic_iv[i] = mpdu[i + 8];	/* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
-#ifdef CONSISTENT_PN_ORDER
-	for (i = 8; i < 14; i++)
-		mic_iv[i] = pn_vector[i - 8];	/* mic_iv[8:13] = PN[0:5] */
-#else
-	for (i = 8; i < 14; i++)
-		mic_iv[i] = pn_vector[13 - i];	/* mic_iv[8:13] = PN[5:0] */
-#endif
-	mic_iv[14] = (unsigned char)(payload_length / 256);
-	mic_iv[15] = (unsigned char)(payload_length % 256);
-
-}
-
-/****************************************/
-/* aes128k128d()                        */
-/* Performs a 128 bit AES encrypt with  */
-/* 128 bit data.                        */
-/****************************************/
-void aes128k128d(unsigned char *key, unsigned char *data,
-		 unsigned char *ciphertext)
-{
-	int round;
-	int i;
-	unsigned char intermediatea[16];
-	unsigned char intermediateb[16];
-	unsigned char round_key[16];
-
-	for (i = 0; i < 16; i++)
-		round_key[i] = key[i];
-
-	for (round = 0; round < 11; round++) {
-		if (round == 0) {
-			xor_128(round_key, data, ciphertext);
-			next_key(round_key, round);
-		} else if (round == 10) {
-			byte_sub(ciphertext, intermediatea);
-			shift_row(intermediatea, intermediateb);
-			xor_128(intermediateb, round_key, ciphertext);
-		} else {	/* 1 - 9 */
-
-			byte_sub(ciphertext, intermediatea);
-			shift_row(intermediatea, intermediateb);
-			mix_column(&intermediateb[0], &intermediatea[0]);
-			mix_column(&intermediateb[4], &intermediatea[4]);
-			mix_column(&intermediateb[8], &intermediatea[8]);
-			mix_column(&intermediateb[12], &intermediatea[12]);
-			xor_128(intermediatea, round_key, ciphertext);
-			next_key(round_key, round);
-		}
-	}
-
-}
-
-void construct_ctr_preload(unsigned char *ctr_preload,
-			   int a4_exists,
-			   int qc_exists,
-			   unsigned char *mpdu, unsigned char *pn_vector, int c)
-{
-
-	int i = 0;
-	for (i = 0; i < 16; i++)
-		ctr_preload[i] = 0x00;
-	i = 0;
-
-	ctr_preload[0] = 0x01;	/* flag */
-	if (qc_exists && a4_exists)
-		ctr_preload[1] = mpdu[30] & 0x0f;	/* QoC_Control  */
-	if (qc_exists && !a4_exists)
-		ctr_preload[1] = mpdu[24] & 0x0f;
-
-	for (i = 2; i < 8; i++)
-		ctr_preload[i] = mpdu[i + 8];	/* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
-#ifdef CONSISTENT_PN_ORDER
-	for (i = 8; i < 14; i++)
-		ctr_preload[i] = pn_vector[i - 8];	/* ctr_preload[8:13] = PN[0:5] */
-#else
-	for (i = 8; i < 14; i++)
-		ctr_preload[i] = pn_vector[13 - i];	/* ctr_preload[8:13] = PN[5:0] */
-#endif
-	ctr_preload[14] = (unsigned char)(c / 256);	/* Ctr */
-	ctr_preload[15] = (unsigned char)(c % 256);
-
-}
-
-BOOLEAN RTMPSoftDecryptAES(struct rt_rtmp_adapter *pAd,
-			   u8 *pData,
-			   unsigned long DataByteCnt, struct rt_cipher_key *pWpaKey)
-{
-	u8 KeyID;
-	u32 HeaderLen;
-	u8 PN[6];
-	u32 payload_len;
-	u32 num_blocks;
-	u32 payload_remainder;
-	u16 fc;
-	u8 fc0;
-	u8 fc1;
-	u32 frame_type;
-	u32 frame_subtype;
-	u32 from_ds;
-	u32 to_ds;
-	int a4_exists;
-	int qc_exists;
-	u8 aes_out[16];
-	int payload_index;
-	u32 i;
-	u8 ctr_preload[16];
-	u8 chain_buffer[16];
-	u8 padded_buffer[16];
-	u8 mic_iv[16];
-	u8 mic_header1[16];
-	u8 mic_header2[16];
-	u8 MIC[8];
-	u8 TrailMIC[8];
-
-	fc0 = *pData;
-	fc1 = *(pData + 1);
-
-	fc = *((u16 *)pData);
-
-	frame_type = ((fc0 >> 2) & 0x03);
-	frame_subtype = ((fc0 >> 4) & 0x0f);
-
-	from_ds = (fc1 & 0x2) >> 1;
-	to_ds = (fc1 & 0x1);
-
-	a4_exists = (from_ds & to_ds);
-	qc_exists = ((frame_subtype == 0x08) ||	/* Assumed QoS subtypes */
-		     (frame_subtype == 0x09) ||	/* Likely to change.    */
-		     (frame_subtype == 0x0a) || (frame_subtype == 0x0b)
-	    );
-
-	HeaderLen = 24;
-	if (a4_exists)
-		HeaderLen += 6;
-
-	KeyID = *((u8 *)(pData + HeaderLen + 3));
-	KeyID = KeyID >> 6;
-
-	if (pWpaKey[KeyID].KeyLen == 0) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTMPSoftDecryptAES failed!(KeyID[%d] Length can not be 0)\n",
-			  KeyID));
-		return FALSE;
-	}
-
-	PN[0] = *(pData + HeaderLen);
-	PN[1] = *(pData + HeaderLen + 1);
-	PN[2] = *(pData + HeaderLen + 4);
-	PN[3] = *(pData + HeaderLen + 5);
-	PN[4] = *(pData + HeaderLen + 6);
-	PN[5] = *(pData + HeaderLen + 7);
-
-	payload_len = DataByteCnt - HeaderLen - 8 - 8;	/* 8 bytes for CCMP header , 8 bytes for MIC */
-	payload_remainder = (payload_len) % 16;
-	num_blocks = (payload_len) / 16;
-
-	/* Find start of payload */
-	payload_index = HeaderLen + 8;	/*IV+EIV */
-
-	for (i = 0; i < num_blocks; i++) {
-		construct_ctr_preload(ctr_preload,
-				      a4_exists, qc_exists, pData, PN, i + 1);
-
-		aes128k128d(pWpaKey[KeyID].Key, ctr_preload, aes_out);
-
-		bitwise_xor(aes_out, pData + payload_index, chain_buffer);
-		NdisMoveMemory(pData + payload_index - 8, chain_buffer, 16);
-		payload_index += 16;
-	}
-
-	/* */
-	/* If there is a short final block, then pad it */
-	/* encrypt it and copy the unpadded part back */
-	/* */
-	if (payload_remainder > 0) {
-		construct_ctr_preload(ctr_preload,
-				      a4_exists,
-				      qc_exists, pData, PN, num_blocks + 1);
-
-		NdisZeroMemory(padded_buffer, 16);
-		NdisMoveMemory(padded_buffer, pData + payload_index,
-			       payload_remainder);
-
-		aes128k128d(pWpaKey[KeyID].Key, ctr_preload, aes_out);
-
-		bitwise_xor(aes_out, padded_buffer, chain_buffer);
-		NdisMoveMemory(pData + payload_index - 8, chain_buffer,
-			       payload_remainder);
-		payload_index += payload_remainder;
-	}
-	/* */
-	/* Descrypt the MIC */
-	/* */
-	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pData, PN, 0);
-	NdisZeroMemory(padded_buffer, 16);
-	NdisMoveMemory(padded_buffer, pData + payload_index, 8);
-
-	aes128k128d(pWpaKey[KeyID].Key, ctr_preload, aes_out);
-
-	bitwise_xor(aes_out, padded_buffer, chain_buffer);
-
-	NdisMoveMemory(TrailMIC, chain_buffer, 8);
-
-	/* */
-	/* Calculate MIC */
-	/* */
-
-	/*Force the protected frame bit on */
-	*(pData + 1) = *(pData + 1) | 0x40;
-
-	/* Find start of payload */
-	/* Because the CCMP header has been removed */
-	payload_index = HeaderLen;
-
-	construct_mic_iv(mic_iv, qc_exists, a4_exists, pData, payload_len, PN);
-
-	construct_mic_header1(mic_header1, HeaderLen, pData);
-
-	construct_mic_header2(mic_header2, pData, a4_exists, qc_exists);
-
-	aes128k128d(pWpaKey[KeyID].Key, mic_iv, aes_out);
-	bitwise_xor(aes_out, mic_header1, chain_buffer);
-	aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
-	bitwise_xor(aes_out, mic_header2, chain_buffer);
-	aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
-
-	/* iterate through each 16 byte payload block */
-	for (i = 0; i < num_blocks; i++) {
-		bitwise_xor(aes_out, pData + payload_index, chain_buffer);
-		payload_index += 16;
-		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
-	}
-
-	/* Add on the final payload block if it needs padding */
-	if (payload_remainder > 0) {
-		NdisZeroMemory(padded_buffer, 16);
-		NdisMoveMemory(padded_buffer, pData + payload_index,
-			       payload_remainder);
-
-		bitwise_xor(aes_out, padded_buffer, chain_buffer);
-		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
-	}
-	/* aes_out contains padded mic, discard most significant */
-	/* 8 bytes to generate 64 bit MIC */
-	for (i = 0; i < 8; i++)
-		MIC[i] = aes_out[i];
-
-	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptAES, MIC Error !\n"));	/*MIC error. */
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/* =========================  AES En/Decryption ========================== */
-#ifndef	uint8
-#define	uint8  unsigned	char
-#endif
-
-#ifndef	uint32
-#define	uint32 unsigned	int
-#endif
-
-/* forward S-box */
-static uint32 FSb[256] = {
-	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
-	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
-	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
-	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
-	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
-	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
-	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
-	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
-	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
-	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
-	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
-	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
-	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
-	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
-	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
-	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
-	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
-	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
-	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
-	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
-	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
-	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
-	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
-	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
-	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
-	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
-	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
-	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
-	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
-	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
-	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
-	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
-};
-
-/* forward table */
-#define	FT \
-\
-	V(C6,63,63,A5),	V(F8,7C,7C,84),	V(EE,77,77,99),	V(F6,7B,7B,8D),	\
-	V(FF,F2,F2,0D),	V(D6,6B,6B,BD),	V(DE,6F,6F,B1),	V(91,C5,C5,54),	\
-	V(60,30,30,50),	V(02,01,01,03),	V(CE,67,67,A9),	V(56,2B,2B,7D),	\
-	V(E7,FE,FE,19),	V(B5,D7,D7,62),	V(4D,AB,AB,E6),	V(EC,76,76,9A),	\
-	V(8F,CA,CA,45),	V(1F,82,82,9D),	V(89,C9,C9,40),	V(FA,7D,7D,87),	\
-	V(EF,FA,FA,15),	V(B2,59,59,EB),	V(8E,47,47,C9),	V(FB,F0,F0,0B),	\
-	V(41,AD,AD,EC),	V(B3,D4,D4,67),	V(5F,A2,A2,FD),	V(45,AF,AF,EA),	\
-	V(23,9C,9C,BF),	V(53,A4,A4,F7),	V(E4,72,72,96),	V(9B,C0,C0,5B),	\
-	V(75,B7,B7,C2),	V(E1,FD,FD,1C),	V(3D,93,93,AE),	V(4C,26,26,6A),	\
-	V(6C,36,36,5A),	V(7E,3F,3F,41),	V(F5,F7,F7,02),	V(83,CC,CC,4F),	\
-	V(68,34,34,5C),	V(51,A5,A5,F4),	V(D1,E5,E5,34),	V(F9,F1,F1,08),	\
-	V(E2,71,71,93),	V(AB,D8,D8,73),	V(62,31,31,53),	V(2A,15,15,3F),	\
-	V(08,04,04,0C),	V(95,C7,C7,52),	V(46,23,23,65),	V(9D,C3,C3,5E),	\
-	V(30,18,18,28),	V(37,96,96,A1),	V(0A,05,05,0F),	V(2F,9A,9A,B5),	\
-	V(0E,07,07,09),	V(24,12,12,36),	V(1B,80,80,9B),	V(DF,E2,E2,3D),	\
-	V(CD,EB,EB,26),	V(4E,27,27,69),	V(7F,B2,B2,CD),	V(EA,75,75,9F),	\
-	V(12,09,09,1B),	V(1D,83,83,9E),	V(58,2C,2C,74),	V(34,1A,1A,2E),	\
-	V(36,1B,1B,2D),	V(DC,6E,6E,B2),	V(B4,5A,5A,EE),	V(5B,A0,A0,FB),	\
-	V(A4,52,52,F6),	V(76,3B,3B,4D),	V(B7,D6,D6,61),	V(7D,B3,B3,CE),	\
-	V(52,29,29,7B),	V(DD,E3,E3,3E),	V(5E,2F,2F,71),	V(13,84,84,97),	\
-	V(A6,53,53,F5),	V(B9,D1,D1,68),	V(00,00,00,00),	V(C1,ED,ED,2C),	\
-	V(40,20,20,60),	V(E3,FC,FC,1F),	V(79,B1,B1,C8),	V(B6,5B,5B,ED),	\
-	V(D4,6A,6A,BE),	V(8D,CB,CB,46),	V(67,BE,BE,D9),	V(72,39,39,4B),	\
-	V(94,4A,4A,DE),	V(98,4C,4C,D4),	V(B0,58,58,E8),	V(85,CF,CF,4A),	\
-	V(BB,D0,D0,6B),	V(C5,EF,EF,2A),	V(4F,AA,AA,E5),	V(ED,FB,FB,16),	\
-	V(86,43,43,C5),	V(9A,4D,4D,D7),	V(66,33,33,55),	V(11,85,85,94),	\
-	V(8A,45,45,CF),	V(E9,F9,F9,10),	V(04,02,02,06),	V(FE,7F,7F,81),	\
-	V(A0,50,50,F0),	V(78,3C,3C,44),	V(25,9F,9F,BA),	V(4B,A8,A8,E3),	\
-	V(A2,51,51,F3),	V(5D,A3,A3,FE),	V(80,40,40,C0),	V(05,8F,8F,8A),	\
-	V(3F,92,92,AD),	V(21,9D,9D,BC),	V(70,38,38,48),	V(F1,F5,F5,04),	\
-	V(63,BC,BC,DF),	V(77,B6,B6,C1),	V(AF,DA,DA,75),	V(42,21,21,63),	\
-	V(20,10,10,30),	V(E5,FF,FF,1A),	V(FD,F3,F3,0E),	V(BF,D2,D2,6D),	\
-	V(81,CD,CD,4C),	V(18,0C,0C,14),	V(26,13,13,35),	V(C3,EC,EC,2F),	\
-	V(BE,5F,5F,E1),	V(35,97,97,A2),	V(88,44,44,CC),	V(2E,17,17,39),	\
-	V(93,C4,C4,57),	V(55,A7,A7,F2),	V(FC,7E,7E,82),	V(7A,3D,3D,47),	\
-	V(C8,64,64,AC),	V(BA,5D,5D,E7),	V(32,19,19,2B),	V(E6,73,73,95),	\
-	V(C0,60,60,A0),	V(19,81,81,98),	V(9E,4F,4F,D1),	V(A3,DC,DC,7F),	\
-	V(44,22,22,66),	V(54,2A,2A,7E),	V(3B,90,90,AB),	V(0B,88,88,83),	\
-	V(8C,46,46,CA),	V(C7,EE,EE,29),	V(6B,B8,B8,D3),	V(28,14,14,3C),	\
-	V(A7,DE,DE,79),	V(BC,5E,5E,E2),	V(16,0B,0B,1D),	V(AD,DB,DB,76),	\
-	V(DB,E0,E0,3B),	V(64,32,32,56),	V(74,3A,3A,4E),	V(14,0A,0A,1E),	\
-	V(92,49,49,DB),	V(0C,06,06,0A),	V(48,24,24,6C),	V(B8,5C,5C,E4),	\
-	V(9F,C2,C2,5D),	V(BD,D3,D3,6E),	V(43,AC,AC,EF),	V(C4,62,62,A6),	\
-	V(39,91,91,A8),	V(31,95,95,A4),	V(D3,E4,E4,37),	V(F2,79,79,8B),	\
-	V(D5,E7,E7,32),	V(8B,C8,C8,43),	V(6E,37,37,59),	V(DA,6D,6D,B7),	\
-	V(01,8D,8D,8C),	V(B1,D5,D5,64),	V(9C,4E,4E,D2),	V(49,A9,A9,E0),	\
-	V(D8,6C,6C,B4),	V(AC,56,56,FA),	V(F3,F4,F4,07),	V(CF,EA,EA,25),	\
-	V(CA,65,65,AF),	V(F4,7A,7A,8E),	V(47,AE,AE,E9),	V(10,08,08,18),	\
-	V(6F,BA,BA,D5),	V(F0,78,78,88),	V(4A,25,25,6F),	V(5C,2E,2E,72),	\
-	V(38,1C,1C,24),	V(57,A6,A6,F1),	V(73,B4,B4,C7),	V(97,C6,C6,51),	\
-	V(CB,E8,E8,23),	V(A1,DD,DD,7C),	V(E8,74,74,9C),	V(3E,1F,1F,21),	\
-	V(96,4B,4B,DD),	V(61,BD,BD,DC),	V(0D,8B,8B,86),	V(0F,8A,8A,85),	\
-	V(E0,70,70,90),	V(7C,3E,3E,42),	V(71,B5,B5,C4),	V(CC,66,66,AA),	\
-	V(90,48,48,D8),	V(06,03,03,05),	V(F7,F6,F6,01),	V(1C,0E,0E,12),	\
-	V(C2,61,61,A3),	V(6A,35,35,5F),	V(AE,57,57,F9),	V(69,B9,B9,D0),	\
-	V(17,86,86,91),	V(99,C1,C1,58),	V(3A,1D,1D,27),	V(27,9E,9E,B9),	\
-	V(D9,E1,E1,38),	V(EB,F8,F8,13),	V(2B,98,98,B3),	V(22,11,11,33),	\
-	V(D2,69,69,BB),	V(A9,D9,D9,70),	V(07,8E,8E,89),	V(33,94,94,A7),	\
-	V(2D,9B,9B,B6),	V(3C,1E,1E,22),	V(15,87,87,92),	V(C9,E9,E9,20),	\
-	V(87,CE,CE,49),	V(AA,55,55,FF),	V(50,28,28,78),	V(A5,DF,DF,7A),	\
-	V(03,8C,8C,8F),	V(59,A1,A1,F8),	V(09,89,89,80),	V(1A,0D,0D,17),	\
-	V(65,BF,BF,DA),	V(D7,E6,E6,31),	V(84,42,42,C6),	V(D0,68,68,B8),	\
-	V(82,41,41,C3),	V(29,99,99,B0),	V(5A,2D,2D,77),	V(1E,0F,0F,11),	\
-	V(7B,B0,B0,CB),	V(A8,54,54,FC),	V(6D,BB,BB,D6),	V(2C,16,16,3A)
-
-#define	V(a,b,c,d) 0x##a##b##c##d
-static uint32 FT0[256] = { FT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##d##a##b##c
-static uint32 FT1[256] = { FT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##c##d##a##b
-static uint32 FT2[256] = { FT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##b##c##d##a
-static uint32 FT3[256] = { FT };
-
-#undef V
-
-#undef FT
-
-/* reverse S-box */
-
-static uint32 RSb[256] = {
-	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
-	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
-	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
-	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
-	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
-	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
-	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
-	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
-	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
-	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
-	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
-	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
-	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
-	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
-	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
-	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
-	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
-	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
-	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
-	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
-	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
-	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
-	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
-	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
-	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
-	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
-	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
-	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
-	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
-	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
-	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
-	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
-};
-
-/* reverse table */
-
-#define	RT \
-\
-	V(51,F4,A7,50),	V(7E,41,65,53),	V(1A,17,A4,C3),	V(3A,27,5E,96),	\
-	V(3B,AB,6B,CB),	V(1F,9D,45,F1),	V(AC,FA,58,AB),	V(4B,E3,03,93),	\
-	V(20,30,FA,55),	V(AD,76,6D,F6),	V(88,CC,76,91),	V(F5,02,4C,25),	\
-	V(4F,E5,D7,FC),	V(C5,2A,CB,D7),	V(26,35,44,80),	V(B5,62,A3,8F),	\
-	V(DE,B1,5A,49),	V(25,BA,1B,67),	V(45,EA,0E,98),	V(5D,FE,C0,E1),	\
-	V(C3,2F,75,02),	V(81,4C,F0,12),	V(8D,46,97,A3),	V(6B,D3,F9,C6),	\
-	V(03,8F,5F,E7),	V(15,92,9C,95),	V(BF,6D,7A,EB),	V(95,52,59,DA),	\
-	V(D4,BE,83,2D),	V(58,74,21,D3),	V(49,E0,69,29),	V(8E,C9,C8,44),	\
-	V(75,C2,89,6A),	V(F4,8E,79,78),	V(99,58,3E,6B),	V(27,B9,71,DD),	\
-	V(BE,E1,4F,B6),	V(F0,88,AD,17),	V(C9,20,AC,66),	V(7D,CE,3A,B4),	\
-	V(63,DF,4A,18),	V(E5,1A,31,82),	V(97,51,33,60),	V(62,53,7F,45),	\
-	V(B1,64,77,E0),	V(BB,6B,AE,84),	V(FE,81,A0,1C),	V(F9,08,2B,94),	\
-	V(70,48,68,58),	V(8F,45,FD,19),	V(94,DE,6C,87),	V(52,7B,F8,B7),	\
-	V(AB,73,D3,23),	V(72,4B,02,E2),	V(E3,1F,8F,57),	V(66,55,AB,2A),	\
-	V(B2,EB,28,07),	V(2F,B5,C2,03),	V(86,C5,7B,9A),	V(D3,37,08,A5),	\
-	V(30,28,87,F2),	V(23,BF,A5,B2),	V(02,03,6A,BA),	V(ED,16,82,5C),	\
-	V(8A,CF,1C,2B),	V(A7,79,B4,92),	V(F3,07,F2,F0),	V(4E,69,E2,A1),	\
-	V(65,DA,F4,CD),	V(06,05,BE,D5),	V(D1,34,62,1F),	V(C4,A6,FE,8A),	\
-	V(34,2E,53,9D),	V(A2,F3,55,A0),	V(05,8A,E1,32),	V(A4,F6,EB,75),	\
-	V(0B,83,EC,39),	V(40,60,EF,AA),	V(5E,71,9F,06),	V(BD,6E,10,51),	\
-	V(3E,21,8A,F9),	V(96,DD,06,3D),	V(DD,3E,05,AE),	V(4D,E6,BD,46),	\
-	V(91,54,8D,B5),	V(71,C4,5D,05),	V(04,06,D4,6F),	V(60,50,15,FF),	\
-	V(19,98,FB,24),	V(D6,BD,E9,97),	V(89,40,43,CC),	V(67,D9,9E,77),	\
-	V(B0,E8,42,BD),	V(07,89,8B,88),	V(E7,19,5B,38),	V(79,C8,EE,DB),	\
-	V(A1,7C,0A,47),	V(7C,42,0F,E9),	V(F8,84,1E,C9),	V(00,00,00,00),	\
-	V(09,80,86,83),	V(32,2B,ED,48),	V(1E,11,70,AC),	V(6C,5A,72,4E),	\
-	V(FD,0E,FF,FB),	V(0F,85,38,56),	V(3D,AE,D5,1E),	V(36,2D,39,27),	\
-	V(0A,0F,D9,64),	V(68,5C,A6,21),	V(9B,5B,54,D1),	V(24,36,2E,3A),	\
-	V(0C,0A,67,B1),	V(93,57,E7,0F),	V(B4,EE,96,D2),	V(1B,9B,91,9E),	\
-	V(80,C0,C5,4F),	V(61,DC,20,A2),	V(5A,77,4B,69),	V(1C,12,1A,16),	\
-	V(E2,93,BA,0A),	V(C0,A0,2A,E5),	V(3C,22,E0,43),	V(12,1B,17,1D),	\
-	V(0E,09,0D,0B),	V(F2,8B,C7,AD),	V(2D,B6,A8,B9),	V(14,1E,A9,C8),	\
-	V(57,F1,19,85),	V(AF,75,07,4C),	V(EE,99,DD,BB),	V(A3,7F,60,FD),	\
-	V(F7,01,26,9F),	V(5C,72,F5,BC),	V(44,66,3B,C5),	V(5B,FB,7E,34),	\
-	V(8B,43,29,76),	V(CB,23,C6,DC),	V(B6,ED,FC,68),	V(B8,E4,F1,63),	\
-	V(D7,31,DC,CA),	V(42,63,85,10),	V(13,97,22,40),	V(84,C6,11,20),	\
-	V(85,4A,24,7D),	V(D2,BB,3D,F8),	V(AE,F9,32,11),	V(C7,29,A1,6D),	\
-	V(1D,9E,2F,4B),	V(DC,B2,30,F3),	V(0D,86,52,EC),	V(77,C1,E3,D0),	\
-	V(2B,B3,16,6C),	V(A9,70,B9,99),	V(11,94,48,FA),	V(47,E9,64,22),	\
-	V(A8,FC,8C,C4),	V(A0,F0,3F,1A),	V(56,7D,2C,D8),	V(22,33,90,EF),	\
-	V(87,49,4E,C7),	V(D9,38,D1,C1),	V(8C,CA,A2,FE),	V(98,D4,0B,36),	\
-	V(A6,F5,81,CF),	V(A5,7A,DE,28),	V(DA,B7,8E,26),	V(3F,AD,BF,A4),	\
-	V(2C,3A,9D,E4),	V(50,78,92,0D),	V(6A,5F,CC,9B),	V(54,7E,46,62),	\
-	V(F6,8D,13,C2),	V(90,D8,B8,E8),	V(2E,39,F7,5E),	V(82,C3,AF,F5),	\
-	V(9F,5D,80,BE),	V(69,D0,93,7C),	V(6F,D5,2D,A9),	V(CF,25,12,B3),	\
-	V(C8,AC,99,3B),	V(10,18,7D,A7),	V(E8,9C,63,6E),	V(DB,3B,BB,7B),	\
-	V(CD,26,78,09),	V(6E,59,18,F4),	V(EC,9A,B7,01),	V(83,4F,9A,A8),	\
-	V(E6,95,6E,65),	V(AA,FF,E6,7E),	V(21,BC,CF,08),	V(EF,15,E8,E6),	\
-	V(BA,E7,9B,D9),	V(4A,6F,36,CE),	V(EA,9F,09,D4),	V(29,B0,7C,D6),	\
-	V(31,A4,B2,AF),	V(2A,3F,23,31),	V(C6,A5,94,30),	V(35,A2,66,C0),	\
-	V(74,4E,BC,37),	V(FC,82,CA,A6),	V(E0,90,D0,B0),	V(33,A7,D8,15),	\
-	V(F1,04,98,4A),	V(41,EC,DA,F7),	V(7F,CD,50,0E),	V(17,91,F6,2F),	\
-	V(76,4D,D6,8D),	V(43,EF,B0,4D),	V(CC,AA,4D,54),	V(E4,96,04,DF),	\
-	V(9E,D1,B5,E3),	V(4C,6A,88,1B),	V(C1,2C,1F,B8),	V(46,65,51,7F),	\
-	V(9D,5E,EA,04),	V(01,8C,35,5D),	V(FA,87,74,73),	V(FB,0B,41,2E),	\
-	V(B3,67,1D,5A),	V(92,DB,D2,52),	V(E9,10,56,33),	V(6D,D6,47,13),	\
-	V(9A,D7,61,8C),	V(37,A1,0C,7A),	V(59,F8,14,8E),	V(EB,13,3C,89),	\
-	V(CE,A9,27,EE),	V(B7,61,C9,35),	V(E1,1C,E5,ED),	V(7A,47,B1,3C),	\
-	V(9C,D2,DF,59),	V(55,F2,73,3F),	V(18,14,CE,79),	V(73,C7,37,BF),	\
-	V(53,F7,CD,EA),	V(5F,FD,AA,5B),	V(DF,3D,6F,14),	V(78,44,DB,86),	\
-	V(CA,AF,F3,81),	V(B9,68,C4,3E),	V(38,24,34,2C),	V(C2,A3,40,5F),	\
-	V(16,1D,C3,72),	V(BC,E2,25,0C),	V(28,3C,49,8B),	V(FF,0D,95,41),	\
-	V(39,A8,01,71),	V(08,0C,B3,DE),	V(D8,B4,E4,9C),	V(64,56,C1,90),	\
-	V(7B,CB,84,61),	V(D5,32,B6,70),	V(48,6C,5C,74),	V(D0,B8,57,42)
-
-#define	V(a,b,c,d) 0x##a##b##c##d
-static uint32 RT0[256] = { RT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##d##a##b##c
-static uint32 RT1[256] = { RT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##c##d##a##b
-static uint32 RT2[256] = { RT };
-
-#undef V
-
-#define	V(a,b,c,d) 0x##b##c##d##a
-static uint32 RT3[256] = { RT };
-
-#undef V
-
-#undef RT
-
-/* round constants */
-
-static uint32 RCON[10] = {
-	0x01000000, 0x02000000, 0x04000000, 0x08000000,
-	0x10000000, 0x20000000, 0x40000000, 0x80000000,
-	0x1B000000, 0x36000000
-};
-
-/* key schedule	tables */
-
-static int KT_init = 1;
-
-static uint32 KT0[256];
-static uint32 KT1[256];
-static uint32 KT2[256];
-static uint32 KT3[256];
-
-/* platform-independent	32-bit integer manipulation	macros */
-
-#define	GET_UINT32(n,b,i)						\
-{												\
-	(n)	= (	(uint32) (b)[(i)	] << 24	)		\
-		| (	(uint32) (b)[(i) + 1] << 16	)		\
-		| (	(uint32) (b)[(i) + 2] <<  8	)		\
-		| (	(uint32) (b)[(i) + 3]		);		\
-}
-
-#define	PUT_UINT32(n,b,i)						\
-{												\
-	(b)[(i)	   ] = (uint8) ( (n) >>	24 );		\
-	(b)[(i)	+ 1] = (uint8) ( (n) >>	16 );		\
-	(b)[(i)	+ 2] = (uint8) ( (n) >>	 8 );		\
-	(b)[(i)	+ 3] = (uint8) ( (n)	   );		\
-}
-
-int rt_aes_set_key(struct aes_context * ctx, uint8 * key, int nbits)
-{
-	int i;
-	uint32 *RK, *SK;
-
-	switch (nbits) {
-	case 128:
-		ctx->nr = 10;
-		break;
-	case 192:
-		ctx->nr = 12;
-		break;
-	case 256:
-		ctx->nr = 14;
-		break;
-	default:
-		return (1);
-	}
-
-	RK = (uint32 *) ctx->erk;
-
-	for (i = 0; i < (nbits >> 5); i++) {
-		GET_UINT32(RK[i], key, i * 4);
-	}
-
-	/* setup encryption     round keys */
-
-	switch (nbits) {
-	case 128:
-
-		for (i = 0; i < 10; i++, RK += 4) {
-			RK[4] = RK[0] ^ RCON[i] ^
-			    (FSb[(uint8) (RK[3] >> 16)] << 24) ^
-			    (FSb[(uint8) (RK[3] >> 8)] << 16) ^
-			    (FSb[(uint8) (RK[3])] << 8) ^
-			    (FSb[(uint8) (RK[3] >> 24)]);
-
-			RK[5] = RK[1] ^ RK[4];
-			RK[6] = RK[2] ^ RK[5];
-			RK[7] = RK[3] ^ RK[6];
-		}
-		break;
-
-	case 192:
-
-		for (i = 0; i < 8; i++, RK += 6) {
-			RK[6] = RK[0] ^ RCON[i] ^
-			    (FSb[(uint8) (RK[5] >> 16)] << 24) ^
-			    (FSb[(uint8) (RK[5] >> 8)] << 16) ^
-			    (FSb[(uint8) (RK[5])] << 8) ^
-			    (FSb[(uint8) (RK[5] >> 24)]);
-
-			RK[7] = RK[1] ^ RK[6];
-			RK[8] = RK[2] ^ RK[7];
-			RK[9] = RK[3] ^ RK[8];
-			RK[10] = RK[4] ^ RK[9];
-			RK[11] = RK[5] ^ RK[10];
-		}
-		break;
-
-	case 256:
-
-		for (i = 0; i < 7; i++, RK += 8) {
-			RK[8] = RK[0] ^ RCON[i] ^
-			    (FSb[(uint8) (RK[7] >> 16)] << 24) ^
-			    (FSb[(uint8) (RK[7] >> 8)] << 16) ^
-			    (FSb[(uint8) (RK[7])] << 8) ^
-			    (FSb[(uint8) (RK[7] >> 24)]);
-
-			RK[9] = RK[1] ^ RK[8];
-			RK[10] = RK[2] ^ RK[9];
-			RK[11] = RK[3] ^ RK[10];
-
-			RK[12] = RK[4] ^
-			    (FSb[(uint8) (RK[11] >> 24)] << 24) ^
-			    (FSb[(uint8) (RK[11] >> 16)] << 16) ^
-			    (FSb[(uint8) (RK[11] >> 8)] << 8) ^
-			    (FSb[(uint8) (RK[11])]);
-
-			RK[13] = RK[5] ^ RK[12];
-			RK[14] = RK[6] ^ RK[13];
-			RK[15] = RK[7] ^ RK[14];
-		}
-		break;
-	}
-
-	/* setup decryption     round keys */
-
-	if (KT_init) {
-		for (i = 0; i < 256; i++) {
-			KT0[i] = RT0[FSb[i]];
-			KT1[i] = RT1[FSb[i]];
-			KT2[i] = RT2[FSb[i]];
-			KT3[i] = RT3[FSb[i]];
-		}
-
-		KT_init = 0;
-	}
-
-	SK = (uint32 *) ctx->drk;
-
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-
-	for (i = 1; i < ctx->nr; i++) {
-		RK -= 8;
-
-		*SK++ = KT0[(uint8) (*RK >> 24)] ^
-		    KT1[(uint8) (*RK >> 16)] ^
-		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
-		RK++;
-
-		*SK++ = KT0[(uint8) (*RK >> 24)] ^
-		    KT1[(uint8) (*RK >> 16)] ^
-		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
-		RK++;
-
-		*SK++ = KT0[(uint8) (*RK >> 24)] ^
-		    KT1[(uint8) (*RK >> 16)] ^
-		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
-		RK++;
-
-		*SK++ = KT0[(uint8) (*RK >> 24)] ^
-		    KT1[(uint8) (*RK >> 16)] ^
-		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
-		RK++;
-	}
-
-	RK -= 8;
-
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-	*SK++ = *RK++;
-
-	return (0);
-}
-
-/* AES 128-bit block encryption	routine	*/
-
-void rt_aes_encrypt(struct aes_context * ctx, uint8 input[16], uint8 output[16])
-{
-	uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
-
-	RK = (uint32 *) ctx->erk;
-	GET_UINT32(X0, input, 0);
-	X0 ^= RK[0];
-	GET_UINT32(X1, input, 4);
-	X1 ^= RK[1];
-	GET_UINT32(X2, input, 8);
-	X2 ^= RK[2];
-	GET_UINT32(X3, input, 12);
-	X3 ^= RK[3];
-
-#define	AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
-{												\
-	RK += 4;									\
-												\
-	X0 = RK[0] ^ FT0[ (uint8) (	Y0 >> 24 ) ] ^	\
-				 FT1[ (uint8) (	Y1 >> 16 ) ] ^	\
-				 FT2[ (uint8) (	Y2 >>  8 ) ] ^	\
-				 FT3[ (uint8) (	Y3		 ) ];	\
-												\
-	X1 = RK[1] ^ FT0[ (uint8) (	Y1 >> 24 ) ] ^	\
-				 FT1[ (uint8) (	Y2 >> 16 ) ] ^	\
-				 FT2[ (uint8) (	Y3 >>  8 ) ] ^	\
-				 FT3[ (uint8) (	Y0		 ) ];	\
-												\
-	X2 = RK[2] ^ FT0[ (uint8) (	Y2 >> 24 ) ] ^	\
-				 FT1[ (uint8) (	Y3 >> 16 ) ] ^	\
-				 FT2[ (uint8) (	Y0 >>  8 ) ] ^	\
-				 FT3[ (uint8) (	Y1		 ) ];	\
-												\
-	X3 = RK[3] ^ FT0[ (uint8) (	Y3 >> 24 ) ] ^	\
-				 FT1[ (uint8) (	Y0 >> 16 ) ] ^	\
-				 FT2[ (uint8) (	Y1 >>  8 ) ] ^	\
-				 FT3[ (uint8) (	Y2		 ) ];	\
-}
-
-	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 1 */
-	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 2 */
-	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 3 */
-	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 4 */
-	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 5 */
-	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 6 */
-	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 7 */
-	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 8 */
-	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 9 */
-
-	if (ctx->nr > 10) {
-		AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 10     */
-		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 11     */
-	}
-
-	if (ctx->nr > 12) {
-		AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 12     */
-		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 13     */
-	}
-
-	/* last round */
-
-	RK += 4;
-
-	X0 = RK[0] ^ (FSb[(uint8) (Y0 >> 24)] << 24) ^
-	    (FSb[(uint8) (Y1 >> 16)] << 16) ^
-	    (FSb[(uint8) (Y2 >> 8)] << 8) ^ (FSb[(uint8) (Y3)]);
-
-	X1 = RK[1] ^ (FSb[(uint8) (Y1 >> 24)] << 24) ^
-	    (FSb[(uint8) (Y2 >> 16)] << 16) ^
-	    (FSb[(uint8) (Y3 >> 8)] << 8) ^ (FSb[(uint8) (Y0)]);
-
-	X2 = RK[2] ^ (FSb[(uint8) (Y2 >> 24)] << 24) ^
-	    (FSb[(uint8) (Y3 >> 16)] << 16) ^
-	    (FSb[(uint8) (Y0 >> 8)] << 8) ^ (FSb[(uint8) (Y1)]);
-
-	X3 = RK[3] ^ (FSb[(uint8) (Y3 >> 24)] << 24) ^
-	    (FSb[(uint8) (Y0 >> 16)] << 16) ^
-	    (FSb[(uint8) (Y1 >> 8)] << 8) ^ (FSb[(uint8) (Y2)]);
-
-	PUT_UINT32(X0, output, 0);
-	PUT_UINT32(X1, output, 4);
-	PUT_UINT32(X2, output, 8);
-	PUT_UINT32(X3, output, 12);
-}
-
-/* AES 128-bit block decryption	routine	*/
-
-void rt_aes_decrypt(struct aes_context * ctx, uint8 input[16], uint8 output[16])
-{
-	uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
-
-	RK = (uint32 *) ctx->drk;
-
-	GET_UINT32(X0, input, 0);
-	X0 ^= RK[0];
-	GET_UINT32(X1, input, 4);
-	X1 ^= RK[1];
-	GET_UINT32(X2, input, 8);
-	X2 ^= RK[2];
-	GET_UINT32(X3, input, 12);
-	X3 ^= RK[3];
-
-#define	AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
-{												\
-	RK += 4;									\
-												\
-	X0 = RK[0] ^ RT0[ (uint8) (	Y0 >> 24 ) ] ^	\
-				 RT1[ (uint8) (	Y3 >> 16 ) ] ^	\
-				 RT2[ (uint8) (	Y2 >>  8 ) ] ^	\
-				 RT3[ (uint8) (	Y1		 ) ];	\
-												\
-	X1 = RK[1] ^ RT0[ (uint8) (	Y1 >> 24 ) ] ^	\
-				 RT1[ (uint8) (	Y0 >> 16 ) ] ^	\
-				 RT2[ (uint8) (	Y3 >>  8 ) ] ^	\
-				 RT3[ (uint8) (	Y2		 ) ];	\
-												\
-	X2 = RK[2] ^ RT0[ (uint8) (	Y2 >> 24 ) ] ^	\
-				 RT1[ (uint8) (	Y1 >> 16 ) ] ^	\
-				 RT2[ (uint8) (	Y0 >>  8 ) ] ^	\
-				 RT3[ (uint8) (	Y3		 ) ];	\
-												\
-	X3 = RK[3] ^ RT0[ (uint8) (	Y3 >> 24 ) ] ^	\
-				 RT1[ (uint8) (	Y2 >> 16 ) ] ^	\
-				 RT2[ (uint8) (	Y1 >>  8 ) ] ^	\
-				 RT3[ (uint8) (	Y0		 ) ];	\
-}
-
-	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 1 */
-	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 2 */
-	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 3 */
-	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 4 */
-	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 5 */
-	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 6 */
-	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 7 */
-	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 8 */
-	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 9 */
-
-	if (ctx->nr > 10) {
-		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 10     */
-		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 11     */
-	}
-
-	if (ctx->nr > 12) {
-		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 12     */
-		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 13     */
-	}
-
-	/* last round */
-
-	RK += 4;
-
-	X0 = RK[0] ^ (RSb[(uint8) (Y0 >> 24)] << 24) ^
-	    (RSb[(uint8) (Y3 >> 16)] << 16) ^
-	    (RSb[(uint8) (Y2 >> 8)] << 8) ^ (RSb[(uint8) (Y1)]);
-
-	X1 = RK[1] ^ (RSb[(uint8) (Y1 >> 24)] << 24) ^
-	    (RSb[(uint8) (Y0 >> 16)] << 16) ^
-	    (RSb[(uint8) (Y3 >> 8)] << 8) ^ (RSb[(uint8) (Y2)]);
-
-	X2 = RK[2] ^ (RSb[(uint8) (Y2 >> 24)] << 24) ^
-	    (RSb[(uint8) (Y1 >> 16)] << 16) ^
-	    (RSb[(uint8) (Y0 >> 8)] << 8) ^ (RSb[(uint8) (Y3)]);
-
-	X3 = RK[3] ^ (RSb[(uint8) (Y3 >> 24)] << 24) ^
-	    (RSb[(uint8) (Y2 >> 16)] << 16) ^
-	    (RSb[(uint8) (Y1 >> 8)] << 8) ^ (RSb[(uint8) (Y0)]);
-
-	PUT_UINT32(X0, output, 0);
-	PUT_UINT32(X1, output, 4);
-	PUT_UINT32(X2, output, 8);
-	PUT_UINT32(X3, output, 12);
-}
-
-/*
-    ==========================================================================
-    Description:
-        ENCRYPT AES GTK before sending in EAPOL frame.
-        AES GTK length = 128 bit,  so fix blocks for aes-key-wrap as 2 in this function.
-        This function references to RFC 3394 for aes key wrap algorithm.
-    Return:
-    ==========================================================================
-*/
-void AES_GTK_KEY_WRAP(u8 * key,
-		      u8 * plaintext,
-		      u32 p_len, u8 * ciphertext)
-{
-	u8 A[8], BIN[16], BOUT[16];
-	u8 R[512];
-	int num_blocks = p_len / 8;	/* unit:64bits */
-	int i, j;
-	struct aes_context aesctx;
-	u8 xor;
-
-	rt_aes_set_key(&aesctx, key, 128);
-
-	/* Init IA */
-	for (i = 0; i < 8; i++)
-		A[i] = 0xa6;
-
-	/*Input plaintext */
-	for (i = 0; i < num_blocks; i++) {
-		for (j = 0; j < 8; j++)
-			R[8 * (i + 1) + j] = plaintext[8 * i + j];
-	}
-
-	/* Key Mix */
-	for (j = 0; j < 6; j++) {
-		for (i = 1; i <= num_blocks; i++) {
-			/*phase 1 */
-			NdisMoveMemory(BIN, A, 8);
-			NdisMoveMemory(&BIN[8], &R[8 * i], 8);
-			rt_aes_encrypt(&aesctx, BIN, BOUT);
-
-			NdisMoveMemory(A, &BOUT[0], 8);
-			xor = num_blocks * j + i;
-			A[7] = BOUT[7] ^ xor;
-			NdisMoveMemory(&R[8 * i], &BOUT[8], 8);
-		}
-	}
-
-	/* Output ciphertext */
-	NdisMoveMemory(ciphertext, A, 8);
-
-	for (i = 1; i <= num_blocks; i++) {
-		for (j = 0; j < 8; j++)
-			ciphertext[8 * i + j] = R[8 * i + j];
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Misc function to decrypt AES body
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-		This function references to	RFC	3394 for aes key unwrap algorithm.
-
-	========================================================================
-*/
-void AES_GTK_KEY_UNWRAP(u8 * key,
-			u8 * plaintext,
-			u32 c_len, u8 * ciphertext)
-{
-	u8 A[8], BIN[16], BOUT[16];
-	u8 xor;
-	int i, j;
-	struct aes_context aesctx;
-	u8 *R;
-	int num_blocks = c_len / 8;	/* unit:64bits */
-
-	os_alloc_mem(NULL, (u8 **) & R, 512);
-
-	if (R == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("AES_GTK_KEY_UNWRAP: no memory!\n"));
-		return;
-	}
-	/* End of if */
-	/* Initialize */
-	NdisMoveMemory(A, ciphertext, 8);
-	/*Input plaintext */
-	for (i = 0; i < (c_len - 8); i++) {
-		R[i] = ciphertext[i + 8];
-	}
-
-	rt_aes_set_key(&aesctx, key, 128);
-
-	for (j = 5; j >= 0; j--) {
-		for (i = (num_blocks - 1); i > 0; i--) {
-			xor = (num_blocks - 1) * j + i;
-			NdisMoveMemory(BIN, A, 8);
-			BIN[7] = A[7] ^ xor;
-			NdisMoveMemory(&BIN[8], &R[(i - 1) * 8], 8);
-			rt_aes_decrypt(&aesctx, BIN, BOUT);
-			NdisMoveMemory(A, &BOUT[0], 8);
-			NdisMoveMemory(&R[(i - 1) * 8], &BOUT[8], 8);
-		}
-	}
-
-	/* OUTPUT */
-	for (i = 0; i < c_len; i++) {
-		plaintext[i] = R[i];
-	}
-
-	os_free_mem(NULL, R);
-}
diff --git a/drivers/staging/rt2860/common/cmm_asic.c b/drivers/staging/rt2860/common/cmm_asic.c
deleted file mode 100644
index 4d77e83..0000000
--- a/drivers/staging/rt2860/common/cmm_asic.c
+++ /dev/null
@@ -1,2565 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	cmm_asic.c
-
-	Abstract:
-	Functions used to communicate with ASIC
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-*/
-
-#include "../rt_config.h"
-
-/* Reset the RFIC setting to new series */
-struct rt_rtmp_rf_regs RF2850RegTable[] = {
-/*              ch       R1              R2              R3(TX0~4=0) R4 */
-	{1, 0x98402ecc, 0x984c0786, 0x9816b455, 0x9800510b}
-	,
-	{2, 0x98402ecc, 0x984c0786, 0x98168a55, 0x9800519f}
-	,
-	{3, 0x98402ecc, 0x984c078a, 0x98168a55, 0x9800518b}
-	,
-	{4, 0x98402ecc, 0x984c078a, 0x98168a55, 0x9800519f}
-	,
-	{5, 0x98402ecc, 0x984c078e, 0x98168a55, 0x9800518b}
-	,
-	{6, 0x98402ecc, 0x984c078e, 0x98168a55, 0x9800519f}
-	,
-	{7, 0x98402ecc, 0x984c0792, 0x98168a55, 0x9800518b}
-	,
-	{8, 0x98402ecc, 0x984c0792, 0x98168a55, 0x9800519f}
-	,
-	{9, 0x98402ecc, 0x984c0796, 0x98168a55, 0x9800518b}
-	,
-	{10, 0x98402ecc, 0x984c0796, 0x98168a55, 0x9800519f}
-	,
-	{11, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800518b}
-	,
-	{12, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800519f}
-	,
-	{13, 0x98402ecc, 0x984c079e, 0x98168a55, 0x9800518b}
-	,
-	{14, 0x98402ecc, 0x984c07a2, 0x98168a55, 0x98005193}
-	,
-
-	/* 802.11 UNI / HyperLan 2 */
-	{36, 0x98402ecc, 0x984c099a, 0x98158a55, 0x980ed1a3}
-	,
-	{38, 0x98402ecc, 0x984c099e, 0x98158a55, 0x980ed193}
-	,
-	{40, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed183}
-	,
-	{44, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed1a3}
-	,
-	{46, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed18b}
-	,
-	{48, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed19b}
-	,
-	{52, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed193}
-	,
-	{54, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed1a3}
-	,
-	{56, 0x98402ec8, 0x984c068e, 0x98158a55, 0x980ed18b}
-	,
-	{60, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed183}
-	,
-	{62, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed193}
-	,
-	{64, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed1a3}
-	,			/* Plugfest#4, Day4, change RFR3 left4th 9->5. */
-
-	/* 802.11 HyperLan 2 */
-	{100, 0x98402ec8, 0x984c06b2, 0x98178a55, 0x980ed783}
-	,
-
-	/* 2008.04.30 modified */
-	/* The system team has AN to improve the EVM value */
-	/* for channel 102 to 108 for the RT2850/RT2750 dual band solution. */
-	{102, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed793}
-	,
-	{104, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed1a3}
-	,
-	{108, 0x98402ecc, 0x985c0a32, 0x98578a55, 0x980ed193}
-	,
-
-	{110, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed183}
-	,
-	{112, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed19b}
-	,
-	{116, 0x98402ecc, 0x984c0a3a, 0x98178a55, 0x980ed1a3}
-	,
-	{118, 0x98402ecc, 0x984c0a3e, 0x98178a55, 0x980ed193}
-	,
-	{120, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed183}
-	,
-	{124, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed193}
-	,
-	{126, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed15b}
-	,			/* 0x980ed1bb->0x980ed15b required by Rory 20070927 */
-	{128, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed1a3}
-	,
-	{132, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed18b}
-	,
-	{134, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed193}
-	,
-	{136, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed19b}
-	,
-	{140, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed183}
-	,
-
-	/* 802.11 UNII */
-	{149, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed1a7}
-	,
-	{151, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed187}
-	,
-	{153, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed18f}
-	,
-	{157, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed19f}
-	,
-	{159, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed1a7}
-	,
-	{161, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed187}
-	,
-	{165, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed197}
-	,
-	{167, 0x98402ec4, 0x984c03d2, 0x98179855, 0x9815531f}
-	,
-	{169, 0x98402ec4, 0x984c03d2, 0x98179855, 0x98155327}
-	,
-	{171, 0x98402ec4, 0x984c03d6, 0x98179855, 0x98155307}
-	,
-	{173, 0x98402ec4, 0x984c03d6, 0x98179855, 0x9815530f}
-	,
-
-	/* Japan */
-	{184, 0x95002ccc, 0x9500491e, 0x9509be55, 0x950c0a0b}
-	,
-	{188, 0x95002ccc, 0x95004922, 0x9509be55, 0x950c0a13}
-	,
-	{192, 0x95002ccc, 0x95004926, 0x9509be55, 0x950c0a1b}
-	,
-	{196, 0x95002ccc, 0x9500492a, 0x9509be55, 0x950c0a23}
-	,
-	{208, 0x95002ccc, 0x9500493a, 0x9509be55, 0x950c0a13}
-	,
-	{212, 0x95002ccc, 0x9500493e, 0x9509be55, 0x950c0a1b}
-	,
-	{216, 0x95002ccc, 0x95004982, 0x9509be55, 0x950c0a23}
-	,
-
-	/* still lack of MMAC(Japan) ch 34,38,42,46 */
-};
-
-u8 NUM_OF_2850_CHNL = (sizeof(RF2850RegTable) / sizeof(struct rt_rtmp_rf_regs));
-
-struct rt_frequency_item FreqItems3020[] = {
-	/**************************************************/
-	/* ISM : 2.4 to 2.483 GHz                         // */
-	/**************************************************/
-	/* 11g */
-	/**************************************************/
-	/*-CH---N-------R---K----------- */
-	{1, 241, 2, 2}
-	,
-	{2, 241, 2, 7}
-	,
-	{3, 242, 2, 2}
-	,
-	{4, 242, 2, 7}
-	,
-	{5, 243, 2, 2}
-	,
-	{6, 243, 2, 7}
-	,
-	{7, 244, 2, 2}
-	,
-	{8, 244, 2, 7}
-	,
-	{9, 245, 2, 2}
-	,
-	{10, 245, 2, 7}
-	,
-	{11, 246, 2, 2}
-	,
-	{12, 246, 2, 7}
-	,
-	{13, 247, 2, 2}
-	,
-	{14, 248, 2, 4}
-	,
-};
-
-u8 NUM_OF_3020_CHNL = (sizeof(FreqItems3020) / sizeof(struct rt_frequency_item));
-
-void AsicUpdateAutoFallBackTable(struct rt_rtmp_adapter *pAd, u8 *pRateTable)
-{
-	u8 i;
-	HT_FBK_CFG0_STRUC HtCfg0;
-	HT_FBK_CFG1_STRUC HtCfg1;
-	LG_FBK_CFG0_STRUC LgCfg0;
-	LG_FBK_CFG1_STRUC LgCfg1;
-	struct rt_rtmp_tx_rate_switch *pCurrTxRate, *pNextTxRate;
-
-	/* set to initial value */
-	HtCfg0.word = 0x65432100;
-	HtCfg1.word = 0xedcba988;
-	LgCfg0.word = 0xedcba988;
-	LgCfg1.word = 0x00002100;
-
-	pNextTxRate = (struct rt_rtmp_tx_rate_switch *) pRateTable + 1;
-	for (i = 1; i < *((u8 *)pRateTable); i++) {
-		pCurrTxRate = (struct rt_rtmp_tx_rate_switch *) pRateTable + 1 + i;
-		switch (pCurrTxRate->Mode) {
-		case 0:	/*CCK */
-			break;
-		case 1:	/*OFDM */
-			{
-				switch (pCurrTxRate->CurrMCS) {
-				case 0:
-					LgCfg0.field.OFDMMCS0FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 1:
-					LgCfg0.field.OFDMMCS1FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 2:
-					LgCfg0.field.OFDMMCS2FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 3:
-					LgCfg0.field.OFDMMCS3FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 4:
-					LgCfg0.field.OFDMMCS4FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 5:
-					LgCfg0.field.OFDMMCS5FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 6:
-					LgCfg0.field.OFDMMCS6FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				case 7:
-					LgCfg0.field.OFDMMCS7FBK =
-					    (pNextTxRate->Mode ==
-					     MODE_OFDM) ? (pNextTxRate->
-							   CurrMCS +
-							   8) : pNextTxRate->
-					    CurrMCS;
-					break;
-				}
-			}
-			break;
-		case 2:	/*HT-MIX */
-		case 3:	/*HT-GF */
-			{
-				if ((pNextTxRate->Mode >= MODE_HTMIX)
-				    && (pCurrTxRate->CurrMCS !=
-					pNextTxRate->CurrMCS)) {
-					switch (pCurrTxRate->CurrMCS) {
-					case 0:
-						HtCfg0.field.HTMCS0FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 1:
-						HtCfg0.field.HTMCS1FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 2:
-						HtCfg0.field.HTMCS2FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 3:
-						HtCfg0.field.HTMCS3FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 4:
-						HtCfg0.field.HTMCS4FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 5:
-						HtCfg0.field.HTMCS5FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 6:
-						HtCfg0.field.HTMCS6FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 7:
-						HtCfg0.field.HTMCS7FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 8:
-						HtCfg1.field.HTMCS8FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 9:
-						HtCfg1.field.HTMCS9FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 10:
-						HtCfg1.field.HTMCS10FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 11:
-						HtCfg1.field.HTMCS11FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 12:
-						HtCfg1.field.HTMCS12FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 13:
-						HtCfg1.field.HTMCS13FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 14:
-						HtCfg1.field.HTMCS14FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					case 15:
-						HtCfg1.field.HTMCS15FBK =
-						    pNextTxRate->CurrMCS;
-						break;
-					default:
-						DBGPRINT(RT_DEBUG_ERROR,
-							 ("AsicUpdateAutoFallBackTable: not support CurrMCS=%d\n",
-							  pCurrTxRate->
-							  CurrMCS));
-					}
-				}
-			}
-			break;
-		}
-
-		pNextTxRate = pCurrTxRate;
-	}
-
-	RTMP_IO_WRITE32(pAd, HT_FBK_CFG0, HtCfg0.word);
-	RTMP_IO_WRITE32(pAd, HT_FBK_CFG1, HtCfg1.word);
-	RTMP_IO_WRITE32(pAd, LG_FBK_CFG0, LgCfg0.word);
-	RTMP_IO_WRITE32(pAd, LG_FBK_CFG1, LgCfg1.word);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Set MAC register value according operation mode.
-		OperationMode AND bNonGFExist are for MM and GF Proteciton.
-		If MM or GF mask is not set, those passing argument doesn't not take effect.
-
-		Operation mode meaning:
-		= 0 : Pure HT, no preotection.
-		= 0x01; there may be non-HT devices in both the control and extension channel, protection is optional in BSS.
-		= 0x10: No Transmission in 40M is protected.
-		= 0x11: Transmission in both 40M and 20M shall be protected
-		if (bNonGFExist)
-			we should choose not to use GF. But still set correct ASIC registers.
-	========================================================================
-*/
-void AsicUpdateProtect(struct rt_rtmp_adapter *pAd,
-		       u16 OperationMode,
-		       u8 SetMask,
-		       IN BOOLEAN bDisableBGProtect, IN BOOLEAN bNonGFExist)
-{
-	PROT_CFG_STRUC ProtCfg, ProtCfg4;
-	u32 Protect[6];
-	u16 offset;
-	u8 i;
-	u32 MacReg = 0;
-
-	if (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8)) {
-		return;
-	}
-
-	if (pAd->BATable.numDoneOriginator) {
-		/* */
-		/* enable the RTS/CTS to avoid channel collision */
-		/* */
-		SetMask = ALLN_SETPROTECT;
-		OperationMode = 8;
-	}
-	/* Config ASIC RTS threshold register */
-	RTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);
-	MacReg &= 0xFF0000FF;
-	/* If the user want disable RtsThreshold and enable Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096 */
-	if (((pAd->CommonCfg.BACapability.field.AmsduEnable) ||
-	     (pAd->CommonCfg.bAggregationCapable == TRUE))
-	    && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD) {
-		MacReg |= (0x1000 << 8);
-	} else {
-		MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
-	}
-
-	RTMP_IO_WRITE32(pAd, TX_RTS_CFG, MacReg);
-
-	/* Initial common protection settings */
-	RTMPZeroMemory(Protect, sizeof(Protect));
-	ProtCfg4.word = 0;
-	ProtCfg.word = 0;
-	ProtCfg.field.TxopAllowGF40 = 1;
-	ProtCfg.field.TxopAllowGF20 = 1;
-	ProtCfg.field.TxopAllowMM40 = 1;
-	ProtCfg.field.TxopAllowMM20 = 1;
-	ProtCfg.field.TxopAllowOfdm = 1;
-	ProtCfg.field.TxopAllowCck = 1;
-	ProtCfg.field.RTSThEn = 1;
-	ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-
-	/* update PHY mode and rate */
-	if (pAd->CommonCfg.Channel > 14)
-		ProtCfg.field.ProtectRate = 0x4000;
-	ProtCfg.field.ProtectRate |= pAd->CommonCfg.RtsRate;
-
-	/* Handle legacy(B/G) protection */
-	if (bDisableBGProtect) {
-		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate; */
-		ProtCfg.field.ProtectCtrl = 0;
-		Protect[0] = ProtCfg.word;
-		Protect[1] = ProtCfg.word;
-		pAd->FlgCtsEnabled = 0;	/* CTS-self is not used */
-	} else {
-		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate; */
-		ProtCfg.field.ProtectCtrl = 0;	/* CCK do not need to be protected */
-		Protect[0] = ProtCfg.word;
-		ProtCfg.field.ProtectCtrl = ASIC_CTS;	/* OFDM needs using CCK to protect */
-		Protect[1] = ProtCfg.word;
-		pAd->FlgCtsEnabled = 1;	/* CTS-self is used */
-	}
-
-	/* Decide HT frame protection. */
-	if ((SetMask & ALLN_SETPROTECT) != 0) {
-		switch (OperationMode) {
-		case 0x0:
-			/* NO PROTECT */
-			/* 1.All STAs in the BSS are 20/40 MHz HT */
-			/* 2. in ai 20/40MHz BSS */
-			/* 3. all STAs are 20MHz in a 20MHz BSS */
-			/* Pure HT. no protection. */
-
-			/* MM20_PROT_CFG */
-			/*      Reserved (31:27) */
-			/*      PROT_TXOP(25:20) -- 010111 */
-			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
-			/*  PROT_CTRL(17:16) -- 00 (None) */
-			/*      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M) */
-			Protect[2] = 0x01744004;
-
-			/* MM40_PROT_CFG */
-			/*      Reserved (31:27) */
-			/*      PROT_TXOP(25:20) -- 111111 */
-			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
-			/*  PROT_CTRL(17:16) -- 00 (None) */
-			/*      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M) */
-			Protect[3] = 0x03f44084;
-
-			/* CF20_PROT_CFG */
-			/*      Reserved (31:27) */
-			/*      PROT_TXOP(25:20) -- 010111 */
-			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
-			/*  PROT_CTRL(17:16) -- 00 (None) */
-			/*      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M) */
-			Protect[4] = 0x01744004;
-
-			/* CF40_PROT_CFG */
-			/*      Reserved (31:27) */
-			/*      PROT_TXOP(25:20) -- 111111 */
-			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
-			/*  PROT_CTRL(17:16) -- 00 (None) */
-			/*      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M) */
-			Protect[5] = 0x03f44084;
-
-			if (bNonGFExist) {
-				/* PROT_NAV(19:18)  -- 01 (Short NAV protectiion) */
-				/* PROT_CTRL(17:16) -- 01 (RTS/CTS) */
-				Protect[4] = 0x01754004;
-				Protect[5] = 0x03f54084;
-			}
-			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
-			break;
-
-		case 1:
-			/* This is "HT non-member protection mode." */
-			/* If there may be non-HT STAs my BSS */
-			ProtCfg.word = 0x01744004;	/* PROT_CTRL(17:16) : 0 (None) */
-			ProtCfg4.word = 0x03f44084;	/* duplicaet legacy 24M. BW set 1. */
-			if (OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
-				ProtCfg.word = 0x01740003;	/*ERP use Protection bit is set, use protection rate at Clause 18.. */
-				ProtCfg4.word = 0x03f40003;	/* Don't duplicate RTS/CTS in CCK mode. 0x03f40083; */
-			}
-			/*Assign Protection method for 20&40 MHz packets */
-			ProtCfg.field.ProtectCtrl = ASIC_RTS;
-			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-			Protect[2] = ProtCfg.word;
-			Protect[3] = ProtCfg4.word;
-			Protect[4] = ProtCfg.word;
-			Protect[5] = ProtCfg4.word;
-			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-			break;
-
-		case 2:
-			/* If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets */
-			ProtCfg.word = 0x01744004;	/* PROT_CTRL(17:16) : 0 (None) */
-			ProtCfg4.word = 0x03f44084;	/* duplicaet legacy 24M. BW set 1. */
-
-			/*Assign Protection method for 40MHz packets */
-			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-			Protect[2] = ProtCfg.word;
-			Protect[3] = ProtCfg4.word;
-			if (bNonGFExist) {
-				ProtCfg.field.ProtectCtrl = ASIC_RTS;
-				ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-			}
-			Protect[4] = ProtCfg.word;
-			Protect[5] = ProtCfg4.word;
-
-			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
-			break;
-
-		case 3:
-			/* HT mixed mode.        PROTECT ALL! */
-			/* Assign Rate */
-			ProtCfg.word = 0x01744004;	/*duplicaet legacy 24M. BW set 1. */
-			ProtCfg4.word = 0x03f44084;
-			/* both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the */
-			if (OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
-				ProtCfg.word = 0x01740003;	/*ERP use Protection bit is set, use protection rate at Clause 18.. */
-				ProtCfg4.word = 0x03f40003;	/* Don't duplicate RTS/CTS in CCK mode. 0x03f40083 */
-			}
-			/*Assign Protection method for 20&40 MHz packets */
-			ProtCfg.field.ProtectCtrl = ASIC_RTS;
-			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-			Protect[2] = ProtCfg.word;
-			Protect[3] = ProtCfg4.word;
-			Protect[4] = ProtCfg.word;
-			Protect[5] = ProtCfg4.word;
-			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-			break;
-
-		case 8:
-			/* Special on for Atheros problem n chip. */
-			Protect[2] = 0x01754004;
-			Protect[3] = 0x03f54084;
-			Protect[4] = 0x01754004;
-			Protect[5] = 0x03f54084;
-			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-			break;
-		}
-	}
-
-	offset = CCK_PROT_CFG;
-	for (i = 0; i < 6; i++) {
-		if ((SetMask & (1 << i))) {
-			RTMP_IO_WRITE32(pAd, offset + i * 4, Protect[i]);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicSwitchChannel(struct rt_rtmp_adapter *pAd, u8 Channel, IN BOOLEAN bScan)
-{
-	unsigned long R2 = 0, R3 = DEFAULT_RF_TX_POWER, R4 = 0;
-	char TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER;	/*Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER; */
-	u8 index;
-	u32 Value = 0;	/*BbpReg, Value; */
-	struct rt_rtmp_rf_regs *RFRegTable;
-	u8 RFValue;
-
-	RFValue = 0;
-	/* Search Tx power value */
-	/* We can't use ChannelList to search channel, since some central channl's txpowr doesn't list */
-	/* in ChannelList, so use TxPower array instead. */
-	/* */
-	for (index = 0; index < MAX_NUM_OF_CHANNELS; index++) {
-		if (Channel == pAd->TxPower[index].Channel) {
-			TxPwer = pAd->TxPower[index].Power;
-			TxPwer2 = pAd->TxPower[index].Power2;
-			break;
-		}
-	}
-
-	if (index == MAX_NUM_OF_CHANNELS) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("AsicSwitchChannel: Can't find the Channel#%d \n",
-			  Channel));
-	}
-#ifdef RT30xx
-	/* The RF programming sequence is difference between 3xxx and 2xxx */
-	if ((IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3390(pAd))
-	    && ((pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020)
-		|| (pAd->RfIcType == RFIC_3021)
-		|| (pAd->RfIcType == RFIC_3022))) {
-		/* modify by WY for Read RF Reg. error */
-
-		for (index = 0; index < NUM_OF_3020_CHNL; index++) {
-			if (Channel == FreqItems3020[index].Channel) {
-				/* Programming channel parameters */
-				RT30xxWriteRFRegister(pAd, RF_R02,
-						      FreqItems3020[index].N);
-				RT30xxWriteRFRegister(pAd, RF_R03,
-						      FreqItems3020[index].K);
-				RT30xxReadRFRegister(pAd, RF_R06, &RFValue);
-				RFValue =
-				    (RFValue & 0xFC) | FreqItems3020[index].R;
-				RT30xxWriteRFRegister(pAd, RF_R06, RFValue);
-
-				/* Set Tx0 Power */
-				RT30xxReadRFRegister(pAd, RF_R12, &RFValue);
-				RFValue = (RFValue & 0xE0) | TxPwer;
-				RT30xxWriteRFRegister(pAd, RF_R12, RFValue);
-
-				/* Set Tx1 Power */
-				RT30xxReadRFRegister(pAd, RF_R13, &RFValue);
-				RFValue = (RFValue & 0xE0) | TxPwer2;
-				RT30xxWriteRFRegister(pAd, RF_R13, RFValue);
-
-				/* Tx/Rx Stream setting */
-				RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
-				/*if (IS_RT3090(pAd)) */
-				/*      RFValue |= 0x01; // Enable RF block. */
-				RFValue &= 0x03;	/*clear bit[7~2] */
-				if (pAd->Antenna.field.TxPath == 1)
-					RFValue |= 0xA0;
-				else if (pAd->Antenna.field.TxPath == 2)
-					RFValue |= 0x80;
-				if (pAd->Antenna.field.RxPath == 1)
-					RFValue |= 0x50;
-				else if (pAd->Antenna.field.RxPath == 2)
-					RFValue |= 0x40;
-				RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
-
-				/* Set RF offset */
-				RT30xxReadRFRegister(pAd, RF_R23, &RFValue);
-				RFValue = (RFValue & 0x80) | pAd->RfFreqOffset;
-				RT30xxWriteRFRegister(pAd, RF_R23, RFValue);
-
-				/* Set BW */
-				if (!bScan
-				    && (pAd->CommonCfg.BBPCurrentBW == BW_40)) {
-					RFValue = pAd->Mlme.CaliBW40RfR24;
-					/*DISABLE_11N_CHECK(pAd); */
-				} else {
-					RFValue = pAd->Mlme.CaliBW20RfR24;
-				}
-				RT30xxWriteRFRegister(pAd, RF_R24, RFValue);
-				RT30xxWriteRFRegister(pAd, RF_R31, RFValue);
-
-				/* Enable RF tuning */
-				RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
-				RFValue = RFValue | 0x1;
-				RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
-
-				/* latch channel for future usage. */
-				pAd->LatchRfRegs.Channel = Channel;
-
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("SwitchChannel#%d(RF=%d, Pwr0=%d, Pwr1=%d, %dT), N=0x%02X, K=0x%02X, R=0x%02X\n",
-					  Channel, pAd->RfIcType, TxPwer,
-					  TxPwer2, pAd->Antenna.field.TxPath,
-					  FreqItems3020[index].N,
-					  FreqItems3020[index].K,
-					  FreqItems3020[index].R));
-
-				break;
-			}
-		}
-	} else
-#endif /* RT30xx // */
-	{
-		RFRegTable = RF2850RegTable;
-		switch (pAd->RfIcType) {
-		case RFIC_2820:
-		case RFIC_2850:
-		case RFIC_2720:
-		case RFIC_2750:
-
-			for (index = 0; index < NUM_OF_2850_CHNL; index++) {
-				if (Channel == RFRegTable[index].Channel) {
-					R2 = RFRegTable[index].R2;
-					if (pAd->Antenna.field.TxPath == 1) {
-						R2 |= 0x4000;	/* If TXpath is 1, bit 14 = 1; */
-					}
-
-					if (pAd->Antenna.field.RxPath == 2) {
-						R2 |= 0x40;	/* write 1 to off Rxpath. */
-					} else if (pAd->Antenna.field.RxPath ==
-						   1) {
-						R2 |= 0x20040;	/* write 1 to off RxPath */
-					}
-
-					if (Channel > 14) {
-						/* initialize R3, R4 */
-						R3 = (RFRegTable[index].
-						      R3 & 0xffffc1ff);
-						R4 = (RFRegTable[index].
-						      R4 & (~0x001f87c0)) |
-						    (pAd->RfFreqOffset << 15);
-
-						/* 5G band power range: 0xF9~0X0F, TX0 Reg3 bit9/TX1 Reg4 bit6="0" means the TX power reduce 7dB */
-						/* R3 */
-						if ((TxPwer >= -7)
-						    && (TxPwer < 0)) {
-							TxPwer = (7 + TxPwer);
-							TxPwer =
-							    (TxPwer >
-							     0xF) ? (0xF)
-							    : (TxPwer);
-							R3 |= (TxPwer << 10);
-							DBGPRINT(RT_DEBUG_ERROR,
-								 ("AsicSwitchChannel: TxPwer=%d \n",
-								  TxPwer));
-						} else {
-							TxPwer =
-							    (TxPwer >
-							     0xF) ? (0xF)
-							    : (TxPwer);
-							R3 |=
-							    (TxPwer << 10) | (1
-									      <<
-									      9);
-						}
-
-						/* R4 */
-						if ((TxPwer2 >= -7)
-						    && (TxPwer2 < 0)) {
-							TxPwer2 = (7 + TxPwer2);
-							TxPwer2 =
-							    (TxPwer2 >
-							     0xF) ? (0xF)
-							    : (TxPwer2);
-							R4 |= (TxPwer2 << 7);
-							DBGPRINT(RT_DEBUG_ERROR,
-								 ("AsicSwitchChannel: TxPwer2=%d \n",
-								  TxPwer2));
-						} else {
-							TxPwer2 =
-							    (TxPwer2 >
-							     0xF) ? (0xF)
-							    : (TxPwer2);
-							R4 |=
-							    (TxPwer2 << 7) | (1
-									      <<
-									      6);
-						}
-					} else {
-						R3 = (RFRegTable[index].R3 & 0xffffc1ff) | (TxPwer << 9);	/* set TX power0 */
-						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 << 6);	/* Set freq Offset & TxPwr1 */
-					}
-
-					/* Based on BBP current mode before changing RF channel. */
-					if (!bScan
-					    && (pAd->CommonCfg.BBPCurrentBW ==
-						BW_40)) {
-						R4 |= 0x200000;
-					}
-					/* Update variables */
-					pAd->LatchRfRegs.Channel = Channel;
-					pAd->LatchRfRegs.R1 =
-					    RFRegTable[index].R1;
-					pAd->LatchRfRegs.R2 = R2;
-					pAd->LatchRfRegs.R3 = R3;
-					pAd->LatchRfRegs.R4 = R4;
-
-					/* Set RF value 1's set R3[bit2] = [0] */
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R1);
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R2);
-					RTMP_RF_IO_WRITE32(pAd,
-							   (pAd->LatchRfRegs.
-							    R3 & (~0x04)));
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R4);
-
-					RTMPusecDelay(200);
-
-					/* Set RF value 2's set R3[bit2] = [1] */
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R1);
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R2);
-					RTMP_RF_IO_WRITE32(pAd,
-							   (pAd->LatchRfRegs.
-							    R3 | 0x04));
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R4);
-
-					RTMPusecDelay(200);
-
-					/* Set RF value 3's set R3[bit2] = [0] */
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R1);
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R2);
-					RTMP_RF_IO_WRITE32(pAd,
-							   (pAd->LatchRfRegs.
-							    R3 & (~0x04)));
-					RTMP_RF_IO_WRITE32(pAd,
-							   pAd->LatchRfRegs.R4);
-
-					break;
-				}
-			}
-			break;
-
-		default:
-			break;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("SwitchChannel#%d(RF=%d, Pwr0=%lu, Pwr1=%lu, %dT) to , R1=0x%08lx, R2=0x%08lx, R3=0x%08lx, R4=0x%08lx\n",
-			  Channel, pAd->RfIcType, (R3 & 0x00003e00) >> 9,
-			  (R4 & 0x000007c0) >> 6, pAd->Antenna.field.TxPath,
-			  pAd->LatchRfRegs.R1, pAd->LatchRfRegs.R2,
-			  pAd->LatchRfRegs.R3, pAd->LatchRfRegs.R4));
-	}
-
-	/* Change BBP setting during siwtch from a->g, g->a */
-	if (Channel <= 14) {
-		unsigned long TxPinCfg = 0x00050F0A;	/*Gary 2007/08/09 0x050A0A */
-
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	/*(0x44 - GET_LNA_GAIN(pAd)));    // According the Rory's suggestion to solve the middle range issue. */
-		/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62); */
-
-		/* Rx High power VGA offset for LNA select */
-		if (pAd->NicConfig2.field.ExternalLNAForG) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
-		} else {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x84);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
-		}
-
-		/* 5G band selection PIN, bit1 and bit2 are complement */
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
-		Value &= (~0x6);
-		Value |= (0x04);
-		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
-
-		/* Turn off unused PA or LNA when only 1T or 1R */
-		if (pAd->Antenna.field.TxPath == 1) {
-			TxPinCfg &= 0xFFFFFFF3;
-		}
-		if (pAd->Antenna.field.RxPath == 1) {
-			TxPinCfg &= 0xFFFFF3FF;
-		}
-
-		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
-
-#if defined(RT3090) || defined(RT3390)
-		/* PCIe PHY Transmit attenuation adjustment */
-		if (IS_RT3090A(pAd) || IS_RT3390(pAd)) {
-			TX_ATTENUATION_CTRL_STRUC TxAttenuationCtrl = {
-			.word = 0};
-
-			RTMP_IO_READ32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
-				       &TxAttenuationCtrl.word);
-
-			if (Channel == 14)	/* Channel #14 */
-			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 1;	/* Enable PCIe PHY Tx attenuation */
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 4;	/* 9/16 full drive level */
-			} else	/* Channel #1~#13 */
-			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 0;	/* Disable PCIe PHY Tx attenuation */
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 0;	/* n/a */
-			}
-
-			RTMP_IO_WRITE32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
-					TxAttenuationCtrl.word);
-		}
-#endif
-	} else {
-		unsigned long TxPinCfg = 0x00050F05;	/*Gary 2007/8/9 0x050505 */
-
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
-					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	/*(0x44 - GET_LNA_GAIN(pAd)));   // According the Rory's suggestion to solve the middle range issue. */
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0xF2);
-
-		/* Rx High power VGA offset for LNA select */
-		if (pAd->NicConfig2.field.ExternalLNAForA) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
-		} else {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
-		}
-
-		/* 5G band selection PIN, bit1 and bit2 are complement */
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
-		Value &= (~0x6);
-		Value |= (0x02);
-		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
-
-		/* Turn off unused PA or LNA when only 1T or 1R */
-		if (pAd->Antenna.field.TxPath == 1) {
-			TxPinCfg &= 0xFFFFFFF3;
-		}
-		if (pAd->Antenna.field.RxPath == 1) {
-			TxPinCfg &= 0xFFFFF3FF;
-		}
-
-		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
-
-	}
-
-	/* R66 should be set according to Channel and use 20MHz when scanning */
-	/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x2E + GET_LNA_GAIN(pAd))); */
-	if (bScan)
-		RTMPSetAGCInitValue(pAd, BW_20);
-	else
-		RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
-
-	/* */
-	/* On 11A, We should delay and wait RF/BBP to be stable */
-	/* and the appropriate time should be 1000 micro seconds */
-	/* 2005/06/05 - On 11G, We also need this delay time. Otherwise it's difficult to pass the WHQL. */
-	/* */
-	RTMPusecDelay(1000);
-}
-
-void AsicResetBBPAgent(struct rt_rtmp_adapter *pAd)
-{
-	BBP_CSR_CFG_STRUC BbpCsr;
-	DBGPRINT(RT_DEBUG_ERROR, ("Reset BBP Agent busy bit!\n"));
-	/* Still need to find why BBP agent keeps busy, but in fact, hardware still function ok. Now clear busy first. */
-	RTMP_IO_READ32(pAd, H2M_BBP_AGENT, &BbpCsr.word);
-	BbpCsr.field.Busy = 0;
-	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, BbpCsr.word);
-}
-
-/*
-	==========================================================================
-	Description:
-		This function is required for 2421 only, and should not be used during
-		site survey. It's only required after NIC decided to stay at a channel
-		for a longer period.
-		When this function is called, it's always after AsicSwitchChannel().
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicLockChannel(struct rt_rtmp_adapter *pAd, u8 Channel)
-{
-}
-
-void AsicRfTuningExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3)
-{
-}
-
-/*
-	==========================================================================
-	Description:
-		Gives CCK TX rate 2 more dB TX power.
-		This routine works only in LINK UP in INFRASTRUCTURE mode.
-
-		calculate desired Tx power in RF R3.Tx0~5,	should consider -
-		0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)
-		1. TxPowerPercentage
-		2. auto calibration based on TSSI feedback
-		3. extra 2 db for CCK
-		4. -10 db upon very-short distance (AvgRSSI >= -40db) to AP
-
-	NOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),
-		it should be called AFTER MlmeDynamicTxRatSwitching()
-	==========================================================================
- */
-void AsicAdjustTxPower(struct rt_rtmp_adapter *pAd)
-{
-	int i, j;
-	char DeltaPwr = 0;
-	BOOLEAN bAutoTxAgc = FALSE;
-	u8 TssiRef, *pTssiMinusBoundary, *pTssiPlusBoundary, TxAgcStep;
-	u8 BbpR1 = 0, BbpR49 = 0, idx;
-	char *pTxAgcCompensate;
-	unsigned long TxPwr[5];
-	char Value;
-	char Rssi = -127;
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) ||
-#ifdef RTMP_MAC_PCI
-	    (pAd->bPCIclkOff == TRUE) ||
-#endif /* RTMP_MAC_PCI // */
-	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF) ||
-	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		return;
-
-	Rssi = RTMPMaxRssi(pAd,
-			   pAd->StaCfg.RssiSample.AvgRssi0,
-			   pAd->StaCfg.RssiSample.AvgRssi1,
-			   pAd->StaCfg.RssiSample.AvgRssi2);
-
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
-		if (pAd->CommonCfg.CentralChannel > 14) {
-			TxPwr[0] = pAd->Tx40MPwrCfgABand[0];
-			TxPwr[1] = pAd->Tx40MPwrCfgABand[1];
-			TxPwr[2] = pAd->Tx40MPwrCfgABand[2];
-			TxPwr[3] = pAd->Tx40MPwrCfgABand[3];
-			TxPwr[4] = pAd->Tx40MPwrCfgABand[4];
-		} else {
-			TxPwr[0] = pAd->Tx40MPwrCfgGBand[0];
-			TxPwr[1] = pAd->Tx40MPwrCfgGBand[1];
-			TxPwr[2] = pAd->Tx40MPwrCfgGBand[2];
-			TxPwr[3] = pAd->Tx40MPwrCfgGBand[3];
-			TxPwr[4] = pAd->Tx40MPwrCfgGBand[4];
-		}
-	} else {
-		if (pAd->CommonCfg.Channel > 14) {
-			TxPwr[0] = pAd->Tx20MPwrCfgABand[0];
-			TxPwr[1] = pAd->Tx20MPwrCfgABand[1];
-			TxPwr[2] = pAd->Tx20MPwrCfgABand[2];
-			TxPwr[3] = pAd->Tx20MPwrCfgABand[3];
-			TxPwr[4] = pAd->Tx20MPwrCfgABand[4];
-		} else {
-			TxPwr[0] = pAd->Tx20MPwrCfgGBand[0];
-			TxPwr[1] = pAd->Tx20MPwrCfgGBand[1];
-			TxPwr[2] = pAd->Tx20MPwrCfgGBand[2];
-			TxPwr[3] = pAd->Tx20MPwrCfgGBand[3];
-			TxPwr[4] = pAd->Tx20MPwrCfgGBand[4];
-		}
-	}
-
-	/* TX power compensation for temperature variation based on TSSI. try every 4 second */
-	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0) {
-		if (pAd->CommonCfg.Channel <= 14) {
-			/* bg channel */
-			bAutoTxAgc = pAd->bAutoTxAgcG;
-			TssiRef = pAd->TssiRefG;
-			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
-			pTssiPlusBoundary = &pAd->TssiPlusBoundaryG[0];
-			TxAgcStep = pAd->TxAgcStepG;
-			pTxAgcCompensate = &pAd->TxAgcCompensateG;
-		} else {
-			/* a channel */
-			bAutoTxAgc = pAd->bAutoTxAgcA;
-			TssiRef = pAd->TssiRefA;
-			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
-			pTssiPlusBoundary = &pAd->TssiPlusBoundaryA[0];
-			TxAgcStep = pAd->TxAgcStepA;
-			pTxAgcCompensate = &pAd->TxAgcCompensateA;
-		}
-
-		if (bAutoTxAgc) {
-			/* BbpR1 is unsigned char */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R49, &BbpR49);
-
-			/* (p) TssiPlusBoundaryG[0] = 0 = (m) TssiMinusBoundaryG[0] */
-			/* compensate: +4     +3   +2   +1    0   -1   -2   -3   -4 * steps */
-			/* step value is defined in pAd->TxAgcStepG for tx power value */
-
-			/* [4]+1+[4]   p4     p3   p2   p1   o1   m1   m2   m3   m4 */
-			/* ex:         0x00 0x15 0x25 0x45 0x88 0xA0 0xB5 0xD0 0xF0
-			   above value are examined in mass factory production */
-			/*             [4]    [3]  [2]  [1]  [0]  [1]  [2]  [3]  [4] */
-
-			/* plus (+) is 0x00 ~ 0x45, minus (-) is 0xa0 ~ 0xf0 */
-			/* if value is between p1 ~ o1 or o1 ~ s1, no need to adjust tx power */
-			/* if value is 0xa5, tx power will be -= TxAgcStep*(2-1) */
-
-			if (BbpR49 > pTssiMinusBoundary[1]) {
-				/* Reading is larger than the reference value */
-				/* check for how large we need to decrease the Tx power */
-				for (idx = 1; idx < 5; idx++) {
-					if (BbpR49 <= pTssiMinusBoundary[idx])	/* Found the range */
-						break;
-				}
-				/* The index is the step we should decrease, idx = 0 means there is nothing to compensate */
-/*                              if (R3 > (unsigned long)(TxAgcStep * (idx-1))) */
-				*pTxAgcCompensate = -(TxAgcStep * (idx - 1));
-/*                              else */
-/*                                      *pTxAgcCompensate = -((u8)R3); */
-
-				DeltaPwr += (*pTxAgcCompensate);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
-					  BbpR49, TssiRef, TxAgcStep, idx - 1));
-			} else if (BbpR49 < pTssiPlusBoundary[1]) {
-				/* Reading is smaller than the reference value */
-				/* check for how large we need to increase the Tx power */
-				for (idx = 1; idx < 5; idx++) {
-					if (BbpR49 >= pTssiPlusBoundary[idx])	/* Found the range */
-						break;
-				}
-				/* The index is the step we should increase, idx = 0 means there is nothing to compensate */
-				*pTxAgcCompensate = TxAgcStep * (idx - 1);
-				DeltaPwr += (*pTxAgcCompensate);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("++ Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
-					  BbpR49, TssiRef, TxAgcStep, idx - 1));
-			} else {
-				*pTxAgcCompensate = 0;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("   Tx Power, BBP R49=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
-					  BbpR49, TssiRef, TxAgcStep, 0));
-			}
-		}
-	} else {
-		if (pAd->CommonCfg.Channel <= 14) {
-			bAutoTxAgc = pAd->bAutoTxAgcG;
-			pTxAgcCompensate = &pAd->TxAgcCompensateG;
-		} else {
-			bAutoTxAgc = pAd->bAutoTxAgcA;
-			pTxAgcCompensate = &pAd->TxAgcCompensateA;
-		}
-
-		if (bAutoTxAgc)
-			DeltaPwr += (*pTxAgcCompensate);
-	}
-
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BbpR1);
-	BbpR1 &= 0xFC;
-
-	/* calculate delta power based on the percentage specified from UI */
-	/* E2PROM setting is calibrated for maximum TX power (i.e. 100%) */
-	/* We lower TX power here according to the percentage specified from UI */
-	if (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)	/* AUTO TX POWER control */
-	{
-		{
-			/* to patch high power issue with some APs, like Belkin N1. */
-			if (Rssi > -35) {
-				BbpR1 |= 0x02;	/* DeltaPwr -= 12; */
-			} else if (Rssi > -40) {
-				BbpR1 |= 0x01;	/* DeltaPwr -= 6; */
-			} else;
-		}
-	} else if (pAd->CommonCfg.TxPowerPercentage > 90)	/* 91 ~ 100% & AUTO, treat as 100% in terms of mW */
-		;
-	else if (pAd->CommonCfg.TxPowerPercentage > 60)	/* 61 ~ 90%, treat as 75% in terms of mW               // DeltaPwr -= 1; */
-	{
-		DeltaPwr -= 1;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 30)	/* 31 ~ 60%, treat as 50% in terms of mW               // DeltaPwr -= 3; */
-	{
-		DeltaPwr -= 3;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 15)	/* 16 ~ 30%, treat as 25% in terms of mW               // DeltaPwr -= 6; */
-	{
-		BbpR1 |= 0x01;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 9)	/* 10 ~ 15%, treat as 12.5% in terms of mW             // DeltaPwr -= 9; */
-	{
-		BbpR1 |= 0x01;
-		DeltaPwr -= 3;
-	} else			/* 0 ~ 9 %, treat as MIN(~3%) in terms of mW             // DeltaPwr -= 12; */
-	{
-		BbpR1 |= 0x02;
-	}
-
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, BbpR1);
-
-	/* reset different new tx power for different TX rate */
-	for (i = 0; i < 5; i++) {
-		if (TxPwr[i] != 0xffffffff) {
-			for (j = 0; j < 8; j++) {
-				Value = (char)((TxPwr[i] >> j * 4) & 0x0F);	/* 0 ~ 15 */
-
-				if ((Value + DeltaPwr) < 0) {
-					Value = 0;	/* min */
-				} else if ((Value + DeltaPwr) > 0xF) {
-					Value = 0xF;	/* max */
-				} else {
-					Value += DeltaPwr;	/* temperature compensation */
-				}
-
-				/* fill new value to CSR offset */
-				TxPwr[i] =
-				    (TxPwr[i] & ~(0x0000000F << j * 4)) | (Value
-									   << j
-									   * 4);
-			}
-
-			/* write tx power value to CSR */
-			/* TX_PWR_CFG_0 (8 tx rate) for TX power for OFDM 12M/18M
-			   TX power for OFDM 6M/9M
-			   TX power for CCK5.5M/11M
-			   TX power for CCK1M/2M */
-			/* TX_PWR_CFG_1 ~ TX_PWR_CFG_4 */
-			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i * 4, TxPwr[i]);
-		}
-	}
-
-}
-
-/*
-	==========================================================================
-	Description:
-		put PHY to sleep here, and set next wakeup timer. PHY doesn't not wakeup
-		automatically. Instead, MCU will issue a TwakeUpInterrupt to host after
-		the wakeup timer timeout. Driver has to issue a separate command to wake
-		PHY up.
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-			     u16 TbttNumToNextWakeUp)
-{
-	RTMP_STA_SLEEP_THEN_AUTO_WAKEUP(pAd, TbttNumToNextWakeUp);
-}
-
-/*
-	==========================================================================
-	Description:
-		AsicForceWakeup() is used whenever manual wakeup is required
-		AsicForceSleep() should only be used when not in INFRA BSS. When
-		in INFRA BSS, we should use AsicSleepThenAutoWakeup() instead.
-	==========================================================================
- */
-void AsicForceSleep(struct rt_rtmp_adapter *pAd)
-{
-
-}
-
-/*
-	==========================================================================
-	Description:
-		AsicForceWakeup() is used whenever Twakeup timer (set via AsicSleepThenAutoWakeup)
-		expired.
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-	==========================================================================
- */
-void AsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx)
-{
-	DBGPRINT(RT_DEBUG_INFO, ("--> AsicForceWakeup \n"));
-	RTMP_STA_FORCE_WAKEUP(pAd, bFromTx);
-}
-
-/*
-	==========================================================================
-	Description:
-		Set My BSSID
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicSetBssid(struct rt_rtmp_adapter *pAd, u8 *pBssid)
-{
-	unsigned long Addr4;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==============> AsicSetBssid %x:%x:%x:%x:%x:%x\n", pBssid[0],
-		  pBssid[1], pBssid[2], pBssid[3], pBssid[4], pBssid[5]));
-
-	Addr4 = (unsigned long)(pBssid[0]) |
-	    (unsigned long)(pBssid[1] << 8) |
-	    (unsigned long)(pBssid[2] << 16) | (unsigned long)(pBssid[3] << 24);
-	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW0, Addr4);
-
-	Addr4 = 0;
-	/* always one BSSID in STA mode */
-	Addr4 = (unsigned long)(pBssid[4]) | (unsigned long)(pBssid[5] << 8);
-
-	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW1, Addr4);
-}
-
-void AsicSetMcastWC(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_mac_table_entry *pEntry = &pAd->MacTab.Content[MCAST_WCID];
-	u16 offset;
-
-	pEntry->Sst = SST_ASSOC;
-	pEntry->Aid = MCAST_WCID;	/* Softap supports 1 BSSID and use WCID=0 as multicast Wcid index */
-	pEntry->PsMode = PWR_ACTIVE;
-	pEntry->CurrTxRate = pAd->CommonCfg.MlmeRate;
-	offset = MAC_WCID_BASE + BSS0Mcast_WCID * HW_WCID_ENTRY_SIZE;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicDelWcidTab(struct rt_rtmp_adapter *pAd, u8 Wcid)
-{
-	unsigned long Addr0 = 0x0, Addr1 = 0x0;
-	unsigned long offset;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("AsicDelWcidTab==>Wcid = 0x%x\n", Wcid));
-	offset = MAC_WCID_BASE + Wcid * HW_WCID_ENTRY_SIZE;
-	RTMP_IO_WRITE32(pAd, offset, Addr0);
-	offset += 4;
-	RTMP_IO_WRITE32(pAd, offset, Addr1);
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicEnableRDG(struct rt_rtmp_adapter *pAd)
-{
-	TX_LINK_CFG_STRUC TxLinkCfg;
-	u32 Data = 0;
-
-	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
-	TxLinkCfg.field.TxRDGEn = 1;
-	RTMP_IO_WRITE32(pAd, TX_LINK_CFG, TxLinkCfg.word);
-
-	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-	Data &= 0xFFFFFF00;
-	Data |= 0x80;
-	RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
-
-	/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED); */
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicDisableRDG(struct rt_rtmp_adapter *pAd)
-{
-	TX_LINK_CFG_STRUC TxLinkCfg;
-	u32 Data = 0;
-
-	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
-	TxLinkCfg.field.TxRDGEn = 0;
-	RTMP_IO_WRITE32(pAd, TX_LINK_CFG, TxLinkCfg.word);
-
-	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-
-	Data &= 0xFFFFFF00;
-	/*Data  |= 0x20; */
-#ifndef WIFI_TEST
-	/*if ( pAd->CommonCfg.bEnableTxBurst ) */
-	/*      Data |= 0x60; // for performance issue not set the TXOP to 0 */
-#endif
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
-	    && (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
-	    ) {
-		/* For CWC test, change txop from 0x30 to 0x20 in TxBurst mode */
-		if (pAd->CommonCfg.bEnableTxBurst)
-			Data |= 0x20;
-	}
-	RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicDisableSync(struct rt_rtmp_adapter *pAd)
-{
-	BCN_TIME_CFG_STRUC csr;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--->Disable TSF synchronization\n"));
-
-	/* 2003-12-20 disable TSF and TBTT while NIC in power-saving have side effect */
-	/*                        that NIC will never wakes up because TSF stops and no more */
-	/*                        TBTT interrupts */
-	pAd->TbttTickCount = 0;
-	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-	csr.field.bBeaconGen = 0;
-	csr.field.bTBTTEnable = 0;
-	csr.field.TsfSyncMode = 0;
-	csr.field.bTsfTicking = 0;
-	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
-
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicEnableBssSync(struct rt_rtmp_adapter *pAd)
-{
-	BCN_TIME_CFG_STRUC csr;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableBssSync(INFRA mode)\n"));
-
-	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-/*      RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000); */
-	{
-		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	/* ASIC register in units of 1/16 TU */
-		csr.field.bTsfTicking = 1;
-		csr.field.TsfSyncMode = 1;	/* sync TSF in INFRASTRUCTURE mode */
-		csr.field.bBeaconGen = 0;	/* do NOT generate BEACON */
-		csr.field.bTBTTEnable = 1;
-	}
-	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
-}
-
-/*
-	==========================================================================
-	Description:
-	Note:
-		BEACON frame in shared memory should be built ok before this routine
-		can be called. Otherwise, a garbage frame maybe transmitted out every
-		Beacon period.
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicEnableIbssSync(struct rt_rtmp_adapter *pAd)
-{
-	BCN_TIME_CFG_STRUC csr9;
-	u8 *ptr;
-	u32 i;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("--->AsicEnableIbssSync(ADHOC mode. MPDUtotalByteCount = %d)\n",
-		  pAd->BeaconTxWI.MPDUtotalByteCount));
-
-	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr9.word);
-	csr9.field.bBeaconGen = 0;
-	csr9.field.bTBTTEnable = 0;
-	csr9.field.bTsfTicking = 0;
-	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
-
-#ifdef RTMP_MAC_PCI
-	/* move BEACON TXD and frame content to on-chip memory */
-	ptr = (u8 *)& pAd->BeaconTxWI;
-	for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
-	{
-		u32 longptr =
-		    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
-		    (*(ptr + 3) << 24);
-		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
-		ptr += 4;
-	}
-
-	/* start right after the 16-byte TXWI field */
-	ptr = pAd->BeaconBuf;
-	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 4) {
-		u32 longptr =
-		    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
-		    (*(ptr + 3) << 24);
-		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
-		ptr += 4;
-	}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	/* move BEACON TXD and frame content to on-chip memory */
-	ptr = (u8 *)& pAd->BeaconTxWI;
-	for (i = 0; i < TXWI_SIZE; i += 2)	/* 16-byte TXWI field */
-	{
-		/*u32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24); */
-		/*RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr); */
-		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + i, ptr, 2);
-		ptr += 2;
-	}
-
-	/* start right after the 16-byte TXWI field */
-	ptr = pAd->BeaconBuf;
-	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 2) {
-		/*u32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24); */
-		/*RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr); */
-		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, ptr, 2);
-		ptr += 2;
-	}
-#endif /* RTMP_MAC_USB // */
-
-	/* */
-	/* For Wi-Fi faily generated beacons between participating stations. */
-	/* Set TBTT phase adaptive adjustment step to 8us (default 16us) */
-	/* don't change settings 2006-5- by Jerry */
-	/*RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010); */
-
-	/* start sending BEACON */
-	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	/* ASIC register in units of 1/16 TU */
-	csr9.field.bTsfTicking = 1;
-	csr9.field.TsfSyncMode = 2;	/* sync TSF in IBSS mode */
-	csr9.field.bTBTTEnable = 1;
-	csr9.field.bBeaconGen = 1;
-	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicSetEdcaParm(struct rt_rtmp_adapter *pAd, struct rt_edca_parm *pEdcaParm)
-{
-	EDCA_AC_CFG_STRUC Ac0Cfg, Ac1Cfg, Ac2Cfg, Ac3Cfg;
-	AC_TXOP_CSR0_STRUC csr0;
-	AC_TXOP_CSR1_STRUC csr1;
-	AIFSN_CSR_STRUC AifsnCsr;
-	CWMIN_CSR_STRUC CwminCsr;
-	CWMAX_CSR_STRUC CwmaxCsr;
-	int i;
-
-	Ac0Cfg.word = 0;
-	Ac1Cfg.word = 0;
-	Ac2Cfg.word = 0;
-	Ac3Cfg.word = 0;
-	if ((pEdcaParm == NULL) || (pEdcaParm->bValid == FALSE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("AsicSetEdcaParm\n"));
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WMM_INUSED);
-		for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++) {
-			if (pAd->MacTab.Content[i].ValidAsCLI
-			    || pAd->MacTab.Content[i].ValidAsApCli)
-				CLIENT_STATUS_CLEAR_FLAG(&pAd->MacTab.
-							 Content[i],
-							 fCLIENT_STATUS_WMM_CAPABLE);
-		}
-
-		/*======================================================== */
-		/*      MAC Register has a copy . */
-		/*======================================================== */
-/*#ifndef WIFI_TEST */
-		if (pAd->CommonCfg.bEnableTxBurst) {
-			/* For CWC test, change txop from 0x30 to 0x20 in TxBurst mode */
-			Ac0Cfg.field.AcTxop = 0x20;	/* Suggest by John for TxBurst in HT Mode */
-		} else
-			Ac0Cfg.field.AcTxop = 0;	/* QID_AC_BE */
-/*#else */
-/*              Ac0Cfg.field.AcTxop = 0;        // QID_AC_BE */
-/*#endif */
-		Ac0Cfg.field.Cwmin = CW_MIN_IN_BITS;
-		Ac0Cfg.field.Cwmax = CW_MAX_IN_BITS;
-		Ac0Cfg.field.Aifsn = 2;
-		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Ac0Cfg.word);
-
-		Ac1Cfg.field.AcTxop = 0;	/* QID_AC_BK */
-		Ac1Cfg.field.Cwmin = CW_MIN_IN_BITS;
-		Ac1Cfg.field.Cwmax = CW_MAX_IN_BITS;
-		Ac1Cfg.field.Aifsn = 2;
-		RTMP_IO_WRITE32(pAd, EDCA_AC1_CFG, Ac1Cfg.word);
-
-		if (pAd->CommonCfg.PhyMode == PHY_11B) {
-			Ac2Cfg.field.AcTxop = 192;	/* AC_VI: 192*32us ~= 6ms */
-			Ac3Cfg.field.AcTxop = 96;	/* AC_VO: 96*32us  ~= 3ms */
-		} else {
-			Ac2Cfg.field.AcTxop = 96;	/* AC_VI: 96*32us ~= 3ms */
-			Ac3Cfg.field.AcTxop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
-		}
-		Ac2Cfg.field.Cwmin = CW_MIN_IN_BITS;
-		Ac2Cfg.field.Cwmax = CW_MAX_IN_BITS;
-		Ac2Cfg.field.Aifsn = 2;
-		RTMP_IO_WRITE32(pAd, EDCA_AC2_CFG, Ac2Cfg.word);
-		Ac3Cfg.field.Cwmin = CW_MIN_IN_BITS;
-		Ac3Cfg.field.Cwmax = CW_MAX_IN_BITS;
-		Ac3Cfg.field.Aifsn = 2;
-		RTMP_IO_WRITE32(pAd, EDCA_AC3_CFG, Ac3Cfg.word);
-
-		/*======================================================== */
-		/*      DMA Register has a copy too. */
-		/*======================================================== */
-		csr0.field.Ac0Txop = 0;	/* QID_AC_BE */
-		csr0.field.Ac1Txop = 0;	/* QID_AC_BK */
-		RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
-		if (pAd->CommonCfg.PhyMode == PHY_11B) {
-			csr1.field.Ac2Txop = 192;	/* AC_VI: 192*32us ~= 6ms */
-			csr1.field.Ac3Txop = 96;	/* AC_VO: 96*32us  ~= 3ms */
-		} else {
-			csr1.field.Ac2Txop = 96;	/* AC_VI: 96*32us ~= 3ms */
-			csr1.field.Ac3Txop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
-		}
-		RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr1.word);
-
-		CwminCsr.word = 0;
-		CwminCsr.field.Cwmin0 = CW_MIN_IN_BITS;
-		CwminCsr.field.Cwmin1 = CW_MIN_IN_BITS;
-		CwminCsr.field.Cwmin2 = CW_MIN_IN_BITS;
-		CwminCsr.field.Cwmin3 = CW_MIN_IN_BITS;
-		RTMP_IO_WRITE32(pAd, WMM_CWMIN_CFG, CwminCsr.word);
-
-		CwmaxCsr.word = 0;
-		CwmaxCsr.field.Cwmax0 = CW_MAX_IN_BITS;
-		CwmaxCsr.field.Cwmax1 = CW_MAX_IN_BITS;
-		CwmaxCsr.field.Cwmax2 = CW_MAX_IN_BITS;
-		CwmaxCsr.field.Cwmax3 = CW_MAX_IN_BITS;
-		RTMP_IO_WRITE32(pAd, WMM_CWMAX_CFG, CwmaxCsr.word);
-
-		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, 0x00002222);
-
-		NdisZeroMemory(&pAd->CommonCfg.APEdcaParm, sizeof(struct rt_edca_parm));
-	} else {
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WMM_INUSED);
-		/*======================================================== */
-		/*      MAC Register has a copy. */
-		/*======================================================== */
-		/* */
-		/* Modify Cwmin/Cwmax/Txop on queue[QID_AC_VI], Recommend by Jerry 2005/07/27 */
-		/* To degrade our VIDO Queue's throughput for WiFi WMM S3T07 Issue. */
-		/* */
-		/*pEdcaParm->Txop[QID_AC_VI] = pEdcaParm->Txop[QID_AC_VI] * 7 / 10; // rt2860c need this */
-
-		Ac0Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BE];
-		Ac0Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BE];
-		Ac0Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BE];
-		Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE];	/*+1; */
-
-		Ac1Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BK];
-		Ac1Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BK];	/*+2; */
-		Ac1Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BK];
-		Ac1Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BK];	/*+1; */
-
-		Ac2Cfg.field.AcTxop = (pEdcaParm->Txop[QID_AC_VI] * 6) / 10;
-		if (pAd->Antenna.field.TxPath == 1) {
-			Ac2Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VI] + 1;
-			Ac2Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VI] + 1;
-		} else {
-			Ac2Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VI];
-			Ac2Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VI];
-		}
-		Ac2Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VI] + 1;
-#ifdef RTMP_MAC_USB
-		Ac2Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VI] + 3;
-#endif /* RTMP_MAC_USB // */
-
-		{
-			/* Tuning for Wi-Fi WMM S06 */
-			if (pAd->CommonCfg.bWiFiTest &&
-			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
-				Ac2Cfg.field.Aifsn -= 1;
-
-			/* Tuning for TGn Wi-Fi 5.2.32 */
-			/* STA TestBed changes in this item: conexant legacy sta ==> broadcom 11n sta */
-			if (STA_TGN_WIFI_ON(pAd) &&
-			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
-				Ac0Cfg.field.Aifsn = 3;
-				Ac2Cfg.field.AcTxop = 5;
-			}
-#ifdef RT30xx
-			if (pAd->RfIcType == RFIC_3020
-			    || pAd->RfIcType == RFIC_2020) {
-				/* Tuning for WiFi WMM S3-T07: connexant legacy sta ==> broadcom 11n sta. */
-				Ac2Cfg.field.Aifsn = 5;
-			}
-#endif /* RT30xx // */
-		}
-
-		Ac3Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_VO];
-		Ac3Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VO];
-		Ac3Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VO];
-		Ac3Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VO];
-
-/*#ifdef WIFI_TEST */
-		if (pAd->CommonCfg.bWiFiTest) {
-			if (Ac3Cfg.field.AcTxop == 102) {
-				Ac0Cfg.field.AcTxop =
-				    pEdcaParm->Txop[QID_AC_BE] ? pEdcaParm->
-				    Txop[QID_AC_BE] : 10;
-				Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE] - 1;	/* AIFSN must >= 1 */
-				Ac1Cfg.field.AcTxop =
-				    pEdcaParm->Txop[QID_AC_BK];
-				Ac1Cfg.field.Aifsn =
-				    pEdcaParm->Aifsn[QID_AC_BK];
-				Ac2Cfg.field.AcTxop =
-				    pEdcaParm->Txop[QID_AC_VI];
-			}	/* End of if */
-		}
-/*#endif // WIFI_TEST // */
-
-		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Ac0Cfg.word);
-		RTMP_IO_WRITE32(pAd, EDCA_AC1_CFG, Ac1Cfg.word);
-		RTMP_IO_WRITE32(pAd, EDCA_AC2_CFG, Ac2Cfg.word);
-		RTMP_IO_WRITE32(pAd, EDCA_AC3_CFG, Ac3Cfg.word);
-
-		/*======================================================== */
-		/*      DMA Register has a copy too. */
-		/*======================================================== */
-		csr0.field.Ac0Txop = Ac0Cfg.field.AcTxop;
-		csr0.field.Ac1Txop = Ac1Cfg.field.AcTxop;
-		RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
-
-		csr1.field.Ac2Txop = Ac2Cfg.field.AcTxop;
-		csr1.field.Ac3Txop = Ac3Cfg.field.AcTxop;
-		RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr1.word);
-
-		CwminCsr.word = 0;
-		CwminCsr.field.Cwmin0 = pEdcaParm->Cwmin[QID_AC_BE];
-		CwminCsr.field.Cwmin1 = pEdcaParm->Cwmin[QID_AC_BK];
-		CwminCsr.field.Cwmin2 = pEdcaParm->Cwmin[QID_AC_VI];
-		CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO] - 1;	/*for TGn wifi test */
-		RTMP_IO_WRITE32(pAd, WMM_CWMIN_CFG, CwminCsr.word);
-
-		CwmaxCsr.word = 0;
-		CwmaxCsr.field.Cwmax0 = pEdcaParm->Cwmax[QID_AC_BE];
-		CwmaxCsr.field.Cwmax1 = pEdcaParm->Cwmax[QID_AC_BK];
-		CwmaxCsr.field.Cwmax2 = pEdcaParm->Cwmax[QID_AC_VI];
-		CwmaxCsr.field.Cwmax3 = pEdcaParm->Cwmax[QID_AC_VO];
-		RTMP_IO_WRITE32(pAd, WMM_CWMAX_CFG, CwmaxCsr.word);
-
-		AifsnCsr.word = 0;
-		AifsnCsr.field.Aifsn0 = Ac0Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_BE]; */
-		AifsnCsr.field.Aifsn1 = Ac1Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_BK]; */
-		AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_VI]; */
-
-		{
-			/* Tuning for Wi-Fi WMM S06 */
-			if (pAd->CommonCfg.bWiFiTest &&
-			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
-				AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn - 4;
-
-			/* Tuning for TGn Wi-Fi 5.2.32 */
-			/* STA TestBed changes in this item: connexant legacy sta ==> broadcom 11n sta */
-			if (STA_TGN_WIFI_ON(pAd) &&
-			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
-				AifsnCsr.field.Aifsn0 = 3;
-				AifsnCsr.field.Aifsn2 = 7;
-			}
-
-			if (INFRA_ON(pAd))
-				CLIENT_STATUS_SET_FLAG(&pAd->MacTab.
-						       Content[BSSID_WCID],
-						       fCLIENT_STATUS_WMM_CAPABLE);
-		}
-
-		{
-			AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1;	/*pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test */
-#ifdef RT30xx
-			/* TODO: Shiang, this modification also suitable for RT3052/RT3050 ??? */
-			if (pAd->RfIcType == RFIC_3020
-			    || pAd->RfIcType == RFIC_2020) {
-				AifsnCsr.field.Aifsn2 = 0x2;	/*pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04. */
-			}
-#endif /* RT30xx // */
-		}
-		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, AifsnCsr.word);
-
-		NdisMoveMemory(&pAd->CommonCfg.APEdcaParm, pEdcaParm,
-			       sizeof(struct rt_edca_parm));
-		if (!ADHOC_ON(pAd)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("EDCA [#%d]: AIFSN CWmin CWmax  TXOP(us)  ACM\n",
-				  pEdcaParm->EdcaUpdateCount));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("     AC_BE      %2d     %2d     %2d      %4d     %d\n",
-				  pEdcaParm->Aifsn[0], pEdcaParm->Cwmin[0],
-				  pEdcaParm->Cwmax[0], pEdcaParm->Txop[0] << 5,
-				  pEdcaParm->bACM[0]));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("     AC_BK      %2d     %2d     %2d      %4d     %d\n",
-				  pEdcaParm->Aifsn[1], pEdcaParm->Cwmin[1],
-				  pEdcaParm->Cwmax[1], pEdcaParm->Txop[1] << 5,
-				  pEdcaParm->bACM[1]));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("     AC_VI      %2d     %2d     %2d      %4d     %d\n",
-				  pEdcaParm->Aifsn[2], pEdcaParm->Cwmin[2],
-				  pEdcaParm->Cwmax[2], pEdcaParm->Txop[2] << 5,
-				  pEdcaParm->bACM[2]));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("     AC_VO      %2d     %2d     %2d      %4d     %d\n",
-				  pEdcaParm->Aifsn[3], pEdcaParm->Cwmin[3],
-				  pEdcaParm->Cwmax[3], pEdcaParm->Txop[3] << 5,
-				  pEdcaParm->bACM[3]));
-		}
-	}
-
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicSetSlotTime(struct rt_rtmp_adapter *pAd, IN BOOLEAN bUseShortSlotTime)
-{
-	unsigned long SlotTime;
-	u32 RegValue = 0;
-
-	if (pAd->CommonCfg.Channel > 14)
-		bUseShortSlotTime = TRUE;
-
-	if (bUseShortSlotTime
-	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
-		return;
-	else if ((!bUseShortSlotTime)
-		 && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)))
-		return;
-
-	if (bUseShortSlotTime)
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
-	else
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
-
-	SlotTime = (bUseShortSlotTime) ? 9 : 20;
-
-	{
-		/* force using short SLOT time for FAE to demo performance when TxBurst is ON */
-		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
-		     && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
-		    || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
-			&& (pAd->CommonCfg.BACapability.field.Policy ==
-			    BA_NOTUSE))
-		    ) {
-			/* In this case, we will think it is doing Wi-Fi test */
-			/* And we will not set to short slot when bEnableTxBurst is TRUE. */
-		} else if (pAd->CommonCfg.bEnableTxBurst) {
-			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
-			SlotTime = 9;
-		}
-	}
-
-	/* */
-	/* For some reasons, always set it to short slot time. */
-	/* */
-	/* ToDo: Should consider capability with 11B */
-	/* */
-	{
-		if (pAd->StaCfg.BssType == BSS_ADHOC) {
-			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
-			SlotTime = 20;
-		}
-	}
-
-	RTMP_IO_READ32(pAd, BKOFF_SLOT_CFG, &RegValue);
-	RegValue = RegValue & 0xFFFFFF00;
-
-	RegValue |= SlotTime;
-
-	RTMP_IO_WRITE32(pAd, BKOFF_SLOT_CFG, RegValue);
-}
-
-/*
-	========================================================================
-	Description:
-		Add Shared key information into ASIC.
-		Update shared key, TxMic and RxMic to Asic Shared key table
-		Update its cipherAlg to Asic Shared key Mode.
-
-    Return:
-	========================================================================
-*/
-void AsicAddSharedKeyEntry(struct rt_rtmp_adapter *pAd,
-			   u8 BssIndex,
-			   u8 KeyIdx,
-			   u8 CipherAlg,
-			   u8 *pKey, u8 *pTxMic, u8 *pRxMic)
-{
-	unsigned long offset;		/*, csr0; */
-	SHAREDKEY_MODE_STRUC csr1;
-#ifdef RTMP_MAC_PCI
-	int i;
-#endif /* RTMP_MAC_PCI // */
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AsicAddSharedKeyEntry BssIndex=%d, KeyIdx=%d\n", BssIndex,
-		  KeyIdx));
-/*============================================================================================ */
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg],
-		  BssIndex * 4 + KeyIdx));
-	DBGPRINT_RAW(RT_DEBUG_TRACE,
-		     ("		Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-		      pKey[0], pKey[1], pKey[2], pKey[3], pKey[4],
-		      pKey[5], pKey[6], pKey[7], pKey[8], pKey[9],
-		      pKey[10], pKey[11], pKey[12], pKey[13], pKey[14],
-		      pKey[15]));
-	if (pRxMic) {
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("		Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			      pRxMic[0], pRxMic[1], pRxMic[2], pRxMic[3],
-			      pRxMic[4], pRxMic[5], pRxMic[6], pRxMic[7]));
-	}
-	if (pTxMic) {
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("		Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			      pTxMic[0], pTxMic[1], pTxMic[2], pTxMic[3],
-			      pTxMic[4], pTxMic[5], pTxMic[6], pTxMic[7]));
-	}
-/*============================================================================================ */
-	/* */
-	/* fill key material - key + TX MIC + RX MIC */
-	/* */
-#ifdef RTMP_MAC_PCI
-	offset =
-	    SHARED_KEY_TABLE_BASE + (4 * BssIndex + KeyIdx) * HW_KEY_ENTRY_SIZE;
-	for (i = 0; i < MAX_LEN_OF_SHARE_KEY; i++) {
-		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
-	}
-
-	offset += MAX_LEN_OF_SHARE_KEY;
-	if (pTxMic) {
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
-		}
-	}
-
-	offset += 8;
-	if (pRxMic) {
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	{
-		offset =
-		    SHARED_KEY_TABLE_BASE + (4 * BssIndex +
-					     KeyIdx) * HW_KEY_ENTRY_SIZE;
-		RTUSBMultiWrite(pAd, offset, pKey, MAX_LEN_OF_SHARE_KEY);
-
-		offset += MAX_LEN_OF_SHARE_KEY;
-		if (pTxMic) {
-			RTUSBMultiWrite(pAd, offset, pTxMic, 8);
-		}
-
-		offset += 8;
-		if (pRxMic) {
-			RTUSBMultiWrite(pAd, offset, pRxMic, 8);
-		}
-	}
-#endif /* RTMP_MAC_USB // */
-
-	/* */
-	/* Update cipher algorithm. WSTA always use BSS0 */
-	/* */
-	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-		       &csr1.word);
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Read: SHARED_KEY_MODE_BASE at this Bss[%d] KeyIdx[%d]= 0x%x \n",
-		  BssIndex, KeyIdx, csr1.word));
-	if ((BssIndex % 2) == 0) {
-		if (KeyIdx == 0)
-			csr1.field.Bss0Key0CipherAlg = CipherAlg;
-		else if (KeyIdx == 1)
-			csr1.field.Bss0Key1CipherAlg = CipherAlg;
-		else if (KeyIdx == 2)
-			csr1.field.Bss0Key2CipherAlg = CipherAlg;
-		else
-			csr1.field.Bss0Key3CipherAlg = CipherAlg;
-	} else {
-		if (KeyIdx == 0)
-			csr1.field.Bss1Key0CipherAlg = CipherAlg;
-		else if (KeyIdx == 1)
-			csr1.field.Bss1Key1CipherAlg = CipherAlg;
-		else if (KeyIdx == 2)
-			csr1.field.Bss1Key2CipherAlg = CipherAlg;
-		else
-			csr1.field.Bss1Key3CipherAlg = CipherAlg;
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n",
-		  BssIndex, csr1.word));
-	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-			csr1.word);
-
-}
-
-/*      IRQL = DISPATCH_LEVEL */
-void AsicRemoveSharedKeyEntry(struct rt_rtmp_adapter *pAd,
-			      u8 BssIndex, u8 KeyIdx)
-{
-	/*unsigned long SecCsr0; */
-	SHAREDKEY_MODE_STRUC csr1;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AsicRemoveSharedKeyEntry: #%d \n", BssIndex * 4 + KeyIdx));
-
-	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-		       &csr1.word);
-	if ((BssIndex % 2) == 0) {
-		if (KeyIdx == 0)
-			csr1.field.Bss0Key0CipherAlg = 0;
-		else if (KeyIdx == 1)
-			csr1.field.Bss0Key1CipherAlg = 0;
-		else if (KeyIdx == 2)
-			csr1.field.Bss0Key2CipherAlg = 0;
-		else
-			csr1.field.Bss0Key3CipherAlg = 0;
-	} else {
-		if (KeyIdx == 0)
-			csr1.field.Bss1Key0CipherAlg = 0;
-		else if (KeyIdx == 1)
-			csr1.field.Bss1Key1CipherAlg = 0;
-		else if (KeyIdx == 2)
-			csr1.field.Bss1Key2CipherAlg = 0;
-		else
-			csr1.field.Bss1Key3CipherAlg = 0;
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n",
-		  BssIndex, csr1.word));
-	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-			csr1.word);
-	ASSERT(BssIndex < 4);
-	ASSERT(KeyIdx < 4);
-
-}
-
-void AsicUpdateWCIDAttribute(struct rt_rtmp_adapter *pAd,
-			     u16 WCID,
-			     u8 BssIndex,
-			     u8 CipherAlg,
-			     IN BOOLEAN bUsePairewiseKeyTable)
-{
-	unsigned long WCIDAttri = 0, offset;
-
-	/* */
-	/* Update WCID attribute. */
-	/* Only TxKey could update WCID attribute. */
-	/* */
-	offset = MAC_WCID_ATTRIBUTE_BASE + (WCID * HW_WCID_ATTRI_SIZE);
-	WCIDAttri =
-	    (BssIndex << 4) | (CipherAlg << 1) | (bUsePairewiseKeyTable);
-	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
-}
-
-void AsicUpdateWCIDIVEIV(struct rt_rtmp_adapter *pAd,
-			 u16 WCID, unsigned long uIV, unsigned long uEIV)
-{
-	unsigned long offset;
-
-	offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
-
-	RTMP_IO_WRITE32(pAd, offset, uIV);
-	RTMP_IO_WRITE32(pAd, offset + 4, uEIV);
-}
-
-void AsicUpdateRxWCIDTable(struct rt_rtmp_adapter *pAd,
-			   u16 WCID, u8 *pAddr)
-{
-	unsigned long offset;
-	unsigned long Addr;
-
-	offset = MAC_WCID_BASE + (WCID * HW_WCID_ENTRY_SIZE);
-	Addr = pAddr[0] + (pAddr[1] << 8) + (pAddr[2] << 16) + (pAddr[3] << 24);
-	RTMP_IO_WRITE32(pAd, offset, Addr);
-	Addr = pAddr[4] + (pAddr[5] << 8);
-	RTMP_IO_WRITE32(pAd, offset + 4, Addr);
-}
-
-/*
-    ========================================================================
-
-    Routine Description:
-        Set Cipher Key, Cipher algorithm, IV/EIV to Asic
-
-    Arguments:
-        pAd                     Pointer to our adapter
-        WCID                    WCID Entry number.
-        BssIndex                BSSID index, station or none multiple BSSID support
-                                this value should be 0.
-        KeyIdx                  This KeyIdx will set to IV's KeyID if bTxKey enabled
-        pCipherKey              Pointer to Cipher Key.
-        bUsePairewiseKeyTable   TRUE means saved the key in SharedKey table,
-                                otherwise PairewiseKey table
-        bTxKey                  This is the transmit key if enabled.
-
-    Return Value:
-        None
-
-    Note:
-        This routine will set the relative key stuff to Asic including WCID attribute,
-        Cipher Key, Cipher algorithm and IV/EIV.
-
-        IV/EIV will be update if this CipherKey is the transmission key because
-        ASIC will base on IV's KeyID value to select Cipher Key.
-
-        If bTxKey sets to FALSE, this is not the TX key, but it could be
-        RX key
-
-	For AP mode bTxKey must be always set to TRUE.
-    ========================================================================
-*/
-void AsicAddKeyEntry(struct rt_rtmp_adapter *pAd,
-		     u16 WCID,
-		     u8 BssIndex,
-		     u8 KeyIdx,
-		     struct rt_cipher_key *pCipherKey,
-		     IN BOOLEAN bUsePairewiseKeyTable, IN BOOLEAN bTxKey)
-{
-	unsigned long offset;
-/*      unsigned long   WCIDAttri = 0; */
-	u8 IV4 = 0;
-	u8 *pKey = pCipherKey->Key;
-/*      unsigned long           KeyLen = pCipherKey->KeyLen; */
-	u8 *pTxMic = pCipherKey->TxMic;
-	u8 *pRxMic = pCipherKey->RxMic;
-	u8 *pTxtsc = pCipherKey->TxTsc;
-	u8 CipherAlg = pCipherKey->CipherAlg;
-	SHAREDKEY_MODE_STRUC csr1;
-#ifdef RTMP_MAC_PCI
-	u8 i;
-#endif /* RTMP_MAC_PCI // */
-
-/*      ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY); */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
-	/* */
-	/* 1.) decide key table offset */
-	/* */
-	if (bUsePairewiseKeyTable)
-		offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
-	else
-		offset =
-		    SHARED_KEY_TABLE_BASE + (4 * BssIndex +
-					     KeyIdx) * HW_KEY_ENTRY_SIZE;
-
-	/* */
-	/* 2.) Set Key to Asic */
-	/* */
-	/*for (i = 0; i < KeyLen; i++) */
-#ifdef RTMP_MAC_PCI
-	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
-		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
-	}
-	offset += MAX_LEN_OF_PEER_KEY;
-
-	/* */
-	/* 3.) Set MIC key if available */
-	/* */
-	if (pTxMic) {
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
-		}
-	}
-	offset += LEN_TKIP_TXMICK;
-
-	if (pRxMic) {
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	RTUSBMultiWrite(pAd, offset, pKey, MAX_LEN_OF_PEER_KEY);
-	offset += MAX_LEN_OF_PEER_KEY;
-
-	/* */
-	/* 3.) Set MIC key if available */
-	/* */
-	if (pTxMic) {
-		RTUSBMultiWrite(pAd, offset, pTxMic, 8);
-	}
-	offset += LEN_TKIP_TXMICK;
-
-	if (pRxMic) {
-		RTUSBMultiWrite(pAd, offset, pRxMic, 8);
-	}
-#endif /* RTMP_MAC_USB // */
-
-	/* */
-	/* 4.) Modify IV/EIV if needs */
-	/*     This will force Asic to use this key ID by setting IV. */
-	/* */
-	if (bTxKey) {
-#ifdef RTMP_MAC_PCI
-		offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
-		/* */
-		/* Write IV */
-		/* */
-		RTMP_IO_WRITE8(pAd, offset, pTxtsc[1]);
-		RTMP_IO_WRITE8(pAd, offset + 1, ((pTxtsc[1] | 0x20) & 0x7f));
-		RTMP_IO_WRITE8(pAd, offset + 2, pTxtsc[0]);
-
-		IV4 = (KeyIdx << 6);
-		if ((CipherAlg == CIPHER_TKIP)
-		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
-		    || (CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;	/* turn on extension bit means EIV existence */
-
-		RTMP_IO_WRITE8(pAd, offset + 3, IV4);
-
-		/* */
-		/* Write EIV */
-		/* */
-		offset += 4;
-		for (i = 0; i < 4; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pTxtsc[i + 2]);
-		}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		u32 tmpVal;
-
-		/* */
-		/* Write IV */
-		/* */
-		IV4 = (KeyIdx << 6);
-		if ((CipherAlg == CIPHER_TKIP)
-		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
-		    || (CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;	/* turn on extension bit means EIV existence */
-
-		tmpVal =
-		    pTxtsc[1] + (((pTxtsc[1] | 0x20) & 0x7f) << 8) +
-		    (pTxtsc[0] << 16) + (IV4 << 24);
-		RTMP_IO_WRITE32(pAd, offset, tmpVal);
-
-		/* */
-		/* Write EIV */
-		/* */
-		offset += 4;
-		RTMP_IO_WRITE32(pAd, offset, *(u32 *)& pCipherKey->TxTsc[2]);
-#endif /* RTMP_MAC_USB // */
-
-		AsicUpdateWCIDAttribute(pAd, WCID, BssIndex, CipherAlg,
-					bUsePairewiseKeyTable);
-	}
-
-	if (!bUsePairewiseKeyTable) {
-		/* */
-		/* Only update the shared key security mode */
-		/* */
-		RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-			       &csr1.word);
-		if ((BssIndex % 2) == 0) {
-			if (KeyIdx == 0)
-				csr1.field.Bss0Key0CipherAlg = CipherAlg;
-			else if (KeyIdx == 1)
-				csr1.field.Bss0Key1CipherAlg = CipherAlg;
-			else if (KeyIdx == 2)
-				csr1.field.Bss0Key2CipherAlg = CipherAlg;
-			else
-				csr1.field.Bss0Key3CipherAlg = CipherAlg;
-		} else {
-			if (KeyIdx == 0)
-				csr1.field.Bss1Key0CipherAlg = CipherAlg;
-			else if (KeyIdx == 1)
-				csr1.field.Bss1Key1CipherAlg = CipherAlg;
-			else if (KeyIdx == 2)
-				csr1.field.Bss1Key2CipherAlg = CipherAlg;
-			else
-				csr1.field.Bss1Key3CipherAlg = CipherAlg;
-		}
-		RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
-				csr1.word);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<== AsicAddKeyEntry\n"));
-}
-
-/*
-	========================================================================
-	Description:
-		Add Pair-wise key material into ASIC.
-		Update pairwise key, TxMic and RxMic to Asic Pair-wise key table
-
-    Return:
-	========================================================================
-*/
-void AsicAddPairwiseKeyEntry(struct rt_rtmp_adapter *pAd,
-			     u8 *pAddr,
-			     u8 WCID, struct rt_cipher_key *pCipherKey)
-{
-	int i;
-	unsigned long offset;
-	u8 *pKey = pCipherKey->Key;
-	u8 *pTxMic = pCipherKey->TxMic;
-	u8 *pRxMic = pCipherKey->RxMic;
-#ifdef DBG
-	u8 CipherAlg = pCipherKey->CipherAlg;
-#endif /* DBG // */
-
-	/* EKEY */
-	offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
-#ifdef RTMP_MAC_PCI
-	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
-		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
-	}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	RTUSBMultiWrite(pAd, offset, &pCipherKey->Key[0], MAX_LEN_OF_PEER_KEY);
-#endif /* RTMP_MAC_USB // */
-	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i += 4) {
-		u32 Value;
-		RTMP_IO_READ32(pAd, offset + i, &Value);
-	}
-
-	offset += MAX_LEN_OF_PEER_KEY;
-
-	/*  MIC KEY */
-	if (pTxMic) {
-#ifdef RTMP_MAC_PCI
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
-		}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		RTUSBMultiWrite(pAd, offset, &pCipherKey->TxMic[0], 8);
-#endif /* RTMP_MAC_USB // */
-	}
-	offset += 8;
-	if (pRxMic) {
-#ifdef RTMP_MAC_PCI
-		for (i = 0; i < 8; i++) {
-			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
-		}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		RTUSBMultiWrite(pAd, offset, &pCipherKey->RxMic[0], 8);
-#endif /* RTMP_MAC_USB // */
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AsicAddPairwiseKeyEntry: WCID #%d Alg=%s\n", WCID,
-		  CipherName[CipherAlg]));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("	Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-		  pKey[0], pKey[1], pKey[2], pKey[3], pKey[4], pKey[5],
-		  pKey[6], pKey[7], pKey[8], pKey[9], pKey[10], pKey[11],
-		  pKey[12], pKey[13], pKey[14], pKey[15]));
-	if (pRxMic) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("	Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			  pRxMic[0], pRxMic[1], pRxMic[2], pRxMic[3],
-			  pRxMic[4], pRxMic[5], pRxMic[6], pRxMic[7]));
-	}
-	if (pTxMic) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("	Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			  pTxMic[0], pTxMic[1], pTxMic[2], pTxMic[3],
-			  pTxMic[4], pTxMic[5], pTxMic[6], pTxMic[7]));
-	}
-}
-
-/*
-	========================================================================
-	Description:
-		Remove Pair-wise key material from ASIC.
-
-    Return:
-	========================================================================
-*/
-void AsicRemovePairwiseKeyEntry(struct rt_rtmp_adapter *pAd,
-				u8 BssIdx, u8 Wcid)
-{
-	unsigned long WCIDAttri;
-	u16 offset;
-
-	/* re-set the entry's WCID attribute as OPEN-NONE. */
-	offset = MAC_WCID_ATTRIBUTE_BASE + (Wcid * HW_WCID_ATTRI_SIZE);
-	WCIDAttri = (BssIdx << 4) | PAIRWISEKEYTABLE;
-	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
-}
-
-BOOLEAN AsicSendCommandToMcu(struct rt_rtmp_adapter *pAd,
-			     u8 Command,
-			     u8 Token, u8 Arg0, u8 Arg1)
-{
-
-	if (pAd->chipOps.sendCommandToMcu)
-		pAd->chipOps.sendCommandToMcu(pAd, Command, Token, Arg0, Arg1);
-
-	return TRUE;
-}
-
-void AsicSetRxAnt(struct rt_rtmp_adapter *pAd, u8 Ant)
-{
-#ifdef RT30xx
-	/* RT3572 ATE need not to do this. */
-	RT30xxSetRxAnt(pAd, Ant);
-#endif /* RT30xx // */
-}
-
-void AsicTurnOffRFClk(struct rt_rtmp_adapter *pAd, u8 Channel)
-{
-	if (pAd->chipOps.AsicRfTurnOff) {
-		pAd->chipOps.AsicRfTurnOff(pAd);
-	} else {
-		/* RF R2 bit 18 = 0 */
-		u32 R1 = 0, R2 = 0, R3 = 0;
-		u8 index;
-		struct rt_rtmp_rf_regs *RFRegTable;
-
-		RFRegTable = RF2850RegTable;
-
-		switch (pAd->RfIcType) {
-		case RFIC_2820:
-		case RFIC_2850:
-		case RFIC_2720:
-		case RFIC_2750:
-
-			for (index = 0; index < NUM_OF_2850_CHNL; index++) {
-				if (Channel == RFRegTable[index].Channel) {
-					R1 = RFRegTable[index].R1 & 0xffffdfff;
-					R2 = RFRegTable[index].R2 & 0xfffbffff;
-					R3 = RFRegTable[index].R3 & 0xfff3ffff;
-
-					RTMP_RF_IO_WRITE32(pAd, R1);
-					RTMP_RF_IO_WRITE32(pAd, R2);
-
-					/* Program R1b13 to 1, R3/b18,19 to 0, R2b18 to 0. */
-					/* Set RF R2 bit18=0, R3 bit[18:19]=0 */
-					/*if (pAd->StaCfg.bRadio == FALSE) */
-					if (1) {
-						RTMP_RF_IO_WRITE32(pAd, R3);
-
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x,  R3 = 0x%08x \n",
-							  Channel,
-							  pAd->RfIcType, R2,
-							  R3));
-					} else
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x \n",
-							  Channel,
-							  pAd->RfIcType, R2));
-					break;
-				}
-			}
-			break;
-
-		default:
-			break;
-		}
-	}
-}
-
-void AsicTurnOnRFClk(struct rt_rtmp_adapter *pAd, u8 Channel)
-{
-	/* RF R2 bit 18 = 0 */
-	u32 R1 = 0, R2 = 0, R3 = 0;
-	u8 index;
-	struct rt_rtmp_rf_regs *RFRegTable;
-
-#ifdef PCIE_PS_SUPPORT
-	/* The RF programming sequence is difference between 3xxx and 2xxx */
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
-		return;
-	}
-#endif /* PCIE_PS_SUPPORT // */
-
-	RFRegTable = RF2850RegTable;
-
-	switch (pAd->RfIcType) {
-	case RFIC_2820:
-	case RFIC_2850:
-	case RFIC_2720:
-	case RFIC_2750:
-
-		for (index = 0; index < NUM_OF_2850_CHNL; index++) {
-			if (Channel == RFRegTable[index].Channel) {
-				R3 = pAd->LatchRfRegs.R3;
-				R3 &= 0xfff3ffff;
-				R3 |= 0x00080000;
-				RTMP_RF_IO_WRITE32(pAd, R3);
-
-				R1 = RFRegTable[index].R1;
-				RTMP_RF_IO_WRITE32(pAd, R1);
-
-				R2 = RFRegTable[index].R2;
-				if (pAd->Antenna.field.TxPath == 1) {
-					R2 |= 0x4000;	/* If TXpath is 1, bit 14 = 1; */
-				}
-
-				if (pAd->Antenna.field.RxPath == 2) {
-					R2 |= 0x40;	/* write 1 to off Rxpath. */
-				} else if (pAd->Antenna.field.RxPath == 1) {
-					R2 |= 0x20040;	/* write 1 to off RxPath */
-				}
-				RTMP_RF_IO_WRITE32(pAd, R2);
-
-				break;
-			}
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("AsicTurnOnRFClk#%d(RF=%d, ) , R2=0x%08x\n",
-				  Channel, pAd->RfIcType, R2));
-}
diff --git a/drivers/staging/rt2860/common/cmm_cfg.c b/drivers/staging/rt2860/common/cmm_cfg.c
deleted file mode 100644
index 727f799..0000000
--- a/drivers/staging/rt2860/common/cmm_cfg.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	cmm_cfg.c
-
-    Abstract:
-    Ralink WiFi Driver configuration related subroutines
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
-*/
-
-#include "../rt_config.h"
-
-char *GetPhyMode(int Mode)
-{
-	switch (Mode) {
-	case MODE_CCK:
-		return "CCK";
-
-	case MODE_OFDM:
-		return "OFDM";
-	case MODE_HTMIX:
-		return "HTMIX";
-
-	case MODE_HTGREENFIELD:
-		return "GREEN";
-	default:
-		return "N/A";
-	}
-}
-
-char *GetBW(int BW)
-{
-	switch (BW) {
-	case BW_10:
-		return "10M";
-
-	case BW_20:
-		return "20M";
-	case BW_40:
-		return "40M";
-	default:
-		return "N/A";
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set Country Region to pAd->CommonCfg.CountryRegion.
-        This command will not work, if the field of CountryRegion in eeprom is programmed.
-
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int RT_CfgSetCountryRegion(struct rt_rtmp_adapter *pAd, char *arg, int band)
-{
-	long region, regionMax;
-	u8 *pCountryRegion;
-
-	region = simple_strtol(arg, 0, 10);
-
-	if (band == BAND_24G) {
-		pCountryRegion = &pAd->CommonCfg.CountryRegion;
-		regionMax = REGION_MAXIMUM_BG_BAND;
-	} else {
-		pCountryRegion = &pAd->CommonCfg.CountryRegionForABand;
-		regionMax = REGION_MAXIMUM_A_BAND;
-	}
-
-	/* TODO: Is it neccesay for following check??? */
-	/* Country can be set only when EEPROM not programmed */
-	if (*pCountryRegion & 0x80) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("CfgSetCountryRegion():CountryRegion in eeprom was programmed\n"));
-		return FALSE;
-	}
-
-	if ((region >= 0) && (region <= REGION_MAXIMUM_BG_BAND)) {
-		*pCountryRegion = (u8)region;
-	} else if ((region == REGION_31_BG_BAND) && (band == BAND_24G)) {
-		*pCountryRegion = (u8)region;
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("CfgSetCountryRegion():region(%ld) out of range!\n",
-			  region));
-		return FALSE;
-	}
-
-	return TRUE;
-
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set Wireless Mode
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int RT_CfgSetWirelessMode(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	int MaxPhyMode = PHY_11G;
-	long WirelessMode;
-
-	MaxPhyMode = PHY_11N_5G;
-
-	WirelessMode = simple_strtol(arg, 0, 10);
-	if (WirelessMode <= MaxPhyMode) {
-		pAd->CommonCfg.PhyMode = WirelessMode;
-		return TRUE;
-	}
-
-	return FALSE;
-
-}
-
-int RT_CfgSetShortSlot(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	long ShortSlot;
-
-	ShortSlot = simple_strtol(arg, 0, 10);
-
-	if (ShortSlot == 1)
-		pAd->CommonCfg.bUseShortSlotTime = TRUE;
-	else if (ShortSlot == 0)
-		pAd->CommonCfg.bUseShortSlotTime = FALSE;
-	else
-		return FALSE;	/*Invalid argument */
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set WEP KEY base on KeyIdx
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int RT_CfgSetWepKey(struct rt_rtmp_adapter *pAd,
-		    char *keyString,
-		    struct rt_cipher_key *pSharedKey, int keyIdx)
-{
-	int KeyLen;
-	int i;
-	u8 CipherAlg = CIPHER_NONE;
-	BOOLEAN bKeyIsHex = FALSE;
-
-	/* TODO: Shall we do memset for the original key info?? */
-	memset(pSharedKey, 0, sizeof(struct rt_cipher_key));
-	KeyLen = strlen(keyString);
-	switch (KeyLen) {
-	case 5:		/*wep 40 Ascii type */
-	case 13:		/*wep 104 Ascii type */
-		bKeyIsHex = FALSE;
-		pSharedKey->KeyLen = KeyLen;
-		NdisMoveMemory(pSharedKey->Key, keyString, KeyLen);
-		break;
-
-	case 10:		/*wep 40 Hex type */
-	case 26:		/*wep 104 Hex type */
-		for (i = 0; i < KeyLen; i++) {
-			if (!isxdigit(*(keyString + i)))
-				return FALSE;	/*Not Hex value; */
-		}
-		bKeyIsHex = TRUE;
-		pSharedKey->KeyLen = KeyLen / 2;
-		AtoH(keyString, pSharedKey->Key, pSharedKey->KeyLen);
-		break;
-
-	default:		/*Invalid argument */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RT_CfgSetWepKey(keyIdx=%d):Invalid argument (arg=%s)\n",
-			  keyIdx, keyString));
-		return FALSE;
-	}
-
-	pSharedKey->CipherAlg = ((KeyLen % 5) ? CIPHER_WEP128 : CIPHER_WEP64);
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RT_CfgSetWepKey:(KeyIdx=%d,type=%s, Alg=%s)\n", keyIdx,
-		  (bKeyIsHex == FALSE ? "Ascii" : "Hex"),
-		  CipherName[CipherAlg]));
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set WPA PSK key
-
-    Arguments:
-        pAdapter	Pointer to our adapter
-        keyString	WPA pre-shared key string
-        pHashStr	String used for password hash function
-        hashStrLen	Length of the hash string
-        pPMKBuf		Output buffer of WPAPSK key
-
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int RT_CfgSetWPAPSKKey(struct rt_rtmp_adapter *pAd,
-		       char *keyString,
-		       u8 * pHashStr,
-		       int hashStrLen, u8 *pPMKBuf)
-{
-	int keyLen;
-	u8 keyMaterial[40];
-
-	keyLen = strlen(keyString);
-	if ((keyLen < 8) || (keyLen > 64)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("WPAPSK Key length(%d) error, required 8 ~ 64 characters!(keyStr=%s)\n",
-			  keyLen, keyString));
-		return FALSE;
-	}
-
-	memset(pPMKBuf, 0, 32);
-	if (keyLen == 64) {
-		AtoH(keyString, pPMKBuf, 32);
-	} else {
-		PasswordHash(keyString, pHashStr, hashStrLen, keyMaterial);
-		NdisMoveMemory(pPMKBuf, keyMaterial, 32);
-	}
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/common/cmm_data.c b/drivers/staging/rt2860/common/cmm_data.c
deleted file mode 100644
index 33799e1..0000000
--- a/drivers/staging/rt2860/common/cmm_data.c
+++ /dev/null
@@ -1,2361 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#include "../rt_config.h"
-
-u8 SNAP_802_1H[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
-u8 SNAP_BRIDGE_TUNNEL[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
-
-/* Add Cisco Aironet SNAP heade for CCX2 support */
-u8 SNAP_AIRONET[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x00 };
-u8 CKIP_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x02 };
-u8 EAPOL_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e };
-u8 EAPOL[] = { 0x88, 0x8e };
-u8 TPID[] = { 0x81, 0x00 };	/* VLAN related */
-
-u8 IPX[] = { 0x81, 0x37 };
-u8 APPLE_TALK[] = { 0x80, 0xf3 };
-
-u8 RateIdToPlcpSignal[12] = {
-	0, /* RATE_1 */ 1, /* RATE_2 */ 2, /* RATE_5_5 */ 3,	/* RATE_11 *//* see BBP spec */
-	11, /* RATE_6 */ 15, /* RATE_9 */ 10, /* RATE_12 */ 14,	/* RATE_18 *//* see IEEE802.11a-1999 p.14 */
-	9, /* RATE_24 */ 13, /* RATE_36 */ 8, /* RATE_48 */ 12 /* RATE_54 */
-};				/* see IEEE802.11a-1999 p.14 */
-
-u8 OfdmSignalToRateId[16] = {
-	RATE_54, RATE_54, RATE_54, RATE_54,	/* OFDM PLCP Signal = 0,  1,  2,  3 respectively */
-	RATE_54, RATE_54, RATE_54, RATE_54,	/* OFDM PLCP Signal = 4,  5,  6,  7 respectively */
-	RATE_48, RATE_24, RATE_12, RATE_6,	/* OFDM PLCP Signal = 8,  9,  10, 11 respectively */
-	RATE_54, RATE_36, RATE_18, RATE_9,	/* OFDM PLCP Signal = 12, 13, 14, 15 respectively */
-};
-
-u8 OfdmRateToRxwiMCS[12] = {
-	0, 0, 0, 0,
-	0, 1, 2, 3,		/* OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3 */
-	4, 5, 6, 7,		/* OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7 */
-};
-
-u8 RxwiMCSToOfdmRate[12] = {
-	RATE_6, RATE_9, RATE_12, RATE_18,
-	RATE_24, RATE_36, RATE_48, RATE_54,	/* OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3 */
-	4, 5, 6, 7,		/* OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7 */
-};
-
-char *MCSToMbps[] =
-    { "1Mbps", "2Mbps", "5.5Mbps", "11Mbps", "06Mbps", "09Mbps", "12Mbps",
-"18Mbps", "24Mbps", "36Mbps", "48Mbps", "54Mbps", "MM-0", "MM-1", "MM-2", "MM-3",
-"MM-4", "MM-5", "MM-6", "MM-7", "MM-8", "MM-9", "MM-10", "MM-11", "MM-12", "MM-13",
-"MM-14", "MM-15", "MM-32", "ee1", "ee2", "ee3" };
-
-u8 default_cwmin[] =
-    { CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS - 1, CW_MIN_IN_BITS - 2 };
-/*u8 default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1}; */
-u8 default_sta_aifsn[] = { 3, 7, 2, 2 };
-
-u8 MapUserPriorityToAccessCategory[8] =
-    { QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI,
-QID_AC_VO, QID_AC_VO };
-
-/*
-	========================================================================
-
-	Routine Description:
-		API for MLME to transmit management frame to AP (BSS Mode)
-	or station (IBSS Mode)
-
-	Arguments:
-		pAd Pointer to our adapter
-		pData		Pointer to the outgoing 802.11 frame
-		Length		Size of outgoing management frame
-
-	Return Value:
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_PENDING
-		NDIS_STATUS_SUCCESS
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int MiniportMMRequest(struct rt_rtmp_adapter *pAd,
-			      u8 QueIdx, u8 *pData, u32 Length)
-{
-	void *pPacket;
-	int Status = NDIS_STATUS_SUCCESS;
-	unsigned long FreeNum;
-	u8 rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE];	/*RTMP_HW_HDR_LEN]; */
-#ifdef RTMP_MAC_PCI
-	unsigned long IrqFlags = 0;
-	u8 IrqState;
-#endif /* RTMP_MAC_PCI // */
-	BOOLEAN bUseDataQ = FALSE;
-	int retryCnt = 0;
-
-	ASSERT(Length <= MGMT_DMA_BUFFER_SIZE);
-
-	if ((QueIdx & MGMT_USE_QUEUE_FLAG) == MGMT_USE_QUEUE_FLAG) {
-		bUseDataQ = TRUE;
-		QueIdx &= (~MGMT_USE_QUEUE_FLAG);
-	}
-#ifdef RTMP_MAC_PCI
-	/* 2860C use Tx Ring */
-	IrqState = pAd->irq_disabled;
-	if (pAd->MACVersion == 0x28600100) {
-		QueIdx = (bUseDataQ == TRUE ? QueIdx : 3);
-		bUseDataQ = TRUE;
-	}
-	if (bUseDataQ && (!IrqState))
-		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-#endif /* RTMP_MAC_PCI // */
-
-	do {
-		/* Reset is in progress, stop immediately */
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-		    RTMP_TEST_FLAG(pAd,
-				   fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				   fRTMP_ADAPTER_NIC_NOT_EXIST)
-		    || !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
-			Status = NDIS_STATUS_FAILURE;
-			break;
-		}
-		/* Check Free priority queue */
-		/* Since we use PBF Queue2 for management frame.  Its corresponding DMA ring should be using TxRing. */
-#ifdef RTMP_MAC_PCI
-		if (bUseDataQ) {
-			retryCnt = MAX_DATAMM_RETRY;
-			/* free Tx(QueIdx) resources */
-			RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
-			FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
-		} else
-#endif /* RTMP_MAC_PCI // */
-		{
-			FreeNum = GET_MGMTRING_FREENO(pAd);
-		}
-
-		if ((FreeNum > 0)) {
-			/* We need to reserve space for rtmp hardware header. i.e., TxWI for RT2860 and TxInfo+TxWI for RT2870 */
-			NdisZeroMemory(&rtmpHwHdr, (TXINFO_SIZE + TXWI_SIZE));
-			Status =
-			    RTMPAllocateNdisPacket(pAd, &pPacket,
-						   (u8 *)& rtmpHwHdr,
-						   (TXINFO_SIZE + TXWI_SIZE),
-						   pData, Length);
-			if (Status != NDIS_STATUS_SUCCESS) {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("MiniportMMRequest (error:: can't allocate NDIS PACKET)\n"));
-				break;
-			}
-			/*pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK; */
-			/*pAd->CommonCfg.MlmeRate = RATE_2; */
-
-#ifdef RTMP_MAC_PCI
-			if (bUseDataQ) {
-				Status =
-				    MlmeDataHardTransmit(pAd, QueIdx, pPacket);
-				retryCnt--;
-			} else
-#endif /* RTMP_MAC_PCI // */
-				Status = MlmeHardTransmit(pAd, QueIdx, pPacket);
-			if (Status == NDIS_STATUS_SUCCESS)
-				retryCnt = 0;
-			else
-				RTMPFreeNdisPacket(pAd, pPacket);
-		} else {
-			pAd->RalinkCounters.MgmtRingFullCount++;
-#ifdef RTMP_MAC_PCI
-			if (bUseDataQ) {
-				retryCnt--;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("retryCnt %d\n", retryCnt));
-				if (retryCnt == 0) {
-					DBGPRINT(RT_DEBUG_ERROR,
-						 ("Qidx(%d), not enough space in DataRing, MgmtRingFullCount=%ld!\n",
-						  QueIdx,
-						  pAd->RalinkCounters.
-						  MgmtRingFullCount));
-				}
-			}
-#endif /* RTMP_MAC_PCI // */
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Qidx(%d), not enough space in MgmtRing, MgmtRingFullCount=%ld!\n",
-				  QueIdx,
-				  pAd->RalinkCounters.MgmtRingFullCount));
-		}
-	} while (retryCnt > 0);
-
-#ifdef RTMP_MAC_PCI
-	if (bUseDataQ && (!IrqState))
-		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-#endif /* RTMP_MAC_PCI // */
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Copy frame from waiting queue into relative ring buffer and set
-	appropriate ASIC register to kick hardware transmit function
-
-	Arguments:
-		pAd Pointer to our adapter
-		pBuffer 	Pointer to	memory of outgoing frame
-		Length		Size of outgoing management frame
-
-	Return Value:
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_PENDING
-		NDIS_STATUS_SUCCESS
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int MlmeHardTransmit(struct rt_rtmp_adapter *pAd,
-			     u8 QueIdx, void *pPacket)
-{
-	struct rt_packet_info PacketInfo;
-	u8 *pSrcBufVA;
-	u32 SrcBufLen;
-	struct rt_header_802_11 * pHeader_802_11;
-
-	if ((pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)
-	    ) {
-		return NDIS_STATUS_FAILURE;
-	}
-
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
-	if (pSrcBufVA == NULL)
-		return NDIS_STATUS_FAILURE;
-
-	pHeader_802_11 = (struct rt_header_802_11 *) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);
-
-#ifdef RTMP_MAC_PCI
-	if (pAd->MACVersion == 0x28600100)
-		return MlmeHardTransmitTxRing(pAd, QueIdx, pPacket);
-	else
-#endif /* RTMP_MAC_PCI // */
-		return MlmeHardTransmitMgmtRing(pAd, QueIdx, pPacket);
-
-}
-
-int MlmeHardTransmitMgmtRing(struct rt_rtmp_adapter *pAd,
-				     u8 QueIdx, void *pPacket)
-{
-	struct rt_packet_info PacketInfo;
-	u8 *pSrcBufVA;
-	u32 SrcBufLen;
-	struct rt_header_802_11 * pHeader_802_11;
-	BOOLEAN bAckRequired, bInsertTimestamp;
-	u8 MlmeRate;
-	struct rt_txwi * pFirstTxWI;
-	struct rt_mac_table_entry *pMacEntry = NULL;
-	u8 PID;
-
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
-
-	/* Make sure MGMT ring resource won't be used by other threads */
-	RTMP_SEM_LOCK(&pAd->MgmtRingLock);
-	if (pSrcBufVA == NULL) {
-		/* The buffer shouldn't be NULL */
-		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
-		return NDIS_STATUS_FAILURE;
-	}
-
-	{
-		/* outgoing frame always wakeup PHY to prevent frame lost */
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-			AsicForceWakeup(pAd, TRUE);
-	}
-
-	pFirstTxWI = (struct rt_txwi *) (pSrcBufVA + TXINFO_SIZE);
-	pHeader_802_11 = (struct rt_header_802_11 *) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);	/*TXWI_SIZE); */
-
-	if (pHeader_802_11->Addr1[0] & 0x01) {
-		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
-	} else {
-		MlmeRate = pAd->CommonCfg.MlmeRate;
-	}
-
-	/* Verify Mlme rate for a / g bands. */
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	/* 11A band */
-		MlmeRate = RATE_6;
-
-	if ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-	    (pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL)) {
-		pMacEntry = MacTableLookup(pAd, pHeader_802_11->Addr1);
-	}
-
-	{
-		/* Fixed W52 with Activity scan issue in ABG_MIXED and ABGN_MIXED mode. */
-		if (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED
-		    || pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) {
-			if (pAd->LatchRfRegs.Channel > 14)
-				pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
-			else
-				pAd->CommonCfg.MlmeTransmit.field.MODE = 0;
-		}
-	}
-
-	/* */
-	/* Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE) */
-	/* Snice it's been set to 0 while on MgtMacHeaderInit */
-	/* By the way this will cause frame to be send on PWR_SAVE failed. */
-	/* */
-	pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;	/* (pAd->StaCfg.Psm == PWR_SAVE); */
-
-	/* */
-	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
-	/* Data-Null packets also pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
-/*      if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL)) */
-	{
-		if ((pHeader_802_11->FC.SubType == SUBTYPE_ACTION) ||
-		    ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-		     ((pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL) ||
-		      (pHeader_802_11->FC.SubType == SUBTYPE_NULL_FUNC)))) {
-			if (pAd->StaCfg.Psm == PWR_SAVE)
-				pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
-			else
-				pHeader_802_11->FC.PwrMgmt =
-				    pAd->CommonCfg.bAPSDForcePowerSave;
-		}
-	}
-
-	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	/* must be PS-POLL */
-	{
-		/*Set PM bit in ps-poll, to fix WLK 1.2  PowerSaveMode_ext failure issue. */
-		if ((pAd->OpMode == OPMODE_STA)
-		    && (pHeader_802_11->FC.SubType == SUBTYPE_PS_POLL)) {
-			pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
-		}
-		bAckRequired = FALSE;
-	} else			/* BTYPE_MGMT or BTYPE_DATA(must be NULL frame) */
-	{
-		/*pAd->Sequence++; */
-		/*pHeader_802_11->Sequence = pAd->Sequence; */
-
-		if (pHeader_802_11->Addr1[0] & 0x01)	/* MULTICAST, BROADCAST */
-		{
-			bAckRequired = FALSE;
-			pHeader_802_11->Duration = 0;
-		} else {
-			bAckRequired = TRUE;
-			pHeader_802_11->Duration =
-			    RTMPCalcDuration(pAd, MlmeRate, 14);
-			if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
-			    && (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
-				bInsertTimestamp = TRUE;
-				bAckRequired = FALSE;	/* Disable ACK to prevent retry 0x1f for Probe Response */
-			} else
-			    if ((pHeader_802_11->FC.SubType ==
-				 SUBTYPE_PROBE_REQ)
-				&& (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
-				bAckRequired = FALSE;	/* Disable ACK to prevent retry 0x1f for Probe Request */
-			}
-		}
-	}
-
-	pHeader_802_11->Sequence = pAd->Sequence++;
-	if (pAd->Sequence > 0xfff)
-		pAd->Sequence = 0;
-
-	/* Before radar detection done, mgmt frame can not be sent but probe req */
-	/* Because we need to use probe req to trigger driver to send probe req in passive scan */
-	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
-	    && (pAd->CommonCfg.bIEEE80211H == 1)
-	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeHardTransmit --> radar detect not in normal mode!\n"));
-/*              if (!IrqState) */
-		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
-		return (NDIS_STATUS_FAILURE);
-	}
-
-	/* */
-	/* fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET */
-	/* should always has only one physical buffer, and the whole frame size equals */
-	/* to the first scatter buffer size */
-	/* */
-
-	/* Initialize TX Descriptor */
-	/* For inter-frame gap, the number is for this frame and next frame */
-	/* For MLME rate, we will fix as 2Mb to match other vendor's implement */
-/*      pAd->CommonCfg.MlmeTransmit.field.MODE = 1; */
-
-/* management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not. */
-	PID = PID_MGMT;
-
-	if (pMacEntry == NULL) {
-		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp,
-			      FALSE, bAckRequired, FALSE, 0, RESERVED_WCID,
-			      (SrcBufLen - TXINFO_SIZE - TXWI_SIZE), PID, 0,
-			      (u8)pAd->CommonCfg.MlmeTransmit.field.MCS,
-			      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	} else {
-		/* dont use low rate to send QoS Null data frame */
-		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE,
-			      bInsertTimestamp, FALSE, bAckRequired, FALSE,
-			      0, pMacEntry->Aid,
-			      (SrcBufLen - TXINFO_SIZE - TXWI_SIZE),
-			      pMacEntry->MaxHTPhyMode.field.MCS, 0,
-			      (u8)pMacEntry->MaxHTPhyMode.field.MCS,
-			      IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
-	}
-
-	/* Now do hardware-depened kick out. */
-	HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen);
-
-	/* Make sure to release MGMT ring resource */
-/*      if (!IrqState) */
-	RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
-	return NDIS_STATUS_SUCCESS;
-}
-
-/********************************************************************************
-
-	New DeQueue Procedures.
-
- ********************************************************************************/
-
-#define DEQUEUE_LOCK(lock, bIntContext, IrqFlags) 				\
-			do{													\
-				if (bIntContext == FALSE)						\
-				RTMP_IRQ_LOCK((lock), IrqFlags);		\
-			}while(0)
-
-#define DEQUEUE_UNLOCK(lock, bIntContext, IrqFlags)				\
-			do{													\
-				if (bIntContext == FALSE)						\
-					RTMP_IRQ_UNLOCK((lock), IrqFlags);	\
-			}while(0)
-
-/*
-	========================================================================
-	Tx Path design algorithm:
-		Basically, we divide the packets into four types, Broadcast/Multicast, 11N Rate(AMPDU, AMSDU, Normal), B/G Rate(ARALINK, Normal),
-		Specific Packet Type. Following show the classification rule and policy for each kinds of packets.
-				Classification Rule=>
-					Multicast: (*addr1 & 0x01) == 0x01
-					Specific : bDHCPFrame, bARPFrame, bEAPOLFrame, etc.
-					11N Rate : If peer support HT
-								(1).AMPDU  -- If TXBA is negotiated.
-								(2).AMSDU  -- If AMSDU is capable for both peer and ourself.
-											*). AMSDU can embedded in a AMPDU, but now we didn't support it.
-								(3).Normal -- Other packets which send as 11n rate.
-
-					B/G Rate : If peer is b/g only.
-								(1).ARALINK-- If both of peer/us supprot Ralink proprietary Aggregation and the TxRate is large than RATE_6
-								(2).Normal -- Other packets which send as b/g rate.
-					Fragment:
-								The packet must be unicast, NOT A-RALINK, NOT A-MSDU, NOT 11n, then can consider about fragment.
-
-				Classified Packet Handle Rule=>
-					Multicast:
-								No ACK, 		//pTxBlk->bAckRequired = FALSE;
-								No WMM, 		//pTxBlk->bWMM = FALSE;
-								No piggyback,   //pTxBlk->bPiggyBack = FALSE;
-								Force LowRate,  //pTxBlk->bForceLowRate = TRUE;
-					Specific :	Basically, for specific packet, we should handle it specifically, but now all specific packets are use
-									the same policy to handle it.
-								Force LowRate,  //pTxBlk->bForceLowRate = TRUE;
-
-					11N Rate :
-								No piggyback,	//pTxBlk->bPiggyBack = FALSE;
-
-								(1).AMSDU
-									pTxBlk->bWMM = TRUE;
-								(2).AMPDU
-									pTxBlk->bWMM = TRUE;
-								(3).Normal
-
-					B/G Rate :
-								(1).ARALINK
-
-								(2).Normal
-	========================================================================
-*/
-static u8 TxPktClassification(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	u8 TxFrameType = TX_UNKOWN_FRAME;
-	u8 Wcid;
-	struct rt_mac_table_entry *pMacEntry = NULL;
-	BOOLEAN bHTRate = FALSE;
-
-	Wcid = RTMP_GET_PACKET_WCID(pPacket);
-	if (Wcid == MCAST_WCID) {	/* Handle for RA is Broadcast/Multicast Address. */
-		return TX_MCAST_FRAME;
-	}
-	/* Handle for unicast packets */
-	pMacEntry = &pAd->MacTab.Content[Wcid];
-	if (RTMP_GET_PACKET_LOWRATE(pPacket)) {	/* It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame */
-		TxFrameType = TX_LEGACY_FRAME;
-	} else if (IS_HT_RATE(pMacEntry)) {	/* it's a 11n capable packet */
-
-		/* Depends on HTPhyMode to check if the peer support the HTRate transmission. */
-		/*      Currently didn't support A-MSDU embedded in A-MPDU */
-		bHTRate = TRUE;
-		if (RTMP_GET_PACKET_MOREDATA(pPacket)
-		    || (pMacEntry->PsMode == PWR_SAVE))
-			TxFrameType = TX_LEGACY_FRAME;
-		else if ((pMacEntry->
-			  TXBAbitmap & (1 << (RTMP_GET_PACKET_UP(pPacket)))) !=
-			 0)
-			return TX_AMPDU_FRAME;
-		else if (CLIENT_STATUS_TEST_FLAG
-			 (pMacEntry, fCLIENT_STATUS_AMSDU_INUSED))
-			return TX_AMSDU_FRAME;
-		else
-			TxFrameType = TX_LEGACY_FRAME;
-	} else {		/* it's a legacy b/g packet. */
-		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) && (RTMP_GET_PACKET_TXRATE(pPacket) >= RATE_6) && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	/* if peer support Ralink Aggregation, we use it. */
-			TxFrameType = TX_RALINK_FRAME;
-		} else {
-			TxFrameType = TX_LEGACY_FRAME;
-		}
-	}
-
-	/* Currently, our fragment only support when a unicast packet send as NOT-ARALINK, NOT-AMSDU and NOT-AMPDU. */
-	if ((RTMP_GET_PACKET_FRAGMENTS(pPacket) > 1)
-	    && (TxFrameType == TX_LEGACY_FRAME))
-		TxFrameType = TX_FRAG_FRAME;
-
-	return TxFrameType;
-}
-
-BOOLEAN RTMP_FillTxBlkInfo(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	struct rt_packet_info PacketInfo;
-	void *pPacket;
-	struct rt_mac_table_entry *pMacEntry = NULL;
-
-	pPacket = pTxBlk->pPacket;
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pTxBlk->pSrcBufHeader,
-			     &pTxBlk->SrcBufLen);
-
-	pTxBlk->Wcid = RTMP_GET_PACKET_WCID(pPacket);
-	pTxBlk->apidx = RTMP_GET_PACKET_IF(pPacket);
-	pTxBlk->UserPriority = RTMP_GET_PACKET_UP(pPacket);
-	pTxBlk->FrameGap = IFS_HTTXOP;	/* ASIC determine Frame Gap */
-
-	if (RTMP_GET_PACKET_CLEAR_EAP_FRAME(pTxBlk->pPacket))
-		TX_BLK_SET_FLAG(pTxBlk, fTX_bClearEAPFrame);
-	else
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bClearEAPFrame);
-
-	/* Default to clear this flag */
-	TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bForceNonQoS);
-
-	if (pTxBlk->Wcid == MCAST_WCID) {
-		pTxBlk->pMacEntry = NULL;
-		{
-			pTxBlk->pTransmit =
-			    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
-		}
-
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);	/* AckRequired = FALSE, when broadcast packet in Adhoc mode. */
-		/*TX_BLK_SET_FLAG(pTxBlk, fTX_bForceLowRate); */
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAllowFrag);
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
-		if (RTMP_GET_PACKET_MOREDATA(pPacket)) {
-			TX_BLK_SET_FLAG(pTxBlk, fTX_bMoreData);
-		}
-
-	} else {
-		pTxBlk->pMacEntry = &pAd->MacTab.Content[pTxBlk->Wcid];
-		pTxBlk->pTransmit = &pTxBlk->pMacEntry->HTPhyMode;
-
-		pMacEntry = pTxBlk->pMacEntry;
-
-		/* For all unicast packets, need Ack unless the Ack Policy is not set as NORMAL_ACK. */
-		if (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx] != NORMAL_ACK)
-			TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);
-		else
-			TX_BLK_SET_FLAG(pTxBlk, fTX_bAckRequired);
-
-		if ((pAd->OpMode == OPMODE_STA) &&
-		    (ADHOC_ON(pAd)) &&
-		    (RX_FILTER_TEST_FLAG(pAd, fRX_FILTER_ACCEPT_PROMISCUOUS))) {
-			if (pAd->CommonCfg.PSPXlink)
-				TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);
-		}
-
-		{
-			{
-
-				/* If support WMM, enable it. */
-				if (OPSTATUS_TEST_FLAG
-				    (pAd, fOP_STATUS_WMM_INUSED)
-				    && CLIENT_STATUS_TEST_FLAG(pMacEntry,
-							       fCLIENT_STATUS_WMM_CAPABLE))
-					TX_BLK_SET_FLAG(pTxBlk, fTX_bWMM);
-
-/*                              if (pAd->StaCfg.bAutoTxRateSwitch) */
-/*                                      TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch); */
-			}
-		}
-
-		if (pTxBlk->TxFrameType == TX_LEGACY_FRAME) {
-			if ((RTMP_GET_PACKET_LOWRATE(pPacket)) || ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1))) {	/* Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate. */
-				pTxBlk->pTransmit =
-				    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
-
-				/* Modify the WMM bit for ICV issue. If we have a packet with EOSP field need to set as 1, how to handle it??? */
-				if (IS_HT_STA(pTxBlk->pMacEntry) &&
-				    (CLIENT_STATUS_TEST_FLAG
-				     (pMacEntry, fCLIENT_STATUS_RALINK_CHIPSET))
-				    && ((pAd->CommonCfg.bRdg == TRUE)
-					&& CLIENT_STATUS_TEST_FLAG(pMacEntry,
-								   fCLIENT_STATUS_RDG_CAPABLE)))
-				{
-					TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
-					TX_BLK_SET_FLAG(pTxBlk,
-							fTX_bForceNonQoS);
-				}
-			}
-
-			if ((IS_HT_RATE(pMacEntry) == FALSE) && (CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE))) {	/* Currently piggy-back only support when peer is operate in b/g mode. */
-				TX_BLK_SET_FLAG(pTxBlk, fTX_bPiggyBack);
-			}
-
-			if (RTMP_GET_PACKET_MOREDATA(pPacket)) {
-				TX_BLK_SET_FLAG(pTxBlk, fTX_bMoreData);
-			}
-		} else if (pTxBlk->TxFrameType == TX_FRAG_FRAME) {
-			TX_BLK_SET_FLAG(pTxBlk, fTX_bAllowFrag);
-		}
-
-		pMacEntry->DebugTxCount++;
-	}
-
-	return TRUE;
-}
-
-BOOLEAN CanDoAggregateTransmit(struct rt_rtmp_adapter *pAd,
-			       char * pPacket, struct rt_tx_blk *pTxBlk)
-{
-
-	/*DBGPRINT(RT_DEBUG_TRACE, ("Check if can do aggregation! TxFrameType=%d!\n", pTxBlk->TxFrameType)); */
-
-	if (RTMP_GET_PACKET_WCID(pPacket) == MCAST_WCID)
-		return FALSE;
-
-	if (RTMP_GET_PACKET_DHCP(pPacket) ||
-	    RTMP_GET_PACKET_EAPOL(pPacket) || RTMP_GET_PACKET_WAI(pPacket))
-		return FALSE;
-
-	if ((pTxBlk->TxFrameType == TX_AMSDU_FRAME) && ((pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket)) > (RX_BUFFER_AGGRESIZE - 100))) {	/* For AMSDU, allow the packets with total length < max-amsdu size */
-		return FALSE;
-	}
-
-	if ((pTxBlk->TxFrameType == TX_RALINK_FRAME) && (pTxBlk->TxPacketList.Number == 2)) {	/* For RALINK-Aggregation, allow two frames in one batch. */
-		return FALSE;
-	}
-
-	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))	/* must be unicast to AP */
-		return TRUE;
-	else
-		return FALSE;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		To do the enqueue operation and extract the first item of waiting
-		list. If a number of available shared memory segments could meet
-		the request of extracted item, the extracted item will be fragmented
-		into shared memory segments.
-
-	Arguments:
-		pAd Pointer to our adapter
-		pQueue		Pointer to Waiting Queue
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPDeQueuePacket(struct rt_rtmp_adapter *pAd, IN BOOLEAN bIntContext, u8 QIdx,	/* BulkOutPipeId */
-		       u8 Max_Tx_Packets)
-{
-	struct rt_queue_entry *pEntry = NULL;
-	void *pPacket;
-	int Status = NDIS_STATUS_SUCCESS;
-	u8 Count = 0;
-	struct rt_queue_header *pQueue;
-	unsigned long FreeNumber[NUM_OF_TX_RING];
-	u8 QueIdx, sQIdx, eQIdx;
-	unsigned long IrqFlags = 0;
-	BOOLEAN hasTxDesc = FALSE;
-	struct rt_tx_blk TxBlk;
-	struct rt_tx_blk *pTxBlk;
-
-	if (QIdx == NUM_OF_TX_RING) {
-		sQIdx = 0;
-		eQIdx = 3;	/* 4 ACs, start from 0. */
-	} else {
-		sQIdx = eQIdx = QIdx;
-	}
-
-	for (QueIdx = sQIdx; QueIdx <= eQIdx; QueIdx++) {
-		Count = 0;
-
-		RTMP_START_DEQUEUE(pAd, QueIdx, IrqFlags);
-
-		while (1) {
-			if ((RTMP_TEST_FLAG
-			     (pAd,
-			      (fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS |
-			       fRTMP_ADAPTER_RADIO_OFF |
-			       fRTMP_ADAPTER_RESET_IN_PROGRESS |
-			       fRTMP_ADAPTER_HALT_IN_PROGRESS |
-			       fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-				RTMP_STOP_DEQUEUE(pAd, QueIdx, IrqFlags);
-				return;
-			}
-
-			if (Count >= Max_Tx_Packets)
-				break;
-
-			DEQUEUE_LOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-			if (&pAd->TxSwQueue[QueIdx] == NULL) {
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
-					       IrqFlags);
-				break;
-			}
-#ifdef RTMP_MAC_PCI
-			FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
-
-			if (FreeNumber[QueIdx] <= 5) {
-				/* free Tx(QueIdx) resources */
-				RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
-				FreeNumber[QueIdx] =
-				    GET_TXRING_FREENO(pAd, QueIdx);
-			}
-#endif /* RTMP_MAC_PCI // */
-
-			/* probe the Queue Head */
-			pQueue = &pAd->TxSwQueue[QueIdx];
-			pEntry = pQueue->Head;
-			if (pEntry == NULL) {
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
-					       IrqFlags);
-				break;
-			}
-
-			pTxBlk = &TxBlk;
-			NdisZeroMemory((u8 *)pTxBlk, sizeof(struct rt_tx_blk));
-			/*InitializeQueueHeader(&pTxBlk->TxPacketList);         // Didn't need it because we already memzero it. */
-			pTxBlk->QueIdx = QueIdx;
-
-			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-
-			/* Early check to make sure we have enoguh Tx Resource. */
-			hasTxDesc =
-			    RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk,
-						      FreeNumber[QueIdx],
-						      pPacket);
-			if (!hasTxDesc) {
-				pAd->PrivateInfo.TxRingFullCnt++;
-
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
-					       IrqFlags);
-
-				break;
-			}
-
-			pTxBlk->TxFrameType = TxPktClassification(pAd, pPacket);
-			pEntry = RemoveHeadQueue(pQueue);
-			pTxBlk->TotalFrameNum++;
-			pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	/* The real fragment number maybe vary */
-			pTxBlk->TotalFrameLen += GET_OS_PKT_LEN(pPacket);
-			pTxBlk->pPacket = pPacket;
-			InsertTailQueue(&pTxBlk->TxPacketList,
-					PACKET_TO_QUEUE_ENTRY(pPacket));
-
-			if (pTxBlk->TxFrameType == TX_RALINK_FRAME
-			    || pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
-				/* Enhance SW Aggregation Mechanism */
-				if (NEED_QUEUE_BACK_FOR_AGG
-				    (pAd, QueIdx, FreeNumber[QueIdx],
-				     pTxBlk->TxFrameType)) {
-					InsertHeadQueue(pQueue,
-							PACKET_TO_QUEUE_ENTRY
-							(pPacket));
-					DEQUEUE_UNLOCK(&pAd->irq_lock,
-						       bIntContext, IrqFlags);
-					break;
-				}
-
-				do {
-					pEntry = pQueue->Head;
-					if (pEntry == NULL)
-						break;
-
-					/* For TX_AMSDU_FRAME/TX_RALINK_FRAME, Need to check if next pakcet can do aggregation. */
-					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-					FreeNumber[QueIdx] =
-					    GET_TXRING_FREENO(pAd, QueIdx);
-					hasTxDesc =
-					    RTMP_HAS_ENOUGH_FREE_DESC(pAd,
-								      pTxBlk,
-								      FreeNumber
-								      [QueIdx],
-								      pPacket);
-					if ((hasTxDesc == FALSE)
-					    ||
-					    (CanDoAggregateTransmit
-					     (pAd, pPacket, pTxBlk) == FALSE))
-						break;
-
-					/*Remove the packet from the TxSwQueue and insert into pTxBlk */
-					pEntry = RemoveHeadQueue(pQueue);
-					ASSERT(pEntry);
-					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-					pTxBlk->TotalFrameNum++;
-					pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	/* The real fragment number maybe vary */
-					pTxBlk->TotalFrameLen +=
-					    GET_OS_PKT_LEN(pPacket);
-					InsertTailQueue(&pTxBlk->TxPacketList,
-							PACKET_TO_QUEUE_ENTRY
-							(pPacket));
-				} while (1);
-
-				if (pTxBlk->TxPacketList.Number == 1)
-					pTxBlk->TxFrameType = TX_LEGACY_FRAME;
-			}
-#ifdef RTMP_MAC_USB
-			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-#endif /* RTMP_MAC_USB // */
-			Count += pTxBlk->TxPacketList.Number;
-
-			/* Do HardTransmit now. */
-			Status = STAHardTransmit(pAd, pTxBlk, QueIdx);
-
-#ifdef RTMP_MAC_PCI
-			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-			/* static rate also need NICUpdateFifoStaCounters() function. */
-			/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
-			NICUpdateFifoStaCounters(pAd);
-#endif /* RTMP_MAC_PCI // */
-
-		}
-
-		RTMP_STOP_DEQUEUE(pAd, QueIdx, IrqFlags);
-
-#ifdef RTMP_MAC_USB
-		if (!hasTxDesc)
-			RTUSBKickBulkOut(pAd);
-#endif /* RTMP_MAC_USB // */
-	}
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Calculates the duration which is required to transmit out frames
-	with given size and specified rate.
-
-	Arguments:
-		pAd 	Pointer to our adapter
-		Rate			Transmit rate
-		Size			Frame size in units of byte
-
-	Return Value:
-		Duration number in units of usec
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-u16 RTMPCalcDuration(struct rt_rtmp_adapter *pAd, u8 Rate, unsigned long Size)
-{
-	unsigned long Duration = 0;
-
-	if (Rate < RATE_FIRST_OFDM_RATE)	/* CCK */
-	{
-		if ((Rate > RATE_1)
-		    && OPSTATUS_TEST_FLAG(pAd,
-					  fOP_STATUS_SHORT_PREAMBLE_INUSED))
-			Duration = 96;	/* 72+24 preamble+plcp */
-		else
-			Duration = 192;	/* 144+48 preamble+plcp */
-
-		Duration += (u16)((Size << 4) / RateIdTo500Kbps[Rate]);
-		if ((Size << 4) % RateIdTo500Kbps[Rate])
-			Duration++;
-	} else if (Rate <= RATE_LAST_OFDM_RATE)	/* OFDM rates */
-	{
-		Duration = 20 + 6;	/* 16+4 preamble+plcp + Signal Extension */
-		Duration +=
-		    4 * (u16)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
-		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
-			Duration += 4;
-	} else			/*mimo rate */
-	{
-		Duration = 20 + 6;	/* 16+4 preamble+plcp + Signal Extension */
-	}
-
-	return (u16)Duration;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Calculates the duration which is required to transmit out frames
-	with given size and specified rate.
-
-	Arguments:
-		pTxWI		Pointer to head of each MPDU to HW.
-		Ack 		Setting for Ack requirement bit
-		Fragment	Setting for Fragment bit
-		RetryMode	Setting for retry mode
-		Ifs 		Setting for IFS gap
-		Rate		Setting for transmit rate
-		Service 	Setting for service
-		Length		Frame length
-		TxPreamble	Short or Long preamble when using CCK rates
-		QueIdx - 0-3, according to 802.11e/d4.4 June/2003
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-    See also : BASmartHardTransmit()    !
-
-	========================================================================
-*/
-void RTMPWriteTxWI(struct rt_rtmp_adapter *pAd, struct rt_txwi * pOutTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	/* HW new a sequence. */
-		   u8 BASize,
-		   u8 WCID,
-		   unsigned long Length,
-		   u8 PID,
-		   u8 TID,
-		   u8 TxRate,
-		   u8 Txopmode,
-		   IN BOOLEAN CfAck, IN HTTRANSMIT_SETTING * pTransmit)
-{
-	struct rt_mac_table_entry *pMac = NULL;
-	struct rt_txwi TxWI;
-	struct rt_txwi * pTxWI;
-
-	if (WCID < MAX_LEN_OF_MAC_TABLE)
-		pMac = &pAd->MacTab.Content[WCID];
-
-	/* */
-	/* Always use Long preamble before verifiation short preamble functionality works well. */
-	/* Todo: remove the following line if short preamble functionality works */
-	/* */
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
-	NdisZeroMemory(&TxWI, TXWI_SIZE);
-	pTxWI = &TxWI;
-
-	pTxWI->FRAG = FRAG;
-
-	pTxWI->CFACK = CFACK;
-	pTxWI->TS = InsTimestamp;
-	pTxWI->AMPDU = AMPDU;
-	pTxWI->ACK = Ack;
-	pTxWI->txop = Txopmode;
-
-	pTxWI->NSEQ = NSeq;
-	/* John tune the performace with Intel Client in 20 MHz performance */
-	BASize = pAd->CommonCfg.TxBASize;
-	if (pAd->MACVersion == 0x28720200) {
-		if (BASize > 13)
-			BASize = 13;
-	} else {
-		if (BASize > 7)
-			BASize = 7;
-	}
-	pTxWI->BAWinSize = BASize;
-	pTxWI->ShortGI = pTransmit->field.ShortGI;
-	pTxWI->STBC = pTransmit->field.STBC;
-
-	pTxWI->WirelessCliID = WCID;
-	pTxWI->MPDUtotalByteCount = Length;
-	pTxWI->PacketId = PID;
-
-	/* If CCK or OFDM, BW must be 20 */
-	pTxWI->BW =
-	    (pTransmit->field.MODE <=
-	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
-
-	pTxWI->MCS = pTransmit->field.MCS;
-	pTxWI->PHYMODE = pTransmit->field.MODE;
-	pTxWI->CFACK = CfAck;
-
-	if (pMac) {
-		if (pAd->CommonCfg.bMIMOPSEnable) {
-			if ((pMac->MmpsMode == MMPS_DYNAMIC)
-			    && (pTransmit->field.MCS > 7)) {
-				/* Dynamic MIMO Power Save Mode */
-				pTxWI->MIMOps = 1;
-			} else if (pMac->MmpsMode == MMPS_STATIC) {
-				/* Static MIMO Power Save Mode */
-				if (pTransmit->field.MODE >= MODE_HTMIX
-				    && pTransmit->field.MCS > 7) {
-					pTxWI->MCS = 7;
-					pTxWI->MIMOps = 0;
-				}
-			}
-		}
-		/*pTxWI->MIMOps = (pMac->PsMode == PWR_MMPS)? 1:0; */
-		if (pMac->bIAmBadAtheros
-		    && (pMac->WepStatus != Ndis802_11WEPDisabled)) {
-			pTxWI->MpduDensity = 7;
-		} else {
-			pTxWI->MpduDensity = pMac->MpduDensity;
-		}
-	}
-
-	pTxWI->PacketId = pTxWI->MCS;
-	NdisMoveMemory(pOutTxWI, &TxWI, sizeof(struct rt_txwi));
-}
-
-void RTMPWriteTxWI_Data(struct rt_rtmp_adapter *pAd,
-			struct rt_txwi * pTxWI, struct rt_tx_blk *pTxBlk)
-{
-	HTTRANSMIT_SETTING *pTransmit;
-	struct rt_mac_table_entry *pMacEntry;
-	u8 BASize;
-
-	ASSERT(pTxWI);
-
-	pTransmit = pTxBlk->pTransmit;
-	pMacEntry = pTxBlk->pMacEntry;
-
-	/* */
-	/* Always use Long preamble before verifiation short preamble functionality works well. */
-	/* Todo: remove the following line if short preamble functionality works */
-	/* */
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
-	NdisZeroMemory(pTxWI, TXWI_SIZE);
-
-	pTxWI->FRAG = TX_BLK_TEST_FLAG(pTxBlk, fTX_bAllowFrag);
-	pTxWI->ACK = TX_BLK_TEST_FLAG(pTxBlk, fTX_bAckRequired);
-	pTxWI->txop = pTxBlk->FrameGap;
-
-	pTxWI->WirelessCliID = pTxBlk->Wcid;
-
-	pTxWI->MPDUtotalByteCount = pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
-	pTxWI->CFACK = TX_BLK_TEST_FLAG(pTxBlk, fTX_bPiggyBack);
-
-	/* If CCK or OFDM, BW must be 20 */
-	pTxWI->BW =
-	    (pTransmit->field.MODE <=
-	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
-	pTxWI->AMPDU = ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) ? TRUE : FALSE);
-
-	/* John tune the performace with Intel Client in 20 MHz performance */
-	BASize = pAd->CommonCfg.TxBASize;
-	if ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) && (pMacEntry)) {
-		u8 RABAOriIdx = 0;	/*The RA's BA Originator table index. */
-
-		RABAOriIdx =
-		    pTxBlk->pMacEntry->BAOriWcidArray[pTxBlk->UserPriority];
-		BASize = pAd->BATable.BAOriEntry[RABAOriIdx].BAWinSize;
-	}
-
-	pTxWI->TxBF = pTransmit->field.TxBF;
-	pTxWI->BAWinSize = BASize;
-	pTxWI->ShortGI = pTransmit->field.ShortGI;
-	pTxWI->STBC = pTransmit->field.STBC;
-
-	pTxWI->MCS = pTransmit->field.MCS;
-	pTxWI->PHYMODE = pTransmit->field.MODE;
-
-	if (pMacEntry) {
-		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
-		    && (pTransmit->field.MCS > 7)) {
-			/* Dynamic MIMO Power Save Mode */
-			pTxWI->MIMOps = 1;
-		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
-			/* Static MIMO Power Save Mode */
-			if (pTransmit->field.MODE >= MODE_HTMIX
-			    && pTransmit->field.MCS > 7) {
-				pTxWI->MCS = 7;
-				pTxWI->MIMOps = 0;
-			}
-		}
-
-		if (pMacEntry->bIAmBadAtheros
-		    && (pMacEntry->WepStatus != Ndis802_11WEPDisabled)) {
-			pTxWI->MpduDensity = 7;
-		} else {
-			pTxWI->MpduDensity = pMacEntry->MpduDensity;
-		}
-	}
-
-	/* for rate adapation */
-	pTxWI->PacketId = pTxWI->MCS;
-}
-
-void RTMPWriteTxWI_Cache(struct rt_rtmp_adapter *pAd,
-			 struct rt_txwi * pTxWI, struct rt_tx_blk *pTxBlk)
-{
-	PHTTRANSMIT_SETTING /*pTxHTPhyMode, */ pTransmit;
-	struct rt_mac_table_entry *pMacEntry;
-
-	/* */
-	/* update TXWI */
-	/* */
-	pMacEntry = pTxBlk->pMacEntry;
-	pTransmit = pTxBlk->pTransmit;
-
-	/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
-	/*if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pMacEntry)) */
-	/*if (TX_BLK_TEST_FLAG(pTxBlk, fTX_AutoRateSwitch)) */
-	if (pMacEntry->bAutoTxRateSwitch) {
-		pTxWI->txop = IFS_HTTXOP;
-
-		/* If CCK or OFDM, BW must be 20 */
-		pTxWI->BW =
-		    (pTransmit->field.MODE <=
-		     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
-		pTxWI->ShortGI = pTransmit->field.ShortGI;
-		pTxWI->STBC = pTransmit->field.STBC;
-
-		pTxWI->MCS = pTransmit->field.MCS;
-		pTxWI->PHYMODE = pTransmit->field.MODE;
-
-		/* set PID for TxRateSwitching */
-		pTxWI->PacketId = pTransmit->field.MCS;
-	}
-
-	pTxWI->AMPDU = ((pMacEntry->NoBADataCountDown == 0) ? TRUE : FALSE);
-	pTxWI->MIMOps = 0;
-
-	if (pAd->CommonCfg.bMIMOPSEnable) {
-		/* MIMO Power Save Mode */
-		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
-		    && (pTransmit->field.MCS > 7)) {
-			/* Dynamic MIMO Power Save Mode */
-			pTxWI->MIMOps = 1;
-		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
-			/* Static MIMO Power Save Mode */
-			if ((pTransmit->field.MODE >= MODE_HTMIX)
-			    && (pTransmit->field.MCS > 7)) {
-				pTxWI->MCS = 7;
-				pTxWI->MIMOps = 0;
-			}
-		}
-	}
-
-	pTxWI->MPDUtotalByteCount = pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
-
-}
-
-/* should be called only when - */
-/* 1. MEADIA_CONNECTED */
-/* 2. AGGREGATION_IN_USED */
-/* 3. Fragmentation not in used */
-/* 4. either no previous frame (pPrevAddr1=NULL) .OR. previoud frame is aggregatible */
-BOOLEAN TxFrameIsAggregatible(struct rt_rtmp_adapter *pAd,
-			      u8 *pPrevAddr1, u8 *p8023hdr)
-{
-
-	/* can't aggregate EAPOL (802.1x) frame */
-	if ((p8023hdr[12] == 0x88) && (p8023hdr[13] == 0x8e))
-		return FALSE;
-
-	/* can't aggregate multicast/broadcast frame */
-	if (p8023hdr[0] & 0x01)
-		return FALSE;
-
-	if (INFRA_ON(pAd))	/* must be unicast to AP */
-		return TRUE;
-	else if ((pPrevAddr1 == NULL) || MAC_ADDR_EQUAL(pPrevAddr1, p8023hdr))	/* unicast to same STA */
-		return TRUE;
-	else
-		return FALSE;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	   Check the MSDU Aggregation policy
-	1.HT aggregation is A-MSDU
-	2.legaacy rate aggregation is software aggregation by Ralink.
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-BOOLEAN PeerIsAggreOn(struct rt_rtmp_adapter *pAd,
-		      unsigned long TxRate, struct rt_mac_table_entry *pMacEntry)
-{
-	unsigned long AFlags =
-	    (fCLIENT_STATUS_AMSDU_INUSED | fCLIENT_STATUS_AGGREGATION_CAPABLE);
-
-	if (pMacEntry != NULL && CLIENT_STATUS_TEST_FLAG(pMacEntry, AFlags)) {
-		if (pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX) {
-			return TRUE;
-		}
-#ifdef AGGREGATION_SUPPORT
-		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	/* legacy  Ralink Aggregation support */
-			return TRUE;
-		}
-#endif /* AGGREGATION_SUPPORT // */
-	}
-
-	return FALSE;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Check and fine the packet waiting in SW queue with highest priority
-
-	Arguments:
-		pAd Pointer to our adapter
-
-	Return Value:
-		pQueue		Pointer to Waiting Queue
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-struct rt_queue_header *RTMPCheckTxSwQueue(struct rt_rtmp_adapter *pAd, u8 *pQueIdx)
-{
-
-	unsigned long Number;
-	/* 2004-11-15 to be removed. test aggregation only */
-/*      if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2)) */
-/*               return NULL; */
-
-	Number = pAd->TxSwQueue[QID_AC_BK].Number
-	    + pAd->TxSwQueue[QID_AC_BE].Number
-	    + pAd->TxSwQueue[QID_AC_VI].Number
-	    + pAd->TxSwQueue[QID_AC_VO].Number;
-
-	if (pAd->TxSwQueue[QID_AC_VO].Head != NULL) {
-		*pQueIdx = QID_AC_VO;
-		return (&pAd->TxSwQueue[QID_AC_VO]);
-	} else if (pAd->TxSwQueue[QID_AC_VI].Head != NULL) {
-		*pQueIdx = QID_AC_VI;
-		return (&pAd->TxSwQueue[QID_AC_VI]);
-	} else if (pAd->TxSwQueue[QID_AC_BE].Head != NULL) {
-		*pQueIdx = QID_AC_BE;
-		return (&pAd->TxSwQueue[QID_AC_BE]);
-	} else if (pAd->TxSwQueue[QID_AC_BK].Head != NULL) {
-		*pQueIdx = QID_AC_BK;
-		return (&pAd->TxSwQueue[QID_AC_BK]);
-	}
-	/* No packet pending in Tx Sw queue */
-	*pQueIdx = QID_AC_BK;
-
-	return (NULL);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Suspend MSDU transmission
-
-	Arguments:
-		pAd 	Pointer to our adapter
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void RTMPSuspendMsduTransmission(struct rt_rtmp_adapter *pAd)
-{
-	DBGPRINT(RT_DEBUG_TRACE, ("SCANNING, suspend MSDU transmission ...\n"));
-
-	/* */
-	/* Before BSS_SCAN_IN_PROGRESS, we need to keep Current R66 value and */
-	/* use Lowbound as R66 value on ScanNextChannel(...) */
-	/* */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
-				    &pAd->BbpTuning.R66CurrentValue);
-
-	/* set BBP_R66 to 0x30/0x40 when scanning (AsicSwitchChannel will set R66 according to channel when scanning) */
-	/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x26 + GET_LNA_GAIN(pAd))); */
-	RTMPSetAGCInitValue(pAd, BW_20);
-
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	/*RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);                // abort all TX rings */
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Resume MSDU transmission
-
-	Arguments:
-		pAd 	Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPResumeMsduTransmission(struct rt_rtmp_adapter *pAd)
-{
-/*    u8                     IrqState; */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("SCAN done, resume MSDU transmission ...\n"));
-
-	/* After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R66 value */
-	/* R66 should not be 0 */
-	if (pAd->BbpTuning.R66CurrentValue == 0) {
-		pAd->BbpTuning.R66CurrentValue = 0x38;
-		DBGPRINT_ERR("RTMPResumeMsduTransmission, R66CurrentValue=0...\n");
-	}
-
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66,
-				     pAd->BbpTuning.R66CurrentValue);
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-/* sample, for IRQ LOCK to SEM LOCK */
-/*    IrqState = pAd->irq_disabled; */
-/*      if (IrqState) */
-/*              RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS); */
-/*    else */
-	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-}
-
-u32 deaggregate_AMSDU_announce(struct rt_rtmp_adapter *pAd,
-				void *pPacket,
-				u8 *pData, unsigned long DataSize)
-{
-	u16 PayloadSize;
-	u16 SubFrameSize;
-	struct rt_header_802_3 * pAMSDUsubheader;
-	u32 nMSDU;
-	u8 Header802_3[14];
-
-	u8 *pPayload, *pDA, *pSA, *pRemovedLLCSNAP;
-	void *pClonePacket;
-
-	nMSDU = 0;
-
-	while (DataSize > LENGTH_802_3) {
-
-		nMSDU++;
-
-		/*hex_dump("subheader", pData, 64); */
-		pAMSDUsubheader = (struct rt_header_802_3 *) pData;
-		/*pData += LENGTH_802_3; */
-		PayloadSize =
-		    pAMSDUsubheader->Octet[1] +
-		    (pAMSDUsubheader->Octet[0] << 8);
-		SubFrameSize = PayloadSize + LENGTH_802_3;
-
-		if ((DataSize < SubFrameSize) || (PayloadSize > 1518)) {
-			break;
-		}
-		/*DBGPRINT(RT_DEBUG_TRACE,("%d subframe: Size = %d\n",  nMSDU, PayloadSize)); */
-
-		pPayload = pData + LENGTH_802_3;
-		pDA = pData;
-		pSA = pData + MAC_ADDR_LEN;
-
-		/* convert to 802.3 header */
-		CONVERT_TO_802_3(Header802_3, pDA, pSA, pPayload, PayloadSize,
-				 pRemovedLLCSNAP);
-
-		if ((Header802_3[12] == 0x88) && (Header802_3[13] == 0x8E)) {
-			/* avoid local heap overflow, use dyanamic allocation */
-			struct rt_mlme_queue_elem *Elem =
-			    kmalloc(sizeof(struct rt_mlme_queue_elem),
-							MEM_ALLOC_FLAG);
-			if (Elem != NULL) {
-				memmove(Elem->Msg +
-					(LENGTH_802_11 + LENGTH_802_1_H),
-					pPayload, PayloadSize);
-				Elem->MsgLen =
-				    LENGTH_802_11 + LENGTH_802_1_H +
-				    PayloadSize;
-				/*WpaEAPOLKeyAction(pAd, Elem); */
-				REPORT_MGMT_FRAME_TO_MLME(pAd, BSSID_WCID,
-							  Elem->Msg,
-							  Elem->MsgLen, 0, 0, 0,
-							  0);
-				kfree(Elem);
-			}
-		}
-
-		{
-			if (pRemovedLLCSNAP) {
-				pPayload -= LENGTH_802_3;
-				PayloadSize += LENGTH_802_3;
-				NdisMoveMemory(pPayload, &Header802_3[0],
-					       LENGTH_802_3);
-			}
-		}
-
-		pClonePacket = ClonePacket(pAd, pPacket, pPayload, PayloadSize);
-		if (pClonePacket) {
-			ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pClonePacket,
-							 RTMP_GET_PACKET_IF
-							 (pPacket));
-		}
-
-		/* A-MSDU has padding to multiple of 4 including subframe header. */
-		/* align SubFrameSize up to multiple of 4 */
-		SubFrameSize = (SubFrameSize + 3) & (~0x3);
-
-		if (SubFrameSize > 1528 || SubFrameSize < 32) {
-			break;
-		}
-
-		if (DataSize > SubFrameSize) {
-			pData += SubFrameSize;
-			DataSize -= SubFrameSize;
-		} else {
-			/* end of A-MSDU */
-			DataSize = 0;
-		}
-	}
-
-	/* finally release original rx packet */
-	RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
-
-	return nMSDU;
-}
-
-u32 BA_Reorder_AMSDU_Announce(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	u8 *pData;
-	u16 DataSize;
-	u32 nMSDU = 0;
-
-	pData = (u8 *)GET_OS_PKT_DATAPTR(pPacket);
-	DataSize = (u16)GET_OS_PKT_LEN(pPacket);
-
-	nMSDU = deaggregate_AMSDU_announce(pAd, pPacket, pData, DataSize);
-
-	return nMSDU;
-}
-
-/*
-	==========================================================================
-	Description:
-		Look up the MAC address in the MAC table. Return NULL if not found.
-	Return:
-		pEntry - pointer to the MAC entry; NULL is not found
-	==========================================================================
-*/
-struct rt_mac_table_entry *MacTableLookup(struct rt_rtmp_adapter *pAd, u8 *pAddr)
-{
-	unsigned long HashIdx;
-	struct rt_mac_table_entry *pEntry = NULL;
-
-	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-	pEntry = pAd->MacTab.Hash[HashIdx];
-
-	while (pEntry
-	       && (pEntry->ValidAsCLI || pEntry->ValidAsWDS
-		   || pEntry->ValidAsApCli || pEntry->ValidAsMesh)) {
-		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr)) {
-			break;
-		} else
-			pEntry = pEntry->pNext;
-	}
-
-	return pEntry;
-}
-
-struct rt_mac_table_entry *MacTableInsertEntry(struct rt_rtmp_adapter *pAd,
-				     u8 *pAddr,
-				     u8 apidx, IN BOOLEAN CleanAll)
-{
-	u8 HashIdx;
-	int i, FirstWcid;
-	struct rt_mac_table_entry *pEntry = NULL, *pCurrEntry;
-/*      u16  offset; */
-/*      unsigned long   addr; */
-
-	/* if FULL, return */
-	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
-		return NULL;
-
-	FirstWcid = 1;
-
-	if (pAd->StaCfg.BssType == BSS_INFRA)
-		FirstWcid = 2;
-
-	/* allocate one MAC entry */
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-	for (i = FirstWcid; i < MAX_LEN_OF_MAC_TABLE; i++)	/* skip entry#0 so that "entry index == AID" for fast lookup */
-	{
-		/* pick up the first available vacancy */
-		if ((pAd->MacTab.Content[i].ValidAsCLI == FALSE) &&
-		    (pAd->MacTab.Content[i].ValidAsWDS == FALSE) &&
-		    (pAd->MacTab.Content[i].ValidAsApCli == FALSE) &&
-		    (pAd->MacTab.Content[i].ValidAsMesh == FALSE)
-		    ) {
-			pEntry = &pAd->MacTab.Content[i];
-			if (CleanAll == TRUE) {
-				pEntry->MaxSupportedRate = RATE_11;
-				pEntry->CurrTxRate = RATE_11;
-				NdisZeroMemory(pEntry, sizeof(struct rt_mac_table_entry));
-				pEntry->PairwiseKey.KeyLen = 0;
-				pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
-			}
-			{
-				{
-					pEntry->ValidAsCLI = TRUE;
-					pEntry->ValidAsWDS = FALSE;
-					pEntry->ValidAsApCli = FALSE;
-					pEntry->ValidAsMesh = FALSE;
-					pEntry->ValidAsDls = FALSE;
-				}
-			}
-
-			pEntry->bIAmBadAtheros = FALSE;
-			pEntry->pAd = pAd;
-			pEntry->CMTimerRunning = FALSE;
-			pEntry->EnqueueEapolStartTimerRunning =
-			    EAPOL_START_DISABLE;
-			pEntry->RSNIE_Len = 0;
-			NdisZeroMemory(pEntry->R_Counter,
-				       sizeof(pEntry->R_Counter));
-			pEntry->ReTryCounter = PEER_MSG1_RETRY_TIMER_CTR;
-
-			if (pEntry->ValidAsMesh)
-				pEntry->apidx =
-				    (apidx - MIN_NET_DEVICE_FOR_MESH);
-			else if (pEntry->ValidAsApCli)
-				pEntry->apidx =
-				    (apidx - MIN_NET_DEVICE_FOR_APCLI);
-			else if (pEntry->ValidAsWDS)
-				pEntry->apidx =
-				    (apidx - MIN_NET_DEVICE_FOR_WDS);
-			else
-				pEntry->apidx = apidx;
-
-			{
-				{
-					pEntry->AuthMode = pAd->StaCfg.AuthMode;
-					pEntry->WepStatus =
-					    pAd->StaCfg.WepStatus;
-					pEntry->PrivacyFilter =
-					    Ndis802_11PrivFilterAcceptAll;
-#ifdef RTMP_MAC_PCI
-					AsicRemovePairwiseKeyEntry(pAd,
-								   pEntry->
-								   apidx,
-								   (u8)i);
-#endif /* RTMP_MAC_PCI // */
-				}
-			}
-
-			pEntry->GTKState = REKEY_NEGOTIATING;
-			pEntry->PairwiseKey.KeyLen = 0;
-			pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
-			pEntry->PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-
-			pEntry->PMKID_CacheIdx = ENTRY_NOT_FOUND;
-			COPY_MAC_ADDR(pEntry->Addr, pAddr);
-			pEntry->Sst = SST_NOT_AUTH;
-			pEntry->AuthState = AS_NOT_AUTH;
-			pEntry->Aid = (u16)i;	/*0; */
-			pEntry->CapabilityInfo = 0;
-			pEntry->PsMode = PWR_ACTIVE;
-			pEntry->PsQIdleCount = 0;
-			pEntry->NoDataIdleCount = 0;
-			pEntry->AssocDeadLine = MAC_TABLE_ASSOC_TIMEOUT;
-			pEntry->ContinueTxFailCnt = 0;
-			InitializeQueueHeader(&pEntry->PsQueue);
-
-			pAd->MacTab.Size++;
-			/* Add this entry into ASIC RX WCID search table */
-			RTMP_STA_ENTRY_ADD(pAd, pEntry);
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MacTableInsertEntry - allocate entry #%d, Total= %d\n",
-				  i, pAd->MacTab.Size));
-			break;
-		}
-	}
-
-	/* add this MAC entry into HASH table */
-	if (pEntry) {
-		HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-		if (pAd->MacTab.Hash[HashIdx] == NULL) {
-			pAd->MacTab.Hash[HashIdx] = pEntry;
-		} else {
-			pCurrEntry = pAd->MacTab.Hash[HashIdx];
-			while (pCurrEntry->pNext != NULL)
-				pCurrEntry = pCurrEntry->pNext;
-			pCurrEntry->pNext = pEntry;
-		}
-	}
-
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-	return pEntry;
-}
-
-/*
-	==========================================================================
-	Description:
-		Delete a specified client from MAC table
-	==========================================================================
- */
-BOOLEAN MacTableDeleteEntry(struct rt_rtmp_adapter *pAd,
-			    u16 wcid, u8 *pAddr)
-{
-	u16 HashIdx;
-	struct rt_mac_table_entry *pEntry, *pPrevEntry, *pProbeEntry;
-	BOOLEAN Cancelled;
-	/*u16        offset; // unused variable */
-	/*u8 j;                      // unused variable */
-
-	if (wcid >= MAX_LEN_OF_MAC_TABLE)
-		return FALSE;
-
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-
-	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-	/*pEntry = pAd->MacTab.Hash[HashIdx]; */
-	pEntry = &pAd->MacTab.Content[wcid];
-
-	if (pEntry
-	    && (pEntry->ValidAsCLI || pEntry->ValidAsApCli || pEntry->ValidAsWDS
-		|| pEntry->ValidAsMesh)) {
-		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr)) {
-
-			/* Delete this entry from ASIC on-chip WCID Table */
-			RTMP_STA_ENTRY_MAC_RESET(pAd, wcid);
-
-			/* free resources of BA */
-			BASessionTearDownALL(pAd, pEntry->Aid);
-
-			pPrevEntry = NULL;
-			pProbeEntry = pAd->MacTab.Hash[HashIdx];
-			ASSERT(pProbeEntry);
-
-			/* update Hash list */
-			do {
-				if (pProbeEntry == pEntry) {
-					if (pPrevEntry == NULL) {
-						pAd->MacTab.Hash[HashIdx] =
-						    pEntry->pNext;
-					} else {
-						pPrevEntry->pNext =
-						    pEntry->pNext;
-					}
-					break;
-				}
-
-				pPrevEntry = pProbeEntry;
-				pProbeEntry = pProbeEntry->pNext;
-			} while (pProbeEntry);
-
-			/* not found ! */
-			ASSERT(pProbeEntry != NULL);
-
-			RTMP_STA_ENTRY_KEY_DEL(pAd, BSS0, wcid);
-
-			if (pEntry->EnqueueEapolStartTimerRunning !=
-			    EAPOL_START_DISABLE) {
-				RTMPCancelTimer(&pEntry->
-						EnqueueStartForPSKTimer,
-						&Cancelled);
-				pEntry->EnqueueEapolStartTimerRunning =
-				    EAPOL_START_DISABLE;
-			}
-
-			NdisZeroMemory(pEntry, sizeof(struct rt_mac_table_entry));
-			pAd->MacTab.Size--;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MacTableDeleteEntry1 - Total= %d\n",
-				  pAd->MacTab.Size));
-		} else {
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("\n%s: Impossible Wcid = %d !\n",
-				  __func__, wcid));
-		}
-	}
-
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-
-	/*Reset operating mode when no Sta. */
-	if (pAd->MacTab.Size == 0) {
-		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
-		RTMP_UPDATE_PROTECT(pAd);	/* edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
-	}
-
-	return TRUE;
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine reset the entire MAC table. All packets pending in
-		the power-saving queues are freed here.
-	==========================================================================
- */
-void MacTableReset(struct rt_rtmp_adapter *pAd)
-{
-	int i;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("MacTableReset\n"));
-	/*NdisAcquireSpinLock(&pAd->MacTabLock); */
-
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
-#ifdef RTMP_MAC_PCI
-		RTMP_STA_ENTRY_MAC_RESET(pAd, i);
-#endif /* RTMP_MAC_PCI // */
-		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE) {
-
-			/* free resources of BA */
-			BASessionTearDownALL(pAd, i);
-
-			pAd->MacTab.Content[i].ValidAsCLI = FALSE;
-
-#ifdef RTMP_MAC_USB
-			NdisZeroMemory(pAd->MacTab.Content[i].Addr, 6);
-			RTMP_STA_ENTRY_MAC_RESET(pAd, i);
-#endif /* RTMP_MAC_USB // */
-
-			/*AsicDelWcidTab(pAd, i); */
-		}
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void AssocParmFill(struct rt_rtmp_adapter *pAd,
-		   struct rt_mlme_assoc_req *AssocReq,
-		   u8 *pAddr,
-		   u16 CapabilityInfo,
-		   unsigned long Timeout, u16 ListenIntv)
-{
-	COPY_MAC_ADDR(AssocReq->Addr, pAddr);
-	/* Add mask to support 802.11b mode only */
-	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;	/* not cf-pollable, not cf-poll-request */
-	AssocReq->Timeout = Timeout;
-	AssocReq->ListenIntv = ListenIntv;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void DisassocParmFill(struct rt_rtmp_adapter *pAd,
-		      struct rt_mlme_disassoc_req *DisassocReq,
-		      u8 *pAddr, u16 Reason)
-{
-	COPY_MAC_ADDR(DisassocReq->Addr, pAddr);
-	DisassocReq->Reason = Reason;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Check the out going frame, if this is an DHCP or ARP datagram
-	will be duplicate another frame at low data rate transmit.
-
-	Arguments:
-		pAd 		Pointer to our adapter
-		pPacket 	Pointer to outgoing Ndis frame
-
-	Return Value:
-		TRUE		To be duplicate at Low data rate transmit. (1mb)
-		FALSE		Do nothing.
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-		MAC header + IP Header + UDP Header
-		  14 Bytes	  20 Bytes
-
-		UDP Header
-		00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|
-						Source Port
-		16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
-					Destination Port
-
-		port 0x43 means Bootstrap Protocol, server.
-		Port 0x44 means Bootstrap Protocol, client.
-
-	========================================================================
-*/
-
-BOOLEAN RTMPCheckDHCPFrame(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	struct rt_packet_info PacketInfo;
-	unsigned long NumberOfBytesRead = 0;
-	unsigned long CurrentOffset = 0;
-	void *pVirtualAddress = NULL;
-	u32 NdisBufferLength;
-	u8 *pSrc;
-	u16 Protocol;
-	u8 ByteOffset36 = 0;
-	u8 ByteOffset38 = 0;
-	BOOLEAN ReadFirstParm = TRUE;
-
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, (u8 **) & pVirtualAddress,
-			     &NdisBufferLength);
-
-	NumberOfBytesRead += NdisBufferLength;
-	pSrc = (u8 *)pVirtualAddress;
-	Protocol = *(pSrc + 12) * 256 + *(pSrc + 13);
-
-	/* */
-	/* Check DHCP & BOOTP protocol */
-	/* */
-	while (NumberOfBytesRead <= PacketInfo.TotalPacketLength) {
-		if ((NumberOfBytesRead >= 35) && (ReadFirstParm == TRUE)) {
-			CurrentOffset =
-			    35 - (NumberOfBytesRead - NdisBufferLength);
-			ByteOffset36 = *(pSrc + CurrentOffset);
-			ReadFirstParm = FALSE;
-		}
-
-		if (NumberOfBytesRead >= 37) {
-			CurrentOffset =
-			    37 - (NumberOfBytesRead - NdisBufferLength);
-			ByteOffset38 = *(pSrc + CurrentOffset);
-			/*End of Read */
-			break;
-		}
-		return FALSE;
-	}
-
-	/* Check for DHCP & BOOTP protocol */
-	if ((ByteOffset36 != 0x44) || (ByteOffset38 != 0x43)) {
-		/* */
-		/* 2054 (hex 0806) for ARP datagrams */
-		/* if this packet is not ARP datagrams, then do nothing */
-		/* ARP datagrams will also be duplicate at 1mb broadcast frames */
-		/* */
-		if (Protocol != 0x0806)
-			return FALSE;
-	}
-
-	return TRUE;
-}
-
-BOOLEAN RTMPCheckEtherType(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	u16 TypeLen;
-	u8 Byte0, Byte1;
-	u8 *pSrcBuf;
-	u32 pktLen;
-	u16 srcPort, dstPort;
-	BOOLEAN status = TRUE;
-
-	pSrcBuf = GET_OS_PKT_DATAPTR(pPacket);
-	pktLen = GET_OS_PKT_LEN(pPacket);
-
-	ASSERT(pSrcBuf);
-
-	RTMP_SET_PACKET_SPECIFIC(pPacket, 0);
-
-	/* get Ethernet protocol field */
-	TypeLen = (pSrcBuf[12] << 8) | pSrcBuf[13];
-
-	pSrcBuf += LENGTH_802_3;	/* Skip the Ethernet Header. */
-
-	if (TypeLen <= 1500) {	/* 802.3, 802.3 LLC */
-		/*
-		   DestMAC(6) + SrcMAC(6) + Length(2) +
-		   DSAP(1) + SSAP(1) + Control(1) +
-		   if the DSAP = 0xAA, SSAP=0xAA, Contorl = 0x03, it has a 5-bytes SNAP header.
-		   => + SNAP (5, OriginationID(3) + etherType(2))
-		 */
-		if (pSrcBuf[0] == 0xAA && pSrcBuf[1] == 0xAA
-		    && pSrcBuf[2] == 0x03) {
-			Sniff2BytesFromNdisBuffer((char *)pSrcBuf, 6,
-						  &Byte0, &Byte1);
-			RTMP_SET_PACKET_LLCSNAP(pPacket, 1);
-			TypeLen = (u16)((Byte0 << 8) + Byte1);
-			pSrcBuf += 8;	/* Skip this LLC/SNAP header */
-		} else {
-			/*It just has 3-byte LLC header, maybe a legacy ether type frame. we didn't handle it. */
-		}
-	}
-	/* If it's a VLAN packet, get the real Type/Length field. */
-	if (TypeLen == 0x8100) {
-		/* 0x8100 means VLAN packets */
-
-		/* Dest. MAC Address (6-bytes) +
-		   Source MAC Address (6-bytes) +
-		   Length/Type = 802.1Q Tag Type (2-byte) +
-		   Tag Control Information (2-bytes) +
-		   Length / Type (2-bytes) +
-		   data payload (0-n bytes) +
-		   Pad (0-p bytes) +
-		   Frame Check Sequence (4-bytes) */
-
-		RTMP_SET_PACKET_VLAN(pPacket, 1);
-		Sniff2BytesFromNdisBuffer((char *)pSrcBuf, 2, &Byte0,
-					  &Byte1);
-		TypeLen = (u16)((Byte0 << 8) + Byte1);
-
-		pSrcBuf += 4;	/* Skip the VLAN Header. */
-	}
-
-	switch (TypeLen) {
-	case 0x0800:
-		{
-			ASSERT((pktLen > 34));
-			if (*(pSrcBuf + 9) == 0x11) {	/* udp packet */
-				ASSERT((pktLen > 34));	/* 14 for ethernet header, 20 for IP header */
-
-				pSrcBuf += 20;	/* Skip the IP header */
-				srcPort =
-				    OS_NTOHS(get_unaligned
-					     ((u16 *)(pSrcBuf)));
-				dstPort =
-				    OS_NTOHS(get_unaligned
-					     ((u16 *)(pSrcBuf + 2)));
-
-				if ((srcPort == 0x44 && dstPort == 0x43) || (srcPort == 0x43 && dstPort == 0x44)) {	/*It's a BOOTP/DHCP packet */
-					RTMP_SET_PACKET_DHCP(pPacket, 1);
-				}
-			}
-		}
-		break;
-	case 0x0806:
-		{
-			/*ARP Packet. */
-			RTMP_SET_PACKET_DHCP(pPacket, 1);
-		}
-		break;
-	case 0x888e:
-		{
-			/* EAPOL Packet. */
-			RTMP_SET_PACKET_EAPOL(pPacket, 1);
-		}
-		break;
-	default:
-		status = FALSE;
-		break;
-	}
-
-	return status;
-
-}
-
-void Update_Rssi_Sample(struct rt_rtmp_adapter *pAd,
-			struct rt_rssi_sample *pRssi, struct rt_rxwi * pRxWI)
-{
-	char rssi0 = pRxWI->RSSI0;
-	char rssi1 = pRxWI->RSSI1;
-	char rssi2 = pRxWI->RSSI2;
-
-	if (rssi0 != 0) {
-		pRssi->LastRssi0 = ConvertToRssi(pAd, (char)rssi0, RSSI_0);
-		pRssi->AvgRssi0X8 =
-		    (pRssi->AvgRssi0X8 - pRssi->AvgRssi0) + pRssi->LastRssi0;
-		pRssi->AvgRssi0 = pRssi->AvgRssi0X8 >> 3;
-	}
-
-	if (rssi1 != 0) {
-		pRssi->LastRssi1 = ConvertToRssi(pAd, (char)rssi1, RSSI_1);
-		pRssi->AvgRssi1X8 =
-		    (pRssi->AvgRssi1X8 - pRssi->AvgRssi1) + pRssi->LastRssi1;
-		pRssi->AvgRssi1 = pRssi->AvgRssi1X8 >> 3;
-	}
-
-	if (rssi2 != 0) {
-		pRssi->LastRssi2 = ConvertToRssi(pAd, (char)rssi2, RSSI_2);
-		pRssi->AvgRssi2X8 =
-		    (pRssi->AvgRssi2X8 - pRssi->AvgRssi2) + pRssi->LastRssi2;
-		pRssi->AvgRssi2 = pRssi->AvgRssi2X8 >> 3;
-	}
-}
-
-/* Normal legacy Rx packet indication */
-void Indicate_Legacy_Packet(struct rt_rtmp_adapter *pAd,
-			    struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	void *pRxPacket = pRxBlk->pRxPacket;
-	u8 Header802_3[LENGTH_802_3];
-
-	/* 1. get 802.3 Header */
-	/* 2. remove LLC */
-	/*              a. pointer pRxBlk->pData to payload */
-	/*      b. modify pRxBlk->DataSize */
-	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
-
-	if (pRxBlk->DataSize > MAX_RX_PKT_LEN) {
-
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
-
-#ifdef RTMP_MAC_USB
-	if (pAd->CommonCfg.bDisableReordering == 0) {
-		struct rt_ba_rec_entry *pBAEntry;
-		unsigned long Now32;
-		u8 Wcid = pRxBlk->pRxWI->WirelessCliID;
-		u8 TID = pRxBlk->pRxWI->TID;
-		u16 Idx;
-
-#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	/* system ticks -- 100 ms */
-
-		if (Wcid < MAX_LEN_OF_MAC_TABLE) {
-			Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-			if (Idx != 0) {
-				pBAEntry = &pAd->BATable.BARecEntry[Idx];
-				/* update last rx time */
-				NdisGetSystemUpTime(&Now32);
-				if ((pBAEntry->list.qlen > 0) &&
-				    RTMP_TIME_AFTER((unsigned long)Now32,
-						    (unsigned long)(pBAEntry->
-								    LastIndSeqAtTimer
-								    +
-								    (REORDERING_PACKET_TIMEOUT)))
-				    ) {
-					DBGPRINT(RT_DEBUG_OFF,
-						 ("Indicate_Legacy_Packet():flush reordering_timeout_mpdus! RxWI->Flags=%d, pRxWI.TID=%d, RxD->AMPDU=%d!\n",
-						  pRxBlk->Flags,
-						  pRxBlk->pRxWI->TID,
-						  pRxBlk->RxD.AMPDU));
-					hex_dump("Dump the legacy Packet:",
-						 GET_OS_PKT_DATAPTR(pRxBlk->
-								    pRxPacket),
-						 64);
-					ba_flush_reordering_timeout_mpdus(pAd,
-									  pBAEntry,
-									  Now32);
-				}
-			}
-		}
-	}
-#endif /* RTMP_MAC_USB // */
-
-	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
-
-	/* */
-	/* pass this 802.3 packet to upper layer or forward this packet to WM directly */
-	/* */
-	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxPacket, FromWhichBSSID);
-}
-
-/* Normal, AMPDU or AMSDU */
-void CmmRxnonRalinkFrameIndicate(struct rt_rtmp_adapter *pAd,
-				 struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU)
-	    && (pAd->CommonCfg.bDisableReordering == 0)) {
-		Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-	} else {
-		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
-			/* handle A-MSDU */
-			Indicate_AMSDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-		} else {
-			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
-		}
-	}
-}
-
-void CmmRxRalinkFrameIndicate(struct rt_rtmp_adapter *pAd,
-			      struct rt_mac_table_entry *pEntry,
-			      struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	u8 Header802_3[LENGTH_802_3];
-	u16 Msdu2Size;
-	u16 Payload1Size, Payload2Size;
-	u8 *pData2;
-	void *pPacket2 = NULL;
-
-	Msdu2Size = *(pRxBlk->pData) + (*(pRxBlk->pData + 1) << 8);
-
-	if ((Msdu2Size <= 1536) && (Msdu2Size < pRxBlk->DataSize)) {
-		/* skip two byte MSDU2 len */
-		pRxBlk->pData += 2;
-		pRxBlk->DataSize -= 2;
-	} else {
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	/* get 802.3 Header and  remove LLC */
-	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
-
-	ASSERT(pRxBlk->pRxPacket);
-
-	/* Ralink Aggregation frame */
-	pAd->RalinkCounters.OneSecRxAggregationCount++;
-	Payload1Size = pRxBlk->DataSize - Msdu2Size;
-	Payload2Size = Msdu2Size - LENGTH_802_3;
-
-	pData2 = pRxBlk->pData + Payload1Size + LENGTH_802_3;
-
-	pPacket2 =
-	    duplicate_pkt(pAd, (pData2 - LENGTH_802_3), LENGTH_802_3, pData2,
-			  Payload2Size, FromWhichBSSID);
-
-	if (!pPacket2) {
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return;
-	}
-	/* update payload size of 1st packet */
-	pRxBlk->DataSize = Payload1Size;
-	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
-
-	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxBlk->pRxPacket,
-					 FromWhichBSSID);
-
-	if (pPacket2) {
-		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket2, FromWhichBSSID);
-	}
-}
-
-#define RESET_FRAGFRAME(_fragFrame) \
-	{								\
-		_fragFrame.RxSize = 0;		\
-		_fragFrame.Sequence = 0;	\
-		_fragFrame.LastFrag = 0;	\
-		_fragFrame.Flags = 0;		\
-	}
-
-void *RTMPDeFragmentDataFrame(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk)
-{
-	struct rt_header_802_11 * pHeader = pRxBlk->pHeader;
-	void *pRxPacket = pRxBlk->pRxPacket;
-	u8 *pData = pRxBlk->pData;
-	u16 DataSize = pRxBlk->DataSize;
-	void *pRetPacket = NULL;
-	u8 *pFragBuffer = NULL;
-	BOOLEAN bReassDone = FALSE;
-	u8 HeaderRoom = 0;
-
-	ASSERT(pHeader);
-
-	HeaderRoom = pData - (u8 *) pHeader;
-
-	/* Re-assemble the fragmented packets */
-	if (pHeader->Frag == 0)	/* Frag. Number is 0 : First frag or only one pkt */
-	{
-		/* the first pkt of fragment, record it. */
-		if (pHeader->FC.MoreFrag) {
-			ASSERT(pAd->FragFrame.pFragPacket);
-			pFragBuffer =
-			    GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
-			pAd->FragFrame.RxSize = DataSize + HeaderRoom;
-			NdisMoveMemory(pFragBuffer, pHeader,
-				       pAd->FragFrame.RxSize);
-			pAd->FragFrame.Sequence = pHeader->Sequence;
-			pAd->FragFrame.LastFrag = pHeader->Frag;	/* Should be 0 */
-			ASSERT(pAd->FragFrame.LastFrag == 0);
-			goto done;	/* end of processing this frame */
-		}
-	} else			/*Middle & End of fragment */
-	{
-		if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
-		    (pHeader->Frag != (pAd->FragFrame.LastFrag + 1))) {
-			/* Fragment is not the same sequence or out of fragment number order */
-			/* Reset Fragment control blk */
-			RESET_FRAGFRAME(pAd->FragFrame);
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Fragment is not the same sequence or out of fragment number order.\n"));
-			goto done;	/* give up this frame */
-		} else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE) {
-			/* Fragment frame is too large, it exeeds the maximum frame size. */
-			/* Reset Fragment control blk */
-			RESET_FRAGFRAME(pAd->FragFrame);
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Fragment frame is too large, it exeeds the maximum frame size.\n"));
-			goto done;	/* give up this frame */
-		}
-		/* */
-		/* Broadcom AP(BCM94704AGR) will send out LLC in fragment's packet, LLC only can accpet at first fragment. */
-		/* In this case, we will dropt it. */
-		/* */
-		if (NdisEqualMemory(pData, SNAP_802_1H, sizeof(SNAP_802_1H))) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Find another LLC at Middle or End fragment(SN=%d, Frag=%d)\n",
-				  pHeader->Sequence, pHeader->Frag));
-			goto done;	/* give up this frame */
-		}
-
-		pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
-
-		/* concatenate this fragment into the re-assembly buffer */
-		NdisMoveMemory((pFragBuffer + pAd->FragFrame.RxSize), pData,
-			       DataSize);
-		pAd->FragFrame.RxSize += DataSize;
-		pAd->FragFrame.LastFrag = pHeader->Frag;	/* Update fragment number */
-
-		/* Last fragment */
-		if (pHeader->FC.MoreFrag == FALSE) {
-			bReassDone = TRUE;
-		}
-	}
-
-done:
-	/* always release rx fragmented packet */
-	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
-
-	/* return defragmented packet if packet is reassembled completely */
-	/* otherwise return NULL */
-	if (bReassDone) {
-		void *pNewFragPacket;
-
-		/* allocate a new packet buffer for fragment */
-		pNewFragPacket =
-		    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
-		if (pNewFragPacket) {
-			/* update RxBlk */
-			pRetPacket = pAd->FragFrame.pFragPacket;
-			pAd->FragFrame.pFragPacket = pNewFragPacket;
-			pRxBlk->pHeader =
-			    (struct rt_header_802_11 *) GET_OS_PKT_DATAPTR(pRetPacket);
-			pRxBlk->pData = (u8 *) pRxBlk->pHeader + HeaderRoom;
-			pRxBlk->DataSize = pAd->FragFrame.RxSize - HeaderRoom;
-			pRxBlk->pRxPacket = pRetPacket;
-		} else {
-			RESET_FRAGFRAME(pAd->FragFrame);
-		}
-	}
-
-	return pRetPacket;
-}
-
-void Indicate_AMSDU_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	u32 nMSDU;
-
-	update_os_packet_info(pAd, pRxBlk, FromWhichBSSID);
-	RTMP_SET_PACKET_IF(pRxBlk->pRxPacket, FromWhichBSSID);
-	nMSDU =
-	    deaggregate_AMSDU_announce(pAd, pRxBlk->pRxPacket, pRxBlk->pData,
-				       pRxBlk->DataSize);
-}
-
-void Indicate_EAPOL_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	struct rt_mac_table_entry *pEntry = NULL;
-
-	{
-		pEntry = &pAd->MacTab.Content[BSSID_WCID];
-		STARxEAPOLFrameIndicate(pAd, pEntry, pRxBlk, FromWhichBSSID);
-		return;
-	}
-
-	if (pEntry == NULL) {
-		DBGPRINT(RT_DEBUG_WARN,
-			 ("Indicate_EAPOL_Packet: drop and release the invalid packet.\n"));
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return;
-	}
-}
-
-#define BCN_TBTT_OFFSET		64	/*defer 64 us */
-void ReSyncBeaconTime(struct rt_rtmp_adapter *pAd)
-{
-
-	u32 Offset;
-
-	Offset = (pAd->TbttTickCount) % (BCN_TBTT_OFFSET);
-
-	pAd->TbttTickCount++;
-
-	/* */
-	/* The updated BeaconInterval Value will affect Beacon Interval after two TBTT */
-	/* beacasue the original BeaconInterval had been loaded into next TBTT_TIMER */
-	/* */
-	if (Offset == (BCN_TBTT_OFFSET - 2)) {
-		BCN_TIME_CFG_STRUC csr;
-		RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1;	/* ASIC register in units of 1/16 TU = 64us */
-		RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
-	} else {
-		if (Offset == (BCN_TBTT_OFFSET - 1)) {
-			BCN_TIME_CFG_STRUC csr;
-
-			RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4;	/* ASIC register in units of 1/16 TU */
-			RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
-		}
-	}
-}
diff --git a/drivers/staging/rt2860/common/cmm_data_pci.c b/drivers/staging/rt2860/common/cmm_data_pci.c
deleted file mode 100644
index bef0bbd..0000000
--- a/drivers/staging/rt2860/common/cmm_data_pci.c
+++ /dev/null
@@ -1,1096 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-/*
-   All functions in this file must be PCI-depended, or you should out your function
-	in other files.
-
-*/
-#include	"../rt_config.h"
-
-u16 RtmpPCI_WriteTxResource(struct rt_rtmp_adapter *pAd,
-			       struct rt_tx_blk *pTxBlk,
-			       IN BOOLEAN bIsLast, u16 * FreeNumber)
-{
-
-	u8 *pDMAHeaderBufVA;
-	u16 TxIdx, RetTxIdx;
-	struct rt_txd * pTxD;
-	u32 BufBasePaLow;
-	struct rt_rtmp_tx_ring *pTxRing;
-	u16 hwHeaderLen;
-
-	/* */
-	/* get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
-	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
-	pDMAHeaderBufVA = (u8 *)pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow =
-	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
-
-	/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
-	if (pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
-		/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
-		hwHeaderLen =
-		    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
-		    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
-	} else {
-		/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-		hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-	}
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
-		       TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
-
-	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
-	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
-
-	/* */
-	/* build Tx Descriptor */
-	/* */
-
-	pTxD = (struct rt_txd *) pTxRing->Cell[TxIdx].AllocVa;
-	NdisZeroMemory(pTxD, TXD_SIZE);
-
-	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	/* include padding */
-	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
-	pTxD->SDLen1 = pTxBlk->SrcBufLen;
-	pTxD->LastSec0 = 0;
-	pTxD->LastSec1 = (bIsLast) ? 1 : 0;
-
-	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
-
-	RetTxIdx = TxIdx;
-	/* */
-	/* Update Tx index */
-	/* */
-	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
-	pTxRing->TxCpuIdx = TxIdx;
-
-	*FreeNumber -= 1;
-
-	return RetTxIdx;
-}
-
-u16 RtmpPCI_WriteSingleTxResource(struct rt_rtmp_adapter *pAd,
-				     struct rt_tx_blk *pTxBlk,
-				     IN BOOLEAN bIsLast,
-				     u16 * FreeNumber)
-{
-
-	u8 *pDMAHeaderBufVA;
-	u16 TxIdx, RetTxIdx;
-	struct rt_txd * pTxD;
-	u32 BufBasePaLow;
-	struct rt_rtmp_tx_ring *pTxRing;
-	u16 hwHeaderLen;
-
-	/* */
-	/* get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
-	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
-	pDMAHeaderBufVA = (u8 *)pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow =
-	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
-
-	/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
-	/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-	hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
-		       TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
-
-	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
-	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
-
-	/* */
-	/* build Tx Descriptor */
-	/* */
-	pTxD = (struct rt_txd *) pTxRing->Cell[TxIdx].AllocVa;
-	NdisZeroMemory(pTxD, TXD_SIZE);
-
-	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	/* include padding */
-	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
-	pTxD->SDLen1 = pTxBlk->SrcBufLen;
-	pTxD->LastSec0 = 0;
-	pTxD->LastSec1 = (bIsLast) ? 1 : 0;
-
-	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
-
-	RetTxIdx = TxIdx;
-	/* */
-	/* Update Tx index */
-	/* */
-	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
-	pTxRing->TxCpuIdx = TxIdx;
-
-	*FreeNumber -= 1;
-
-	return RetTxIdx;
-}
-
-u16 RtmpPCI_WriteMultiTxResource(struct rt_rtmp_adapter *pAd,
-				    struct rt_tx_blk *pTxBlk,
-				    u8 frameNum, u16 * FreeNumber)
-{
-	BOOLEAN bIsLast;
-	u8 *pDMAHeaderBufVA;
-	u16 TxIdx, RetTxIdx;
-	struct rt_txd * pTxD;
-	u32 BufBasePaLow;
-	struct rt_rtmp_tx_ring *pTxRing;
-	u16 hwHdrLen;
-	u32 firstDMALen;
-
-	bIsLast = ((frameNum == (pTxBlk->TotalFrameNum - 1)) ? 1 : 0);
-
-	/* */
-	/* get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
-	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
-	pDMAHeaderBufVA = (u8 *)pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow =
-	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
-
-	if (frameNum == 0) {
-		/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
-		if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
-			hwHdrLen =
-			    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
-			    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
-		else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
-			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD; */
-			hwHdrLen =
-			    pTxBlk->MpduHeaderLen -
-			    LENGTH_ARALINK_HEADER_FIELD + pTxBlk->HdrPadLen +
-			    LENGTH_ARALINK_HEADER_FIELD;
-		else
-			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-			hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-		firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
-	} else {
-		firstDMALen = pTxBlk->MpduHeaderLen;
-	}
-
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, firstDMALen);
-
-	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
-	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
-
-	/* */
-	/* build Tx Descriptor */
-	/* */
-	pTxD = (struct rt_txd *) pTxRing->Cell[TxIdx].AllocVa;
-	NdisZeroMemory(pTxD, TXD_SIZE);
-
-	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen;	/* include padding */
-	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
-	pTxD->SDLen1 = pTxBlk->SrcBufLen;
-	pTxD->LastSec0 = 0;
-	pTxD->LastSec1 = (bIsLast) ? 1 : 0;
-
-	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
-
-	RetTxIdx = TxIdx;
-	/* */
-	/* Update Tx index */
-	/* */
-	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
-	pTxRing->TxCpuIdx = TxIdx;
-
-	*FreeNumber -= 1;
-
-	return RetTxIdx;
-
-}
-
-void RtmpPCI_FinalWriteTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  u16 totalMPDUSize, u16 FirstTxIdx)
-{
-
-	struct rt_txwi * pTxWI;
-	struct rt_rtmp_tx_ring *pTxRing;
-
-	/* */
-	/* get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
-	pTxWI = (struct rt_txwi *) pTxRing->Cell[FirstTxIdx].DmaBuf.AllocVa;
-	pTxWI->MPDUtotalByteCount = totalMPDUSize;
-
-}
-
-void RtmpPCIDataLastTxIdx(struct rt_rtmp_adapter *pAd,
-			  u8 QueIdx, u16 LastTxIdx)
-{
-	struct rt_txd * pTxD;
-	struct rt_rtmp_tx_ring *pTxRing;
-
-	/* */
-	/* get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[QueIdx];
-
-	/* */
-	/* build Tx Descriptor */
-	/* */
-	pTxD = (struct rt_txd *) pTxRing->Cell[LastTxIdx].AllocVa;
-
-	pTxD->LastSec1 = 1;
-
-}
-
-u16 RtmpPCI_WriteFragTxResource(struct rt_rtmp_adapter *pAd,
-				   struct rt_tx_blk *pTxBlk,
-				   u8 fragNum, u16 * FreeNumber)
-{
-	u8 *pDMAHeaderBufVA;
-	u16 TxIdx, RetTxIdx;
-	struct rt_txd * pTxD;
-	u32 BufBasePaLow;
-	struct rt_rtmp_tx_ring *pTxRing;
-	u16 hwHeaderLen;
-	u32 firstDMALen;
-
-	/* */
-	/* Get Tx Ring Resource */
-	/* */
-	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
-	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
-	pDMAHeaderBufVA = (u8 *)pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow =
-	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
-
-	/* */
-	/* Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
-	/* */
-	/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-	hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-	firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, firstDMALen);
-
-	/* */
-	/* Build Tx Descriptor */
-	/* */
-	pTxD = (struct rt_txd *) pTxRing->Cell[TxIdx].AllocVa;
-	NdisZeroMemory(pTxD, TXD_SIZE);
-
-	if (fragNum == pTxBlk->TotalFragNum) {
-		pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
-		pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
-	}
-
-	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen;	/* include padding */
-	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
-	pTxD->SDLen1 = pTxBlk->SrcBufLen;
-	pTxD->LastSec0 = 0;
-	pTxD->LastSec1 = 1;
-
-	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
-
-	RetTxIdx = TxIdx;
-	pTxBlk->Priv += pTxBlk->SrcBufLen;
-
-	/* */
-	/* Update Tx index */
-	/* */
-	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
-	pTxRing->TxCpuIdx = TxIdx;
-
-	*FreeNumber -= 1;
-
-	return RetTxIdx;
-
-}
-
-/*
-	Must be run in Interrupt context
-	This function handle PCI specific TxDesc and cpu index update and kick the packet out.
- */
-int RtmpPCIMgmtKickOut(struct rt_rtmp_adapter *pAd,
-		       u8 QueIdx,
-		       void *pPacket,
-		       u8 *pSrcBufVA, u32 SrcBufLen)
-{
-	struct rt_txd * pTxD;
-	unsigned long SwIdx = pAd->MgmtRing.TxCpuIdx;
-
-	pTxD = (struct rt_txd *) pAd->MgmtRing.Cell[SwIdx].AllocVa;
-
-	pAd->MgmtRing.Cell[SwIdx].pNdisPacket = pPacket;
-	pAd->MgmtRing.Cell[SwIdx].pNextNdisPacket = NULL;
-
-	RTMPWriteTxDescriptor(pAd, pTxD, TRUE, FIFO_MGMT);
-	pTxD->LastSec0 = 1;
-	pTxD->LastSec1 = 1;
-	pTxD->DMADONE = 0;
-	pTxD->SDLen1 = 0;
-	pTxD->SDPtr0 =
-	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
-	pTxD->SDLen0 = SrcBufLen;
-
-/*================================================================== */
-/*	DBGPRINT_RAW(RT_DEBUG_TRACE, ("MLMEHardTransmit\n"));
-	for (i = 0; i < (TXWI_SIZE+24); i++)
-	{
-
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("%x:", *(pSrcBufVA+i)));
-		if ( i%4 == 3)
-			DBGPRINT_RAW(RT_DEBUG_TRACE, (" :: "));
-		if ( i%16 == 15)
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n      "));
-	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n      "));*/
-/*======================================================================= */
-
-	pAd->RalinkCounters.KickTxCount++;
-	pAd->RalinkCounters.OneSecTxDoneCount++;
-
-	/* Increase TX_CTX_IDX, but write to register later. */
-	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
-
-	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
-
-	return 0;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
-
-	Arguments:
-		pRxD		Pointer to the Rx descriptor
-
-	Return Value:
-		NDIS_STATUS_SUCCESS	No err
-		NDIS_STATUS_FAILURE	Error
-
-	Note:
-
-	========================================================================
-*/
-int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
-			     struct rt_header_802_11 * pHeader,
-			     struct rt_rxwi * pRxWI, IN PRT28XX_RXD_STRUC pRxD)
-{
-	struct rt_cipher_key *pWpaKey;
-	int dBm;
-
-	/* Phy errors & CRC errors */
-	if ( /*(pRxD->PhyErr) || */ (pRxD->Crc)) {
-		/* Check RSSI for Noise Hist statistic collection. */
-		dBm = (int)(pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
-		if (dBm <= -87)
-			pAd->StaCfg.RPIDensity[0] += 1;
-		else if (dBm <= -82)
-			pAd->StaCfg.RPIDensity[1] += 1;
-		else if (dBm <= -77)
-			pAd->StaCfg.RPIDensity[2] += 1;
-		else if (dBm <= -72)
-			pAd->StaCfg.RPIDensity[3] += 1;
-		else if (dBm <= -67)
-			pAd->StaCfg.RPIDensity[4] += 1;
-		else if (dBm <= -62)
-			pAd->StaCfg.RPIDensity[5] += 1;
-		else if (dBm <= -57)
-			pAd->StaCfg.RPIDensity[6] += 1;
-		else if (dBm > -57)
-			pAd->StaCfg.RPIDensity[7] += 1;
-
-		return (NDIS_STATUS_FAILURE);
-	}
-	/* Add Rx size to channel load counter, we should ignore error counts */
-	pAd->StaCfg.CLBusyBytes += (pRxD->SDL0 + 14);
-
-	/* Drop ToDs promiscuous frame, it is opened due to CCX 2 channel load statistics */
-	if (pHeader != NULL) {
-		if (pHeader->FC.ToDs) {
-			return (NDIS_STATUS_FAILURE);
-		}
-	}
-	/* Drop not U2M frames, can't's drop here because we will drop beacon in this case */
-	/* I am kind of doubting the U2M bit operation */
-	/* if (pRxD->U2M == 0) */
-	/*      return(NDIS_STATUS_FAILURE); */
-
-	/* drop decyption fail frame */
-	if (pRxD->CipherErr) {
-		if (pRxD->CipherErr == 2) {
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("pRxD ERROR: ICV ok but MICErr "));
-		} else if (pRxD->CipherErr == 1) {
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("pRxD ERROR: ICV Err "));
-		} else if (pRxD->CipherErr == 3)
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("pRxD ERROR: Key not valid "));
-
-		if (((pRxD->CipherErr & 1) == 1)
-		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-			RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     (" %d (len=%d, Mcast=%d, MyBss=%d, Wcid=%d, KeyId=%d)\n",
-			      pRxD->CipherErr, pRxD->SDL0,
-			      pRxD->Mcast | pRxD->Bcast, pRxD->MyBss,
-			      pRxWI->WirelessCliID,
-/*                      CipherName[pRxD->CipherAlg], */
-			      pRxWI->KeyIndex));
-
-		/* */
-		/* MIC Error */
-		/* */
-		if (pRxD->CipherErr == 2) {
-			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
-			if (pAd->StaCfg.WpaSupplicantUP)
-				WpaSendMicFailureToWpaSupplicant(pAd,
-								 (pWpaKey->
-								  Type ==
-								  PAIRWISEKEY) ?
-								 TRUE : FALSE);
-			else
-				RTMPReportMicError(pAd, pWpaKey);
-
-			if (((pRxD->CipherErr & 2) == 2)
-			    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-				RTMPSendWirelessEvent(pAd,
-						      IW_MIC_ERROR_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error\n"));
-		}
-
-		if (pHeader == NULL)
-			return (NDIS_STATUS_SUCCESS);
-		/*if ((pRxD->CipherAlg == CIPHER_AES) &&
-		   (pHeader->Sequence == pAd->FragFrame.Sequence))
-		   {
-		   //
-		   // Acceptable since the First FragFrame no CipherErr problem.
-		   //
-		   return(NDIS_STATUS_SUCCESS);
-		   } */
-
-		return (NDIS_STATUS_FAILURE);
-	}
-
-	return (NDIS_STATUS_SUCCESS);
-}
-
-BOOLEAN RTMPFreeTXDUponTxDmaDone(struct rt_rtmp_adapter *pAd, u8 QueIdx)
-{
-	struct rt_rtmp_tx_ring *pTxRing;
-	struct rt_txd * pTxD;
-	void *pPacket;
-	u8 FREE = 0;
-	struct rt_txd TxD, *pOriTxD;
-	/*unsigned long         IrqFlags; */
-	BOOLEAN bReschedule = FALSE;
-
-	ASSERT(QueIdx < NUM_OF_TX_RING);
-	pTxRing = &pAd->TxRing[QueIdx];
-
-	RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF,
-		       &pTxRing->TxDmaIdx);
-	while (pTxRing->TxSwFreeIdx != pTxRing->TxDmaIdx) {
-/*              RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags); */
-
-		/* static rate also need NICUpdateFifoStaCounters() function. */
-		/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
-		NICUpdateFifoStaCounters(pAd);
-
-		/* Note : If (pAd->ate.bQATxStart == TRUE), we will never reach here. */
-		FREE++;
-		pTxD =
-		    (struct rt_txd *) (pTxRing->Cell[pTxRing->TxSwFreeIdx].AllocVa);
-		pOriTxD = pTxD;
-		NdisMoveMemory(&TxD, pTxD, sizeof(struct rt_txd));
-		pTxD = &TxD;
-
-		pTxD->DMADONE = 0;
-
-		{
-			pPacket =
-			    pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket;
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
-						 pTxD->SDLen1,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_SUCCESS);
-			}
-			/*Always assign pNdisPacket as NULL after clear */
-			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket = NULL;
-
-			pPacket =
-			    pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket;
-
-			ASSERT(pPacket == NULL);
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
-						 pTxD->SDLen1,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_SUCCESS);
-			}
-			/*Always assign pNextNdisPacket as NULL after clear */
-			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
-			    NULL;
-		}
-
-		pAd->RalinkCounters.TransmittedByteCount +=
-		    (pTxD->SDLen1 + pTxD->SDLen0);
-		pAd->RalinkCounters.OneSecDmaDoneCount[QueIdx]++;
-		INC_RING_INDEX(pTxRing->TxSwFreeIdx, TX_RING_SIZE);
-		/* get tx_tdx_idx again */
-		RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF,
-			       &pTxRing->TxDmaIdx);
-		NdisMoveMemory(pOriTxD, pTxD, sizeof(struct rt_txd));
-
-/*         RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags); */
-	}
-
-	return bReschedule;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process TX Rings DMA Done interrupt, running in DPC level
-
-	Arguments:
-		Adapter		Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(struct rt_rtmp_adapter *pAd,
-					 INT_SOURCE_CSR_STRUC TxRingBitmap)
-{
-/*      u8                   Count = 0; */
-	unsigned long IrqFlags;
-	BOOLEAN bReschedule = FALSE;
-
-	/* Make sure Tx ring resource won't be used by other threads */
-	/*NdisAcquireSpinLock(&pAd->TxRingLock); */
-
-	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-
-	if (TxRingBitmap.field.Ac0DmaDone)
-		bReschedule = RTMPFreeTXDUponTxDmaDone(pAd, QID_AC_BE);
-
-	if (TxRingBitmap.field.Ac3DmaDone)
-		bReschedule |= RTMPFreeTXDUponTxDmaDone(pAd, QID_AC_VO);
-
-	if (TxRingBitmap.field.Ac2DmaDone)
-		bReschedule |= RTMPFreeTXDUponTxDmaDone(pAd, QID_AC_VI);
-
-	if (TxRingBitmap.field.Ac1DmaDone)
-		bReschedule |= RTMPFreeTXDUponTxDmaDone(pAd, QID_AC_BK);
-
-	/* Make sure to release Tx ring resource */
-	/*NdisReleaseSpinLock(&pAd->TxRingLock); */
-	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-
-	/* Dequeue outgoing frames from TxSwQueue[] and process it */
-	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-
-	return bReschedule;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process MGMT ring DMA done interrupt, running in DPC level
-
-	Arguments:
-		pAd	Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPHandleMgmtRingDmaDoneInterrupt(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_txd * pTxD;
-	void *pPacket;
-/*      int              i; */
-	u8 FREE = 0;
-	struct rt_rtmp_mgmt_ring *pMgmtRing = &pAd->MgmtRing;
-
-	NdisAcquireSpinLock(&pAd->MgmtRingLock);
-
-	RTMP_IO_READ32(pAd, TX_MGMTDTX_IDX, &pMgmtRing->TxDmaIdx);
-	while (pMgmtRing->TxSwFreeIdx != pMgmtRing->TxDmaIdx) {
-		FREE++;
-		pTxD =
-		    (struct rt_txd *) (pMgmtRing->Cell[pAd->MgmtRing.TxSwFreeIdx].
-				  AllocVa);
-		pTxD->DMADONE = 0;
-		pPacket = pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNdisPacket;
-
-		if (pPacket) {
-			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0, pTxD->SDLen0,
-					 PCI_DMA_TODEVICE);
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
-		}
-		pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNdisPacket = NULL;
-
-		pPacket =
-		    pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNextNdisPacket;
-		if (pPacket) {
-			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1,
-					 PCI_DMA_TODEVICE);
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
-		}
-		pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNextNdisPacket = NULL;
-		INC_RING_INDEX(pMgmtRing->TxSwFreeIdx, MGMT_RING_SIZE);
-
-	}
-	NdisReleaseSpinLock(&pAd->MgmtRingLock);
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	Arguments:
-		Adapter		Pointer to our adapter. Dequeue all power safe delayed braodcast frames after beacon.
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void RTMPHandleTBTTInterrupt(struct rt_rtmp_adapter *pAd)
-{
-	{
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-		}
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	Arguments:
-		pAd		Pointer to our adapter. Rewrite beacon content before next send-out.
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void RTMPHandlePreTBTTInterrupt(struct rt_rtmp_adapter *pAd)
-{
-	{
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("RTMPHandlePreTBTTInterrupt...\n"));
-		}
-	}
-
-}
-
-void RTMPHandleRxCoherentInterrupt(struct rt_rtmp_adapter *pAd)
-{
-	WPDMA_GLO_CFG_STRUC GloCfg;
-
-	if (pAd == NULL) {
-		DBGPRINT(RT_DEBUG_TRACE, ("====> pAd is NULL, return.\n"));
-		return;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPHandleRxCoherentInterrupt \n"));
-
-	RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-
-	GloCfg.field.EnTXWriteBackDDONE = 0;
-	GloCfg.field.EnableRxDMA = 0;
-	GloCfg.field.EnableTxDMA = 0;
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-	RTMPRingCleanUp(pAd, QID_AC_BE);
-	RTMPRingCleanUp(pAd, QID_AC_BK);
-	RTMPRingCleanUp(pAd, QID_AC_VI);
-	RTMPRingCleanUp(pAd, QID_AC_VO);
-	RTMPRingCleanUp(pAd, QID_MGMT);
-	RTMPRingCleanUp(pAd, QID_RX);
-
-	RTMPEnableRxTx(pAd);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<== RTMPHandleRxCoherentInterrupt \n"));
-}
-
-void *GetPacketFromRxRing(struct rt_rtmp_adapter *pAd,
-				 OUT PRT28XX_RXD_STRUC pSaveRxD,
-				 OUT BOOLEAN * pbReschedule,
-				 IN u32 * pRxPending)
-{
-	struct rt_rxd * pRxD;
-	void *pRxPacket = NULL;
-	void *pNewPacket;
-	void *AllocVa;
-	dma_addr_t AllocPa;
-	BOOLEAN bReschedule = FALSE;
-	struct rt_rtmp_dmacb *pRxCell;
-
-	RTMP_SEM_LOCK(&pAd->RxRingLock);
-
-	if (*pRxPending == 0) {
-		/* Get how may packets had been received */
-		RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
-
-		if (pAd->RxRing.RxSwReadIdx == pAd->RxRing.RxDmaIdx) {
-			/* no more rx packets */
-			bReschedule = FALSE;
-			goto done;
-		}
-		/* get rx pending count */
-		if (pAd->RxRing.RxDmaIdx > pAd->RxRing.RxSwReadIdx)
-			*pRxPending =
-			    pAd->RxRing.RxDmaIdx - pAd->RxRing.RxSwReadIdx;
-		else
-			*pRxPending =
-			    pAd->RxRing.RxDmaIdx + RX_RING_SIZE -
-			    pAd->RxRing.RxSwReadIdx;
-
-	}
-
-	pRxCell = &pAd->RxRing.Cell[pAd->RxRing.RxSwReadIdx];
-
-	/* Point to Rx indexed rx ring descriptor */
-	pRxD = (struct rt_rxd *) pRxCell->AllocVa;
-
-	if (pRxD->DDONE == 0) {
-		*pRxPending = 0;
-		/* DMAIndx had done but DDONE bit not ready */
-		bReschedule = TRUE;
-		goto done;
-	}
-
-	/* return rx descriptor */
-	NdisMoveMemory(pSaveRxD, pRxD, RXD_SIZE);
-
-	pNewPacket =
-	    RTMP_AllocateRxPacketBuffer(pAd, RX_BUFFER_AGGRESIZE, FALSE,
-					&AllocVa, &AllocPa);
-
-	if (pNewPacket) {
-		/* unmap the rx buffer */
-		PCI_UNMAP_SINGLE(pAd, pRxCell->DmaBuf.AllocPa,
-				 pRxCell->DmaBuf.AllocSize, PCI_DMA_FROMDEVICE);
-		pRxPacket = pRxCell->pNdisPacket;
-
-		pRxCell->DmaBuf.AllocSize = RX_BUFFER_AGGRESIZE;
-		pRxCell->pNdisPacket = (void *)pNewPacket;
-		pRxCell->DmaBuf.AllocVa = AllocVa;
-		pRxCell->DmaBuf.AllocPa = AllocPa;
-		/* update SDP0 to new buffer of rx packet */
-		pRxD->SDP0 = AllocPa;
-	} else {
-		/*DBGPRINT(RT_DEBUG_TRACE,("No Rx Buffer\n")); */
-		pRxPacket = NULL;
-		bReschedule = TRUE;
-	}
-
-	pRxD->DDONE = 0;
-
-	/* had handled one rx packet */
-	*pRxPending = *pRxPending - 1;
-
-	/* update rx descriptor and kick rx */
-	INC_RING_INDEX(pAd->RxRing.RxSwReadIdx, RX_RING_SIZE);
-
-	pAd->RxRing.RxCpuIdx =
-	    (pAd->RxRing.RxSwReadIdx ==
-	     0) ? (RX_RING_SIZE - 1) : (pAd->RxRing.RxSwReadIdx - 1);
-	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
-
-done:
-	RTMP_SEM_UNLOCK(&pAd->RxRingLock);
-	*pbReschedule = bReschedule;
-	return pRxPacket;
-}
-
-int MlmeHardTransmitTxRing(struct rt_rtmp_adapter *pAd,
-				   u8 QueIdx, void *pPacket)
-{
-	struct rt_packet_info PacketInfo;
-	u8 *pSrcBufVA;
-	u32 SrcBufLen;
-	struct rt_txd * pTxD;
-	struct rt_header_802_11 * pHeader_802_11;
-	BOOLEAN bAckRequired, bInsertTimestamp;
-	unsigned long SrcBufPA;
-	/*u8                 TxBufIdx; */
-	u8 MlmeRate;
-	unsigned long SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
-	struct rt_txwi * pFirstTxWI;
-	/*unsigned long i; */
-	/*HTTRANSMIT_SETTING    MlmeTransmit;   //Rate for this MGMT frame. */
-	unsigned long FreeNum;
-	struct rt_mac_table_entry *pMacEntry = NULL;
-
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
-
-	if (pSrcBufVA == NULL) {
-		/* The buffer shouldn't be NULL */
-		return NDIS_STATUS_FAILURE;
-	}
-	/* Make sure MGMT ring resource won't be used by other threads */
-	/*NdisAcquireSpinLock(&pAd->TxRingLock); */
-
-	FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
-
-	if (FreeNum == 0) {
-		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
-		return NDIS_STATUS_FAILURE;
-	}
-
-	SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
-
-	pTxD = (struct rt_txd *) pAd->TxRing[QueIdx].Cell[SwIdx].AllocVa;
-
-	if (pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket) {
-		DBGPRINT(RT_DEBUG_OFF, ("MlmeHardTransmit Error\n"));
-		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
-		return NDIS_STATUS_FAILURE;
-	}
-
-	{
-		/* outgoing frame always wakeup PHY to prevent frame lost */
-		/* if (pAd->StaCfg.Psm == PWR_SAVE) */
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-			AsicForceWakeup(pAd, TRUE);
-	}
-	pFirstTxWI = (struct rt_txwi *) pSrcBufVA;
-
-	pHeader_802_11 = (struct rt_header_802_11 *) (pSrcBufVA + TXWI_SIZE);
-	if (pHeader_802_11->Addr1[0] & 0x01) {
-		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
-	} else {
-		MlmeRate = pAd->CommonCfg.MlmeRate;
-	}
-
-	if ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-	    (pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL)) {
-		pMacEntry = MacTableLookup(pAd, pHeader_802_11->Addr1);
-	}
-	/* Verify Mlme rate for a / g bands. */
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	/* 11A band */
-		MlmeRate = RATE_6;
-
-	/* */
-	/* Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE) */
-	/* Snice it's been set to 0 while on MgtMacHeaderInit */
-	/* By the way this will cause frame to be send on PWR_SAVE failed. */
-	/* */
-	/* */
-	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
-	/* Data-Null packets also pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
-	if (pHeader_802_11->FC.Type != BTYPE_DATA) {
-		if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ)
-		    || !(pAd->CommonCfg.bAPSDCapable
-			 && pAd->CommonCfg.APEdcaParm.bAPSDCapable)) {
-			pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;
-		} else {
-			pHeader_802_11->FC.PwrMgmt =
-			    pAd->CommonCfg.bAPSDForcePowerSave;
-		}
-	}
-
-	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	/* must be PS-POLL */
-	{
-		bAckRequired = FALSE;
-	} else			/* BTYPE_MGMT or BTYPE_DATA(must be NULL frame) */
-	{
-		if (pHeader_802_11->Addr1[0] & 0x01)	/* MULTICAST, BROADCAST */
-		{
-			bAckRequired = FALSE;
-			pHeader_802_11->Duration = 0;
-		} else {
-			bAckRequired = TRUE;
-			pHeader_802_11->Duration =
-			    RTMPCalcDuration(pAd, MlmeRate, 14);
-			if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP) {
-				bInsertTimestamp = TRUE;
-			}
-		}
-	}
-	pHeader_802_11->Sequence = pAd->Sequence++;
-	if (pAd->Sequence > 0xfff)
-		pAd->Sequence = 0;
-	/* Before radar detection done, mgmt frame can not be sent but probe req */
-	/* Because we need to use probe req to trigger driver to send probe req in passive scan */
-	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
-	    && (pAd->CommonCfg.bIEEE80211H == 1)
-	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeHardTransmit --> radar detect not in normal mode!\n"));
-		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
-		return (NDIS_STATUS_FAILURE);
-	}
-	/* */
-	/* fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET */
-	/* should always has only one ohysical buffer, and the whole frame size equals */
-	/* to the first scatter buffer size */
-	/* */
-
-	/* Initialize TX Descriptor */
-	/* For inter-frame gap, the number is for this frame and next frame */
-	/* For MLME rate, we will fix as 2Mb to match other vendor's implement */
-/*      pAd->CommonCfg.MlmeTransmit.field.MODE = 1; */
-
-/* management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not. */
-	/* Only beacon use Nseq=TRUE. So here we use Nseq=FALSE. */
-	if (pMacEntry == NULL) {
-		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp,
-			      FALSE, bAckRequired, FALSE, 0, RESERVED_WCID,
-			      (SrcBufLen - TXWI_SIZE), PID_MGMT, 0,
-			      (u8)pAd->CommonCfg.MlmeTransmit.field.MCS,
-			      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	} else {
-		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE,
-			      bInsertTimestamp, FALSE, bAckRequired, FALSE,
-			      0, pMacEntry->Aid, (SrcBufLen - TXWI_SIZE),
-			      pMacEntry->MaxHTPhyMode.field.MCS, 0,
-			      (u8)pMacEntry->MaxHTPhyMode.field.MCS,
-			      IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
-	}
-
-	pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket = pPacket;
-	pAd->TxRing[QueIdx].Cell[SwIdx].pNextNdisPacket = NULL;
-/*      pFirstTxWI->MPDUtotalByteCount = SrcBufLen - TXWI_SIZE; */
-	SrcBufPA =
-	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
-
-	RTMPWriteTxDescriptor(pAd, pTxD, TRUE, FIFO_EDCA);
-	pTxD->LastSec0 = 1;
-	pTxD->LastSec1 = 1;
-	pTxD->SDLen0 = SrcBufLen;
-	pTxD->SDLen1 = 0;
-	pTxD->SDPtr0 = SrcBufPA;
-	pTxD->DMADONE = 0;
-
-	pAd->RalinkCounters.KickTxCount++;
-	pAd->RalinkCounters.OneSecTxDoneCount++;
-
-	/* Increase TX_CTX_IDX, but write to register later. */
-	INC_RING_INDEX(pAd->TxRing[QueIdx].TxCpuIdx, TX_RING_SIZE);
-
-	RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + QueIdx * 0x10,
-			pAd->TxRing[QueIdx].TxCpuIdx);
-
-	/* Make sure to release MGMT ring resource */
-/*      NdisReleaseSpinLock(&pAd->TxRingLock); */
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-int MlmeDataHardTransmit(struct rt_rtmp_adapter *pAd,
-				 u8 QueIdx, void *pPacket)
-{
-	if ((pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)
-	    ) {
-		return NDIS_STATUS_FAILURE;
-	}
-
-	return MlmeHardTransmitTxRing(pAd, QueIdx, pPacket);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Calculates the duration which is required to transmit out frames
-	with given size and specified rate.
-
-	Arguments:
-		pTxD		Pointer to transmit descriptor
-		Ack		Setting for Ack requirement bit
-		Fragment	Setting for Fragment bit
-		RetryMode	Setting for retry mode
-		Ifs		Setting for IFS gap
-		Rate		Setting for transmit rate
-		Service		Setting for service
-		Length		Frame length
-		TxPreamble	Short or Long preamble when using CCK rates
-		QueIdx - 0-3, according to 802.11e/d4.4 June/2003
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void RTMPWriteTxDescriptor(struct rt_rtmp_adapter *pAd,
-			   struct rt_txd * pTxD,
-			   IN BOOLEAN bWIV, u8 QueueSEL)
-{
-	/* */
-	/* Always use Long preamble before verifiation short preamble functionality works well. */
-	/* Todo: remove the following line if short preamble functionality works */
-	/* */
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
-
-	pTxD->WIV = (bWIV) ? 1 : 0;
-	pTxD->QSEL = (QueueSEL);
-	/*RT2860c??  fixed using EDCA queue for test...  We doubt Queue1 has problem.  2006-09-26 Jan */
-	/*pTxD->QSEL= FIFO_EDCA; */
-	pTxD->DMADONE = 0;
-}
diff --git a/drivers/staging/rt2860/common/cmm_data_usb.c b/drivers/staging/rt2860/common/cmm_data_usb.c
deleted file mode 100644
index 5637857..0000000
--- a/drivers/staging/rt2860/common/cmm_data_usb.c
+++ /dev/null
@@ -1,951 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-/*
-   All functions in this file must be USB-depended, or you should out your function
-	in other files.
-
-*/
-
-#ifdef RTMP_MAC_USB
-
-#include	"../rt_config.h"
-
-/*
-	We can do copy the frame into pTxContext when match following conditions.
-		=>
-		=>
-		=>
-*/
-static inline int RtmpUSBCanDoWrite(struct rt_rtmp_adapter *pAd,
-					    u8 QueIdx,
-					    struct rt_ht_tx_context *pHTTXContext)
-{
-	int canWrite = NDIS_STATUS_RESOURCES;
-
-	if (((pHTTXContext->CurWritePosition) <
-	     pHTTXContext->NextBulkOutPosition)
-	    && (pHTTXContext->CurWritePosition + LOCAL_TXBUF_SIZE) >
-	    pHTTXContext->NextBulkOutPosition) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c1!\n"));
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
-	} else if ((pHTTXContext->CurWritePosition == 8)
-		   && (pHTTXContext->NextBulkOutPosition < LOCAL_TXBUF_SIZE)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c2!\n"));
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
-	} else if (pHTTXContext->bCurWriting == TRUE) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c3!\n"));
-	} else {
-		canWrite = NDIS_STATUS_SUCCESS;
-	}
-
-	return canWrite;
-}
-
-u16 RtmpUSB_WriteSubTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  IN BOOLEAN bIsLast, u16 * FreeNumber)
-{
-
-	/* Dummy function. Should be removed in the future. */
-	return 0;
-
-}
-
-u16 RtmpUSB_WriteFragTxResource(struct rt_rtmp_adapter *pAd,
-				   struct rt_tx_blk *pTxBlk,
-				   u8 fragNum, u16 * FreeNumber)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	u16 hwHdrLen;	/* The hwHdrLen consist of 802.11 header length plus the header padding length. */
-	u32 fillOffset;
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi *pTxWI;
-	u8 *pWirelessPacket = NULL;
-	u8 QueIdx;
-	int Status;
-	unsigned long IrqFlags;
-	u32 USBDMApktLen = 0, DMAHdrLen, padding;
-	BOOLEAN TxQLastRound = FALSE;
-
-	/* */
-	/* get Tx Ring Resource & Dma Buffer address */
-	/* */
-	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext = &pAd->TxContext[QueIdx];
-
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	pHTTXContext = &pAd->TxContext[QueIdx];
-	fillOffset = pHTTXContext->CurWritePosition;
-
-	if (fragNum == 0) {
-		/* Check if we have enough space for this bulk-out batch. */
-		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-		if (Status == NDIS_STATUS_SUCCESS) {
-			pHTTXContext->bCurWriting = TRUE;
-
-			/* Reserve space for 8 bytes padding. */
-			if ((pHTTXContext->ENextBulkOutPosition ==
-			     pHTTXContext->CurWritePosition)) {
-				pHTTXContext->ENextBulkOutPosition += 8;
-				pHTTXContext->CurWritePosition += 8;
-				fillOffset += 8;
-			}
-			pTxBlk->Priv = 0;
-			pHTTXContext->CurWriteRealPos =
-			    pHTTXContext->CurWritePosition;
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
-					IrqFlags);
-
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
-					    NDIS_STATUS_FAILURE);
-			return (Status);
-		}
-	} else {
-		/* For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer. */
-		Status =
-		    ((pHTTXContext->bCurWriting ==
-		      TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
-		if (Status == NDIS_STATUS_SUCCESS) {
-			fillOffset += pTxBlk->Priv;
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
-					IrqFlags);
-
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
-					    NDIS_STATUS_FAILURE);
-			return (Status);
-		}
-	}
-
-	NdisZeroMemory((u8 *)(&pTxBlk->HeaderBuf[0]), TXINFO_SIZE);
-	pTxInfo = (struct rt_txinfo *)(&pTxBlk->HeaderBuf[0]);
-	pTxWI = (struct rt_txwi *) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
-
-	pWirelessPacket =
-	    &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
-
-	/* copy TXWI + WLAN Header + LLC into DMA Header Buffer */
-	/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-	hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-	/* Build our URB for USBD */
-	DMAHdrLen = TXWI_SIZE + hwHdrLen;
-	USBDMApktLen = DMAHdrLen + pTxBlk->SrcBufLen;
-	padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
-	USBDMApktLen += padding;
-
-	pTxBlk->Priv += (TXINFO_SIZE + USBDMApktLen);
-
-	/* For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload */
-	RTMPWriteTxInfo(pAd, pTxInfo, (u16)(USBDMApktLen), FALSE, FIFO_EDCA,
-			FALSE /*NextValid */ , FALSE);
-
-	if (fragNum == pTxBlk->TotalFragNum) {
-		pTxInfo->USBDMATxburst = 0;
-		if ((pHTTXContext->CurWritePosition + pTxBlk->Priv + 3906) >
-		    MAX_TXBULK_LIMIT) {
-			pTxInfo->SwUseLastRound = 1;
-			TxQLastRound = TRUE;
-		}
-	} else {
-		pTxInfo->USBDMATxburst = 1;
-	}
-
-	NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
-		       TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-	pWirelessPacket += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-	pHTTXContext->CurWriteRealPos += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
-
-	/*      Zero the last padding. */
-	pWirelessPacket += pTxBlk->SrcBufLen;
-	NdisZeroMemory(pWirelessPacket, padding + 8);
-
-	if (fragNum == pTxBlk->TotalFragNum) {
-		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-		/* Update the pHTTXContext->CurWritePosition. 3906 used to prevent the NextBulkOut is a A-RALINK/A-MSDU Frame. */
-		pHTTXContext->CurWritePosition += pTxBlk->Priv;
-		if (TxQLastRound == TRUE)
-			pHTTXContext->CurWritePosition = 8;
-		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
-
-		/* Finally, set bCurWriting as FALSE */
-		pHTTXContext->bCurWriting = FALSE;
-
-		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-		/* succeed and release the skb buffer */
-		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
-	}
-
-	return (Status);
-
-}
-
-u16 RtmpUSB_WriteSingleTxResource(struct rt_rtmp_adapter *pAd,
-				     struct rt_tx_blk *pTxBlk,
-				     IN BOOLEAN bIsLast,
-				     u16 * FreeNumber)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	u16 hwHdrLen;
-	u32 fillOffset;
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi *pTxWI;
-	u8 *pWirelessPacket;
-	u8 QueIdx;
-	unsigned long IrqFlags;
-	int Status;
-	u32 USBDMApktLen = 0, DMAHdrLen, padding;
-	BOOLEAN bTxQLastRound = FALSE;
-
-	/* For USB, didn't need PCI_MAP_SINGLE() */
-	/*SrcBufPA = PCI_MAP_SINGLE(pAd, (char *) pTxBlk->pSrcBufData, pTxBlk->SrcBufLen, PCI_DMA_TODEVICE); */
-
-	/* */
-	/* get Tx Ring Resource & Dma Buffer address */
-	/* */
-	QueIdx = pTxBlk->QueIdx;
-
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-	pHTTXContext = &pAd->TxContext[QueIdx];
-	fillOffset = pHTTXContext->CurWritePosition;
-
-	/* Check ring full. */
-	Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-	if (Status == NDIS_STATUS_SUCCESS) {
-		pHTTXContext->bCurWriting = TRUE;
-
-		pTxInfo = (struct rt_txinfo *)(&pTxBlk->HeaderBuf[0]);
-		pTxWI = (struct rt_txwi *) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
-
-		/* Reserve space for 8 bytes padding. */
-		if ((pHTTXContext->ENextBulkOutPosition ==
-		     pHTTXContext->CurWritePosition)) {
-			pHTTXContext->ENextBulkOutPosition += 8;
-			pHTTXContext->CurWritePosition += 8;
-			fillOffset += 8;
-		}
-		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
-
-		pWirelessPacket =
-		    &pHTTXContext->TransferBuffer->field.
-		    WirelessPacket[fillOffset];
-
-		/* copy TXWI + WLAN Header + LLC into DMA Header Buffer */
-		/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-		hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-		/* Build our URB for USBD */
-		DMAHdrLen = TXWI_SIZE + hwHdrLen;
-		USBDMApktLen = DMAHdrLen + pTxBlk->SrcBufLen;
-		padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
-		USBDMApktLen += padding;
-
-		pTxBlk->Priv = (TXINFO_SIZE + USBDMApktLen);
-
-		/* For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload */
-		RTMPWriteTxInfo(pAd, pTxInfo, (u16)(USBDMApktLen), FALSE,
-				FIFO_EDCA, FALSE /*NextValid */ , FALSE);
-
-		if ((pHTTXContext->CurWritePosition + 3906 + pTxBlk->Priv) >
-		    MAX_TXBULK_LIMIT) {
-			pTxInfo->SwUseLastRound = 1;
-			bTxQLastRound = TRUE;
-		}
-		NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
-			       TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-		pWirelessPacket += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-
-		/* We unlock it here to prevent the first 8 bytes maybe over-writed issue. */
-		/*      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxcontext. */
-		/*      2. An interrupt break our routine and handle bulk-out complete. */
-		/*      3. In the bulk-out compllete, it need to do another bulk-out, */
-		/*                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition, */
-		/*                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE. */
-		/*      4. Interrupt complete. */
-		/*  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext. */
-		/*      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition. */
-		/*              and the packet will wrong. */
-		pHTTXContext->CurWriteRealPos +=
-		    (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
-		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-		NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData,
-			       pTxBlk->SrcBufLen);
-		pWirelessPacket += pTxBlk->SrcBufLen;
-		NdisZeroMemory(pWirelessPacket, padding + 8);
-
-		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-		pHTTXContext->CurWritePosition += pTxBlk->Priv;
-		if (bTxQLastRound)
-			pHTTXContext->CurWritePosition = 8;
-		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
-
-		pHTTXContext->bCurWriting = FALSE;
-	}
-
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	/* succeed and release the skb buffer */
-	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
-
-	return (Status);
-
-}
-
-u16 RtmpUSB_WriteMultiTxResource(struct rt_rtmp_adapter *pAd,
-				    struct rt_tx_blk *pTxBlk,
-				    u8 frameNum, u16 * FreeNumber)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	u16 hwHdrLen;	/* The hwHdrLen consist of 802.11 header length plus the header padding length. */
-	u32 fillOffset;
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi *pTxWI;
-	u8 *pWirelessPacket = NULL;
-	u8 QueIdx;
-	int Status;
-	unsigned long IrqFlags;
-	/*u32                        USBDMApktLen = 0, DMAHdrLen, padding; */
-
-	/* */
-	/* get Tx Ring Resource & Dma Buffer address */
-	/* */
-	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext = &pAd->TxContext[QueIdx];
-
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	if (frameNum == 0) {
-		/* Check if we have enough space for this bulk-out batch. */
-		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-		if (Status == NDIS_STATUS_SUCCESS) {
-			pHTTXContext->bCurWriting = TRUE;
-
-			pTxInfo = (struct rt_txinfo *)(&pTxBlk->HeaderBuf[0]);
-			pTxWI = (struct rt_txwi *) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
-
-			/* Reserve space for 8 bytes padding. */
-			if ((pHTTXContext->ENextBulkOutPosition ==
-			     pHTTXContext->CurWritePosition)) {
-
-				pHTTXContext->CurWritePosition += 8;
-				pHTTXContext->ENextBulkOutPosition += 8;
-			}
-			fillOffset = pHTTXContext->CurWritePosition;
-			pHTTXContext->CurWriteRealPos =
-			    pHTTXContext->CurWritePosition;
-
-			pWirelessPacket =
-			    &pHTTXContext->TransferBuffer->field.
-			    WirelessPacket[fillOffset];
-
-			/* */
-			/* Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
-			/* */
-			if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
-				hwHdrLen =
-				    pTxBlk->MpduHeaderLen -
-				    LENGTH_AMSDU_SUBFRAMEHEAD +
-				    pTxBlk->HdrPadLen +
-				    LENGTH_AMSDU_SUBFRAMEHEAD;
-			else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
-				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD; */
-				hwHdrLen =
-				    pTxBlk->MpduHeaderLen -
-				    LENGTH_ARALINK_HEADER_FIELD +
-				    pTxBlk->HdrPadLen +
-				    LENGTH_ARALINK_HEADER_FIELD;
-			else
-				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
-				hwHdrLen =
-				    pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
-
-			/* Update the pTxBlk->Priv. */
-			pTxBlk->Priv = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
-
-			/*      pTxInfo->USBDMApktLen now just a temp value and will to correct latter. */
-			RTMPWriteTxInfo(pAd, pTxInfo, (u16)(pTxBlk->Priv),
-					FALSE, FIFO_EDCA, FALSE /*NextValid */ ,
-					FALSE);
-
-			/* Copy it. */
-			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
-				       pTxBlk->Priv);
-			pHTTXContext->CurWriteRealPos += pTxBlk->Priv;
-			pWirelessPacket += pTxBlk->Priv;
-		}
-	} else {		/* For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer. */
-
-		Status =
-		    ((pHTTXContext->bCurWriting ==
-		      TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
-		if (Status == NDIS_STATUS_SUCCESS) {
-			fillOffset =
-			    (pHTTXContext->CurWritePosition + pTxBlk->Priv);
-			pWirelessPacket =
-			    &pHTTXContext->TransferBuffer->field.
-			    WirelessPacket[fillOffset];
-
-			/*hwHdrLen = pTxBlk->MpduHeaderLen; */
-			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
-				       pTxBlk->MpduHeaderLen);
-			pWirelessPacket += (pTxBlk->MpduHeaderLen);
-			pTxBlk->Priv += pTxBlk->MpduHeaderLen;
-		} else {	/* It should not happened now unless we are going to shutdown. */
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("WriteMultiTxResource():bCurWriting is FALSE when handle sub-sequent frames.\n"));
-			Status = NDIS_STATUS_FAILURE;
-		}
-	}
-
-	/* We unlock it here to prevent the first 8 bytes maybe over-write issue. */
-	/*      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxContext. */
-	/*      2. An interrupt break our routine and handle bulk-out complete. */
-	/*      3. In the bulk-out compllete, it need to do another bulk-out, */
-	/*                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition, */
-	/*                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE. */
-	/*      4. Interrupt complete. */
-	/*  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext. */
-	/*      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition. */
-	/*              and the packet will wrong. */
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	if (Status != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("WriteMultiTxResource: CWPos = %ld, NBOutPos = %ld.\n",
-			  pHTTXContext->CurWritePosition,
-			  pHTTXContext->NextBulkOutPosition));
-		goto done;
-	}
-	/* Copy the frame content into DMA buffer and update the pTxBlk->Priv */
-	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
-	pWirelessPacket += pTxBlk->SrcBufLen;
-	pTxBlk->Priv += pTxBlk->SrcBufLen;
-
-done:
-	/* Release the skb buffer here */
-	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
-
-	return (Status);
-
-}
-
-void RtmpUSB_FinalWriteTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  u16 totalMPDUSize, u16 TxIdx)
-{
-	u8 QueIdx;
-	struct rt_ht_tx_context *pHTTXContext;
-	u32 fillOffset;
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi *pTxWI;
-	u32 USBDMApktLen, padding;
-	unsigned long IrqFlags;
-	u8 *pWirelessPacket;
-
-	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext = &pAd->TxContext[QueIdx];
-
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-	if (pHTTXContext->bCurWriting == TRUE) {
-		fillOffset = pHTTXContext->CurWritePosition;
-		if (((pHTTXContext->ENextBulkOutPosition ==
-		      pHTTXContext->CurWritePosition)
-		     || ((pHTTXContext->ENextBulkOutPosition - 8) ==
-			 pHTTXContext->CurWritePosition))
-		    && (pHTTXContext->bCopySavePad == TRUE))
-			pWirelessPacket = (u8 *)(&pHTTXContext->SavedPad[0]);
-		else
-			pWirelessPacket =
-			    (u8 *)(&pHTTXContext->TransferBuffer->field.
-				      WirelessPacket[fillOffset]);
-
-		/* */
-		/* Update TxInfo->USBDMApktLen , */
-		/*              the length = TXWI_SIZE + 802.11_hdr + 802.11_hdr_pad + payload_of_all_batch_frames + Bulk-Out-padding */
-		/* */
-		pTxInfo = (struct rt_txinfo *)(pWirelessPacket);
-
-		/* Calculate the bulk-out padding */
-		USBDMApktLen = pTxBlk->Priv - TXINFO_SIZE;
-		padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
-		USBDMApktLen += padding;
-
-		pTxInfo->USBDMATxPktLen = USBDMApktLen;
-
-		/* */
-		/* Update TXWI->MPDUtotalByteCount , */
-		/*              the length = 802.11 header + payload_of_all_batch_frames */
-		pTxWI = (struct rt_txwi *) (pWirelessPacket + TXINFO_SIZE);
-		pTxWI->MPDUtotalByteCount = totalMPDUSize;
-
-		/* */
-		/* Update the pHTTXContext->CurWritePosition */
-		/* */
-		pHTTXContext->CurWritePosition += (TXINFO_SIZE + USBDMApktLen);
-		if ((pHTTXContext->CurWritePosition + 3906) > MAX_TXBULK_LIMIT) {	/* Add 3906 for prevent the NextBulkOut packet size is a A-RALINK/A-MSDU Frame. */
-			pHTTXContext->CurWritePosition = 8;
-			pTxInfo->SwUseLastRound = 1;
-		}
-		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
-
-		/* */
-		/*      Zero the last padding. */
-		/* */
-		pWirelessPacket =
-		    (&pHTTXContext->TransferBuffer->field.
-		     WirelessPacket[fillOffset + pTxBlk->Priv]);
-		NdisZeroMemory(pWirelessPacket, padding + 8);
-
-		/* Finally, set bCurWriting as FALSE */
-		pHTTXContext->bCurWriting = FALSE;
-
-	} else {		/* It should not happened now unless we are going to shutdown. */
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("FinalWriteTxResource():bCurWriting is FALSE when handle last frames.\n"));
-	}
-
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-}
-
-void RtmpUSBDataLastTxIdx(struct rt_rtmp_adapter *pAd,
-			  u8 QueIdx, u16 TxIdx)
-{
-	/* DO nothing for USB. */
-}
-
-/*
-	When can do bulk-out:
-		1. TxSwFreeIdx < TX_RING_SIZE;
-			It means has at least one Ring entity is ready for bulk-out, kick it out.
-		2. If TxSwFreeIdx == TX_RING_SIZE
-			Check if the CurWriting flag is FALSE, if it's FALSE, we can do kick out.
-
-*/
-void RtmpUSBDataKickOut(struct rt_rtmp_adapter *pAd,
-			struct rt_tx_blk *pTxBlk, u8 QueIdx)
-{
-	RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
-	RTUSBKickBulkOut(pAd);
-
-}
-
-/*
-	Must be run in Interrupt context
-	This function handle RT2870 specific TxDesc and cpu index update and kick the packet out.
- */
-int RtmpUSBMgmtKickOut(struct rt_rtmp_adapter *pAd,
-		       u8 QueIdx,
-		       void *pPacket,
-		       u8 *pSrcBufVA, u32 SrcBufLen)
-{
-	struct rt_txinfo *pTxInfo;
-	unsigned long BulkOutSize;
-	u8 padLen;
-	u8 *pDest;
-	unsigned long SwIdx = pAd->MgmtRing.TxCpuIdx;
-	struct rt_tx_context *pMLMEContext =
-	    (struct rt_tx_context *)pAd->MgmtRing.Cell[SwIdx].AllocVa;
-	unsigned long IrqFlags;
-
-	pTxInfo = (struct rt_txinfo *)(pSrcBufVA);
-
-	/* Build our URB for USBD */
-	BulkOutSize = SrcBufLen;
-	BulkOutSize = (BulkOutSize + 3) & (~3);
-	RTMPWriteTxInfo(pAd, pTxInfo, (u16)(BulkOutSize - TXINFO_SIZE),
-			TRUE, EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
-
-	BulkOutSize += 4;	/* Always add 4 extra bytes at every packet. */
-
-	/* If BulkOutSize is multiple of BulkOutMaxPacketSize, add extra 4 bytes again. */
-	if ((BulkOutSize % pAd->BulkOutMaxPacketSize) == 0)
-		BulkOutSize += 4;
-
-	padLen = BulkOutSize - SrcBufLen;
-	ASSERT((padLen <= RTMP_PKT_TAIL_PADDING));
-
-	/* Now memzero all extra padding bytes. */
-	pDest = (u8 *)(pSrcBufVA + SrcBufLen);
-	skb_put(GET_OS_PKT_TYPE(pPacket), padLen);
-	NdisZeroMemory(pDest, padLen);
-
-	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-
-	pAd->MgmtRing.Cell[pAd->MgmtRing.TxCpuIdx].pNdisPacket = pPacket;
-	pMLMEContext->TransferBuffer =
-	    (struct rt_tx_buffer *)(GET_OS_PKT_DATAPTR(pPacket));
-
-	/* Length in TxInfo should be 8 less than bulkout size. */
-	pMLMEContext->BulkOutSize = BulkOutSize;
-	pMLMEContext->InUse = TRUE;
-	pMLMEContext->bWaitingBulkOut = TRUE;
-
-	/*for debug */
-	/*hex_dump("RtmpUSBMgmtKickOut", &pMLMEContext->TransferBuffer->field.WirelessPacket[0], (pMLMEContext->BulkOutSize > 16 ? 16 : pMLMEContext->BulkOutSize)); */
-
-	/*pAd->RalinkCounters.KickTxCount++; */
-	/*pAd->RalinkCounters.OneSecTxDoneCount++; */
-
-	/*if (pAd->MgmtRing.TxSwFreeIdx == MGMT_RING_SIZE) */
-	/*      needKickOut = TRUE; */
-
-	/* Decrease the TxSwFreeIdx and Increase the TX_CTX_IDX */
-	pAd->MgmtRing.TxSwFreeIdx--;
-	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
-
-	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-
-	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-	/*if (needKickOut) */
-	RTUSBKickBulkOut(pAd);
-
-	return 0;
-}
-
-void RtmpUSBNullFrameKickOut(struct rt_rtmp_adapter *pAd,
-			     u8 QueIdx,
-			     u8 * pNullFrame, u32 frameLen)
-{
-	if (pAd->NullContext.InUse == FALSE) {
-		struct rt_tx_context *pNullContext;
-		struct rt_txinfo *pTxInfo;
-		struct rt_txwi * pTxWI;
-		u8 *pWirelessPkt;
-
-		pNullContext = &(pAd->NullContext);
-
-		/* Set the in use bit */
-		pNullContext->InUse = TRUE;
-		pWirelessPkt =
-		    (u8 *)& pNullContext->TransferBuffer->field.
-		    WirelessPacket[0];
-
-		RTMPZeroMemory(&pWirelessPkt[0], 100);
-		pTxInfo = (struct rt_txinfo *)& pWirelessPkt[0];
-		RTMPWriteTxInfo(pAd, pTxInfo,
-				(u16)(sizeof(struct rt_header_802_11) + TXWI_SIZE),
-				TRUE, EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
-		pTxInfo->QSEL = FIFO_EDCA;
-		pTxWI = (struct rt_txwi *) & pWirelessPkt[TXINFO_SIZE];
-		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE,
-			      FALSE, 0, BSSID_WCID, (sizeof(struct rt_header_802_11)), 0,
-			      0, (u8)pAd->CommonCfg.MlmeTransmit.field.MCS,
-			      IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
-
-		RTMPMoveMemory(&pWirelessPkt[TXWI_SIZE + TXINFO_SIZE],
-			       &pAd->NullFrame, sizeof(struct rt_header_802_11));
-		pAd->NullContext.BulkOutSize =
-		    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
-
-		/* Fill out frame length information for global Bulk out arbitor */
-		/*pNullContext->BulkOutSize = TransferBufferLength; */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("SYNC - send NULL Frame @%d Mbps...\n",
-			  RateIdToMbps[pAd->CommonCfg.TxRate]));
-		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
-
-		/* Kick bulk out */
-		RTUSBKickBulkOut(pAd);
-	}
-
-}
-
-/*
-========================================================================
-Routine Description:
-    Get a received packet.
-
-Arguments:
-	pAd					device control block
-	pSaveRxD			receive descriptor information
-	*pbReschedule		need reschedule flag
-	*pRxPending			pending received packet flag
-
-Return Value:
-    the received packet
-
-Note:
-========================================================================
-*/
-void *GetPacketFromRxRing(struct rt_rtmp_adapter *pAd,
-				 OUT PRT28XX_RXD_STRUC pSaveRxD,
-				 OUT BOOLEAN * pbReschedule,
-				 IN u32 * pRxPending)
-{
-	struct rt_rx_context *pRxContext;
-	void *pSkb;
-	u8 *pData;
-	unsigned long ThisFrameLen;
-	unsigned long RxBufferLength;
-	struct rt_rxwi * pRxWI;
-
-	pRxContext = &pAd->RxContext[pAd->NextRxBulkInReadIndex];
-	if ((pRxContext->Readable == FALSE) || (pRxContext->InUse == TRUE))
-		return NULL;
-
-	RxBufferLength = pRxContext->BulkInOffset - pAd->ReadPosition;
-	if (RxBufferLength <
-	    (RT2870_RXDMALEN_FIELD_SIZE + sizeof(struct rt_rxwi) +
-	     sizeof(struct rt_rxinfo))) {
-		goto label_null;
-	}
-
-	pData = &pRxContext->TransferBuffer[pAd->ReadPosition];	/* 4KB */
-	/* The RXDMA field is 4 bytes, now just use the first 2 bytes. The Length including the (RXWI + MSDU + Padding) */
-	ThisFrameLen = *pData + (*(pData + 1) << 8);
-	if (ThisFrameLen == 0) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BIRIdx(%d): RXDMALen is zero.[%ld], BulkInBufLen = %ld)\n",
-			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
-			  pRxContext->BulkInOffset));
-		goto label_null;
-	}
-	if ((ThisFrameLen & 0x3) != 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("BIRIdx(%d): RXDMALen not multiple of 4.[%ld], BulkInBufLen = %ld)\n",
-			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
-			  pRxContext->BulkInOffset));
-		goto label_null;
-	}
-
-	if ((ThisFrameLen + 8) > RxBufferLength)	/* 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(struct rt_rxinfo)) */
-	{
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BIRIdx(%d):FrameLen(0x%lx) outranges. BulkInLen=0x%lx, remaining RxBufLen=0x%lx, ReadPos=0x%lx\n",
-			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
-			  pRxContext->BulkInOffset, RxBufferLength,
-			  pAd->ReadPosition));
-
-		/* error frame. finish this loop */
-		goto label_null;
-	}
-	/* skip USB frame length field */
-	pData += RT2870_RXDMALEN_FIELD_SIZE;
-	pRxWI = (struct rt_rxwi *) pData;
-	if (pRxWI->MPDUtotalByteCount > ThisFrameLen) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s():pRxWIMPDUtotalByteCount(%d) large than RxDMALen(%ld)\n",
-			  __FUNCTION__, pRxWI->MPDUtotalByteCount,
-			  ThisFrameLen));
-		goto label_null;
-	}
-	/* allocate a rx packet */
-	pSkb = dev_alloc_skb(ThisFrameLen);
-	if (pSkb == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s():Cannot Allocate sk buffer for this Bulk-In buffer!\n",
-			  __FUNCTION__));
-		goto label_null;
-	}
-	/* copy the rx packet */
-	memcpy(skb_put(pSkb, ThisFrameLen), pData, ThisFrameLen);
-	RTPKT_TO_OSPKT(pSkb)->dev = get_netdev_from_bssid(pAd, BSS0);
-	RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pSkb), PKTSRC_NDIS);
-
-	/* copy RxD */
-	*pSaveRxD = *(struct rt_rxinfo *) (pData + ThisFrameLen);
-
-	/* update next packet read position. */
-	pAd->ReadPosition += (ThisFrameLen + RT2870_RXDMALEN_FIELD_SIZE + RXINFO_SIZE);	/* 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(struct rt_rxinfo)) */
-
-	return pSkb;
-
-label_null:
-
-	return NULL;
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
-
-	Arguments:
-		pRxD		Pointer	to the Rx descriptor
-
-	Return Value:
-		NDIS_STATUS_SUCCESS		No err
-		NDIS_STATUS_FAILURE		Error
-
-	Note:
-
-	========================================================================
-*/
-int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
-			     struct rt_header_802_11 * pHeader,
-			     struct rt_rxwi * pRxWI, IN PRT28XX_RXD_STRUC pRxINFO)
-{
-	struct rt_cipher_key *pWpaKey;
-	int dBm;
-
-	if (pAd->bPromiscuous == TRUE)
-		return (NDIS_STATUS_SUCCESS);
-	if (pRxINFO == NULL)
-		return (NDIS_STATUS_FAILURE);
-
-	/* Phy errors & CRC errors */
-	if (pRxINFO->Crc) {
-		/* Check RSSI for Noise Hist statistic collection. */
-		dBm = (int)(pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
-		if (dBm <= -87)
-			pAd->StaCfg.RPIDensity[0] += 1;
-		else if (dBm <= -82)
-			pAd->StaCfg.RPIDensity[1] += 1;
-		else if (dBm <= -77)
-			pAd->StaCfg.RPIDensity[2] += 1;
-		else if (dBm <= -72)
-			pAd->StaCfg.RPIDensity[3] += 1;
-		else if (dBm <= -67)
-			pAd->StaCfg.RPIDensity[4] += 1;
-		else if (dBm <= -62)
-			pAd->StaCfg.RPIDensity[5] += 1;
-		else if (dBm <= -57)
-			pAd->StaCfg.RPIDensity[6] += 1;
-		else if (dBm > -57)
-			pAd->StaCfg.RPIDensity[7] += 1;
-
-		return (NDIS_STATUS_FAILURE);
-	}
-	/* Add Rx size to channel load counter, we should ignore error counts */
-	pAd->StaCfg.CLBusyBytes += (pRxWI->MPDUtotalByteCount + 14);
-
-	/* Drop ToDs promiscuous frame, it is opened due to CCX 2 channel load statistics */
-	if (pHeader->FC.ToDs) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Err;FC.ToDs\n"));
-		return NDIS_STATUS_FAILURE;
-	}
-	/* Paul 04-03 for OFDM Rx length issue */
-	if (pRxWI->MPDUtotalByteCount > MAX_AGGREGATION_SIZE) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("received packet too long\n"));
-		return NDIS_STATUS_FAILURE;
-	}
-	/* Drop not U2M frames, can't's drop here because we will drop beacon in this case */
-	/* I am kind of doubting the U2M bit operation */
-	/* if (pRxD->U2M == 0) */
-	/*      return(NDIS_STATUS_FAILURE); */
-
-	/* drop decyption fail frame */
-	if (pRxINFO->Decrypted && pRxINFO->CipherErr) {
-
-		if (((pRxINFO->CipherErr & 1) == 1)
-		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-			RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-
-		if (((pRxINFO->CipherErr & 2) == 2)
-		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-			RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		/* */
-		/* MIC Error */
-		/* */
-		if ((pRxINFO->CipherErr == 2) && pRxINFO->MyBss) {
-			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
-			RTMPReportMicError(pAd, pWpaKey);
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error\n"));
-		}
-
-		if (pRxINFO->Decrypted &&
-		    (pAd->SharedKey[BSS0][pRxWI->KeyIndex].CipherAlg ==
-		     CIPHER_AES)
-		    && (pHeader->Sequence == pAd->FragFrame.Sequence)) {
-			/* */
-			/* Acceptable since the First FragFrame no CipherErr problem. */
-			/* */
-			return (NDIS_STATUS_SUCCESS);
-		}
-
-		return (NDIS_STATUS_FAILURE);
-	}
-
-	return (NDIS_STATUS_SUCCESS);
-}
-
-void RtmpUsbStaAsicForceWakeupTimeout(void *SystemSpecific1,
-				      void *FunctionContext,
-				      void *SystemSpecific2,
-				      void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	if (pAd && pAd->Mlme.AutoWakeupTimerRunning) {
-		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-		pAd->Mlme.AutoWakeupTimerRunning = FALSE;
-	}
-}
-
-void RT28xxUsbStaAsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx)
-{
-	BOOLEAN Canceled;
-
-	if (pAd->Mlme.AutoWakeupTimerRunning)
-		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Canceled);
-
-	AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-}
-
-void RT28xxUsbStaAsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-					 u16 TbttNumToNextWakeUp)
-{
-
-	/* we have decided to SLEEP, so at least do it for a BEACON period. */
-	if (TbttNumToNextWakeUp == 0)
-		TbttNumToNextWakeUp = 1;
-
-	RTMPSetTimer(&pAd->Mlme.AutoWakeupTimer, AUTO_WAKEUP_TIMEOUT);
-	pAd->Mlme.AutoWakeupTimerRunning = TRUE;
-
-	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);	/* send POWER-SAVE command to MCU. Timeout 40us. */
-
-	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
-
-}
-
-#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2860/common/cmm_info.c b/drivers/staging/rt2860/common/cmm_info.c
deleted file mode 100644
index 25302e8..0000000
--- a/drivers/staging/rt2860/common/cmm_info.c
+++ /dev/null
@@ -1,955 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-#include <linux/sched.h>
-#include "../rt_config.h"
-
-/*
-	========================================================================
-
-	Routine Description:
-		Remove WPA Key process
-
-	Arguments:
-		pAd 					Pointer to our adapter
-		pBuf							Pointer to the where the key stored
-
-	Return Value:
-		NDIS_SUCCESS					Add key successfully
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPSetDesiredRates(struct rt_rtmp_adapter *pAdapter, long Rates)
-{
-	NDIS_802_11_RATES aryRates;
-
-	memset(&aryRates, 0x00, sizeof(NDIS_802_11_RATES));
-	switch (pAdapter->CommonCfg.PhyMode) {
-	case PHY_11A:		/* A only */
-		switch (Rates) {
-		case 6000000:	/*6M */
-			aryRates[0] = 0x0c;	/* 6M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_0;
-			break;
-		case 9000000:	/*9M */
-			aryRates[0] = 0x12;	/* 9M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_1;
-			break;
-		case 12000000:	/*12M */
-			aryRates[0] = 0x18;	/* 12M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_2;
-			break;
-		case 18000000:	/*18M */
-			aryRates[0] = 0x24;	/* 18M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_3;
-			break;
-		case 24000000:	/*24M */
-			aryRates[0] = 0x30;	/* 24M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_4;
-			break;
-		case 36000000:	/*36M */
-			aryRates[0] = 0x48;	/* 36M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_5;
-			break;
-		case 48000000:	/*48M */
-			aryRates[0] = 0x60;	/* 48M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_6;
-			break;
-		case 54000000:	/*54M */
-			aryRates[0] = 0x6c;	/* 54M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_7;
-			break;
-		case -1:	/*Auto */
-		default:
-			aryRates[0] = 0x6c;	/* 54Mbps */
-			aryRates[1] = 0x60;	/* 48Mbps */
-			aryRates[2] = 0x48;	/* 36Mbps */
-			aryRates[3] = 0x30;	/* 24Mbps */
-			aryRates[4] = 0x24;	/* 18M */
-			aryRates[5] = 0x18;	/* 12M */
-			aryRates[6] = 0x12;	/* 9M */
-			aryRates[7] = 0x0c;	/* 6M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_AUTO;
-			break;
-		}
-		break;
-	case PHY_11BG_MIXED:	/* B/G Mixed */
-	case PHY_11B:		/* B only */
-	case PHY_11ABG_MIXED:	/* A/B/G Mixed */
-	default:
-		switch (Rates) {
-		case 1000000:	/*1M */
-			aryRates[0] = 0x02;
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_0;
-			break;
-		case 2000000:	/*2M */
-			aryRates[0] = 0x04;
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_1;
-			break;
-		case 5000000:	/*5.5M */
-			aryRates[0] = 0x0b;	/* 5.5M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_2;
-			break;
-		case 11000000:	/*11M */
-			aryRates[0] = 0x16;	/* 11M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_3;
-			break;
-		case 6000000:	/*6M */
-			aryRates[0] = 0x0c;	/* 6M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_0;
-			break;
-		case 9000000:	/*9M */
-			aryRates[0] = 0x12;	/* 9M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_1;
-			break;
-		case 12000000:	/*12M */
-			aryRates[0] = 0x18;	/* 12M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_2;
-			break;
-		case 18000000:	/*18M */
-			aryRates[0] = 0x24;	/* 18M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_3;
-			break;
-		case 24000000:	/*24M */
-			aryRates[0] = 0x30;	/* 24M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_4;
-			break;
-		case 36000000:	/*36M */
-			aryRates[0] = 0x48;	/* 36M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_5;
-			break;
-		case 48000000:	/*48M */
-			aryRates[0] = 0x60;	/* 48M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_6;
-			break;
-		case 54000000:	/*54M */
-			aryRates[0] = 0x6c;	/* 54M */
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_7;
-			break;
-		case -1:	/*Auto */
-		default:
-			if (pAdapter->CommonCfg.PhyMode == PHY_11B) {	/*B Only */
-				aryRates[0] = 0x16;	/* 11Mbps */
-				aryRates[1] = 0x0b;	/* 5.5Mbps */
-				aryRates[2] = 0x04;	/* 2Mbps */
-				aryRates[3] = 0x02;	/* 1Mbps */
-			} else {	/*(B/G) Mixed or (A/B/G) Mixed */
-				aryRates[0] = 0x6c;	/* 54Mbps */
-				aryRates[1] = 0x60;	/* 48Mbps */
-				aryRates[2] = 0x48;	/* 36Mbps */
-				aryRates[3] = 0x30;	/* 24Mbps */
-				aryRates[4] = 0x16;	/* 11Mbps */
-				aryRates[5] = 0x0b;	/* 5.5Mbps */
-				aryRates[6] = 0x04;	/* 2Mbps */
-				aryRates[7] = 0x02;	/* 1Mbps */
-			}
-			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
-			    MCS_AUTO;
-			break;
-		}
-		break;
-	}
-
-	NdisZeroMemory(pAdapter->CommonCfg.DesireRate,
-		       MAX_LEN_OF_SUPPORTED_RATES);
-	NdisMoveMemory(pAdapter->CommonCfg.DesireRate, &aryRates,
-		       sizeof(NDIS_802_11_RATES));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 (" RTMPSetDesiredRates (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
-		  pAdapter->CommonCfg.DesireRate[0],
-		  pAdapter->CommonCfg.DesireRate[1],
-		  pAdapter->CommonCfg.DesireRate[2],
-		  pAdapter->CommonCfg.DesireRate[3],
-		  pAdapter->CommonCfg.DesireRate[4],
-		  pAdapter->CommonCfg.DesireRate[5],
-		  pAdapter->CommonCfg.DesireRate[6],
-		  pAdapter->CommonCfg.DesireRate[7]));
-	/* Changing DesiredRate may affect the MAX TX rate we used to TX frames out */
-	MlmeUpdateTxRates(pAdapter, FALSE, 0);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Remove All WPA Keys
-
-	Arguments:
-		pAd 					Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPWPARemoveAllKeys(struct rt_rtmp_adapter *pAd)
-{
-
-	u8 i;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n",
-		  pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus));
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-	/* For WEP/CKIP, there is no need to remove it, since WinXP won't set it again after */
-	/* Link up. And it will be replaced if user changed it. */
-	if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
-		return;
-
-	/* For WPA-None, there is no need to remove it, since WinXP won't set it again after */
-	/* Link up. And it will be replaced if user changed it. */
-	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
-		return;
-
-	/* set BSSID wcid entry of the Pair-wise Key table as no-security mode */
-	AsicRemovePairwiseKeyEntry(pAd, BSS0, BSSID_WCID);
-
-	/* set all shared key mode as no-security. */
-	for (i = 0; i < SHARE_KEY_NUM; i++) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("remove %s key #%d\n",
-			  CipherName[pAd->SharedKey[BSS0][i].CipherAlg], i));
-		NdisZeroMemory(&pAd->SharedKey[BSS0][i], sizeof(struct rt_cipher_key));
-
-		AsicRemoveSharedKeyEntry(pAd, BSS0, i);
-	}
-	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		As STA's BSSID is a WC too, it uses shared key table.
-		This function write correct unicast TX key to ASIC WCID.
-		And we still make a copy in our MacTab.Content[BSSID_WCID].PairwiseKey.
-		Caller guarantee TKIP/AES always has keyidx = 0. (pairwise key)
-		Caller guarantee WEP calls this function when set Txkey,  default key index=0~3.
-
-	Arguments:
-		pAd					Pointer to our adapter
-		pKey							Pointer to the where the key stored
-
-	Return Value:
-		NDIS_SUCCESS					Add key successfully
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-/*
-	========================================================================
-	Routine Description:
-		Change NIC PHY mode. Re-association may be necessary. possible settings
-		include - PHY_11B, PHY_11BG_MIXED, PHY_11A, and PHY_11ABG_MIXED
-
-	Arguments:
-		pAd - Pointer to our adapter
-		phymode  -
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void RTMPSetPhyMode(struct rt_rtmp_adapter *pAd, unsigned long phymode)
-{
-	int i;
-	/* the selected phymode must be supported by the RF IC encoded in E2PROM */
-
-	/* if no change, do nothing */
-	/* bug fix
-	   if (pAd->CommonCfg.PhyMode == phymode)
-	   return;
-	 */
-	pAd->CommonCfg.PhyMode = (u8)phymode;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetPhyMode : PhyMode=%d, channel=%d \n",
-		  pAd->CommonCfg.PhyMode, pAd->CommonCfg.Channel));
-
-	BuildChannelList(pAd);
-
-	/* sanity check user setting */
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		if (pAd->CommonCfg.Channel == pAd->ChannelList[i].Channel)
-			break;
-	}
-
-	if (i == pAd->ChannelListNum) {
-		pAd->CommonCfg.Channel = FirstChannel(pAd);
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTMPSetPhyMode: channel is out of range, use first channel=%d \n",
-			  pAd->CommonCfg.Channel));
-	}
-
-	NdisZeroMemory(pAd->CommonCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
-	NdisZeroMemory(pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
-	NdisZeroMemory(pAd->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
-	switch (phymode) {
-	case PHY_11B:
-		pAd->CommonCfg.SupRate[0] = 0x82;	/* 1 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[1] = 0x84;	/* 2 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[2] = 0x8B;	/* 5.5 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[3] = 0x96;	/* 11 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRateLen = 4;
-		pAd->CommonCfg.ExtRateLen = 0;
-		pAd->CommonCfg.DesireRate[0] = 2;	/* 1 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[1] = 4;	/* 2 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[2] = 11;	/* 5.5 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[3] = 22;	/* 11 mbps, in units of 0.5 Mbps */
-		/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK; // This MODE is only FYI. not use */
-		break;
-
-	case PHY_11G:
-	case PHY_11BG_MIXED:
-	case PHY_11ABG_MIXED:
-	case PHY_11N_2_4G:
-	case PHY_11ABGN_MIXED:
-	case PHY_11BGN_MIXED:
-	case PHY_11GN_MIXED:
-		pAd->CommonCfg.SupRate[0] = 0x82;	/* 1 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[1] = 0x84;	/* 2 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[2] = 0x8B;	/* 5.5 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[3] = 0x96;	/* 11 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[4] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[5] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[6] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRateLen = 8;
-		pAd->CommonCfg.ExtRate[0] = 0x0C;	/* 6 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.ExtRate[1] = 0x18;	/* 12 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.ExtRate[2] = 0x30;	/* 24 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.ExtRate[3] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.ExtRateLen = 4;
-		pAd->CommonCfg.DesireRate[0] = 2;	/* 1 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[1] = 4;	/* 2 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[2] = 11;	/* 5.5 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[3] = 22;	/* 11 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[4] = 12;	/* 6 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[5] = 18;	/* 9 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[6] = 24;	/* 12 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[7] = 36;	/* 18 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[8] = 48;	/* 24 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[9] = 72;	/* 36 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[10] = 96;	/* 48 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[11] = 108;	/* 54 mbps, in units of 0.5 Mbps */
-		break;
-
-	case PHY_11A:
-	case PHY_11AN_MIXED:
-	case PHY_11AGN_MIXED:
-	case PHY_11N_5G:
-		pAd->CommonCfg.SupRate[0] = 0x8C;	/* 6 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[2] = 0x98;	/* 12 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[4] = 0xb0;	/* 24 mbps, in units of 0.5 Mbps, basic rate */
-		pAd->CommonCfg.SupRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.SupRateLen = 8;
-		pAd->CommonCfg.ExtRateLen = 0;
-		pAd->CommonCfg.DesireRate[0] = 12;	/* 6 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[1] = 18;	/* 9 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[2] = 24;	/* 12 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[3] = 36;	/* 18 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[4] = 48;	/* 24 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[5] = 72;	/* 36 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[6] = 96;	/* 48 mbps, in units of 0.5 Mbps */
-		pAd->CommonCfg.DesireRate[7] = 108;	/* 54 mbps, in units of 0.5 Mbps */
-		/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM; // This MODE is only FYI. not use */
-		break;
-
-	default:
-		break;
-	}
-
-	pAd->CommonCfg.BandState = UNKNOWN_BAND;
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Caller ensures we has 802.11n support.
-		Calls at setting HT from AP/STASetinformation
-
-	Arguments:
-		pAd - Pointer to our adapter
-		phymode  -
-
-	========================================================================
-*/
-void RTMPSetHT(struct rt_rtmp_adapter *pAd, struct rt_oid_set_ht_phymode *pHTPhyMode)
-{
-	/*unsigned long *pmcs; */
-	u32 Value = 0;
-	u8 BBPValue = 0;
-	u8 BBP3Value = 0;
-	u8 RxStream = pAd->CommonCfg.RxStream;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetHT : HT_mode(%d), ExtOffset(%d), MCS(%d), BW(%d), STBC(%d), SHORTGI(%d)\n",
-		  pHTPhyMode->HtMode, pHTPhyMode->ExtOffset, pHTPhyMode->MCS,
-		  pHTPhyMode->BW, pHTPhyMode->STBC, pHTPhyMode->SHORTGI));
-
-	/* Don't zero supportedHyPhy structure. */
-	RTMPZeroMemory(&pAd->CommonCfg.HtCapability,
-		       sizeof(pAd->CommonCfg.HtCapability));
-	RTMPZeroMemory(&pAd->CommonCfg.AddHTInfo,
-		       sizeof(pAd->CommonCfg.AddHTInfo));
-	RTMPZeroMemory(&pAd->CommonCfg.NewExtChanOffset,
-		       sizeof(pAd->CommonCfg.NewExtChanOffset));
-	RTMPZeroMemory(&pAd->CommonCfg.DesiredHtPhy,
-		       sizeof(pAd->CommonCfg.DesiredHtPhy));
-
-	if (pAd->CommonCfg.bRdg) {
-		pAd->CommonCfg.HtCapability.ExtHtCapInfo.PlusHTC = 1;
-		pAd->CommonCfg.HtCapability.ExtHtCapInfo.RDGSupport = 1;
-	} else {
-		pAd->CommonCfg.HtCapability.ExtHtCapInfo.PlusHTC = 0;
-		pAd->CommonCfg.HtCapability.ExtHtCapInfo.RDGSupport = 0;
-	}
-
-	pAd->CommonCfg.HtCapability.HtCapParm.MaxRAmpduFactor = 3;
-	pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor = 3;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetHT : RxBAWinLimit = %d\n",
-		  pAd->CommonCfg.BACapability.field.RxBAWinLimit));
-
-	/* Mimo power save, A-MSDU size, */
-	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
-	    (u16)pAd->CommonCfg.BACapability.field.AmsduEnable;
-	pAd->CommonCfg.DesiredHtPhy.AmsduSize =
-	    (u8)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.DesiredHtPhy.MimoPs =
-	    (u8)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.DesiredHtPhy.MpduDensity =
-	    (u8)pAd->CommonCfg.BACapability.field.MpduDensity;
-
-	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize =
-	    (u16)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs =
-	    (u16)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity =
-	    (u8)pAd->CommonCfg.BACapability.field.MpduDensity;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetHT : AMsduSize = %d, MimoPs = %d, MpduDensity = %d, MaxRAmpduFactor = %d\n",
-		  pAd->CommonCfg.DesiredHtPhy.AmsduSize,
-		  pAd->CommonCfg.DesiredHtPhy.MimoPs,
-		  pAd->CommonCfg.DesiredHtPhy.MpduDensity,
-		  pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor));
-
-	if (pHTPhyMode->HtMode == HTMODE_GF) {
-		pAd->CommonCfg.HtCapability.HtCapInfo.GF = 1;
-		pAd->CommonCfg.DesiredHtPhy.GF = 1;
-	} else
-		pAd->CommonCfg.DesiredHtPhy.GF = 0;
-
-	/* Decide Rx MCSSet */
-	switch (RxStream) {
-	case 1:
-		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
-		pAd->CommonCfg.HtCapability.MCSSet[1] = 0x00;
-		break;
-
-	case 2:
-		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
-		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
-		break;
-
-	case 3:		/* 3*3 */
-		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
-		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
-		pAd->CommonCfg.HtCapability.MCSSet[2] = 0xff;
-		break;
-	}
-
-	if (pAd->CommonCfg.bForty_Mhz_Intolerant
-	    && (pAd->CommonCfg.Channel <= 14) && (pHTPhyMode->BW == BW_40)) {
-		pHTPhyMode->BW = BW_20;
-		pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant = 1;
-	}
-
-	if (pHTPhyMode->BW == BW_40) {
-		pAd->CommonCfg.HtCapability.MCSSet[4] = 0x1;	/* MCS 32 */
-		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = 1;
-		if (pAd->CommonCfg.Channel <= 14)
-			pAd->CommonCfg.HtCapability.HtCapInfo.CCKmodein40 = 1;
-
-		pAd->CommonCfg.DesiredHtPhy.ChannelWidth = 1;
-		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 1;
-		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset =
-		    (pHTPhyMode->ExtOffset ==
-		     EXTCHA_BELOW) ? (EXTCHA_BELOW) : EXTCHA_ABOVE;
-		/* Set Regsiter for extension channel position. */
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBP3Value);
-		if ((pHTPhyMode->ExtOffset == EXTCHA_BELOW)) {
-			Value |= 0x1;
-			BBP3Value |= (0x20);
-			RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
-		} else if ((pHTPhyMode->ExtOffset == EXTCHA_ABOVE)) {
-			Value &= 0xfe;
-			BBP3Value &= (~0x20);
-			RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
-		}
-		/* Turn on BBP 40MHz mode now only as AP . */
-		/* Sta can turn on BBP 40MHz after connection with 40MHz AP. Sta only broadcast 40MHz capability before connection. */
-		if ((pAd->OpMode == OPMODE_AP) || INFRA_ON(pAd) || ADHOC_ON(pAd)
-		    ) {
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-			BBPValue &= (~0x18);
-			BBPValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBP3Value);
-			pAd->CommonCfg.BBPCurrentBW = BW_40;
-		}
-	} else {
-		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = 0;
-		pAd->CommonCfg.DesiredHtPhy.ChannelWidth = 0;
-		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
-		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = EXTCHA_NONE;
-		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
-		/* Turn on BBP 20MHz mode by request here. */
-		{
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-			BBPValue &= (~0x18);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-			pAd->CommonCfg.BBPCurrentBW = BW_20;
-		}
-	}
-
-	if (pHTPhyMode->STBC == STBC_USE) {
-		pAd->CommonCfg.HtCapability.HtCapInfo.TxSTBC = 1;
-		pAd->CommonCfg.DesiredHtPhy.TxSTBC = 1;
-		pAd->CommonCfg.HtCapability.HtCapInfo.RxSTBC = 1;
-		pAd->CommonCfg.DesiredHtPhy.RxSTBC = 1;
-	} else {
-		pAd->CommonCfg.DesiredHtPhy.TxSTBC = 0;
-		pAd->CommonCfg.DesiredHtPhy.RxSTBC = 0;
-	}
-
-	if (pHTPhyMode->SHORTGI == GI_400) {
-		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20 = 1;
-		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40 = 1;
-		pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 = 1;
-		pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 = 1;
-	} else {
-		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20 = 0;
-		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40 = 0;
-		pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 = 0;
-		pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 = 0;
-	}
-
-	/* We support link adaptation for unsolicit MCS feedback, set to 2. */
-	pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback = MCSFBK_NONE;	/*MCSFBK_UNSOLICIT; */
-	pAd->CommonCfg.AddHTInfo.ControlChan = pAd->CommonCfg.Channel;
-	/* 1, the extension channel above the control channel. */
-
-	/* EDCA parameters used for AP's own transmission */
-	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
-		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
-		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
-		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
-		pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
-		pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
-
-		pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
-		pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
-
-		pAd->CommonCfg.APEdcaParm.Cwmax[0] = 6;
-		pAd->CommonCfg.APEdcaParm.Cwmax[1] = 10;
-		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
-
-		pAd->CommonCfg.APEdcaParm.Txop[0] = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[1] = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[2] = 94;
-		pAd->CommonCfg.APEdcaParm.Txop[3] = 47;
-	}
-	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
-
-	{
-		RTMPSetIndividualHT(pAd, 0);
-	}
-
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Caller ensures we has 802.11n support.
-		Calls at setting HT from AP/STASetinformation
-
-	Arguments:
-		pAd - Pointer to our adapter
-		phymode  -
-
-	========================================================================
-*/
-void RTMPSetIndividualHT(struct rt_rtmp_adapter *pAd, u8 apidx)
-{
-	struct rt_ht_phy_info *pDesired_ht_phy = NULL;
-	u8 TxStream = pAd->CommonCfg.TxStream;
-	u8 DesiredMcs = MCS_AUTO;
-
-	do {
-		{
-			pDesired_ht_phy = &pAd->StaCfg.DesiredHtPhyInfo;
-			DesiredMcs =
-			    pAd->StaCfg.DesiredTransmitSetting.field.MCS;
-			/*pAd->StaCfg.bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE; */
-			break;
-		}
-	} while (FALSE);
-
-	if (pDesired_ht_phy == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTMPSetIndividualHT: invalid apidx(%d)\n", apidx));
-		return;
-	}
-	RTMPZeroMemory(pDesired_ht_phy, sizeof(struct rt_ht_phy_info));
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetIndividualHT : Desired MCS = %d\n", DesiredMcs));
-	/* Check the validity of MCS */
-	if ((TxStream == 1)
-	    && ((DesiredMcs >= MCS_8) && (DesiredMcs <= MCS_15))) {
-		DBGPRINT(RT_DEBUG_WARN,
-			 ("RTMPSetIndividualHT: MCS(%d) is invalid in 1S, reset it as MCS_7\n",
-			  DesiredMcs));
-		DesiredMcs = MCS_7;
-	}
-
-	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_20)
-	    && (DesiredMcs == MCS_32)) {
-		DBGPRINT(RT_DEBUG_WARN,
-			 ("RTMPSetIndividualHT: MCS_32 is only supported in 40-MHz, reset it as MCS_0\n"));
-		DesiredMcs = MCS_0;
-	}
-
-	pDesired_ht_phy->bHtEnable = TRUE;
-
-	/* Decide desired Tx MCS */
-	switch (TxStream) {
-	case 1:
-		if (DesiredMcs == MCS_AUTO) {
-			pDesired_ht_phy->MCSSet[0] = 0xff;
-			pDesired_ht_phy->MCSSet[1] = 0x00;
-		} else if (DesiredMcs <= MCS_7) {
-			pDesired_ht_phy->MCSSet[0] = 1 << DesiredMcs;
-			pDesired_ht_phy->MCSSet[1] = 0x00;
-		}
-		break;
-
-	case 2:
-		if (DesiredMcs == MCS_AUTO) {
-			pDesired_ht_phy->MCSSet[0] = 0xff;
-			pDesired_ht_phy->MCSSet[1] = 0xff;
-		} else if (DesiredMcs <= MCS_15) {
-			unsigned long mode;
-
-			mode = DesiredMcs / 8;
-			if (mode < 2)
-				pDesired_ht_phy->MCSSet[mode] =
-				    (1 << (DesiredMcs - mode * 8));
-		}
-		break;
-
-	case 3:		/* 3*3 */
-		if (DesiredMcs == MCS_AUTO) {
-			/* MCS0 ~ MCS23, 3 bytes */
-			pDesired_ht_phy->MCSSet[0] = 0xff;
-			pDesired_ht_phy->MCSSet[1] = 0xff;
-			pDesired_ht_phy->MCSSet[2] = 0xff;
-		} else if (DesiredMcs <= MCS_23) {
-			unsigned long mode;
-
-			mode = DesiredMcs / 8;
-			if (mode < 3)
-				pDesired_ht_phy->MCSSet[mode] =
-				    (1 << (DesiredMcs - mode * 8));
-		}
-		break;
-	}
-
-	if (pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_40) {
-		if (DesiredMcs == MCS_AUTO || DesiredMcs == MCS_32)
-			pDesired_ht_phy->MCSSet[4] = 0x1;
-	}
-	/* update HT Rate setting */
-	if (pAd->OpMode == OPMODE_STA)
-		MlmeUpdateHtTxRates(pAd, BSS0);
-	else
-		MlmeUpdateHtTxRates(pAd, apidx);
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Update HT IE from our capability.
-
-	Arguments:
-		Send all HT IE in beacon/probe rsp/assoc rsp/action frame.
-
-	========================================================================
-*/
-void RTMPUpdateHTIE(struct rt_ht_capability *pRtHt,
-		    u8 * pMcsSet,
-		    struct rt_ht_capability_ie * pHtCapability,
-		    struct rt_add_ht_info_ie * pAddHtInfo)
-{
-	RTMPZeroMemory(pHtCapability, sizeof(struct rt_ht_capability_ie));
-	RTMPZeroMemory(pAddHtInfo, sizeof(struct rt_add_ht_info_ie));
-
-	pHtCapability->HtCapInfo.ChannelWidth = pRtHt->ChannelWidth;
-	pHtCapability->HtCapInfo.MimoPs = pRtHt->MimoPs;
-	pHtCapability->HtCapInfo.GF = pRtHt->GF;
-	pHtCapability->HtCapInfo.ShortGIfor20 = pRtHt->ShortGIfor20;
-	pHtCapability->HtCapInfo.ShortGIfor40 = pRtHt->ShortGIfor40;
-	pHtCapability->HtCapInfo.TxSTBC = pRtHt->TxSTBC;
-	pHtCapability->HtCapInfo.RxSTBC = pRtHt->RxSTBC;
-	pHtCapability->HtCapInfo.AMsduSize = pRtHt->AmsduSize;
-	pHtCapability->HtCapParm.MaxRAmpduFactor = pRtHt->MaxRAmpduFactor;
-	pHtCapability->HtCapParm.MpduDensity = pRtHt->MpduDensity;
-
-	pAddHtInfo->AddHtInfo.ExtChanOffset = pRtHt->ExtChanOffset;
-	pAddHtInfo->AddHtInfo.RecomWidth = pRtHt->RecomWidth;
-	pAddHtInfo->AddHtInfo2.OperaionMode = pRtHt->OperaionMode;
-	pAddHtInfo->AddHtInfo2.NonGfPresent = pRtHt->NonGfPresent;
-	RTMPMoveMemory(pAddHtInfo->MCSSet, /*pRtHt->MCSSet */ pMcsSet, 4);	/* rt2860 only support MCS max=32, no need to copy all 16 uchar. */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateHTIE <== \n"));
-}
-
-/*
-	========================================================================
-	Description:
-		Add Client security information into ASIC WCID table and IVEIV table.
-    Return:
-	========================================================================
-*/
-void RTMPAddWcidAttributeEntry(struct rt_rtmp_adapter *pAd,
-			       u8 BssIdx,
-			       u8 KeyIdx,
-			       u8 CipherAlg, struct rt_mac_table_entry *pEntry)
-{
-	u32 WCIDAttri = 0;
-	u16 offset;
-	u8 IVEIV = 0;
-	u16 Wcid = 0;
-
-	{
-		{
-			if (BssIdx > BSS0) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("RTMPAddWcidAttributeEntry: The BSS-index(%d) is out of range for Infra link. \n",
-					  BssIdx));
-				return;
-			}
-			/* 1.   In ADHOC mode, the AID is wcid number. And NO mesh link exists. */
-			/* 2.   In Infra mode, the AID:1 MUST be wcid of infra STA. */
-			/*                                         the AID:2~ assign to mesh link entry. */
-			if (pEntry)
-				Wcid = pEntry->Aid;
-			else
-				Wcid = MCAST_WCID;
-		}
-	}
-
-	/* Update WCID attribute table */
-	offset = MAC_WCID_ATTRIBUTE_BASE + (Wcid * HW_WCID_ATTRI_SIZE);
-
-	{
-		if (pEntry && pEntry->ValidAsMesh)
-			WCIDAttri = (CipherAlg << 1) | PAIRWISEKEYTABLE;
-		else
-			WCIDAttri = (CipherAlg << 1) | SHAREDKEYTABLE;
-	}
-
-	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
-
-	/* Update IV/EIV table */
-	offset = MAC_IVEIV_TABLE_BASE + (Wcid * HW_IVEIV_ENTRY_SIZE);
-
-	/* WPA mode */
-	if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC)
-	    || (CipherAlg == CIPHER_AES)) {
-		/* Eiv bit on. keyid always is 0 for pairwise key */
-		IVEIV = (KeyIdx << 6) | 0x20;
-	} else {
-		/* WEP KeyIdx is default tx key. */
-		IVEIV = (KeyIdx << 6);
-	}
-
-	/* For key index and ext IV bit, so only need to update the position(offset+3). */
-#ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE8(pAd, offset + 3, IVEIV);
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	RTUSBMultiWrite_OneByte(pAd, offset + 3, &IVEIV);
-#endif /* RTMP_MAC_USB // */
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPAddWcidAttributeEntry: WCID #%d, KeyIndex #%d, Alg=%s\n",
-		  Wcid, KeyIdx, CipherName[CipherAlg]));
-	DBGPRINT(RT_DEBUG_TRACE, ("	WCIDAttri = 0x%x \n", WCIDAttri));
-
-}
-
-/*
-    ==========================================================================
-    Description:
-        Parse encryption type
-Arguments:
-    pAdapter                    Pointer to our adapter
-    wrq                         Pointer to the ioctl argument
-
-    Return Value:
-        None
-
-    Note:
-    ==========================================================================
-*/
-char *GetEncryptType(char enc)
-{
-	if (enc == Ndis802_11WEPDisabled)
-		return "NONE";
-	if (enc == Ndis802_11WEPEnabled)
-		return "WEP";
-	if (enc == Ndis802_11Encryption2Enabled)
-		return "TKIP";
-	if (enc == Ndis802_11Encryption3Enabled)
-		return "AES";
-	if (enc == Ndis802_11Encryption4Enabled)
-		return "TKIPAES";
-	else
-		return "UNKNOW";
-}
-
-char *GetAuthMode(char auth)
-{
-	if (auth == Ndis802_11AuthModeOpen)
-		return "OPEN";
-	if (auth == Ndis802_11AuthModeShared)
-		return "SHARED";
-	if (auth == Ndis802_11AuthModeAutoSwitch)
-		return "AUTOWEP";
-	if (auth == Ndis802_11AuthModeWPA)
-		return "WPA";
-	if (auth == Ndis802_11AuthModeWPAPSK)
-		return "WPAPSK";
-	if (auth == Ndis802_11AuthModeWPANone)
-		return "WPANONE";
-	if (auth == Ndis802_11AuthModeWPA2)
-		return "WPA2";
-	if (auth == Ndis802_11AuthModeWPA2PSK)
-		return "WPA2PSK";
-	if (auth == Ndis802_11AuthModeWPA1WPA2)
-		return "WPA1WPA2";
-	if (auth == Ndis802_11AuthModeWPA1PSKWPA2PSK)
-		return "WPA1PSKWPA2PSK";
-
-	return "UNKNOW";
-}
-
-int SetCommonHT(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_oid_set_ht_phymode SetHT;
-
-	if (pAd->CommonCfg.PhyMode < PHY_11ABGN_MIXED)
-		return FALSE;
-
-	SetHT.PhyMode = pAd->CommonCfg.PhyMode;
-	SetHT.TransmitNo = ((u8)pAd->Antenna.field.TxPath);
-	SetHT.HtMode = (u8)pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
-	SetHT.ExtOffset =
-	    (u8)pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
-	SetHT.MCS = MCS_AUTO;
-	SetHT.BW = (u8)pAd->CommonCfg.RegTransmitSetting.field.BW;
-	SetHT.STBC = (u8)pAd->CommonCfg.RegTransmitSetting.field.STBC;
-	SetHT.SHORTGI = (u8)pAd->CommonCfg.RegTransmitSetting.field.ShortGI;
-
-	RTMPSetHT(pAd, &SetHT);
-
-	return TRUE;
-}
-
-char *RTMPGetRalinkEncryModeStr(u16 encryMode)
-{
-	switch (encryMode) {
-	case Ndis802_11WEPDisabled:
-		return "NONE";
-	case Ndis802_11WEPEnabled:
-		return "WEP";
-	case Ndis802_11Encryption2Enabled:
-		return "TKIP";
-	case Ndis802_11Encryption3Enabled:
-		return "AES";
-	case Ndis802_11Encryption4Enabled:
-		return "TKIPAES";
-	default:
-		return "UNKNOW";
-	}
-}
diff --git a/drivers/staging/rt2860/common/cmm_mac_pci.c b/drivers/staging/rt2860/common/cmm_mac_pci.c
deleted file mode 100644
index d06f0a6..0000000
--- a/drivers/staging/rt2860/common/cmm_mac_pci.c
+++ /dev/null
@@ -1,1661 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifdef RTMP_MAC_PCI
-#include	"../rt_config.h"
-
-/*
-	========================================================================
-
-	Routine Description:
-		Allocate DMA memory blocks for send, receive
-
-	Arguments:
-		Adapter		Pointer to our adapter
-
-	Return Value:
-		NDIS_STATUS_SUCCESS
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_RESOURCES
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int RTMPAllocTxRxRingMemory(struct rt_rtmp_adapter *pAd)
-{
-	int Status = NDIS_STATUS_SUCCESS;
-	unsigned long RingBasePaHigh;
-	unsigned long RingBasePaLow;
-	void *RingBaseVa;
-	int index, num;
-	struct rt_txd * pTxD;
-	struct rt_rxd * pRxD;
-	unsigned long ErrorValue = 0;
-	struct rt_rtmp_tx_ring *pTxRing;
-	struct rt_rtmp_dmabuf *pDmaBuf;
-	void *pPacket;
-/*      PRTMP_REORDERBUF        pReorderBuf; */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
-	do {
-		/* */
-		/* Allocate all ring descriptors, include TxD, RxD, MgmtD. */
-		/* Although each size is different, to prevent cacheline and alignment */
-		/* issue, I intentional set them all to 64 bytes. */
-		/* */
-		for (num = 0; num < NUM_OF_TX_RING; num++) {
-			unsigned long BufBasePaHigh;
-			unsigned long BufBasePaLow;
-			void *BufBaseVa;
-
-			/* */
-			/* Allocate Tx ring descriptor's memory (5 TX rings = 4 ACs + 1 HCCA) */
-			/* */
-			pAd->TxDescRing[num].AllocSize =
-			    TX_RING_SIZE * TXD_SIZE;
-			RTMP_AllocateTxDescMemory(pAd, num,
-						  pAd->TxDescRing[num].
-						  AllocSize, FALSE,
-						  &pAd->TxDescRing[num].AllocVa,
-						  &pAd->TxDescRing[num].
-						  AllocPa);
-
-			if (pAd->TxDescRing[num].AllocVa == NULL) {
-				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
-				DBGPRINT_ERR("Failed to allocate a big buffer\n");
-				Status = NDIS_STATUS_RESOURCES;
-				break;
-			}
-			/* Zero init this memory block */
-			NdisZeroMemory(pAd->TxDescRing[num].AllocVa,
-				       pAd->TxDescRing[num].AllocSize);
-
-			/* Save PA & VA for further operation */
-			RingBasePaHigh =
-			    RTMP_GetPhysicalAddressHigh(pAd->TxDescRing[num].
-							AllocPa);
-			RingBasePaLow =
-			    RTMP_GetPhysicalAddressLow(pAd->TxDescRing[num].
-						       AllocPa);
-			RingBaseVa = pAd->TxDescRing[num].AllocVa;
-
-			/* */
-			/* Allocate all 1st TXBuf's memory for this TxRing */
-			/* */
-			pAd->TxBufSpace[num].AllocSize =
-			    TX_RING_SIZE * TX_DMA_1ST_BUFFER_SIZE;
-			RTMP_AllocateFirstTxBuffer(pAd, num,
-						   pAd->TxBufSpace[num].
-						   AllocSize, FALSE,
-						   &pAd->TxBufSpace[num].
-						   AllocVa,
-						   &pAd->TxBufSpace[num].
-						   AllocPa);
-
-			if (pAd->TxBufSpace[num].AllocVa == NULL) {
-				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
-				DBGPRINT_ERR("Failed to allocate a big buffer\n");
-				Status = NDIS_STATUS_RESOURCES;
-				break;
-			}
-			/* Zero init this memory block */
-			NdisZeroMemory(pAd->TxBufSpace[num].AllocVa,
-				       pAd->TxBufSpace[num].AllocSize);
-
-			/* Save PA & VA for further operation */
-			BufBasePaHigh =
-			    RTMP_GetPhysicalAddressHigh(pAd->TxBufSpace[num].
-							AllocPa);
-			BufBasePaLow =
-			    RTMP_GetPhysicalAddressLow(pAd->TxBufSpace[num].
-						       AllocPa);
-			BufBaseVa = pAd->TxBufSpace[num].AllocVa;
-
-			/* */
-			/* Initialize Tx Ring Descriptor and associated buffer memory */
-			/* */
-			pTxRing = &pAd->TxRing[num];
-			for (index = 0; index < TX_RING_SIZE; index++) {
-				pTxRing->Cell[index].pNdisPacket = NULL;
-				pTxRing->Cell[index].pNextNdisPacket = NULL;
-				/* Init Tx Ring Size, Va, Pa variables */
-				pTxRing->Cell[index].AllocSize = TXD_SIZE;
-				pTxRing->Cell[index].AllocVa = RingBaseVa;
-				RTMP_SetPhysicalAddressHigh(pTxRing->
-							    Cell[index].AllocPa,
-							    RingBasePaHigh);
-				RTMP_SetPhysicalAddressLow(pTxRing->Cell[index].
-							   AllocPa,
-							   RingBasePaLow);
-
-				/* Setup Tx Buffer size & address. only 802.11 header will store in this space */
-				pDmaBuf = &pTxRing->Cell[index].DmaBuf;
-				pDmaBuf->AllocSize = TX_DMA_1ST_BUFFER_SIZE;
-				pDmaBuf->AllocVa = BufBaseVa;
-				RTMP_SetPhysicalAddressHigh(pDmaBuf->AllocPa,
-							    BufBasePaHigh);
-				RTMP_SetPhysicalAddressLow(pDmaBuf->AllocPa,
-							   BufBasePaLow);
-
-				/* link the pre-allocated TxBuf to TXD */
-				pTxD =
-				    (struct rt_txd *) pTxRing->Cell[index].AllocVa;
-				pTxD->SDPtr0 = BufBasePaLow;
-				/* advance to next ring descriptor address */
-				pTxD->DMADONE = 1;
-				RingBasePaLow += TXD_SIZE;
-				RingBaseVa = (u8 *)RingBaseVa + TXD_SIZE;
-
-				/* advance to next TxBuf address */
-				BufBasePaLow += TX_DMA_1ST_BUFFER_SIZE;
-				BufBaseVa =
-				    (u8 *)BufBaseVa + TX_DMA_1ST_BUFFER_SIZE;
-			}
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("TxRing[%d]: total %d entry allocated\n", num,
-				  index));
-		}
-		if (Status == NDIS_STATUS_RESOURCES)
-			break;
-
-		/* */
-		/* Allocate MGMT ring descriptor's memory except Tx ring which allocated eariler */
-		/* */
-		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * TXD_SIZE;
-		RTMP_AllocateMgmtDescMemory(pAd,
-					    pAd->MgmtDescRing.AllocSize,
-					    FALSE,
-					    &pAd->MgmtDescRing.AllocVa,
-					    &pAd->MgmtDescRing.AllocPa);
-
-		if (pAd->MgmtDescRing.AllocVa == NULL) {
-			ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
-			DBGPRINT_ERR("Failed to allocate a big buffer\n");
-			Status = NDIS_STATUS_RESOURCES;
-			break;
-		}
-		/* Zero init this memory block */
-		NdisZeroMemory(pAd->MgmtDescRing.AllocVa,
-			       pAd->MgmtDescRing.AllocSize);
-
-		/* Save PA & VA for further operation */
-		RingBasePaHigh =
-		    RTMP_GetPhysicalAddressHigh(pAd->MgmtDescRing.AllocPa);
-		RingBasePaLow =
-		    RTMP_GetPhysicalAddressLow(pAd->MgmtDescRing.AllocPa);
-		RingBaseVa = pAd->MgmtDescRing.AllocVa;
-
-		/* */
-		/* Initialize MGMT Ring and associated buffer memory */
-		/* */
-		for (index = 0; index < MGMT_RING_SIZE; index++) {
-			pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
-			pAd->MgmtRing.Cell[index].pNextNdisPacket = NULL;
-			/* Init MGMT Ring Size, Va, Pa variables */
-			pAd->MgmtRing.Cell[index].AllocSize = TXD_SIZE;
-			pAd->MgmtRing.Cell[index].AllocVa = RingBaseVa;
-			RTMP_SetPhysicalAddressHigh(pAd->MgmtRing.Cell[index].
-						    AllocPa, RingBasePaHigh);
-			RTMP_SetPhysicalAddressLow(pAd->MgmtRing.Cell[index].
-						   AllocPa, RingBasePaLow);
-
-			/* Offset to next ring descriptor address */
-			RingBasePaLow += TXD_SIZE;
-			RingBaseVa = (u8 *)RingBaseVa + TXD_SIZE;
-
-			/* link the pre-allocated TxBuf to TXD */
-			pTxD = (struct rt_txd *) pAd->MgmtRing.Cell[index].AllocVa;
-			pTxD->DMADONE = 1;
-
-			/* no pre-allocated buffer required in MgmtRing for scatter-gather case */
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MGMT Ring: total %d entry allocated\n", index));
-
-		/* */
-		/* Allocate RX ring descriptor's memory except Tx ring which allocated eariler */
-		/* */
-		pAd->RxDescRing.AllocSize = RX_RING_SIZE * RXD_SIZE;
-		RTMP_AllocateRxDescMemory(pAd,
-					  pAd->RxDescRing.AllocSize,
-					  FALSE,
-					  &pAd->RxDescRing.AllocVa,
-					  &pAd->RxDescRing.AllocPa);
-
-		if (pAd->RxDescRing.AllocVa == NULL) {
-			ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
-			DBGPRINT_ERR("Failed to allocate a big buffer\n");
-			Status = NDIS_STATUS_RESOURCES;
-			break;
-		}
-		/* Zero init this memory block */
-		NdisZeroMemory(pAd->RxDescRing.AllocVa,
-			       pAd->RxDescRing.AllocSize);
-
-		DBGPRINT(RT_DEBUG_OFF,
-			 ("RX DESC %p  size = %ld\n", pAd->RxDescRing.AllocVa,
-			  pAd->RxDescRing.AllocSize));
-
-		/* Save PA & VA for further operation */
-		RingBasePaHigh =
-		    RTMP_GetPhysicalAddressHigh(pAd->RxDescRing.AllocPa);
-		RingBasePaLow =
-		    RTMP_GetPhysicalAddressLow(pAd->RxDescRing.AllocPa);
-		RingBaseVa = pAd->RxDescRing.AllocVa;
-
-		/* */
-		/* Initialize Rx Ring and associated buffer memory */
-		/* */
-		for (index = 0; index < RX_RING_SIZE; index++) {
-			/* Init RX Ring Size, Va, Pa variables */
-			pAd->RxRing.Cell[index].AllocSize = RXD_SIZE;
-			pAd->RxRing.Cell[index].AllocVa = RingBaseVa;
-			RTMP_SetPhysicalAddressHigh(pAd->RxRing.Cell[index].
-						    AllocPa, RingBasePaHigh);
-			RTMP_SetPhysicalAddressLow(pAd->RxRing.Cell[index].
-						   AllocPa, RingBasePaLow);
-
-			/*NdisZeroMemory(RingBaseVa, RXD_SIZE); */
-
-			/* Offset to next ring descriptor address */
-			RingBasePaLow += RXD_SIZE;
-			RingBaseVa = (u8 *)RingBaseVa + RXD_SIZE;
-
-			/* Setup Rx associated Buffer size & allocate share memory */
-			pDmaBuf = &pAd->RxRing.Cell[index].DmaBuf;
-			pDmaBuf->AllocSize = RX_BUFFER_AGGRESIZE;
-			pPacket = RTMP_AllocateRxPacketBuffer(pAd,
-							      pDmaBuf->
-							      AllocSize, FALSE,
-							      &pDmaBuf->AllocVa,
-							      &pDmaBuf->
-							      AllocPa);
-
-			/* keep allocated rx packet */
-			pAd->RxRing.Cell[index].pNdisPacket = pPacket;
-
-			/* Error handling */
-			if (pDmaBuf->AllocVa == NULL) {
-				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
-				DBGPRINT_ERR("Failed to allocate RxRing's 1st buffer\n");
-				Status = NDIS_STATUS_RESOURCES;
-				break;
-			}
-			/* Zero init this memory block */
-			NdisZeroMemory(pDmaBuf->AllocVa, pDmaBuf->AllocSize);
-
-			/* Write RxD buffer address & allocated buffer length */
-			pRxD = (struct rt_rxd *) pAd->RxRing.Cell[index].AllocVa;
-			pRxD->SDP0 =
-			    RTMP_GetPhysicalAddressLow(pDmaBuf->AllocPa);
-			pRxD->DDONE = 0;
-
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Rx Ring: total %d entry allocated\n", index));
-
-	} while (FALSE);
-
-	NdisZeroMemory(&pAd->FragFrame, sizeof(struct rt_fragment_frame));
-	pAd->FragFrame.pFragPacket =
-	    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
-
-	if (pAd->FragFrame.pFragPacket == NULL) {
-		Status = NDIS_STATUS_RESOURCES;
-	}
-
-	if (Status != NDIS_STATUS_SUCCESS) {
-		/* Log error inforamtion */
-		NdisWriteErrorLogEntry(pAd->AdapterHandle,
-				       NDIS_ERROR_CODE_OUT_OF_RESOURCES,
-				       1, ErrorValue);
-	}
-	/* Following code segment get from original func:NICInitTxRxRingAndBacklogQueue(), now should integrate it to here. */
-	{
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("--> NICInitTxRxRingAndBacklogQueue\n"));
-
-/*
-		// Disable DMA.
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		GloCfg.word &= 0xff0;
-		GloCfg.field.EnTXWriteBackDDONE =1;
-		RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-*/
-
-		/* Initialize all transmit related software queues */
-		for (index = 0; index < NUM_OF_TX_RING; index++) {
-			InitializeQueueHeader(&pAd->TxSwQueue[index]);
-			/* Init TX rings index pointer */
-			pAd->TxRing[index].TxSwFreeIdx = 0;
-			pAd->TxRing[index].TxCpuIdx = 0;
-			/*RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10) ,  pAd->TxRing[i].TX_CTX_IDX); */
-		}
-
-		/* Init RX Ring index pointer */
-		pAd->RxRing.RxSwReadIdx = 0;
-		pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
-		/*RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RX_CRX_IDX0); */
-
-		/* init MGMT ring index pointer */
-		pAd->MgmtRing.TxSwFreeIdx = 0;
-		pAd->MgmtRing.TxCpuIdx = 0;
-
-		pAd->PrivateInfo.TxRingFullCnt = 0;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("<-- NICInitTxRxRingAndBacklogQueue\n"));
-	}
-
-	DBGPRINT_S(Status,
-		   ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Reset NIC Asics. Call after rest DMA. So reset TX_CTX_IDX to zero.
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		Reset NIC to initial state AS IS system boot up time.
-
-	========================================================================
-*/
-void RTMPRingCleanUp(struct rt_rtmp_adapter *pAd, u8 RingType)
-{
-	struct rt_txd * pTxD;
-	struct rt_rxd * pRxD;
-	struct rt_queue_entry *pEntry;
-	void *pPacket;
-	int i;
-	struct rt_rtmp_tx_ring *pTxRing;
-	unsigned long IrqFlags;
-	/*u32                        RxSwReadIdx; */
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPRingCleanUp(RingIdx=%d, Pending-NDIS=%ld)\n", RingType,
-		  pAd->RalinkCounters.PendingNdisPacketCount));
-	switch (RingType) {
-	case QID_AC_BK:
-	case QID_AC_BE:
-	case QID_AC_VI:
-	case QID_AC_VO:
-
-		pTxRing = &pAd->TxRing[RingType];
-
-		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-		/* We have to clean all descriptors in case some error happened with reset */
-		for (i = 0; i < TX_RING_SIZE; i++)	/* We have to scan all TX ring */
-		{
-			pTxD = (struct rt_txd *) pTxRing->Cell[i].AllocVa;
-
-			pPacket = (void *)pTxRing->Cell[i].pNdisPacket;
-			/* release scatter-and-gather char */
-			if (pPacket) {
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_FAILURE);
-				pTxRing->Cell[i].pNdisPacket = NULL;
-			}
-
-			pPacket =
-			    (void *)pTxRing->Cell[i].pNextNdisPacket;
-			/* release scatter-and-gather char */
-			if (pPacket) {
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_FAILURE);
-				pTxRing->Cell[i].pNextNdisPacket = NULL;
-			}
-		}
-
-		RTMP_IO_READ32(pAd, TX_DTX_IDX0 + RingType * 0x10,
-			       &pTxRing->TxDmaIdx);
-		pTxRing->TxSwFreeIdx = pTxRing->TxDmaIdx;
-		pTxRing->TxCpuIdx = pTxRing->TxDmaIdx;
-		RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + RingType * 0x10,
-				pTxRing->TxCpuIdx);
-
-		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-
-		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-		while (pAd->TxSwQueue[RingType].Head != NULL) {
-			pEntry = RemoveHeadQueue(&pAd->TxSwQueue[RingType]);
-			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Release 1 NDIS packet from s/w backlog queue\n"));
-		}
-		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-		break;
-
-	case QID_MGMT:
-		/* We have to clean all descriptors in case some error happened with reset */
-		NdisAcquireSpinLock(&pAd->MgmtRingLock);
-
-		for (i = 0; i < MGMT_RING_SIZE; i++) {
-			pTxD = (struct rt_txd *) pAd->MgmtRing.Cell[i].AllocVa;
-
-			pPacket =
-			    (void *)pAd->MgmtRing.Cell[i].pNdisPacket;
-			/* rlease scatter-and-gather char */
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0,
-						 pTxD->SDLen0,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_FAILURE);
-			}
-			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
-
-			pPacket =
-			    (void *)pAd->MgmtRing.Cell[i].
-			    pNextNdisPacket;
-			/* release scatter-and-gather char */
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
-						 pTxD->SDLen1,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_FAILURE);
-			}
-			pAd->MgmtRing.Cell[i].pNextNdisPacket = NULL;
-
-		}
-
-		RTMP_IO_READ32(pAd, TX_MGMTDTX_IDX, &pAd->MgmtRing.TxDmaIdx);
-		pAd->MgmtRing.TxSwFreeIdx = pAd->MgmtRing.TxDmaIdx;
-		pAd->MgmtRing.TxCpuIdx = pAd->MgmtRing.TxDmaIdx;
-		RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
-
-		NdisReleaseSpinLock(&pAd->MgmtRingLock);
-		pAd->RalinkCounters.MgmtRingFullCount = 0;
-		break;
-
-	case QID_RX:
-		/* We have to clean all descriptors in case some error happened with reset */
-		NdisAcquireSpinLock(&pAd->RxRingLock);
-
-		for (i = 0; i < RX_RING_SIZE; i++) {
-			pRxD = (struct rt_rxd *) pAd->RxRing.Cell[i].AllocVa;
-			pRxD->DDONE = 0;
-		}
-
-		RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
-		pAd->RxRing.RxSwReadIdx = pAd->RxRing.RxDmaIdx;
-		pAd->RxRing.RxCpuIdx =
-		    ((pAd->RxRing.RxDmaIdx ==
-		      0) ? (RX_RING_SIZE - 1) : (pAd->RxRing.RxDmaIdx - 1));
-		RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
-
-		NdisReleaseSpinLock(&pAd->RxRingLock);
-		break;
-
-	default:
-		break;
-	}
-}
-
-void RTMPFreeTxRxRingMemory(struct rt_rtmp_adapter *pAd)
-{
-	int index, num, j;
-	struct rt_rtmp_tx_ring *pTxRing;
-	struct rt_txd * pTxD;
-	void *pPacket;
-	unsigned int IrqFlags;
-
-	/*struct os_cookie *pObj =(struct os_cookie *)pAd->OS_Cookie; */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPFreeTxRxRingMemory\n"));
-
-	/* Free TxSwQueue Packet */
-	for (index = 0; index < NUM_OF_TX_RING; index++) {
-		struct rt_queue_entry *pEntry;
-		void *pPacket;
-		struct rt_queue_header *pQueue;
-
-		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-		pQueue = &pAd->TxSwQueue[index];
-		while (pQueue->Head) {
-			pEntry = RemoveHeadQueue(pQueue);
-			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		}
-		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-	}
-
-	/* Free Tx Ring Packet */
-	for (index = 0; index < NUM_OF_TX_RING; index++) {
-		pTxRing = &pAd->TxRing[index];
-
-		for (j = 0; j < TX_RING_SIZE; j++) {
-			pTxD = (struct rt_txd *) (pTxRing->Cell[j].AllocVa);
-			pPacket = pTxRing->Cell[j].pNdisPacket;
-
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0,
-						 pTxD->SDLen0,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_SUCCESS);
-			}
-			/*Always assign pNdisPacket as NULL after clear */
-			pTxRing->Cell[j].pNdisPacket = NULL;
-
-			pPacket = pTxRing->Cell[j].pNextNdisPacket;
-
-			if (pPacket) {
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
-						 pTxD->SDLen1,
-						 PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket,
-						    NDIS_STATUS_SUCCESS);
-			}
-			/*Always assign pNextNdisPacket as NULL after clear */
-			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
-			    NULL;
-
-		}
-	}
-
-	for (index = RX_RING_SIZE - 1; index >= 0; index--) {
-		if ((pAd->RxRing.Cell[index].DmaBuf.AllocVa)
-		    && (pAd->RxRing.Cell[index].pNdisPacket)) {
-			PCI_UNMAP_SINGLE(pAd,
-					 pAd->RxRing.Cell[index].DmaBuf.AllocPa,
-					 pAd->RxRing.Cell[index].DmaBuf.
-					 AllocSize, PCI_DMA_FROMDEVICE);
-			RELEASE_NDIS_PACKET(pAd,
-					    pAd->RxRing.Cell[index].pNdisPacket,
-					    NDIS_STATUS_SUCCESS);
-		}
-	}
-	NdisZeroMemory(pAd->RxRing.Cell, RX_RING_SIZE * sizeof(struct rt_rtmp_dmacb));
-
-	if (pAd->RxDescRing.AllocVa) {
-		RTMP_FreeDescMemory(pAd, pAd->RxDescRing.AllocSize,
-				    pAd->RxDescRing.AllocVa,
-				    pAd->RxDescRing.AllocPa);
-	}
-	NdisZeroMemory(&pAd->RxDescRing, sizeof(struct rt_rtmp_dmabuf));
-
-	if (pAd->MgmtDescRing.AllocVa) {
-		RTMP_FreeDescMemory(pAd, pAd->MgmtDescRing.AllocSize,
-				    pAd->MgmtDescRing.AllocVa,
-				    pAd->MgmtDescRing.AllocPa);
-	}
-	NdisZeroMemory(&pAd->MgmtDescRing, sizeof(struct rt_rtmp_dmabuf));
-
-	for (num = 0; num < NUM_OF_TX_RING; num++) {
-		if (pAd->TxBufSpace[num].AllocVa) {
-			RTMP_FreeFirstTxBuffer(pAd,
-					       pAd->TxBufSpace[num].AllocSize,
-					       FALSE,
-					       pAd->TxBufSpace[num].AllocVa,
-					       pAd->TxBufSpace[num].AllocPa);
-		}
-		NdisZeroMemory(&pAd->TxBufSpace[num], sizeof(struct rt_rtmp_dmabuf));
-
-		if (pAd->TxDescRing[num].AllocVa) {
-			RTMP_FreeDescMemory(pAd, pAd->TxDescRing[num].AllocSize,
-					    pAd->TxDescRing[num].AllocVa,
-					    pAd->TxDescRing[num].AllocPa);
-		}
-		NdisZeroMemory(&pAd->TxDescRing[num], sizeof(struct rt_rtmp_dmabuf));
-	}
-
-	if (pAd->FragFrame.pFragPacket)
-		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket,
-				    NDIS_STATUS_SUCCESS);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- RTMPFreeTxRxRingMemory\n"));
-}
-
-/***************************************************************************
-  *
-  *	register related procedures.
-  *
-  **************************************************************************/
-/*
-========================================================================
-Routine Description:
-    Disable DMA.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28XXDMADisable(struct rt_rtmp_adapter *pAd)
-{
-	WPDMA_GLO_CFG_STRUC GloCfg;
-
-	RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE = 1;
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-}
-
-/*
-========================================================================
-Routine Description:
-    Enable DMA.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28XXDMAEnable(struct rt_rtmp_adapter *pAd)
-{
-	WPDMA_GLO_CFG_STRUC GloCfg;
-	int i = 0;
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x4);
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)
-		    && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		DBGPRINT(RT_DEBUG_TRACE, ("==>  DMABusy\n"));
-		RTMPusecDelay(1000);
-		i++;
-	} while (i < 200);
-
-	RTMPusecDelay(50);
-
-	GloCfg.field.EnTXWriteBackDDONE = 1;
-	GloCfg.field.WPDMABurstSIZE = 2;
-	GloCfg.field.EnableRxDMA = 1;
-	GloCfg.field.EnableTxDMA = 1;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-}
-
-BOOLEAN AsicCheckCommanOk(struct rt_rtmp_adapter *pAd, u8 Command)
-{
-	u32 CmdStatus = 0, CID = 0, i;
-	u32 ThisCIDMask = 0;
-
-	i = 0;
-	do {
-		RTMP_IO_READ32(pAd, H2M_MAILBOX_CID, &CID);
-		/* Find where the command is. Because this is randomly specified by firmware. */
-		if ((CID & CID0MASK) == Command) {
-			ThisCIDMask = CID0MASK;
-			break;
-		} else if ((((CID & CID1MASK) >> 8) & 0xff) == Command) {
-			ThisCIDMask = CID1MASK;
-			break;
-		} else if ((((CID & CID2MASK) >> 16) & 0xff) == Command) {
-			ThisCIDMask = CID2MASK;
-			break;
-		} else if ((((CID & CID3MASK) >> 24) & 0xff) == Command) {
-			ThisCIDMask = CID3MASK;
-			break;
-		}
-
-		RTMPusecDelay(100);
-		i++;
-	} while (i < 200);
-
-	/* Get CommandStatus Value */
-	RTMP_IO_READ32(pAd, H2M_MAILBOX_STATUS, &CmdStatus);
-
-	/* This command's status is at the same position as command. So AND command position's bitmask to read status. */
-	if (i < 200) {
-		/* If Status is 1, the command is success. */
-		if (((CmdStatus & ThisCIDMask) == 0x1)
-		    || ((CmdStatus & ThisCIDMask) == 0x100)
-		    || ((CmdStatus & ThisCIDMask) == 0x10000)
-		    || ((CmdStatus & ThisCIDMask) == 0x1000000)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("--> AsicCheckCommanOk CID = 0x%x, CmdStatus= 0x%x \n",
-				  CID, CmdStatus));
-			RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
-			RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
-			return TRUE;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("--> AsicCheckCommanFail1 CID = 0x%x, CmdStatus= 0x%x \n",
-			  CID, CmdStatus));
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("--> AsicCheckCommanFail2 Timeout Command = %d, CmdStatus= 0x%x \n",
-			  Command, CmdStatus));
-	}
-	/* Clear Command and Status. */
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
-
-	return FALSE;
-}
-
-/*
-========================================================================
-Routine Description:
-    Write Beacon buffer to Asic.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28xx_UpdateBeaconToAsic(struct rt_rtmp_adapter *pAd,
-			       int apidx,
-			       unsigned long FrameLen, unsigned long UpdatePos)
-{
-	unsigned long CapInfoPos = 0;
-	u8 *ptr, *ptr_update, *ptr_capinfo;
-	u32 i;
-	BOOLEAN bBcnReq = FALSE;
-	u8 bcn_idx = 0;
-
-	{
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s() : No valid Interface be found.\n", __func__));
-		return;
-	}
-
-	/*if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) */
-	/*      || ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) */
-	/*              || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP)) */
-	/*      ) */
-	if (bBcnReq == FALSE) {
-		/* when the ra interface is down, do not send its beacon frame */
-		/* clear all zero */
-		for (i = 0; i < TXWI_SIZE; i += 4)
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
-					0x00);
-	} else {
-		ptr = (u8 *)& pAd->BeaconTxWI;
-		for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
-		{
-			u32 longptr =
-			    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
-			    (*(ptr + 3) << 24);
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
-					longptr);
-			ptr += 4;
-		}
-
-		/* Update CapabilityInfo in Beacon */
-		for (i = CapInfoPos; i < (CapInfoPos + 2); i++) {
-			RTMP_IO_WRITE8(pAd,
-				       pAd->BeaconOffset[bcn_idx] + TXWI_SIZE +
-				       i, *ptr_capinfo);
-			ptr_capinfo++;
-		}
-
-		if (FrameLen > UpdatePos) {
-			for (i = UpdatePos; i < (FrameLen); i++) {
-				RTMP_IO_WRITE8(pAd,
-					       pAd->BeaconOffset[bcn_idx] +
-					       TXWI_SIZE + i, *ptr_update);
-				ptr_update++;
-			}
-		}
-
-	}
-
-}
-
-void RT28xxPciStaAsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx)
-{
-	AUTO_WAKEUP_STRUC AutoWakeupCfg;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-		return;
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("waking up now!\n"));
-		return;
-	}
-
-	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
-
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		/* Support PCIe Advance Power Save */
-		if (bFromTx == TRUE && (pAd->Mlme.bPsPollTimerRunning == TRUE)) {
-			pAd->Mlme.bPsPollTimerRunning = FALSE;
-			RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-			RTMPusecDelay(3000);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("=======AsicForceWakeup===bFromTx\n"));
-		}
-
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-
-		if (RT28xxPciAsicRadioOn(pAd, DOT11POWERSAVE)) {
-#ifdef PCIE_PS_SUPPORT
-			/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
-			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-			    && IS_VERSION_AFTER_F(pAd)) {
-				struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-
-				if (pChipOps->AsicReverseRfFromSleepMode)
-					pChipOps->
-					    AsicReverseRfFromSleepMode(pAd);
-			} else
-#endif /* PCIE_PS_SUPPORT // */
-			{
-				/* end johnli */
-				/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
-				if (INFRA_ON(pAd)
-				    && (pAd->CommonCfg.CentralChannel !=
-					pAd->CommonCfg.Channel)
-				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
-					ChannelWidth == BW_40)) {
-					/* Must using 40MHz. */
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  CentralChannel,
-							  FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.
-							CentralChannel);
-				} else {
-					/* Must using 20MHz. */
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  Channel, FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.Channel);
-				}
-			}
-		}
-#ifdef PCIE_PS_SUPPORT
-		/* 3090 MCU Wakeup command needs more time to be stable. */
-		/* Before stable, don't issue other MCU command to prevent from firmware error. */
-		if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-		     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("<==RT28xxPciStaAsicForceWakeup::Release the MCU Lock(3090)\n"));
-			RTMP_SEM_LOCK(&pAd->McuCmdLock);
-			pAd->brt30xxBanMcuCmd = FALSE;
-			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-		}
-#endif /* PCIE_PS_SUPPORT // */
-	} else {
-		/* PCI, 2860-PCIe */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("<==RT28xxPciStaAsicForceWakeup::Original PCI Power Saving\n"));
-		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-	}
-
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
-	DBGPRINT(RT_DEBUG_TRACE, ("<=======RT28xxPciStaAsicForceWakeup\n"));
-}
-
-void RT28xxPciStaAsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-					 u16 TbttNumToNextWakeUp)
-{
-	BOOLEAN brc;
-
-	if (pAd->StaCfg.bRadio == FALSE) {
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-		return;
-	}
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		unsigned long Now = 0;
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW)) {
-			DBGPRINT(RT_DEBUG_TRACE, ("waking up now!\n"));
-			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-			return;
-		}
-
-		NdisGetSystemUpTime(&Now);
-		/* If last send NULL fram time is too close to this receiving beacon (within 8ms), don't go to sleep for this DTM. */
-		/* Because Some AP can't queuing outgoing frames immediately. */
-		if (((pAd->Mlme.LastSendNULLpsmTime + 8) >= Now)
-		    && (pAd->Mlme.LastSendNULLpsmTime <= Now)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Now = %lu, LastSendNULLpsmTime=%lu :  RxCountSinceLastNULL = %lu. \n",
-				  Now, pAd->Mlme.LastSendNULLpsmTime,
-				  pAd->RalinkCounters.RxCountSinceLastNULL));
-			return;
-		} else if ((pAd->RalinkCounters.RxCountSinceLastNULL > 0)
-			   &&
-			   ((pAd->Mlme.LastSendNULLpsmTime +
-			     pAd->CommonCfg.BeaconPeriod) >= Now)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Now = %lu, LastSendNULLpsmTime=%lu: RxCountSinceLastNULL = %lu > 0 \n",
-				  Now, pAd->Mlme.LastSendNULLpsmTime,
-				  pAd->RalinkCounters.RxCountSinceLastNULL));
-			return;
-		}
-
-		brc =
-		    RT28xxPciAsicRadioOff(pAd, DOT11POWERSAVE,
-					  TbttNumToNextWakeUp);
-		if (brc == TRUE)
-			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
-	} else {
-		AUTO_WAKEUP_STRUC AutoWakeupCfg;
-		/* we have decided to SLEEP, so at least do it for a BEACON period. */
-		if (TbttNumToNextWakeUp == 0)
-			TbttNumToNextWakeUp = 1;
-
-		/*RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt); */
-
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		AutoWakeupCfg.field.NumofSleepingTbtt = TbttNumToNextWakeUp - 1;
-		AutoWakeupCfg.field.EnableAutoWakeup = 1;
-		AutoWakeupCfg.field.AutoLeadTime = 5;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x00);	/* send POWER-SAVE command to MCU. Timeout 40us. */
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("<-- %s, TbttNumToNextWakeUp=%d \n", __func__,
-			  TbttNumToNextWakeUp));
-	}
-
-}
-
-void PsPollWakeExec(void *SystemSpecific1,
-		    void *FunctionContext,
-		    void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	unsigned long flags;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("-->PsPollWakeExec \n"));
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	if (pAd->Mlme.bPsPollTimerRunning) {
-		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-	}
-	pAd->Mlme.bPsPollTimerRunning = FALSE;
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-#ifdef PCIE_PS_SUPPORT
-	/* For rt30xx power solution 3, Use software timer to wake up in psm. So call */
-	/* AsicForceWakeup here instead of handling twakeup interrupt. */
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	     && IS_VERSION_AFTER_F(pAd))
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("<--PsPollWakeExec::3090 calls AsicForceWakeup(pAd, DOT11POWERSAVE) in advance \n"));
-		AsicForceWakeup(pAd, DOT11POWERSAVE);
-	}
-#endif /* PCIE_PS_SUPPORT // */
-}
-
-void RadioOnExec(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-	WPDMA_GLO_CFG_STRUC DmaCfg;
-	BOOLEAN Cancelled;
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("-->RadioOnExec() return on fOP_STATUS_DOZE == TRUE; \n"));
-/*KH Debug: Add the compile flag "RT2860 and condition */
-#ifdef RTMP_PCI_SUPPORT
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-#endif /* RTMP_PCI_SUPPORT // */
-		return;
-	}
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("-->RadioOnExec() return on SCAN_IN_PROGRESS; \n"));
-#ifdef RTMP_PCI_SUPPORT
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-#endif /* RTMP_PCI_SUPPORT // */
-		return;
-	}
-/*KH Debug: need to check. I add the compile flag "CONFIG_STA_SUPPORT" to enclose the following codes. */
-#ifdef RTMP_PCI_SUPPORT
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		pAd->Mlme.bPsPollTimerRunning = FALSE;
-		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-	}
-#endif /* RTMP_PCI_SUPPORT // */
-	if (pAd->StaCfg.bRadio == TRUE) {
-		pAd->bPCIclkOff = FALSE;
-		RTMPRingCleanUp(pAd, QID_AC_BK);
-		RTMPRingCleanUp(pAd, QID_AC_BE);
-		RTMPRingCleanUp(pAd, QID_AC_VI);
-		RTMPRingCleanUp(pAd, QID_AC_VO);
-		RTMPRingCleanUp(pAd, QID_MGMT);
-		RTMPRingCleanUp(pAd, QID_RX);
-
-		/* 2. Send wake up command. */
-		AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
-		/* 2-1. wait command ok. */
-		AsicCheckCommanOk(pAd, PowerWakeCID);
-
-		/* When PCI clock is off, don't want to service interrupt. So when back to clock on, enable interrupt. */
-		/*RTMP_IO_WRITE32(pAd, INT_MASK_CSR, (DELAYINTMASK|RxINT)); */
-		RTMP_ASIC_INTERRUPT_ENABLE(pAd);
-
-		/* 3. Enable Tx DMA. */
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &DmaCfg.word);
-		DmaCfg.field.EnableTxDMA = 1;
-		RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, DmaCfg.word);
-
-		/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
-		if (INFRA_ON(pAd)
-		    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-		    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
-			BW_40)) {
-			/* Must using 40MHz. */
-			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel,
-					  FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-		} else {
-			/* Must using 20MHz. */
-			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-		}
-
-/*KH Debug:The following codes should be enclosed by RT3090 compile flag */
-		if (pChipOps->AsicReverseRfFromSleepMode)
-			pChipOps->AsicReverseRfFromSleepMode(pAd);
-
-#ifdef PCIE_PS_SUPPORT
-/* 3090 MCU Wakeup command needs more time to be stable. */
-/* Before stable, don't issue other MCU command to prevent from firmware error. */
-		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-		    && IS_VERSION_AFTER_F(pAd)
-		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-			RTMP_SEM_LOCK(&pAd->McuCmdLock);
-			pAd->brt30xxBanMcuCmd = FALSE;
-			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-		}
-#endif /* PCIE_PS_SUPPORT // */
-
-		/* Clear Radio off flag */
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-		/* Set LED */
-		RTMPSetLED(pAd, LED_RADIO_ON);
-
-		if (pAd->StaCfg.Psm == PWR_ACTIVE) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3,
-						     pAd->StaCfg.BBPR3);
-		}
-	} else {
-		RT28xxPciAsicRadioOff(pAd, GUIRADIO_OFF, 0);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine sends command to firmware and turn our chip to wake up mode from power save mode.
-		Both RadioOn and .11 power save function needs to call this routine.
-	Input:
-		Level = GUIRADIO_OFF : call this function is from Radio Off to Radio On.  Need to restore PCI host value.
-		Level = other value : normal wake up function.
-
-	==========================================================================
- */
-BOOLEAN RT28xxPciAsicRadioOn(struct rt_rtmp_adapter *pAd, u8 Level)
-{
-	/*WPDMA_GLO_CFG_STRUC       DmaCfg; */
-	BOOLEAN Cancelled;
-	/*u32                        MACValue; */
-
-	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
-		return FALSE;
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-		if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-			pAd->Mlme.bPsPollTimerRunning = FALSE;
-			RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-		}
-		if ((pAd->StaCfg.PSControl.field.EnableNewPS == TRUE &&
-		     (Level == GUIRADIO_OFF || Level == GUI_IDLE_POWER_SAVE)) ||
-		    RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)) {
-			/* Some chips don't need to delay 6ms, so copy RTMPPCIePowerLinkCtrlRestore */
-			/* return condition here. */
-			/*
-			   if (((pAd->MACVersion&0xffff0000) != 0x28600000)
-			   && ((pAd->DeviceID == NIC2860_PCIe_DEVICE_ID)
-			   ||(pAd->DeviceID == NIC2790_PCIe_DEVICE_ID)))
-			 */
-			{
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("RT28xxPciAsicRadioOn ()\n"));
-				/* 1. Set PCI Link Control in Configuration Space. */
-				RTMPPCIeLinkCtrlValueRestore(pAd,
-							     RESTORE_WAKEUP);
-				RTMPusecDelay(6000);
-			}
-		}
-	}
-#ifdef PCIE_PS_SUPPORT
-	if (!
-	    (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	      && IS_VERSION_AFTER_F(pAd)
-	      && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	      && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))))
-#endif /* PCIE_PS_SUPPORT // */
-	{
-		pAd->bPCIclkOff = FALSE;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PSM :309xbPCIclkOff == %d\n", pAd->bPCIclkOff));
-	}
-	/* 2. Send wake up command. */
-	AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
-	pAd->bPCIclkOff = FALSE;
-	/* 2-1. wait command ok. */
-	AsicCheckCommanOk(pAd, PowerWakeCID);
-	RTMP_ASIC_INTERRUPT_ENABLE(pAd);
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-	if (Level == GUI_IDLE_POWER_SAVE) {
-#ifdef  PCIE_PS_SUPPORT
-
-		/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
-		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
-			struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-
-			if (pChipOps->AsicReverseRfFromSleepMode)
-				pChipOps->AsicReverseRfFromSleepMode(pAd);
-			/* 3090 MCU Wakeup command needs more time to be stable. */
-			/* Before stable, don't issue other MCU command to prevent from firmware error. */
-			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-			    && IS_VERSION_AFTER_F(pAd)
-			    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode ==
-				3)
-			    && (pAd->StaCfg.PSControl.field.EnableNewPS ==
-				TRUE)) {
-				RTMP_SEM_LOCK(&pAd->McuCmdLock);
-				pAd->brt30xxBanMcuCmd = FALSE;
-				RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-			}
-		} else
-			/* end johnli */
-#endif /* PCIE_PS_SUPPORT // */
-		{
-			/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
-			{
-				if (INFRA_ON(pAd)
-				    && (pAd->CommonCfg.CentralChannel !=
-					pAd->CommonCfg.Channel)
-				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
-					ChannelWidth == BW_40)) {
-					/* Must using 40MHz. */
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  CentralChannel,
-							  FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.
-							CentralChannel);
-				} else {
-					/* Must using 20MHz. */
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  Channel, FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.Channel);
-				}
-			}
-
-		}
-	}
-	return TRUE;
-
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine sends command to firmware and turn our chip to power save mode.
-		Both RadioOff and .11 power save function needs to call this routine.
-	Input:
-		Level = GUIRADIO_OFF  : GUI Radio Off mode
-		Level = DOT11POWERSAVE  : 802.11 power save mode
-		Level = RTMP_HALT  : When Disable device.
-
-	==========================================================================
- */
-BOOLEAN RT28xxPciAsicRadioOff(struct rt_rtmp_adapter *pAd,
-			      u8 Level, u16 TbttNumToNextWakeUp)
-{
-	WPDMA_GLO_CFG_STRUC DmaCfg;
-	u8 i, tempBBP_R3 = 0;
-	BOOLEAN brc = FALSE, Cancelled;
-	u32 TbTTTime = 0;
-	u32 PsPollTime = 0 /*, MACValue */ ;
-	unsigned long BeaconPeriodTime;
-	u32 RxDmaIdx, RxCpuIdx;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AsicRadioOff ===> Lv= %d, TxCpuIdx = %d, TxDmaIdx = %d. RxCpuIdx = %d, RxDmaIdx = %d.\n",
-		  Level, pAd->TxRing[0].TxCpuIdx, pAd->TxRing[0].TxDmaIdx,
-		  pAd->RxRing.RxCpuIdx, pAd->RxRing.RxDmaIdx));
-
-	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
-		return FALSE;
-
-	/* Check Rx DMA busy status, if more than half is occupied, give up this radio off. */
-	RTMP_IO_READ32(pAd, RX_DRX_IDX, &RxDmaIdx);
-	RTMP_IO_READ32(pAd, RX_CRX_IDX, &RxCpuIdx);
-	if ((RxDmaIdx > RxCpuIdx) && ((RxDmaIdx - RxCpuIdx) > RX_RING_SIZE / 3)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AsicRadioOff ===> return1. RxDmaIdx = %d ,  RxCpuIdx = %d. \n",
-			  RxDmaIdx, RxCpuIdx));
-		return FALSE;
-	} else if ((RxCpuIdx >= RxDmaIdx)
-		   && ((RxCpuIdx - RxDmaIdx) < RX_RING_SIZE / 3)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AsicRadioOff ===> return2.  RxCpuIdx = %d. RxDmaIdx = %d ,  \n",
-			  RxCpuIdx, RxDmaIdx));
-		return FALSE;
-	}
-	/* Once go into this function, disable tx because don't want too many packets in queue to prevent HW stops. */
-	/*pAd->bPCIclkOffDisableTx = TRUE; */
-	RTMP_SET_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	    && pAd->OpMode == OPMODE_STA
-	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-
-		if (Level == DOT11POWERSAVE) {
-			RTMP_IO_READ32(pAd, TBTT_TIMER, &TbTTTime);
-			TbTTTime &= 0x1ffff;
-			/* 00. check if need to do sleep in this DTIM period.   If next beacon will arrive within 30ms , ...doesn't necessarily sleep. */
-			/* TbTTTime uint = 64us, LEAD_TIME unit = 1024us, PsPollTime unit = 1ms */
-			if (((64 * TbTTTime) < ((LEAD_TIME * 1024) + 40000))
-			    && (TbttNumToNextWakeUp == 0)) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("TbTTTime = 0x%x , give up this sleep. \n",
-					  TbTTTime));
-				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-				/*pAd->bPCIclkOffDisableTx = FALSE; */
-				RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-				return FALSE;
-			} else {
-				PsPollTime =
-				    (64 * TbTTTime - LEAD_TIME * 1024) / 1000;
-#ifdef PCIE_PS_SUPPORT
-				if ((IS_RT3090(pAd) || IS_RT3572(pAd)
-				     || IS_RT3390(pAd))
-				    && IS_VERSION_AFTER_F(pAd)
-				    && (pAd->StaCfg.PSControl.field.
-					rt30xxPowerMode == 3)
-				    && (pAd->StaCfg.PSControl.field.
-					EnableNewPS == TRUE)) {
-					PsPollTime -= 5;
-				} else
-#endif /* PCIE_PS_SUPPORT // */
-					PsPollTime -= 3;
-
-				BeaconPeriodTime =
-				    pAd->CommonCfg.BeaconPeriod * 102 / 100;
-				if (TbttNumToNextWakeUp > 0)
-					PsPollTime +=
-					    ((TbttNumToNextWakeUp -
-					      1) * BeaconPeriodTime);
-
-				pAd->Mlme.bPsPollTimerRunning = TRUE;
-				RTMPSetTimer(&pAd->Mlme.PsPollTimer,
-					     PsPollTime);
-			}
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RT28xxPciAsicRadioOff::Level!=DOT11POWERSAVE \n"));
-	}
-
-	pAd->bPCIclkOffDisableTx = FALSE;
-
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-
-	/* Set to 1R. */
-	if (pAd->Antenna.field.RxPath > 1 && pAd->OpMode == OPMODE_STA) {
-		tempBBP_R3 = (pAd->StaCfg.BBPR3 & 0xE7);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, tempBBP_R3);
-	}
-	/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
-	if ((INFRA_ON(pAd) || pAd->OpMode == OPMODE_AP)
-	    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
-		/* Must using 40MHz. */
-		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
-	} else {
-		/* Must using 20MHz. */
-		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
-	}
-
-	if (Level != RTMP_HALT) {
-		/* Change Interrupt bitmask. */
-		/* When PCI clock is off, don't want to service interrupt. */
-		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt);
-	} else {
-		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
-	}
-
-	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
-	/*  2. Send Sleep command */
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
-	/* send POWER-SAVE command to MCU. high-byte = 1 save power as much as possible. high byte = 0 save less power */
-	AsicSendCommandToMcu(pAd, 0x30, PowerSafeCID, 0xff, 0x1);
-	/*  2-1. Wait command success */
-	/* Status = 1 : success, Status = 2, already sleep, Status = 3, Maybe MAC is busy so can't finish this task. */
-	brc = AsicCheckCommanOk(pAd, PowerSafeCID);
-
-	/*  3. After 0x30 command is ok, send radio off command. lowbyte = 0 for power safe. */
-	/* If 0x30 command is not ok this time, we can ignore 0x35 command. It will make sure not cause firmware'r problem. */
-	if ((Level == DOT11POWERSAVE) && (brc == TRUE)) {
-		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 0, 0x00);	/* lowbyte = 0 means to do power safe, NOT turn off radio. */
-		/*  3-1. Wait command success */
-		AsicCheckCommanOk(pAd, PowerRadioOffCID);
-	} else if (brc == TRUE) {
-		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 1, 0x00);	/* lowbyte = 0 means to do power safe, NOT turn off radio. */
-		/*  3-1. Wait command success */
-		AsicCheckCommanOk(pAd, PowerRadioOffCID);
-	}
-	/* 1. Wait DMA not busy */
-	i = 0;
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &DmaCfg.word);
-		if ((DmaCfg.field.RxDMABusy == 0)
-		    && (DmaCfg.field.TxDMABusy == 0))
-			break;
-		RTMPusecDelay(20);
-		i++;
-	} while (i < 50);
-
-	/*
-	   if (i >= 50)
-	   {
-	   pAd->CheckDmaBusyCount++;
-	   DBGPRINT(RT_DEBUG_TRACE, ("DMA Rx keeps busy.  return on AsicRadioOff () CheckDmaBusyCount = %d \n", pAd->CheckDmaBusyCount));
-	   }
-	   else
-	   {
-	   pAd->CheckDmaBusyCount = 0;
-	   }
-	 */
-/*KH Debug:My original codes have the following codes, but currecnt codes do not have it. */
-/* Disable for stability. If PCIE Link Control is modified for advance power save, re-covery this code segment. */
-	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0x1280);
-/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_CLKSELECT_40MHZ); */
-
-#ifdef PCIE_PS_SUPPORT
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	    && IS_VERSION_AFTER_F(pAd)
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RT28xxPciAsicRadioOff::3090 return to skip the following TbttNumToNextWakeUp setting for 279x\n"));
-		pAd->bPCIclkOff = TRUE;
-		RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-		/* For this case, doesn't need to below actions, so return here. */
-		return brc;
-	}
-#endif /* PCIE_PS_SUPPORT // */
-
-	if (Level == DOT11POWERSAVE) {
-		AUTO_WAKEUP_STRUC AutoWakeupCfg;
-		/*RTMPSetTimer(&pAd->Mlme.PsPollTimer, 90); */
-
-		/* we have decided to SLEEP, so at least do it for a BEACON period. */
-		if (TbttNumToNextWakeUp == 0)
-			TbttNumToNextWakeUp = 1;
-
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-
-		/* 1. Set auto wake up timer. */
-		AutoWakeupCfg.field.NumofSleepingTbtt = TbttNumToNextWakeUp - 1;
-		AutoWakeupCfg.field.EnableAutoWakeup = 1;
-		AutoWakeupCfg.field.AutoLeadTime = LEAD_TIME;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-	}
-	/*  4-1. If it's to disable our device. Need to restore PCI Configuration Space to its original value. */
-	if (Level == RTMP_HALT && pAd->OpMode == OPMODE_STA) {
-		if ((brc == TRUE) && (i < 50))
-			RTMPPCIeLinkCtrlSetting(pAd, 1);
-	}
-	/*  4. Set PCI configuration Space Link Comtrol fields.  Only Radio Off needs to call this function */
-	else if (pAd->OpMode == OPMODE_STA) {
-		if ((brc == TRUE) && (i < 50))
-			RTMPPCIeLinkCtrlSetting(pAd, 3);
-	}
-	/*pAd->bPCIclkOffDisableTx = FALSE; */
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-	return TRUE;
-}
-
-void RT28xxPciMlmeRadioOn(struct rt_rtmp_adapter *pAd)
-{
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
-
-	if ((pAd->OpMode == OPMODE_AP) || ((pAd->OpMode == OPMODE_STA)
-					   &&
-					   (!OPSTATUS_TEST_FLAG
-					    (pAd, fOP_STATUS_PCIE_DEVICE)
-					    || pAd->StaCfg.PSControl.field.
-					    EnableNewPS == FALSE))) {
-		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-		/*NICResetFromError(pAd); */
-
-		RTMPRingCleanUp(pAd, QID_AC_BK);
-		RTMPRingCleanUp(pAd, QID_AC_BE);
-		RTMPRingCleanUp(pAd, QID_AC_VI);
-		RTMPRingCleanUp(pAd, QID_AC_VO);
-		RTMPRingCleanUp(pAd, QID_MGMT);
-		RTMPRingCleanUp(pAd, QID_RX);
-
-		/* Enable Tx/Rx */
-		RTMPEnableRxTx(pAd);
-
-		/* Clear Radio off flag */
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-
-		/* Set LED */
-		RTMPSetLED(pAd, LED_RADIO_ON);
-	}
-
-	if ((pAd->OpMode == OPMODE_STA) &&
-	    (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-		BOOLEAN Cancelled;
-
-		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-
-		pAd->Mlme.bPsPollTimerRunning = FALSE;
-		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
-		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 40);
-	}
-}
-
-void RT28xxPciMlmeRadioOFF(struct rt_rtmp_adapter *pAd)
-{
-	BOOLEAN brc = TRUE;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-		return;
-
-	/* Link down first if any association exists */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
-			struct rt_mlme_disassoc_req DisReq;
-			struct rt_mlme_queue_elem *pMsgElem =
-			    kmalloc(sizeof(struct rt_mlme_queue_elem),
-							MEM_ALLOC_FLAG);
-
-			if (pMsgElem) {
-				COPY_MAC_ADDR(&DisReq.Addr,
-					      pAd->CommonCfg.Bssid);
-				DisReq.Reason = REASON_DISASSOC_STA_LEAVING;
-
-				pMsgElem->Machine = ASSOC_STATE_MACHINE;
-				pMsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-				pMsgElem->MsgLen =
-				    sizeof(struct rt_mlme_disassoc_req);
-				NdisMoveMemory(pMsgElem->Msg, &DisReq,
-					       sizeof
-					       (struct rt_mlme_disassoc_req));
-
-				MlmeDisassocReqAction(pAd, pMsgElem);
-				kfree(pMsgElem);
-
-				RTMPusecDelay(1000);
-			}
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
-
-	/* Set Radio off flag */
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-	{
-		BOOLEAN Cancelled;
-		if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-			if (RTMP_TEST_FLAG
-			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
-				RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,
-						&Cancelled);
-				RTMP_CLEAR_FLAG(pAd,
-						fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-			}
-			/* If during power safe mode. */
-			if (pAd->StaCfg.bRadio == TRUE) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("-->MlmeRadioOff() return on bRadio == TRUE; \n"));
-				return;
-			}
-			/* Always radio on since the NIC needs to set the MCU command (LED_RADIO_OFF). */
-			if (IDLE_ON(pAd) &&
-			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
-			{
-				RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-			}
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-				BOOLEAN Cancelled;
-				pAd->Mlme.bPsPollTimerRunning = FALSE;
-				RTMPCancelTimer(&pAd->Mlme.PsPollTimer,
-						&Cancelled);
-				RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,
-						&Cancelled);
-			}
-		}
-		/* Link down first if any association exists */
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
-			LinkDown(pAd, FALSE);
-		RTMPusecDelay(10000);
-		/*========================================== */
-		/* Clean up old bss table */
-		BssTableInit(&pAd->ScanTab);
-
-		/*
-		   if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-		   {
-		   RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-		   return;
-		   }
-		 */
-	}
-
-	/* Set LED.Move to here for fixing LED bug. This flag must be called after LinkDown */
-	RTMPSetLED(pAd, LED_RADIO_OFF);
-
-/*KH Debug:All PCIe devices need to use timer to execute radio off function, or the PCIe&&EnableNewPS needs. */
-/*KH Ans:It is right, because only when the PCIe and EnableNewPs is true, we need to delay the RadioOffTimer */
-/*to avoid the deadlock with PCIe Power saving function. */
-	if (pAd->OpMode == OPMODE_STA &&
-	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE) &&
-	    pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-	} else {
-		brc = RT28xxPciAsicRadioOff(pAd, GUIRADIO_OFF, 0);
-
-		if (brc == FALSE) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s call RT28xxPciAsicRadioOff fail!\n",
-				  __func__));
-		}
-	}
-/*
-*/
-}
-
-#endif /* RTMP_MAC_PCI // */
diff --git a/drivers/staging/rt2860/common/cmm_mac_usb.c b/drivers/staging/rt2860/common/cmm_mac_usb.c
deleted file mode 100644
index 64a65a4..0000000
--- a/drivers/staging/rt2860/common/cmm_mac_usb.c
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifdef RTMP_MAC_USB
-
-#include	"../rt_config.h"
-
-/*
-========================================================================
-Routine Description:
-    Initialize receive data structures.
-
-Arguments:
-    pAd					Pointer to our adapter
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-	NDIS_STATUS_RESOURCES
-
-Note:
-	Initialize all receive releated private buffer, include those define
-	in struct rt_rtmp_adapter structure and all private data structures. The mahor
-	work is to allocate buffer for each packet and chain buffer to
-	NDIS packet descriptor.
-========================================================================
-*/
-int NICInitRecv(struct rt_rtmp_adapter *pAd)
-{
-	u8 i;
-	int Status = NDIS_STATUS_SUCCESS;
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitRecv\n"));
-	pObj = pObj;
-
-	/*InterlockedExchange(&pAd->PendingRx, 0); */
-	pAd->PendingRx = 0;
-	pAd->NextRxBulkInReadIndex = 0;	/* Next Rx Read index */
-	pAd->NextRxBulkInIndex = 0;	/*RX_RING_SIZE -1; // Rx Bulk pointer */
-	pAd->NextRxBulkInPosition = 0;
-
-	for (i = 0; i < (RX_RING_SIZE); i++) {
-		struct rt_rx_context *pRxContext = &(pAd->RxContext[i]);
-
-		/*Allocate URB */
-		pRxContext->pUrb = RTUSB_ALLOC_URB(0);
-		if (pRxContext->pUrb == NULL) {
-			Status = NDIS_STATUS_RESOURCES;
-			goto out1;
-		}
-		/* Allocate transfer buffer */
-		pRxContext->TransferBuffer =
-		    RTUSB_URB_ALLOC_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE,
-					   &pRxContext->data_dma);
-		if (pRxContext->TransferBuffer == NULL) {
-			Status = NDIS_STATUS_RESOURCES;
-			goto out1;
-		}
-
-		NdisZeroMemory(pRxContext->TransferBuffer, MAX_RXBULK_SIZE);
-
-		pRxContext->pAd = pAd;
-		pRxContext->pIrp = NULL;
-		pRxContext->InUse = FALSE;
-		pRxContext->IRPPending = FALSE;
-		pRxContext->Readable = FALSE;
-		/*pRxContext->ReorderInUse = FALSE; */
-		pRxContext->bRxHandling = FALSE;
-		pRxContext->BulkInOffset = 0;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitRecv(Status=%d)\n", Status));
-	return Status;
-
-out1:
-	for (i = 0; i < (RX_RING_SIZE); i++) {
-		struct rt_rx_context *pRxContext = &(pAd->RxContext[i]);
-
-		if (NULL != pRxContext->TransferBuffer) {
-			RTUSB_URB_FREE_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE,
-					      pRxContext->TransferBuffer,
-					      pRxContext->data_dma);
-			pRxContext->TransferBuffer = NULL;
-		}
-
-		if (NULL != pRxContext->pUrb) {
-			RTUSB_UNLINK_URB(pRxContext->pUrb);
-			RTUSB_FREE_URB(pRxContext->pUrb);
-			pRxContext->pUrb = NULL;
-		}
-	}
-
-	return Status;
-}
-
-/*
-========================================================================
-Routine Description:
-    Initialize transmit data structures.
-
-Arguments:
-    pAd					Pointer to our adapter
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-	NDIS_STATUS_RESOURCES
-
-Note:
-========================================================================
-*/
-int NICInitTransmit(struct rt_rtmp_adapter *pAd)
-{
-#define LM_USB_ALLOC(pObj, Context, TB_Type, BufferSize, Status, msg1, err1, msg2, err2)	\
-	Context->pUrb = RTUSB_ALLOC_URB(0);		\
-	if (Context->pUrb == NULL) {			\
-		DBGPRINT(RT_DEBUG_ERROR, msg1);		\
-		Status = NDIS_STATUS_RESOURCES;		\
-		goto err1; }						\
-											\
-	Context->TransferBuffer =				\
-		(TB_Type)RTUSB_URB_ALLOC_BUFFER(pObj->pUsb_Dev, BufferSize, &Context->data_dma);	\
-	if (Context->TransferBuffer == NULL) {	\
-		DBGPRINT(RT_DEBUG_ERROR, msg2);		\
-		Status = NDIS_STATUS_RESOURCES;		\
-		goto err2; }
-
-#define LM_URB_FREE(pObj, Context, BufferSize)				\
-	if (NULL != Context->pUrb) {							\
-		RTUSB_UNLINK_URB(Context->pUrb);					\
-		RTUSB_FREE_URB(Context->pUrb);						\
-		Context->pUrb = NULL; }								\
-	if (NULL != Context->TransferBuffer) {				\
-		RTUSB_URB_FREE_BUFFER(pObj->pUsb_Dev, BufferSize,	\
-								Context->TransferBuffer,	\
-								Context->data_dma);			\
-		Context->TransferBuffer = NULL; }
-
-	u8 i, acidx;
-	int Status = NDIS_STATUS_SUCCESS;
-	struct rt_tx_context *pNullContext = &(pAd->NullContext);
-	struct rt_tx_context *pPsPollContext = &(pAd->PsPollContext);
-	struct rt_tx_context *pRTSContext = &(pAd->RTSContext);
-	struct rt_tx_context *pMLMEContext = NULL;
-/*      struct rt_ht_tx_context *pHTTXContext = NULL; */
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-	void *RingBaseVa;
-/*      struct rt_rtmp_tx_ring *pTxRing; */
-	struct rt_rtmp_mgmt_ring *pMgmtRing;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitTransmit\n"));
-	pObj = pObj;
-
-	/* Init 4 set of Tx parameters */
-	for (acidx = 0; acidx < NUM_OF_TX_RING; acidx++) {
-		/* Initialize all Transmit releated queues */
-		InitializeQueueHeader(&pAd->TxSwQueue[acidx]);
-
-		/* Next Local tx ring pointer waiting for buck out */
-		pAd->NextBulkOutIndex[acidx] = acidx;
-		pAd->BulkOutPending[acidx] = FALSE;	/* Buck Out control flag */
-		/*pAd->DataBulkDoneIdx[acidx] = 0; */
-	}
-
-	/*pAd->NextMLMEIndex    = 0; */
-	/*pAd->PushMgmtIndex    = 0; */
-	/*pAd->PopMgmtIndex     = 0; */
-	/*InterlockedExchange(&pAd->MgmtQueueSize, 0); */
-	/*InterlockedExchange(&pAd->TxCount, 0); */
-
-	/*pAd->PrioRingFirstIndex       = 0; */
-	/*pAd->PrioRingTxCnt            = 0; */
-
-	do {
-		/* */
-		/* TX_RING_SIZE, 4 ACs */
-		/* */
-		for (acidx = 0; acidx < 4; acidx++) {
-			struct rt_ht_tx_context *pHTTXContext = &(pAd->TxContext[acidx]);
-
-			NdisZeroMemory(pHTTXContext, sizeof(struct rt_ht_tx_context));
-			/*Allocate URB */
-			LM_USB_ALLOC(pObj, pHTTXContext, struct rt_httx_buffer *,
-				     sizeof(struct rt_httx_buffer), Status,
-				     ("<-- ERROR in Alloc TX TxContext[%d] urb!\n",
-				      acidx), done,
-				     ("<-- ERROR in Alloc TX TxContext[%d] struct rt_httx_buffer!\n",
-				      acidx), out1);
-
-			NdisZeroMemory(pHTTXContext->TransferBuffer->
-				       Aggregation, 4);
-			pHTTXContext->pAd = pAd;
-			pHTTXContext->pIrp = NULL;
-			pHTTXContext->IRPPending = FALSE;
-			pHTTXContext->NextBulkOutPosition = 0;
-			pHTTXContext->ENextBulkOutPosition = 0;
-			pHTTXContext->CurWritePosition = 0;
-			pHTTXContext->CurWriteRealPos = 0;
-			pHTTXContext->BulkOutSize = 0;
-			pHTTXContext->BulkOutPipeId = acidx;
-			pHTTXContext->bRingEmpty = TRUE;
-			pHTTXContext->bCopySavePad = FALSE;
-			pAd->BulkOutPending[acidx] = FALSE;
-		}
-
-		/* */
-		/* MGMT_RING_SIZE */
-		/* */
-
-		/* Allocate MGMT ring descriptor's memory */
-		pAd->MgmtDescRing.AllocSize =
-		    MGMT_RING_SIZE * sizeof(struct rt_tx_context);
-		os_alloc_mem(pAd, (u8 **) (&pAd->MgmtDescRing.AllocVa),
-			     pAd->MgmtDescRing.AllocSize);
-		if (pAd->MgmtDescRing.AllocVa == NULL) {
-			DBGPRINT_ERR("Failed to allocate a big buffer for MgmtDescRing!\n");
-			Status = NDIS_STATUS_RESOURCES;
-			goto out1;
-		}
-		NdisZeroMemory(pAd->MgmtDescRing.AllocVa,
-			       pAd->MgmtDescRing.AllocSize);
-		RingBaseVa = pAd->MgmtDescRing.AllocVa;
-
-		/* Initialize MGMT Ring and associated buffer memory */
-		pMgmtRing = &pAd->MgmtRing;
-		for (i = 0; i < MGMT_RING_SIZE; i++) {
-			/* link the pre-allocated Mgmt buffer to MgmtRing.Cell */
-			pMgmtRing->Cell[i].AllocSize = sizeof(struct rt_tx_context);
-			pMgmtRing->Cell[i].AllocVa = RingBaseVa;
-			pMgmtRing->Cell[i].pNdisPacket = NULL;
-			pMgmtRing->Cell[i].pNextNdisPacket = NULL;
-
-			/*Allocate URB for MLMEContext */
-			pMLMEContext =
-			    (struct rt_tx_context *)pAd->MgmtRing.Cell[i].AllocVa;
-			pMLMEContext->pUrb = RTUSB_ALLOC_URB(0);
-			if (pMLMEContext->pUrb == NULL) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("<-- ERROR in Alloc TX MLMEContext[%d] urb!\n",
-					  i));
-				Status = NDIS_STATUS_RESOURCES;
-				goto out2;
-			}
-			pMLMEContext->pAd = pAd;
-			pMLMEContext->pIrp = NULL;
-			pMLMEContext->TransferBuffer = NULL;
-			pMLMEContext->InUse = FALSE;
-			pMLMEContext->IRPPending = FALSE;
-			pMLMEContext->bWaitingBulkOut = FALSE;
-			pMLMEContext->BulkOutSize = 0;
-			pMLMEContext->SelfIdx = i;
-
-			/* Offset to next ring descriptor address */
-			RingBaseVa = (u8 *)RingBaseVa + sizeof(struct rt_tx_context);
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MGMT Ring: total %d entry allocated\n", i));
-
-		/*pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1); */
-		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
-		pAd->MgmtRing.TxCpuIdx = 0;
-		pAd->MgmtRing.TxDmaIdx = 0;
-
-		/* */
-		/* BEACON_RING_SIZE */
-		/* */
-		for (i = 0; i < BEACON_RING_SIZE; i++)	/* 2 */
-		{
-			struct rt_tx_context *pBeaconContext = &(pAd->BeaconContext[i]);
-
-			NdisZeroMemory(pBeaconContext, sizeof(struct rt_tx_context));
-
-			/*Allocate URB */
-			LM_USB_ALLOC(pObj, pBeaconContext, struct rt_tx_buffer *,
-				     sizeof(struct rt_tx_buffer), Status,
-				     ("<-- ERROR in Alloc TX BeaconContext[%d] urb!\n",
-				      i), out2,
-				     ("<-- ERROR in Alloc TX BeaconContext[%d] struct rt_tx_buffer!\n",
-				      i), out3);
-
-			pBeaconContext->pAd = pAd;
-			pBeaconContext->pIrp = NULL;
-			pBeaconContext->InUse = FALSE;
-			pBeaconContext->IRPPending = FALSE;
-		}
-
-		/* */
-		/* NullContext */
-		/* */
-		NdisZeroMemory(pNullContext, sizeof(struct rt_tx_context));
-
-		/*Allocate URB */
-		LM_USB_ALLOC(pObj, pNullContext, struct rt_tx_buffer *, sizeof(struct rt_tx_buffer),
-			     Status,
-			     ("<-- ERROR in Alloc TX NullContext urb!\n"),
-			     out3,
-			     ("<-- ERROR in Alloc TX NullContext struct rt_tx_buffer!\n"),
-			     out4);
-
-		pNullContext->pAd = pAd;
-		pNullContext->pIrp = NULL;
-		pNullContext->InUse = FALSE;
-		pNullContext->IRPPending = FALSE;
-
-		/* */
-		/* RTSContext */
-		/* */
-		NdisZeroMemory(pRTSContext, sizeof(struct rt_tx_context));
-
-		/*Allocate URB */
-		LM_USB_ALLOC(pObj, pRTSContext, struct rt_tx_buffer *, sizeof(struct rt_tx_buffer),
-			     Status,
-			     ("<-- ERROR in Alloc TX RTSContext urb!\n"),
-			     out4,
-			     ("<-- ERROR in Alloc TX RTSContext struct rt_tx_buffer!\n"),
-			     out5);
-
-		pRTSContext->pAd = pAd;
-		pRTSContext->pIrp = NULL;
-		pRTSContext->InUse = FALSE;
-		pRTSContext->IRPPending = FALSE;
-
-		/* */
-		/* PsPollContext */
-		/* */
-		/*NdisZeroMemory(pPsPollContext, sizeof(struct rt_tx_context)); */
-		/*Allocate URB */
-		LM_USB_ALLOC(pObj, pPsPollContext, struct rt_tx_buffer *,
-			     sizeof(struct rt_tx_buffer), Status,
-			     ("<-- ERROR in Alloc TX PsPollContext urb!\n"),
-			     out5,
-			     ("<-- ERROR in Alloc TX PsPollContext struct rt_tx_buffer!\n"),
-			     out6);
-
-		pPsPollContext->pAd = pAd;
-		pPsPollContext->pIrp = NULL;
-		pPsPollContext->InUse = FALSE;
-		pPsPollContext->IRPPending = FALSE;
-		pPsPollContext->bAggregatible = FALSE;
-		pPsPollContext->LastOne = TRUE;
-
-	} while (FALSE);
-
-done:
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitTransmit(Status=%d)\n", Status));
-
-	return Status;
-
-	/* --------------------------- ERROR HANDLE --------------------------- */
-out6:
-	LM_URB_FREE(pObj, pPsPollContext, sizeof(struct rt_tx_buffer));
-
-out5:
-	LM_URB_FREE(pObj, pRTSContext, sizeof(struct rt_tx_buffer));
-
-out4:
-	LM_URB_FREE(pObj, pNullContext, sizeof(struct rt_tx_buffer));
-
-out3:
-	for (i = 0; i < BEACON_RING_SIZE; i++) {
-		struct rt_tx_context *pBeaconContext = &(pAd->BeaconContext[i]);
-		if (pBeaconContext)
-			LM_URB_FREE(pObj, pBeaconContext, sizeof(struct rt_tx_buffer));
-	}
-
-out2:
-	if (pAd->MgmtDescRing.AllocVa) {
-		pMgmtRing = &pAd->MgmtRing;
-		for (i = 0; i < MGMT_RING_SIZE; i++) {
-			pMLMEContext =
-			    (struct rt_tx_context *)pAd->MgmtRing.Cell[i].AllocVa;
-			if (pMLMEContext)
-				LM_URB_FREE(pObj, pMLMEContext,
-					    sizeof(struct rt_tx_buffer));
-		}
-		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
-		pAd->MgmtDescRing.AllocVa = NULL;
-	}
-
-out1:
-	for (acidx = 0; acidx < 4; acidx++) {
-		struct rt_ht_tx_context *pTxContext = &(pAd->TxContext[acidx]);
-		if (pTxContext)
-			LM_URB_FREE(pObj, pTxContext, sizeof(struct rt_httx_buffer));
-	}
-
-	/* Here we didn't have any pre-allocated memory need to free. */
-
-	return Status;
-}
-
-/*
-========================================================================
-Routine Description:
-    Allocate DMA memory blocks for send, receive.
-
-Arguments:
-    pAd					Pointer to our adapter
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-	NDIS_STATUS_FAILURE
-	NDIS_STATUS_RESOURCES
-
-Note:
-========================================================================
-*/
-int RTMPAllocTxRxRingMemory(struct rt_rtmp_adapter *pAd)
-{
-/*      struct rt_counter_802_11  pCounter = &pAd->WlanCounters; */
-	int Status;
-	int num;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
-
-	do {
-		/* Init the struct rt_cmdq and CmdQLock */
-		NdisAllocateSpinLock(&pAd->CmdQLock);
-		NdisAcquireSpinLock(&pAd->CmdQLock);
-		RTUSBInitializeCmdQ(&pAd->CmdQ);
-		NdisReleaseSpinLock(&pAd->CmdQLock);
-
-		NdisAllocateSpinLock(&pAd->MLMEBulkOutLock);
-		/*NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock); */
-		NdisAllocateSpinLock(&pAd->BulkOutLock[0]);
-		NdisAllocateSpinLock(&pAd->BulkOutLock[1]);
-		NdisAllocateSpinLock(&pAd->BulkOutLock[2]);
-		NdisAllocateSpinLock(&pAd->BulkOutLock[3]);
-		NdisAllocateSpinLock(&pAd->BulkOutLock[4]);
-		NdisAllocateSpinLock(&pAd->BulkOutLock[5]);
-		NdisAllocateSpinLock(&pAd->BulkInLock);
-
-		for (num = 0; num < NUM_OF_TX_RING; num++) {
-			NdisAllocateSpinLock(&pAd->TxContextQueueLock[num]);
-		}
-
-/*              NdisAllocateSpinLock(&pAd->MemLock);    // Not used in RT28XX */
-
-/*              NdisAllocateSpinLock(&pAd->MacTabLock); // init it in UserCfgInit() */
-/*              NdisAllocateSpinLock(&pAd->BATabLock); // init it in BATableInit() */
-
-/*              for(num=0; num<MAX_LEN_OF_BA_REC_TABLE; num++) */
-/*              { */
-/*                      NdisAllocateSpinLock(&pAd->BATable.BARecEntry[num].RxReRingLock); */
-/*              } */
-
-		/* */
-		/* Init Mac Table */
-		/* */
-/*              MacTableInitialize(pAd); */
-
-		/* */
-		/* Init send data structures and related parameters */
-		/* */
-		Status = NICInitTransmit(pAd);
-		if (Status != NDIS_STATUS_SUCCESS)
-			break;
-
-		/* */
-		/* Init receive data structures and related parameters */
-		/* */
-		Status = NICInitRecv(pAd);
-		if (Status != NDIS_STATUS_SUCCESS)
-			break;
-
-		pAd->PendingIoCount = 1;
-
-	} while (FALSE);
-
-	NdisZeroMemory(&pAd->FragFrame, sizeof(struct rt_fragment_frame));
-	pAd->FragFrame.pFragPacket =
-	    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
-
-	if (pAd->FragFrame.pFragPacket == NULL) {
-		Status = NDIS_STATUS_RESOURCES;
-	}
-
-	DBGPRINT_S(Status,
-		   ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
-	return Status;
-}
-
-/*
-========================================================================
-Routine Description:
-	Calls USB_InterfaceStop and frees memory allocated for the URBs
-    calls NdisMDeregisterDevice and frees the memory
-    allocated in VNetInitialize for the Adapter Object
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RTMPFreeTxRxRingMemory(struct rt_rtmp_adapter *pAd)
-{
-#define LM_URB_FREE(pObj, Context, BufferSize)				\
-	if (NULL != Context->pUrb) {							\
-		RTUSB_UNLINK_URB(Context->pUrb);					\
-		RTUSB_FREE_URB(Context->pUrb);						\
-		Context->pUrb = NULL; }								\
-	if (NULL != Context->TransferBuffer) {					\
-		RTUSB_URB_FREE_BUFFER(pObj->pUsb_Dev, BufferSize,	\
-								Context->TransferBuffer,	\
-								Context->data_dma);			\
-		Context->TransferBuffer = NULL; }
-
-	u32 i, acidx;
-	struct rt_tx_context *pNullContext = &pAd->NullContext;
-	struct rt_tx_context *pPsPollContext = &pAd->PsPollContext;
-	struct rt_tx_context *pRTSContext = &pAd->RTSContext;
-/*      struct rt_ht_tx_context *pHTTXContext; */
-	/*PRTMP_REORDERBUF      pReorderBuf; */
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-/*      struct rt_rtmp_tx_ring *pTxRing; */
-
-	DBGPRINT(RT_DEBUG_ERROR, ("---> RTMPFreeTxRxRingMemory\n"));
-	pObj = pObj;
-
-	/* Free all resources for the RECEIVE buffer queue. */
-	for (i = 0; i < (RX_RING_SIZE); i++) {
-		struct rt_rx_context *pRxContext = &(pAd->RxContext[i]);
-		if (pRxContext)
-			LM_URB_FREE(pObj, pRxContext, MAX_RXBULK_SIZE);
-	}
-
-	/* Free PsPoll frame resource */
-	LM_URB_FREE(pObj, pPsPollContext, sizeof(struct rt_tx_buffer));
-
-	/* Free NULL frame resource */
-	LM_URB_FREE(pObj, pNullContext, sizeof(struct rt_tx_buffer));
-
-	/* Free RTS frame resource */
-	LM_URB_FREE(pObj, pRTSContext, sizeof(struct rt_tx_buffer));
-
-	/* Free beacon frame resource */
-	for (i = 0; i < BEACON_RING_SIZE; i++) {
-		struct rt_tx_context *pBeaconContext = &(pAd->BeaconContext[i]);
-		if (pBeaconContext)
-			LM_URB_FREE(pObj, pBeaconContext, sizeof(struct rt_tx_buffer));
-	}
-
-	/* Free mgmt frame resource */
-	for (i = 0; i < MGMT_RING_SIZE; i++) {
-		struct rt_tx_context *pMLMEContext =
-		    (struct rt_tx_context *)pAd->MgmtRing.Cell[i].AllocVa;
-		/*LM_URB_FREE(pObj, pMLMEContext, sizeof(struct rt_tx_buffer)); */
-		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) {
-			RTMPFreeNdisPacket(pAd,
-					   pAd->MgmtRing.Cell[i].pNdisPacket);
-			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
-			pMLMEContext->TransferBuffer = NULL;
-		}
-
-		if (pMLMEContext) {
-			if (NULL != pMLMEContext->pUrb) {
-				RTUSB_UNLINK_URB(pMLMEContext->pUrb);
-				RTUSB_FREE_URB(pMLMEContext->pUrb);
-				pMLMEContext->pUrb = NULL;
-			}
-		}
-	}
-	if (pAd->MgmtDescRing.AllocVa)
-		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
-
-	/* Free Tx frame resource */
-	for (acidx = 0; acidx < 4; acidx++) {
-		struct rt_ht_tx_context *pHTTXContext = &(pAd->TxContext[acidx]);
-		if (pHTTXContext)
-			LM_URB_FREE(pObj, pHTTXContext, sizeof(struct rt_httx_buffer));
-	}
-
-	if (pAd->FragFrame.pFragPacket)
-		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket,
-				    NDIS_STATUS_SUCCESS);
-
-	for (i = 0; i < 6; i++) {
-		NdisFreeSpinLock(&pAd->BulkOutLock[i]);
-	}
-
-	NdisFreeSpinLock(&pAd->BulkInLock);
-	NdisFreeSpinLock(&pAd->MLMEBulkOutLock);
-
-	NdisFreeSpinLock(&pAd->CmdQLock);
-	/* Clear all pending bulk-out request flags. */
-	RTUSB_CLEAR_BULK_FLAG(pAd, 0xffffffff);
-
-/*      NdisFreeSpinLock(&pAd->MacTabLock); */
-
-/*      for(i=0; i<MAX_LEN_OF_BA_REC_TABLE; i++) */
-/*      { */
-/*              NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock); */
-/*      } */
-
-	DBGPRINT(RT_DEBUG_ERROR, ("<--- RTMPFreeTxRxRingMemory\n"));
-}
-
-/*
-========================================================================
-Routine Description:
-    Write WLAN MAC address to USB 2870.
-
-Arguments:
-    pAd					Pointer to our adapter
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-
-Note:
-========================================================================
-*/
-int RTUSBWriteHWMACAddress(struct rt_rtmp_adapter *pAd)
-{
-	MAC_DW0_STRUC StaMacReg0;
-	MAC_DW1_STRUC StaMacReg1;
-	int Status = NDIS_STATUS_SUCCESS;
-	LARGE_INTEGER NOW;
-
-	/* initialize the random number generator */
-	RTMP_GetCurrentSystemTime(&NOW);
-
-	if (pAd->bLocalAdminMAC != TRUE) {
-		pAd->CurrentAddress[0] = pAd->PermanentAddress[0];
-		pAd->CurrentAddress[1] = pAd->PermanentAddress[1];
-		pAd->CurrentAddress[2] = pAd->PermanentAddress[2];
-		pAd->CurrentAddress[3] = pAd->PermanentAddress[3];
-		pAd->CurrentAddress[4] = pAd->PermanentAddress[4];
-		pAd->CurrentAddress[5] = pAd->PermanentAddress[5];
-	}
-	/* Write New MAC address to MAC_CSR2 & MAC_CSR3 & let ASIC know our new MAC */
-	StaMacReg0.field.Byte0 = pAd->CurrentAddress[0];
-	StaMacReg0.field.Byte1 = pAd->CurrentAddress[1];
-	StaMacReg0.field.Byte2 = pAd->CurrentAddress[2];
-	StaMacReg0.field.Byte3 = pAd->CurrentAddress[3];
-	StaMacReg1.field.Byte4 = pAd->CurrentAddress[4];
-	StaMacReg1.field.Byte5 = pAd->CurrentAddress[5];
-	StaMacReg1.field.U2MeMask = 0xff;
-	DBGPRINT_RAW(RT_DEBUG_TRACE,
-		("Local MAC = %pM\n", pAd->CurrentAddress));
-
-	RTUSBWriteMACRegister(pAd, MAC_ADDR_DW0, StaMacReg0.word);
-	RTUSBWriteMACRegister(pAd, MAC_ADDR_DW1, StaMacReg1.word);
-	return Status;
-}
-
-/*
-========================================================================
-Routine Description:
-    Disable DMA.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28XXDMADisable(struct rt_rtmp_adapter *pAd)
-{
-	/* no use */
-}
-
-/*
-========================================================================
-Routine Description:
-    Enable DMA.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28XXDMAEnable(struct rt_rtmp_adapter *pAd)
-{
-	WPDMA_GLO_CFG_STRUC GloCfg;
-	USB_DMA_CFG_STRUC UsbCfg;
-	int i = 0;
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x4);
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)
-		    && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		DBGPRINT(RT_DEBUG_TRACE, ("==>  DMABusy\n"));
-		RTMPusecDelay(1000);
-		i++;
-	} while (i < 200);
-
-	RTMPusecDelay(50);
-	GloCfg.field.EnTXWriteBackDDONE = 1;
-	GloCfg.field.EnableRxDMA = 1;
-	GloCfg.field.EnableTxDMA = 1;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-	UsbCfg.word = 0;
-	UsbCfg.field.phyclear = 0;
-	/* usb version is 1.1,do not use bulk in aggregation */
-	if (pAd->BulkInMaxPacketSize == 512)
-		UsbCfg.field.RxBulkAggEn = 1;
-	/* for last packet, PBF might use more than limited, so minus 2 to prevent from error */
-	UsbCfg.field.RxBulkAggLmt = (MAX_RXBULK_SIZE / 1024) - 3;
-	UsbCfg.field.RxBulkAggTOut = 0x80;	/* 2006-10-18 */
-	UsbCfg.field.RxBulkEn = 1;
-	UsbCfg.field.TxBulkEn = 1;
-
-	RTUSBWriteMACRegister(pAd, USB_DMA_CFG, UsbCfg.word);
-
-}
-
-/********************************************************************
-  *
-  *	2870 Beacon Update Related functions.
-  *
-  ********************************************************************/
-
-/*
-========================================================================
-Routine Description:
-    Write Beacon buffer to Asic.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-	None
-
-Note:
-========================================================================
-*/
-void RT28xx_UpdateBeaconToAsic(struct rt_rtmp_adapter *pAd,
-			       int apidx,
-			       unsigned long FrameLen, unsigned long UpdatePos)
-{
-	u8 *pBeaconFrame = NULL;
-	u8 *ptr;
-	u32 i, padding;
-	struct rt_beacon_sync *pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	u32 longValue;
-/*      u16                  shortValue; */
-	BOOLEAN bBcnReq = FALSE;
-	u8 bcn_idx = 0;
-
-	if (pBeaconFrame == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("pBeaconFrame is NULL!\n"));
-		return;
-	}
-
-	if (pBeaconSync == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("pBeaconSync is NULL!\n"));
-		return;
-	}
-	/*if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) || */
-	/*      ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP)) */
-	/*      ) */
-	if (bBcnReq == FALSE) {
-		/* when the ra interface is down, do not send its beacon frame */
-		/* clear all zero */
-		for (i = 0; i < TXWI_SIZE; i += 4) {
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
-					0x00);
-		}
-		pBeaconSync->BeaconBitMap &=
-		    (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
-		NdisZeroMemory(pBeaconSync->BeaconTxWI[bcn_idx], TXWI_SIZE);
-	} else {
-		ptr = (u8 *)& pAd->BeaconTxWI;
-		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE) == FALSE) {	/* If BeaconTxWI changed, we need to rewrite the TxWI for the Beacon frames. */
-			pBeaconSync->BeaconBitMap &=
-			    (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
-			NdisMoveMemory(pBeaconSync->BeaconTxWI[bcn_idx],
-				       &pAd->BeaconTxWI, TXWI_SIZE);
-		}
-
-		if ((pBeaconSync->BeaconBitMap & (1 << bcn_idx)) !=
-		    (1 << bcn_idx)) {
-			for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
-			{
-				longValue =
-				    *ptr + (*(ptr + 1) << 8) +
-				    (*(ptr + 2) << 16) + (*(ptr + 3) << 24);
-				RTMP_IO_WRITE32(pAd,
-						pAd->BeaconOffset[bcn_idx] + i,
-						longValue);
-				ptr += 4;
-			}
-		}
-
-		ptr = pBeaconSync->BeaconBuf[bcn_idx];
-		padding = (FrameLen & 0x01);
-		NdisZeroMemory((u8 *)(pBeaconFrame + FrameLen), padding);
-		FrameLen += padding;
-		for (i = 0; i < FrameLen /*HW_BEACON_OFFSET */ ; i += 2) {
-			if (NdisEqualMemory(ptr, pBeaconFrame, 2) == FALSE) {
-				NdisMoveMemory(ptr, pBeaconFrame, 2);
-				/*shortValue = *ptr + (*(ptr+1)<<8); */
-				/*RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, shortValue); */
-				RTUSBMultiWrite(pAd,
-						pAd->BeaconOffset[bcn_idx] +
-						TXWI_SIZE + i, ptr, 2);
-			}
-			ptr += 2;
-			pBeaconFrame += 2;
-		}
-
-		pBeaconSync->BeaconBitMap |= (1 << bcn_idx);
-
-		/* For AP interface, set the DtimBitOn so that we can send Bcast/Mcast frame out after this beacon frame. */
-	}
-
-}
-
-void RTUSBBssBeaconStop(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_beacon_sync *pBeaconSync;
-	int i, offset;
-	BOOLEAN Cancelled = TRUE;
-
-	pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	if (pBeaconSync && pBeaconSync->EnableBeacon) {
-		int NumOfBcn;
-
-		{
-			NumOfBcn = MAX_MESH_NUM;
-		}
-
-		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
-
-		for (i = 0; i < NumOfBcn; i++) {
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
-				       HW_BEACON_OFFSET);
-			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
-
-			for (offset = 0; offset < HW_BEACON_OFFSET; offset += 4)
-				RTMP_IO_WRITE32(pAd,
-						pAd->BeaconOffset[i] + offset,
-						0x00);
-
-			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
-			pBeaconSync->TimIELocationInBeacon[i] = 0;
-		}
-		pBeaconSync->BeaconBitMap = 0;
-		pBeaconSync->DtimBitOn = 0;
-	}
-}
-
-void RTUSBBssBeaconStart(struct rt_rtmp_adapter *pAd)
-{
-	int apidx;
-	struct rt_beacon_sync *pBeaconSync;
-/*      LARGE_INTEGER   tsfTime, deltaTime; */
-
-	pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	if (pBeaconSync && pBeaconSync->EnableBeacon) {
-		int NumOfBcn;
-
-		{
-			NumOfBcn = MAX_MESH_NUM;
-		}
-
-		for (apidx = 0; apidx < NumOfBcn; apidx++) {
-			u8 CapabilityInfoLocationInBeacon = 0;
-			u8 TimIELocationInBeacon = 0;
-
-			NdisZeroMemory(pBeaconSync->BeaconBuf[apidx],
-				       HW_BEACON_OFFSET);
-			pBeaconSync->CapabilityInfoLocationInBeacon[apidx] =
-			    CapabilityInfoLocationInBeacon;
-			pBeaconSync->TimIELocationInBeacon[apidx] =
-			    TimIELocationInBeacon;
-			NdisZeroMemory(pBeaconSync->BeaconTxWI[apidx],
-				       TXWI_SIZE);
-		}
-		pBeaconSync->BeaconBitMap = 0;
-		pBeaconSync->DtimBitOn = 0;
-		pAd->CommonCfg.BeaconUpdateTimer.Repeat = TRUE;
-
-		pAd->CommonCfg.BeaconAdjust = 0;
-		pAd->CommonCfg.BeaconFactor =
-		    0xffffffff / (pAd->CommonCfg.BeaconPeriod << 10);
-		pAd->CommonCfg.BeaconRemain =
-		    (0xffffffff % (pAd->CommonCfg.BeaconPeriod << 10)) + 1;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBBssBeaconStart:BeaconFactor=%d, BeaconRemain=%d!\n",
-			  pAd->CommonCfg.BeaconFactor,
-			  pAd->CommonCfg.BeaconRemain));
-		RTMPSetTimer(&pAd->CommonCfg.BeaconUpdateTimer,
-			     10 /*pAd->CommonCfg.BeaconPeriod */ );
-
-	}
-}
-
-void RTUSBBssBeaconInit(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_beacon_sync *pBeaconSync;
-	int i;
-
-	os_alloc_mem(pAd, (u8 **) (&pAd->CommonCfg.pBeaconSync),
-		     sizeof(struct rt_beacon_sync));
-	/*NdisAllocMemory(pAd->CommonCfg.pBeaconSync, sizeof(struct rt_beacon_sync), MEM_ALLOC_FLAG); */
-	if (pAd->CommonCfg.pBeaconSync) {
-		pBeaconSync = pAd->CommonCfg.pBeaconSync;
-		NdisZeroMemory(pBeaconSync, sizeof(struct rt_beacon_sync));
-		for (i = 0; i < HW_BEACON_MAX_COUNT; i++) {
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
-				       HW_BEACON_OFFSET);
-			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
-			pBeaconSync->TimIELocationInBeacon[i] = 0;
-			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
-		}
-		pBeaconSync->BeaconBitMap = 0;
-
-		/*RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE); */
-		pBeaconSync->EnableBeacon = TRUE;
-	}
-}
-
-void RTUSBBssBeaconExit(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_beacon_sync *pBeaconSync;
-	BOOLEAN Cancelled = TRUE;
-	int i;
-
-	if (pAd->CommonCfg.pBeaconSync) {
-		pBeaconSync = pAd->CommonCfg.pBeaconSync;
-		pBeaconSync->EnableBeacon = FALSE;
-		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
-		pBeaconSync->BeaconBitMap = 0;
-
-		for (i = 0; i < HW_BEACON_MAX_COUNT; i++) {
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
-				       HW_BEACON_OFFSET);
-			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
-			pBeaconSync->TimIELocationInBeacon[i] = 0;
-			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
-		}
-
-		os_free_mem(pAd, pAd->CommonCfg.pBeaconSync);
-		pAd->CommonCfg.pBeaconSync = NULL;
-	}
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        For device work as AP mode but didn't have TBTT interrupt event, we need a mechanism
-        to update the beacon context in each Beacon interval. Here we use a periodical timer
-        to simulate the TBTT interrupt to handle the beacon context update.
-
-    Arguments:
-        SystemSpecific1         - Not used.
-        FunctionContext         - Pointer to our Adapter context.
-        SystemSpecific2         - Not used.
-        SystemSpecific3         - Not used.
-
-    Return Value:
-        None
-
-    ========================================================================
-*/
-void BeaconUpdateExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	LARGE_INTEGER tsfTime_a;	/*, tsfTime_b, deltaTime_exp, deltaTime_ab; */
-	u32 delta, delta2MS, period2US, remain, remain_low, remain_high;
-/*      BOOLEAN                 positive; */
-
-	if (pAd->CommonCfg.IsUpdateBeacon == TRUE) {
-		ReSyncBeaconTime(pAd);
-
-	}
-
-	RTMP_IO_READ32(pAd, TSF_TIMER_DW0, &tsfTime_a.u.LowPart);
-	RTMP_IO_READ32(pAd, TSF_TIMER_DW1, &tsfTime_a.u.HighPart);
-
-	/*positive=getDeltaTime(tsfTime_a, expectedTime, &deltaTime_exp); */
-	period2US = (pAd->CommonCfg.BeaconPeriod << 10);
-	remain_high = pAd->CommonCfg.BeaconRemain * tsfTime_a.u.HighPart;
-	remain_low = tsfTime_a.u.LowPart % (pAd->CommonCfg.BeaconPeriod << 10);
-	remain =
-	    (remain_high + remain_low) % (pAd->CommonCfg.BeaconPeriod << 10);
-	delta = (pAd->CommonCfg.BeaconPeriod << 10) - remain;
-
-	delta2MS = (delta >> 10);
-	if (delta2MS > 150) {
-		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = 100;
-		pAd->CommonCfg.IsUpdateBeacon = FALSE;
-	} else {
-		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = delta2MS + 10;
-		pAd->CommonCfg.IsUpdateBeacon = TRUE;
-	}
-
-}
-
-/********************************************************************
-  *
-  *	2870 Radio on/off Related functions.
-  *
-  ********************************************************************/
-void RT28xxUsbMlmeRadioOn(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RT28xxUsbMlmeRadioOn()\n"));
-
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-		return;
-
-	{
-		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-		RTMPusecDelay(10000);
-	}
-	/*NICResetFromError(pAd); */
-
-	/* Enable Tx/Rx */
-	RTMPEnableRxTx(pAd);
-
-	if (pChipOps->AsicReverseRfFromSleepMode)
-		pChipOps->AsicReverseRfFromSleepMode(pAd);
-
-	/* Clear Radio off flag */
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-	RTUSBBulkReceive(pAd);
-
-	/* Set LED */
-	RTMPSetLED(pAd, LED_RADIO_ON);
-}
-
-void RT28xxUsbMlmeRadioOFF(struct rt_rtmp_adapter *pAd)
-{
-	WPDMA_GLO_CFG_STRUC GloCfg;
-	u32 Value, i;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RT28xxUsbMlmeRadioOFF()\n"));
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-		return;
-
-	/* Clear PMKID cache. */
-	pAd->StaCfg.SavedPMKNum = 0;
-	RTMPZeroMemory(pAd->StaCfg.SavedPMK, (PMKID_NO * sizeof(struct rt_bssid_info)));
-
-	/* Link down first if any association exists */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
-			struct rt_mlme_disassoc_req DisReq;
-			struct rt_mlme_queue_elem *pMsgElem =
-			    kmalloc(sizeof(struct rt_mlme_queue_elem),
-							MEM_ALLOC_FLAG);
-
-			if (pMsgElem) {
-				COPY_MAC_ADDR(&DisReq.Addr,
-					      pAd->CommonCfg.Bssid);
-				DisReq.Reason = REASON_DISASSOC_STA_LEAVING;
-
-				pMsgElem->Machine = ASSOC_STATE_MACHINE;
-				pMsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-				pMsgElem->MsgLen =
-				    sizeof(struct rt_mlme_disassoc_req);
-				NdisMoveMemory(pMsgElem->Msg, &DisReq,
-					       sizeof
-					       (struct rt_mlme_disassoc_req));
-
-				MlmeDisassocReqAction(pAd, pMsgElem);
-				kfree(pMsgElem);
-
-				RTMPusecDelay(1000);
-			}
-		}
-	}
-	/* Set Radio off flag */
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-	{
-		/* Link down first if any association exists */
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
-			LinkDown(pAd, FALSE);
-		RTMPusecDelay(10000);
-
-		/*========================================== */
-		/* Clean up old bss table */
-		BssTableInit(&pAd->ScanTab);
-	}
-
-	/* Set LED */
-	RTMPSetLED(pAd, LED_RADIO_OFF);
-
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
-		/* Must using 40MHz. */
-		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
-	} else {
-		/* Must using 20MHz. */
-		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
-	}
-
-	/* Disable Tx/Rx DMA */
-	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	/* disable DMA */
-	GloCfg.field.EnableTxDMA = 0;
-	GloCfg.field.EnableRxDMA = 0;
-	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	/* abort all TX rings */
-
-	/* Waiting for DMA idle */
-	i = 0;
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)
-		    && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		RTMPusecDelay(1000);
-	} while (i++ < 100);
-
-	/* Disable MAC Tx/Rx */
-	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
-	Value &= (0xfffffff3);
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-
-	{
-		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
-	}
-}
-
-#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2860/common/cmm_sanity.c b/drivers/staging/rt2860/common/cmm_sanity.c
deleted file mode 100644
index 3bfb4ad..0000000
--- a/drivers/staging/rt2860/common/cmm_sanity.c
+++ /dev/null
@@ -1,1205 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	sanity.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John Chang  2004-09-01      add WMM support
-*/
-#include "../rt_config.h"
-
-extern u8 CISCO_OUI[];
-
-extern u8 WPA_OUI[];
-extern u8 RSN_OUI[];
-extern u8 WME_INFO_ELEM[];
-extern u8 WME_PARM_ELEM[];
-extern u8 Ccx2QosInfo[];
-extern u8 RALINK_OUI[];
-extern u8 BROADCOM_OUI[];
-extern u8 WPS_OUI[];
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN MlmeAddBAReqSanity(struct rt_rtmp_adapter *pAd,
-			   void * Msg, unsigned long MsgLen, u8 *pAddr2)
-{
-	struct rt_mlme_addba_req *pInfo;
-
-	pInfo = (struct rt_mlme_addba_req *)Msg;
-
-	if ((MsgLen != sizeof(struct rt_mlme_addba_req))) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeAddBAReqSanity fail - message length not correct.\n"));
-		return FALSE;
-	}
-
-	if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeAddBAReqSanity fail - The peer Mac is not associated yet.\n"));
-		return FALSE;
-	}
-
-	if ((pInfo->pAddr[0] & 0x01) == 0x01) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeAddBAReqSanity fail - broadcast address not support BA\n"));
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN MlmeDelBAReqSanity(struct rt_rtmp_adapter *pAd, void * Msg, unsigned long MsgLen)
-{
-	struct rt_mlme_delba_req *pInfo;
-	pInfo = (struct rt_mlme_delba_req *)Msg;
-
-	if ((MsgLen != sizeof(struct rt_mlme_delba_req))) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeDelBAReqSanity fail - message length not correct.\n"));
-		return FALSE;
-	}
-
-	if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeDelBAReqSanity fail - The peer Mac is not associated yet.\n"));
-		return FALSE;
-	}
-
-	if ((pInfo->TID & 0xf0)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeDelBAReqSanity fail - The peer TID is incorrect.\n"));
-		return FALSE;
-	}
-
-	if (NdisEqualMemory
-	    (pAd->MacTab.Content[pInfo->Wcid].Addr, pInfo->Addr,
-	     MAC_ADDR_LEN) == 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeDelBAReqSanity fail - the peer addr dosen't exist.\n"));
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-BOOLEAN PeerAddBAReqActionSanity(struct rt_rtmp_adapter *pAd,
-				 void * pMsg,
-				 unsigned long MsgLen, u8 *pAddr2)
-{
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) pMsg;
-	struct rt_frame_addba_req * pAddFrame;
-	pAddFrame = (struct rt_frame_addba_req *) (pMsg);
-	if (MsgLen < (sizeof(struct rt_frame_addba_req))) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBAReqActionSanity: ADDBA Request frame length size = %ld incorrect\n",
-			  MsgLen));
-		return FALSE;
-	}
-	/* we support immediate BA. */
-	*(u16 *) (&pAddFrame->BaParm) =
-	    cpu2le16(*(u16 *) (&pAddFrame->BaParm));
-	pAddFrame->TimeOutValue = cpu2le16(pAddFrame->TimeOutValue);
-	pAddFrame->BaStartSeq.word = cpu2le16(pAddFrame->BaStartSeq.word);
-
-	if (pAddFrame->BaParm.BAPolicy != IMMED_BA) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBAReqActionSanity: ADDBA Request Ba Policy[%d] not support\n",
-			  pAddFrame->BaParm.BAPolicy));
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("ADDBA Request. tid=%x, Bufsize=%x, AMSDUSupported=%x \n",
-			  pAddFrame->BaParm.TID, pAddFrame->BaParm.BufSize,
-			  pAddFrame->BaParm.AMSDUSupported));
-		return FALSE;
-	}
-	/* we support immediate BA. */
-	if (pAddFrame->BaParm.TID & 0xfff0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBAReqActionSanity: ADDBA Request incorrect TID = %d\n",
-			  pAddFrame->BaParm.TID));
-		return FALSE;
-	}
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-	return TRUE;
-}
-
-BOOLEAN PeerAddBARspActionSanity(struct rt_rtmp_adapter *pAd,
-				 void * pMsg, unsigned long MsgLen)
-{
-	struct rt_frame_addba_rsp * pAddFrame;
-
-	pAddFrame = (struct rt_frame_addba_rsp *) (pMsg);
-	if (MsgLen < (sizeof(struct rt_frame_addba_rsp))) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBARspActionSanity: ADDBA Response frame length size = %ld incorrect\n",
-			  MsgLen));
-		return FALSE;
-	}
-	/* we support immediate BA. */
-	*(u16 *) (&pAddFrame->BaParm) =
-	    cpu2le16(*(u16 *) (&pAddFrame->BaParm));
-	pAddFrame->StatusCode = cpu2le16(pAddFrame->StatusCode);
-	pAddFrame->TimeOutValue = cpu2le16(pAddFrame->TimeOutValue);
-
-	if (pAddFrame->BaParm.BAPolicy != IMMED_BA) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBAReqActionSanity: ADDBA Response Ba Policy[%d] not support\n",
-			  pAddFrame->BaParm.BAPolicy));
-		return FALSE;
-	}
-	/* we support immediate BA. */
-	if (pAddFrame->BaParm.TID & 0xfff0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("PeerAddBARspActionSanity: ADDBA Response incorrect TID = %d\n",
-			  pAddFrame->BaParm.TID));
-		return FALSE;
-	}
-	return TRUE;
-
-}
-
-BOOLEAN PeerDelBAActionSanity(struct rt_rtmp_adapter *pAd,
-			      u8 Wcid, void * pMsg, unsigned long MsgLen)
-{
-	/*struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *)pMsg; */
-	struct rt_frame_delba_req * pDelFrame;
-	if (MsgLen != (sizeof(struct rt_frame_delba_req)))
-		return FALSE;
-
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return FALSE;
-
-	pDelFrame = (struct rt_frame_delba_req *) (pMsg);
-
-	*(u16 *) (&pDelFrame->DelbaParm) =
-	    cpu2le16(*(u16 *) (&pDelFrame->DelbaParm));
-	pDelFrame->ReasonCode = cpu2le16(pDelFrame->ReasonCode);
-
-	if (pDelFrame->DelbaParm.TID & 0xfff0)
-		return FALSE;
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerBeaconAndProbeRspSanity(struct rt_rtmp_adapter *pAd, void * Msg, unsigned long MsgLen, u8 MsgChannel, u8 *pAddr2, u8 *pBssid, char Ssid[], u8 * pSsidLen, u8 * pBssType, u16 * pBeaconPeriod, u8 * pChannel, u8 * pNewChannel, OUT LARGE_INTEGER * pTimestamp, struct rt_cf_parm * pCfParm, u16 * pAtimWin, u16 * pCapabilityInfo, u8 * pErp, u8 * pDtimCount, u8 * pDtimPeriod, u8 * pBcastFlag, u8 * pMessageToMe, u8 SupRate[], u8 * pSupRateLen, u8 ExtRate[], u8 * pExtRateLen, u8 * pCkipFlag, u8 * pAironetCellPowerLimit, struct rt_edca_parm *pEdcaParm, struct rt_qbss_load_parm *pQbssLoad, struct rt_qos_capability_parm *pQosCapability, unsigned long * pRalinkIe, u8 * pHtCapabilityLen, u8 * pPreNHtCapabilityLen, struct rt_ht_capability_ie * pHtCapability, u8 * AddHtInfoLen, struct rt_add_ht_info_ie * AddHtInfo, u8 * NewExtChannelOffset,	/* Ht extension channel offset(above or below) */
-				    u16 * LengthVIE,
-				    struct rt_ndis_802_11_variable_ies *pVIE)
-{
-	u8 *Ptr;
-	u8 TimLen;
-	struct rt_frame_802_11 * pFrame;
-	struct rt_eid * pEid;
-	u8 SubType;
-	u8 Sanity;
-	/*u8                             ECWMin, ECWMax; */
-	/*MAC_CSR9_STRUC            Csr9; */
-	unsigned long Length = 0;
-
-	/* For some 11a AP which didn't have DS_IE, we use two conditions to decide the channel */
-	/*      1. If the AP is 11n enabled, then check the control channel. */
-	/*      2. If the AP didn't have any info about channel, use the channel we received this frame as the channel. (May inaccuracy!) */
-	u8 CtrlChannel = 0;
-
-	/* Add for 3 necessary EID field check */
-	Sanity = 0;
-
-	*pAtimWin = 0;
-	*pErp = 0;
-	*pDtimCount = 0;
-	*pDtimPeriod = 0;
-	*pBcastFlag = 0;
-	*pMessageToMe = 0;
-	*pExtRateLen = 0;
-	*pCkipFlag = 0;		/* Default of CkipFlag is 0 */
-	*pAironetCellPowerLimit = 0xFF;	/* Default of AironetCellPowerLimit is 0xFF */
-	*LengthVIE = 0;		/* Set the length of VIE to init value 0 */
-	*pHtCapabilityLen = 0;	/* Set the length of VIE to init value 0 */
-	if (pAd->OpMode == OPMODE_STA)
-		*pPreNHtCapabilityLen = 0;	/* Set the length of VIE to init value 0 */
-	*AddHtInfoLen = 0;	/* Set the length of VIE to init value 0 */
-	*pRalinkIe = 0;
-	*pNewChannel = 0;
-	*NewExtChannelOffset = 0xff;	/*Default 0xff means no such IE */
-	pCfParm->bValid = FALSE;	/* default: no IE_CF found */
-	pQbssLoad->bValid = FALSE;	/* default: no IE_QBSS_LOAD found */
-	pEdcaParm->bValid = FALSE;	/* default: no IE_EDCA_PARAMETER found */
-	pQosCapability->bValid = FALSE;	/* default: no IE_QOS_CAPABILITY found */
-
-	pFrame = (struct rt_frame_802_11 *) Msg;
-
-	/* get subtype from header */
-	SubType = (u8)pFrame->Hdr.FC.SubType;
-
-	/* get Addr2 and BSSID from header */
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-	COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
-
-	Ptr = pFrame->Octet;
-	Length += LENGTH_802_11;
-
-	/* get timestamp from payload and advance the pointer */
-	NdisMoveMemory(pTimestamp, Ptr, TIMESTAMP_LEN);
-
-	pTimestamp->u.LowPart = cpu2le32(pTimestamp->u.LowPart);
-	pTimestamp->u.HighPart = cpu2le32(pTimestamp->u.HighPart);
-
-	Ptr += TIMESTAMP_LEN;
-	Length += TIMESTAMP_LEN;
-
-	/* get beacon interval from payload and advance the pointer */
-	NdisMoveMemory(pBeaconPeriod, Ptr, 2);
-	Ptr += 2;
-	Length += 2;
-
-	/* get capability info from payload and advance the pointer */
-	NdisMoveMemory(pCapabilityInfo, Ptr, 2);
-	Ptr += 2;
-	Length += 2;
-
-	if (CAP_IS_ESS_ON(*pCapabilityInfo))
-		*pBssType = BSS_INFRA;
-	else
-		*pBssType = BSS_ADHOC;
-
-	pEid = (struct rt_eid *) Ptr;
-
-	/* get variable fields from payload and advance the pointer */
-	while ((Length + 2 + pEid->Len) <= MsgLen) {
-		/* */
-		/* Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow. */
-		/* */
-		if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN) {
-			DBGPRINT(RT_DEBUG_WARN,
-				 ("PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
-				  (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN));
-			break;
-		}
-
-		switch (pEid->Eid) {
-		case IE_SSID:
-			/* Already has one SSID EID in this beacon, ignore the second one */
-			if (Sanity & 0x1)
-				break;
-			if (pEid->Len <= MAX_LEN_OF_SSID) {
-				NdisMoveMemory(Ssid, pEid->Octet, pEid->Len);
-				*pSsidLen = pEid->Len;
-				Sanity |= 0x1;
-			} else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_SSID (len=%d)\n",
-					  pEid->Len));
-				return FALSE;
-			}
-			break;
-
-		case IE_SUPP_RATES:
-			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
-				Sanity |= 0x2;
-				NdisMoveMemory(SupRate, pEid->Octet, pEid->Len);
-				*pSupRateLen = pEid->Len;
-
-				/* TODO: 2004-09-14 not a good design here, cause it exclude extra rates */
-				/* from ScanTab. We should report as is. And filter out unsupported */
-				/* rates in MlmeAux. */
-				/* Check against the supported rates */
-				/* RTMPCheckRates(pAd, SupRate, pSupRateLen); */
-			} else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",
-					  pEid->Len));
-				return FALSE;
-			}
-			break;
-
-		case IE_HT_CAP:
-			if (pEid->Len >= SIZE_HT_CAP_IE)	/*Note: allow extension! */
-			{
-				NdisMoveMemory(pHtCapability, pEid->Octet,
-					       sizeof(struct rt_ht_capability_ie));
-				*pHtCapabilityLen = SIZE_HT_CAP_IE;	/* Nnow we only support 26 bytes. */
-
-				*(u16 *) (&pHtCapability->HtCapInfo) =
-				    cpu2le16(*(u16 *)
-					     (&pHtCapability->HtCapInfo));
-				*(u16 *) (&pHtCapability->ExtHtCapInfo) =
-				    cpu2le16(*(u16 *)
-					     (&pHtCapability->ExtHtCapInfo));
-
-				{
-					*pPreNHtCapabilityLen = 0;	/* Nnow we only support 26 bytes. */
-
-					Ptr = (u8 *)pVIE;
-					NdisMoveMemory(Ptr + *LengthVIE,
-						       &pEid->Eid,
-						       pEid->Len + 2);
-					*LengthVIE += (pEid->Len + 2);
-				}
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_HT_CAP. pEid->Len = %d\n",
-					  pEid->Len));
-			}
-
-			break;
-		case IE_ADD_HT:
-			if (pEid->Len >= sizeof(struct rt_add_ht_info_ie)) {
-				/* This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only */
-				/* copy first sizeof(struct rt_add_ht_info_ie) */
-				NdisMoveMemory(AddHtInfo, pEid->Octet,
-					       sizeof(struct rt_add_ht_info_ie));
-				*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
-
-				CtrlChannel = AddHtInfo->ControlChan;
-
-				*(u16 *) (&AddHtInfo->AddHtInfo2) =
-				    cpu2le16(*(u16 *)
-					     (&AddHtInfo->AddHtInfo2));
-				*(u16 *) (&AddHtInfo->AddHtInfo3) =
-				    cpu2le16(*(u16 *)
-					     (&AddHtInfo->AddHtInfo3));
-
-				{
-					Ptr = (u8 *)pVIE;
-					NdisMoveMemory(Ptr + *LengthVIE,
-						       &pEid->Eid,
-						       pEid->Len + 2);
-					*LengthVIE += (pEid->Len + 2);
-				}
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_ADD_HT. \n"));
-			}
-
-			break;
-		case IE_SECONDARY_CH_OFFSET:
-			if (pEid->Len == 1) {
-				*NewExtChannelOffset = pEid->Octet[0];
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
-			}
-
-			break;
-		case IE_FH_PARM:
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerBeaconAndProbeRspSanity(IE_FH_PARM) \n"));
-			break;
-
-		case IE_DS_PARM:
-			if (pEid->Len == 1) {
-				*pChannel = *pEid->Octet;
-
-				{
-					if (ChannelSanity(pAd, *pChannel) == 0) {
-
-						return FALSE;
-					}
-				}
-
-				Sanity |= 0x4;
-			} else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (len=%d)\n",
-					  pEid->Len));
-				return FALSE;
-			}
-			break;
-
-		case IE_CF_PARM:
-			if (pEid->Len == 6) {
-				pCfParm->bValid = TRUE;
-				pCfParm->CfpCount = pEid->Octet[0];
-				pCfParm->CfpPeriod = pEid->Octet[1];
-				pCfParm->CfpMaxDuration =
-				    pEid->Octet[2] + 256 * pEid->Octet[3];
-				pCfParm->CfpDurRemaining =
-				    pEid->Octet[4] + 256 * pEid->Octet[5];
-			} else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_CF_PARM\n"));
-				return FALSE;
-			}
-			break;
-
-		case IE_IBSS_PARM:
-			if (pEid->Len == 2) {
-				NdisMoveMemory(pAtimWin, pEid->Octet,
-					       pEid->Len);
-			} else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAndProbeRspSanity - wrong IE_IBSS_PARM\n"));
-				return FALSE;
-			}
-			break;
-
-		case IE_TIM:
-			if (INFRA_ON(pAd) && SubType == SUBTYPE_BEACON) {
-				GetTimBit((char *)pEid, pAd->StaActive.Aid,
-					  &TimLen, pBcastFlag, pDtimCount,
-					  pDtimPeriod, pMessageToMe);
-			}
-			break;
-		case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
-			if (pEid->Len == 3) {
-				*pNewChannel = pEid->Octet[1];	/*extract new channel number */
-			}
-			break;
-
-			/* New for WPA */
-			/* CCX v2 has the same IE, we need to parse that too */
-			/* Wifi WMM use the same IE vale, need to parse that too */
-			/* case IE_WPA: */
-		case IE_VENDOR_SPECIFIC:
-			/* Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE. */
-			/* This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan. */
-			/*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
-			   {
-			   if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
-			   {
-			   {
-			   NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(struct rt_ht_capability_ie));
-			   *pHtCapabilityLen = SIZE_HT_CAP_IE;  // Nnow we only support 26 bytes.
-			   }
-			   }
-			   if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 26))
-			   {
-			   {
-			   NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(struct rt_add_ht_info_ie));
-			   *AddHtInfoLen = SIZE_ADD_HT_INFO_IE; // Nnow we only support 26 bytes.
-			   }
-			   }
-			   }
-			 */
-			/* Check the OUI version, filter out non-standard usage */
-			if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3)
-			    && (pEid->Len == 7)) {
-				/**pRalinkIe = pEid->Octet[3]; */
-				if (pEid->Octet[3] != 0)
-					*pRalinkIe = pEid->Octet[3];
-				else
-					*pRalinkIe = 0xf0000000;	/* Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag. */
-			}
-			/* This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan. */
-
-			/* Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP, */
-			/* Check broadcom-defiend pre-802.11nD1.0 OUI for HT related IE, including HT Capatilities IE and HT Information IE */
-			else if ((*pHtCapabilityLen == 0)
-				 && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI,
-						    3) && (pEid->Len >= 4)
-				 && (pAd->OpMode == OPMODE_STA)) {
-				if ((pEid->Octet[3] == OUI_PREN_HT_CAP)
-				    && (pEid->Len >= 30)
-				    && (*pHtCapabilityLen == 0)) {
-					NdisMoveMemory(pHtCapability,
-						       &pEid->Octet[4],
-						       sizeof
-						       (struct rt_ht_capability_ie));
-					*pPreNHtCapabilityLen = SIZE_HT_CAP_IE;
-				}
-
-				if ((pEid->Octet[3] == OUI_PREN_ADD_HT)
-				    && (pEid->Len >= 26)) {
-					NdisMoveMemory(AddHtInfo,
-						       &pEid->Octet[4],
-						       sizeof(struct rt_add_ht_info_ie));
-					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
-				}
-			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)) {
-				/* Copy to pVIE which will report to microsoft bssid list. */
-				Ptr = (u8 *)pVIE;
-				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
-					       pEid->Len + 2);
-				*LengthVIE += (pEid->Len + 2);
-			} else
-			    if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6)
-				&& (pEid->Len == 24)) {
-				u8 *ptr;
-				int i;
-
-				/* parsing EDCA parameters */
-				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
-				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
-				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
-				pEdcaParm->EdcaUpdateCount =
-				    pEid->Octet[6] & 0x0f;
-				pEdcaParm->bAPSDCapable =
-				    (pEid->Octet[6] & 0x80) ? 1 : 0;
-				ptr = &pEid->Octet[8];
-				for (i = 0; i < 4; i++) {
-					u8 aci = (*ptr & 0x60) >> 5;	/* b5~6 is AC INDEX */
-					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	/* b5 is ACM */
-					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	/* b0~3 is AIFSN */
-					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	/* b0~4 is Cwmin */
-					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	/* b5~8 is Cwmax */
-					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	/* in unit of 32-us */
-					ptr += 4;	/* point to next AC */
-				}
-			} else
-			    if (NdisEqualMemory(pEid->Octet, WME_INFO_ELEM, 6)
-				&& (pEid->Len == 7)) {
-				/* parsing EDCA parameters */
-				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
-				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
-				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
-				pEdcaParm->EdcaUpdateCount =
-				    pEid->Octet[6] & 0x0f;
-				pEdcaParm->bAPSDCapable =
-				    (pEid->Octet[6] & 0x80) ? 1 : 0;
-
-				/* use default EDCA parameter */
-				pEdcaParm->bACM[QID_AC_BE] = 0;
-				pEdcaParm->Aifsn[QID_AC_BE] = 3;
-				pEdcaParm->Cwmin[QID_AC_BE] = CW_MIN_IN_BITS;
-				pEdcaParm->Cwmax[QID_AC_BE] = CW_MAX_IN_BITS;
-				pEdcaParm->Txop[QID_AC_BE] = 0;
-
-				pEdcaParm->bACM[QID_AC_BK] = 0;
-				pEdcaParm->Aifsn[QID_AC_BK] = 7;
-				pEdcaParm->Cwmin[QID_AC_BK] = CW_MIN_IN_BITS;
-				pEdcaParm->Cwmax[QID_AC_BK] = CW_MAX_IN_BITS;
-				pEdcaParm->Txop[QID_AC_BK] = 0;
-
-				pEdcaParm->bACM[QID_AC_VI] = 0;
-				pEdcaParm->Aifsn[QID_AC_VI] = 2;
-				pEdcaParm->Cwmin[QID_AC_VI] =
-				    CW_MIN_IN_BITS - 1;
-				pEdcaParm->Cwmax[QID_AC_VI] = CW_MAX_IN_BITS;
-				pEdcaParm->Txop[QID_AC_VI] = 96;	/* AC_VI: 96*32us ~= 3ms */
-
-				pEdcaParm->bACM[QID_AC_VO] = 0;
-				pEdcaParm->Aifsn[QID_AC_VO] = 2;
-				pEdcaParm->Cwmin[QID_AC_VO] =
-				    CW_MIN_IN_BITS - 2;
-				pEdcaParm->Cwmax[QID_AC_VO] =
-				    CW_MAX_IN_BITS - 1;
-				pEdcaParm->Txop[QID_AC_VO] = 48;	/* AC_VO: 48*32us ~= 1.5ms */
-			}
-
-			break;
-
-		case IE_EXT_SUPP_RATES:
-			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
-				NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
-				*pExtRateLen = pEid->Len;
-
-				/* TODO: 2004-09-14 not a good design here, cause it exclude extra rates */
-				/* from ScanTab. We should report as is. And filter out unsupported */
-				/* rates in MlmeAux. */
-				/* Check against the supported rates */
-				/* RTMPCheckRates(pAd, ExtRate, pExtRateLen); */
-			}
-			break;
-
-		case IE_ERP:
-			if (pEid->Len == 1) {
-				*pErp = (u8)pEid->Octet[0];
-			}
-			break;
-
-		case IE_AIRONET_CKIP:
-			/* 0. Check Aironet IE length, it must be larger or equal to 28 */
-			/* Cisco AP350 used length as 28 */
-			/* Cisco AP12XX used length as 30 */
-			if (pEid->Len < (CKIP_NEGOTIATION_LENGTH - 2))
-				break;
-
-			/* 1. Copy CKIP flag byte to buffer for process */
-			*pCkipFlag = *(pEid->Octet + 8);
-			break;
-
-		case IE_AP_TX_POWER:
-			/* AP Control of Client Transmit Power */
-			/*0. Check Aironet IE length, it must be 6 */
-			if (pEid->Len != 0x06)
-				break;
-
-			/* Get cell power limit in dBm */
-			if (NdisEqualMemory(pEid->Octet, CISCO_OUI, 3) == 1)
-				*pAironetCellPowerLimit = *(pEid->Octet + 4);
-			break;
-
-			/* WPA2 & 802.11i RSN */
-		case IE_RSN:
-			/* There is no OUI for version anymore, check the group cipher OUI before copying */
-			if (RTMPEqualMemory(pEid->Octet + 2, RSN_OUI, 3)) {
-				/* Copy to pVIE which will report to microsoft bssid list. */
-				Ptr = (u8 *)pVIE;
-				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
-					       pEid->Len + 2);
-				*LengthVIE += (pEid->Len + 2);
-			}
-			break;
-
-		default:
-			break;
-		}
-
-		Length = Length + 2 + pEid->Len;	/* Eid[1] + Len[1]+ content[Len] */
-		pEid = (struct rt_eid *) ((u8 *) pEid + 2 + pEid->Len);
-	}
-
-	/* For some 11a AP. it did not have the channel EID, patch here */
-	{
-		u8 LatchRfChannel = MsgChannel;
-		if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0)) {
-			if (CtrlChannel != 0)
-				*pChannel = CtrlChannel;
-			else
-				*pChannel = LatchRfChannel;
-			Sanity |= 0x4;
-		}
-	}
-
-	if (Sanity != 0x7) {
-		DBGPRINT(RT_DEBUG_LOUD,
-			 ("PeerBeaconAndProbeRspSanity - missing field, Sanity=0x%02x\n",
-			  Sanity));
-		return FALSE;
-	} else {
-		return TRUE;
-	}
-
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
- */
-BOOLEAN MlmeScanReqSanity(struct rt_rtmp_adapter *pAd,
-			  void * Msg,
-			  unsigned long MsgLen,
-			  u8 * pBssType,
-			  char Ssid[],
-			  u8 * pSsidLen, u8 * pScanType)
-{
-	struct rt_mlme_scan_req *Info;
-
-	Info = (struct rt_mlme_scan_req *)(Msg);
-	*pBssType = Info->BssType;
-	*pSsidLen = Info->SsidLen;
-	NdisMoveMemory(Ssid, Info->Ssid, *pSsidLen);
-	*pScanType = Info->ScanType;
-
-	if ((*pBssType == BSS_INFRA || *pBssType == BSS_ADHOC
-	     || *pBssType == BSS_ANY)
-	    && (*pScanType == SCAN_ACTIVE || *pScanType == SCAN_PASSIVE)) {
-		return TRUE;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeScanReqSanity fail - wrong BssType or ScanType\n"));
-		return FALSE;
-	}
-}
-
-/* IRQL = DISPATCH_LEVEL */
-u8 ChannelSanity(struct rt_rtmp_adapter *pAd, u8 channel)
-{
-	int i;
-
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		if (channel == pAd->ChannelList[i].Channel)
-			return 1;
-	}
-	return 0;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerDeauthSanity(struct rt_rtmp_adapter *pAd,
-			 void * Msg,
-			 unsigned long MsgLen,
-			 u8 *pAddr2, u16 * pReason)
-{
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) Msg;
-
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-	NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerAuthSanity(struct rt_rtmp_adapter *pAd,
-		       void * Msg,
-		       unsigned long MsgLen,
-		       u8 *pAddr,
-		       u16 * pAlg,
-		       u16 * pSeq,
-		       u16 * pStatus, char * pChlgText)
-{
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) Msg;
-
-	COPY_MAC_ADDR(pAddr, pFrame->Hdr.Addr2);
-	NdisMoveMemory(pAlg, &pFrame->Octet[0], 2);
-	NdisMoveMemory(pSeq, &pFrame->Octet[2], 2);
-	NdisMoveMemory(pStatus, &pFrame->Octet[4], 2);
-
-	if (*pAlg == AUTH_MODE_OPEN) {
-		if (*pSeq == 1 || *pSeq == 2) {
-			return TRUE;
-		} else {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerAuthSanity fail - wrong Seg#\n"));
-			return FALSE;
-		}
-	} else if (*pAlg == AUTH_MODE_KEY) {
-		if (*pSeq == 1 || *pSeq == 4) {
-			return TRUE;
-		} else if (*pSeq == 2 || *pSeq == 3) {
-			NdisMoveMemory(pChlgText, &pFrame->Octet[8],
-				       CIPHER_TEXT_LEN);
-			return TRUE;
-		} else {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerAuthSanity fail - wrong Seg#\n"));
-			return FALSE;
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PeerAuthSanity fail - wrong algorithm\n"));
-		return FALSE;
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
- */
-BOOLEAN MlmeAuthReqSanity(struct rt_rtmp_adapter *pAd,
-			  void * Msg,
-			  unsigned long MsgLen,
-			  u8 *pAddr,
-			  unsigned long * pTimeout, u16 * pAlg)
-{
-	struct rt_mlme_auth_req *pInfo;
-
-	pInfo = (struct rt_mlme_auth_req *)Msg;
-	COPY_MAC_ADDR(pAddr, pInfo->Addr);
-	*pTimeout = pInfo->Timeout;
-	*pAlg = pInfo->Alg;
-
-	if (((*pAlg == AUTH_MODE_KEY) || (*pAlg == AUTH_MODE_OPEN)
-	    ) && ((*pAddr & 0x01) == 0)) {
-		return TRUE;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeAuthReqSanity fail - wrong algorithm\n"));
-		return FALSE;
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN MlmeAssocReqSanity(struct rt_rtmp_adapter *pAd,
-			   void * Msg,
-			   unsigned long MsgLen,
-			   u8 *pApAddr,
-			   u16 * pCapabilityInfo,
-			   unsigned long * pTimeout, u16 * pListenIntv)
-{
-	struct rt_mlme_assoc_req *pInfo;
-
-	pInfo = (struct rt_mlme_assoc_req *)Msg;
-	*pTimeout = pInfo->Timeout;	/* timeout */
-	COPY_MAC_ADDR(pApAddr, pInfo->Addr);	/* AP address */
-	*pCapabilityInfo = pInfo->CapabilityInfo;	/* capability info */
-	*pListenIntv = pInfo->ListenIntv;
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerDisassocSanity(struct rt_rtmp_adapter *pAd,
-			   void * Msg,
-			   unsigned long MsgLen,
-			   u8 *pAddr2, u16 * pReason)
-{
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) Msg;
-
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-	NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
-
-	return TRUE;
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Sanity check NetworkType (11b, 11g or 11a)
-
-	Arguments:
-		pBss - Pointer to BSS table.
-
-	Return Value:
-        Ndis802_11DS .......(11b)
-        Ndis802_11OFDM24....(11g)
-        Ndis802_11OFDM5.....(11a)
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(struct rt_bss_entry *pBss)
-{
-	NDIS_802_11_NETWORK_TYPE NetWorkType;
-	u8 rate, i;
-
-	NetWorkType = Ndis802_11DS;
-
-	if (pBss->Channel <= 14) {
-		/* */
-		/* First check support Rate. */
-		/* */
-		for (i = 0; i < pBss->SupRateLen; i++) {
-			rate = pBss->SupRate[i] & 0x7f;	/* Mask out basic rate set bit */
-			if ((rate == 2) || (rate == 4) || (rate == 11)
-			    || (rate == 22)) {
-				continue;
-			} else {
-				/* */
-				/* Otherwise (even rate > 108) means Ndis802_11OFDM24 */
-				/* */
-				NetWorkType = Ndis802_11OFDM24;
-				break;
-			}
-		}
-
-		/* */
-		/* Second check Extend Rate. */
-		/* */
-		if (NetWorkType != Ndis802_11OFDM24) {
-			for (i = 0; i < pBss->ExtRateLen; i++) {
-				rate = pBss->SupRate[i] & 0x7f;	/* Mask out basic rate set bit */
-				if ((rate == 2) || (rate == 4) || (rate == 11)
-				    || (rate == 22)) {
-					continue;
-				} else {
-					/* */
-					/* Otherwise (even rate > 108) means Ndis802_11OFDM24 */
-					/* */
-					NetWorkType = Ndis802_11OFDM24;
-					break;
-				}
-			}
-		}
-	} else {
-		NetWorkType = Ndis802_11OFDM5;
-	}
-
-	if (pBss->HtCapabilityLen != 0) {
-		if (NetWorkType == Ndis802_11OFDM5)
-			NetWorkType = Ndis802_11OFDM5_N;
-		else
-			NetWorkType = Ndis802_11OFDM24_N;
-	}
-
-	return NetWorkType;
-}
-
-/*
-    ==========================================================================
-    Description:
-        Check the validity of the received EAPoL frame
-    Return:
-        TRUE if all parameters are OK,
-        FALSE otherwise
-    ==========================================================================
- */
-BOOLEAN PeerWpaMessageSanity(struct rt_rtmp_adapter *pAd,
-			     struct rt_eapol_packet * pMsg,
-			     unsigned long MsgLen,
-			     u8 MsgType, struct rt_mac_table_entry *pEntry)
-{
-	u8 mic[LEN_KEY_DESC_MIC], digest[80], KEYDATA[MAX_LEN_OF_RSNIE];
-	BOOLEAN bReplayDiff = FALSE;
-	BOOLEAN bWPA2 = FALSE;
-	struct rt_key_info EapolKeyInfo;
-	u8 GroupKeyIndex = 0;
-
-	NdisZeroMemory(mic, sizeof(mic));
-	NdisZeroMemory(digest, sizeof(digest));
-	NdisZeroMemory(KEYDATA, sizeof(KEYDATA));
-	NdisZeroMemory((u8 *)& EapolKeyInfo, sizeof(EapolKeyInfo));
-
-	NdisMoveMemory((u8 *)& EapolKeyInfo,
-		       (u8 *)& pMsg->KeyDesc.KeyInfo, sizeof(struct rt_key_info));
-
-	*((u16 *) & EapolKeyInfo) = cpu2le16(*((u16 *) & EapolKeyInfo));
-
-	/* Choose WPA2 or not */
-	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
-	    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
-		bWPA2 = TRUE;
-
-	/* 0. Check MsgType */
-	if ((MsgType > EAPOL_GROUP_MSG_2) || (MsgType < EAPOL_PAIR_MSG_1)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("The message type is invalid(%d)! \n", MsgType));
-		return FALSE;
-	}
-	/* 1. Replay counter check */
-	if (MsgType == EAPOL_PAIR_MSG_1 || MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)	/* For supplicant */
-	{
-		/* First validate replay counter, only accept message with larger replay counter. */
-		/* Let equal pass, some AP start with all zero replay counter */
-		u8 ZeroReplay[LEN_KEY_DESC_REPLAY];
-
-		NdisZeroMemory(ZeroReplay, LEN_KEY_DESC_REPLAY);
-		if ((RTMPCompareMemory
-		     (pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
-		      LEN_KEY_DESC_REPLAY) != 1)
-		    &&
-		    (RTMPCompareMemory
-		     (pMsg->KeyDesc.ReplayCounter, ZeroReplay,
-		      LEN_KEY_DESC_REPLAY) != 0)) {
-			bReplayDiff = TRUE;
-		}
-	} else if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)	/* For authenticator */
-	{
-		/* check Replay Counter coresponds to MSG from authenticator, otherwise discard */
-		if (!NdisEqualMemory
-		    (pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
-		     LEN_KEY_DESC_REPLAY)) {
-			bReplayDiff = TRUE;
-		}
-	}
-	/* Replay Counter different condition */
-	if (bReplayDiff) {
-		/* send wireless event - for replay counter different */
-		if (pAd->CommonCfg.bWirelessEvent)
-			RTMPSendWirelessEvent(pAd,
-					      IW_REPLAY_COUNTER_DIFF_EVENT_FLAG,
-					      pEntry->Addr, pEntry->apidx, 0);
-
-		if (MsgType < EAPOL_GROUP_MSG_1) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Replay Counter Different in pairwise msg %d of 4-way handshake!\n",
-				  MsgType));
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Replay Counter Different in group msg %d of 2-way handshake!\n",
-				  (MsgType - EAPOL_PAIR_MSG_4)));
-		}
-
-		hex_dump("Receive replay counter ", pMsg->KeyDesc.ReplayCounter,
-			 LEN_KEY_DESC_REPLAY);
-		hex_dump("Current replay counter ", pEntry->R_Counter,
-			 LEN_KEY_DESC_REPLAY);
-		return FALSE;
-	}
-	/* 2. Verify MIC except Pairwise Msg1 */
-	if (MsgType != EAPOL_PAIR_MSG_1) {
-		u8 rcvd_mic[LEN_KEY_DESC_MIC];
-
-		/* Record the received MIC for check later */
-		NdisMoveMemory(rcvd_mic, pMsg->KeyDesc.KeyMic,
-			       LEN_KEY_DESC_MIC);
-		NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
-
-		if (EapolKeyInfo.KeyDescVer == DESC_TYPE_TKIP)	/* TKIP */
-		{
-			HMAC_MD5(pEntry->PTK, LEN_EAP_MICK, (u8 *)pMsg,
-				 MsgLen, mic, MD5_DIGEST_SIZE);
-		} else if (EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)	/* AES */
-		{
-			HMAC_SHA1(pEntry->PTK, LEN_EAP_MICK, (u8 *)pMsg,
-				  MsgLen, digest, SHA1_DIGEST_SIZE);
-			NdisMoveMemory(mic, digest, LEN_KEY_DESC_MIC);
-		}
-
-		if (!NdisEqualMemory(rcvd_mic, mic, LEN_KEY_DESC_MIC)) {
-			/* send wireless event - for MIC different */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_MIC_DIFF_EVENT_FLAG,
-						      pEntry->Addr,
-						      pEntry->apidx, 0);
-
-			if (MsgType < EAPOL_GROUP_MSG_1) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("MIC Different in pairwise msg %d of 4-way handshake!\n",
-					  MsgType));
-			} else {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("MIC Different in group msg %d of 2-way handshake!\n",
-					  (MsgType - EAPOL_PAIR_MSG_4)));
-			}
-
-			hex_dump("Received MIC", rcvd_mic, LEN_KEY_DESC_MIC);
-			hex_dump("Desired  MIC", mic, LEN_KEY_DESC_MIC);
-
-			return FALSE;
-		}
-	}
-	/* 1. Decrypt the Key Data field if GTK is included. */
-	/* 2. Extract the context of the Key Data field if it exist. */
-	/* The field in pairwise_msg_2_WPA1(WPA2) & pairwise_msg_3_WPA1 is clear. */
-	/* The field in group_msg_1_WPA1(WPA2) & pairwise_msg_3_WPA2 is encrypted. */
-	if (CONV_ARRARY_TO_u16(pMsg->KeyDesc.KeyDataLen) > 0) {
-		/* Decrypt this field */
-		if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
-		    || (MsgType == EAPOL_GROUP_MSG_1)) {
-			if ((EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)) {
-				/* AES */
-				AES_GTK_KEY_UNWRAP(&pEntry->PTK[16], KEYDATA,
-						   CONV_ARRARY_TO_u16(pMsg->
-									 KeyDesc.
-									 KeyDataLen),
-						   pMsg->KeyDesc.KeyData);
-			} else {
-				int i;
-				u8 Key[32];
-				/* Decrypt TKIP GTK */
-				/* Construct 32 bytes RC4 Key */
-				NdisMoveMemory(Key, pMsg->KeyDesc.KeyIv, 16);
-				NdisMoveMemory(&Key[16], &pEntry->PTK[16], 16);
-				ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key,
-					     32);
-				/*discard first 256 bytes */
-				for (i = 0; i < 256; i++)
-					ARCFOUR_BYTE(&pAd->PrivateInfo.
-						     WEPCONTEXT);
-				/* Decrypt GTK. Becareful, there is no ICV to check the result is correct or not */
-				ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT,
-						KEYDATA, pMsg->KeyDesc.KeyData,
-						CONV_ARRARY_TO_u16(pMsg->
-								      KeyDesc.
-								      KeyDataLen));
-			}
-
-			if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))
-				GroupKeyIndex = EapolKeyInfo.KeyIndex;
-
-		} else if ((MsgType == EAPOL_PAIR_MSG_2)
-			   || (MsgType == EAPOL_PAIR_MSG_3 && !bWPA2)) {
-			NdisMoveMemory(KEYDATA, pMsg->KeyDesc.KeyData,
-				       CONV_ARRARY_TO_u16(pMsg->KeyDesc.
-							     KeyDataLen));
-		} else {
-
-			return TRUE;
-		}
-
-		/* Parse Key Data field to */
-		/* 1. verify RSN IE for pairwise_msg_2_WPA1(WPA2) ,pairwise_msg_3_WPA1(WPA2) */
-		/* 2. verify KDE format for pairwise_msg_3_WPA2, group_msg_1_WPA2 */
-		/* 3. update shared key for pairwise_msg_3_WPA2, group_msg_1_WPA1(WPA2) */
-		if (!RTMPParseEapolKeyData(pAd, KEYDATA,
-					   CONV_ARRARY_TO_u16(pMsg->KeyDesc.
-								 KeyDataLen),
-					   GroupKeyIndex, MsgType, bWPA2,
-					   pEntry)) {
-			return FALSE;
-		}
-	}
-
-	return TRUE;
-
-}
diff --git a/drivers/staging/rt2860/common/cmm_sync.c b/drivers/staging/rt2860/common/cmm_sync.c
deleted file mode 100644
index aefe1b7..0000000
--- a/drivers/staging/rt2860/common/cmm_sync.c
+++ /dev/null
@@ -1,718 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	cmm_sync.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John Chang	2004-09-01      modified for rt2561/2661
-*/
-#include "../rt_config.h"
-
-/* 2.4 Ghz channel plan index in the TxPower arrays. */
-#define	BG_BAND_REGION_0_START	0	/* 1,2,3,4,5,6,7,8,9,10,11 */
-#define	BG_BAND_REGION_0_SIZE	11
-#define	BG_BAND_REGION_1_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13 */
-#define	BG_BAND_REGION_1_SIZE	13
-#define	BG_BAND_REGION_2_START	9	/* 10,11 */
-#define	BG_BAND_REGION_2_SIZE	2
-#define	BG_BAND_REGION_3_START	9	/* 10,11,12,13 */
-#define	BG_BAND_REGION_3_SIZE	4
-#define	BG_BAND_REGION_4_START	13	/* 14 */
-#define	BG_BAND_REGION_4_SIZE	1
-#define	BG_BAND_REGION_5_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13,14 */
-#define	BG_BAND_REGION_5_SIZE	14
-#define	BG_BAND_REGION_6_START	2	/* 3,4,5,6,7,8,9 */
-#define	BG_BAND_REGION_6_SIZE	7
-#define	BG_BAND_REGION_7_START	4	/* 5,6,7,8,9,10,11,12,13 */
-#define	BG_BAND_REGION_7_SIZE	9
-#define	BG_BAND_REGION_31_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13,14 */
-#define	BG_BAND_REGION_31_SIZE	14
-
-/* 5 Ghz channel plan index in the TxPower arrays. */
-u8 A_BAND_REGION_0_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165 };
-u8 A_BAND_REGION_1_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
-132, 136, 140 };
-u8 A_BAND_REGION_2_CHANNEL_LIST[] = { 36, 40, 44, 48, 52, 56, 60, 64 };
-u8 A_BAND_REGION_3_CHANNEL_LIST[] = { 52, 56, 60, 64, 149, 153, 157, 161 };
-u8 A_BAND_REGION_4_CHANNEL_LIST[] = { 149, 153, 157, 161, 165 };
-u8 A_BAND_REGION_5_CHANNEL_LIST[] = { 149, 153, 157, 161 };
-u8 A_BAND_REGION_6_CHANNEL_LIST[] = { 36, 40, 44, 48 };
-u8 A_BAND_REGION_7_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
-132, 136, 140, 149, 153, 157, 161, 165, 169, 173 };
-u8 A_BAND_REGION_8_CHANNEL_LIST[] = { 52, 56, 60, 64 };
-u8 A_BAND_REGION_9_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140,
-149, 153, 157, 161, 165 };
-u8 A_BAND_REGION_10_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 149, 153, 157, 161, 165 };
-u8 A_BAND_REGION_11_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153,
-157, 161 };
-u8 A_BAND_REGION_12_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
-132, 136, 140 };
-u8 A_BAND_REGION_13_CHANNEL_LIST[] =
-    { 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
-149, 153, 157, 161 };
-u8 A_BAND_REGION_14_CHANNEL_LIST[] =
-    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149,
-153, 157, 161, 165 };
-u8 A_BAND_REGION_15_CHANNEL_LIST[] = { 149, 153, 157, 161, 165, 169, 173 };
-
-/*BaSizeArray follows the 802.11n definition as MaxRxFactor.  2^(13+factor) bytes. When factor =0, it's about Ba buffer size =8. */
-u8 BaSizeArray[4] = { 8, 16, 32, 64 };
-
-/*
-	==========================================================================
-	Description:
-		Update StaCfg->ChannelList[] according to 1) Country Region 2) RF IC type,
-		and 3) PHY-mode user selected.
-		The outcome is used by driver when doing site survey.
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void BuildChannelList(struct rt_rtmp_adapter *pAd)
-{
-	u8 i, j, index = 0, num = 0;
-	u8 *pChannelList = NULL;
-
-	NdisZeroMemory(pAd->ChannelList,
-		       MAX_NUM_OF_CHANNELS * sizeof(struct rt_channel_tx_power));
-
-	/* if not 11a-only mode, channel list starts from 2.4Ghz band */
-	if ((pAd->CommonCfg.PhyMode != PHY_11A)
-	    && (pAd->CommonCfg.PhyMode != PHY_11AN_MIXED)
-	    && (pAd->CommonCfg.PhyMode != PHY_11N_5G)
-	    ) {
-		switch (pAd->CommonCfg.CountryRegion & 0x7f) {
-		case REGION_0_BG_BAND:	/* 1 -11 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_0_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_0_SIZE);
-			index += BG_BAND_REGION_0_SIZE;
-			break;
-		case REGION_1_BG_BAND:	/* 1 - 13 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_1_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_1_SIZE);
-			index += BG_BAND_REGION_1_SIZE;
-			break;
-		case REGION_2_BG_BAND:	/* 10 - 11 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_2_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_2_SIZE);
-			index += BG_BAND_REGION_2_SIZE;
-			break;
-		case REGION_3_BG_BAND:	/* 10 - 13 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_3_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_3_SIZE);
-			index += BG_BAND_REGION_3_SIZE;
-			break;
-		case REGION_4_BG_BAND:	/* 14 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_4_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_4_SIZE);
-			index += BG_BAND_REGION_4_SIZE;
-			break;
-		case REGION_5_BG_BAND:	/* 1 - 14 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_5_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_5_SIZE);
-			index += BG_BAND_REGION_5_SIZE;
-			break;
-		case REGION_6_BG_BAND:	/* 3 - 9 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_6_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_6_SIZE);
-			index += BG_BAND_REGION_6_SIZE;
-			break;
-		case REGION_7_BG_BAND:	/* 5 - 13 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_7_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_7_SIZE);
-			index += BG_BAND_REGION_7_SIZE;
-			break;
-		case REGION_31_BG_BAND:	/* 1 - 14 */
-			NdisMoveMemory(&pAd->ChannelList[index],
-				       &pAd->TxPower[BG_BAND_REGION_31_START],
-				       sizeof(struct rt_channel_tx_power) *
-				       BG_BAND_REGION_31_SIZE);
-			index += BG_BAND_REGION_31_SIZE;
-			break;
-		default:	/* Error. should never happen */
-			break;
-		}
-		for (i = 0; i < index; i++)
-			pAd->ChannelList[i].MaxTxPwr = 20;
-	}
-
-	if ((pAd->CommonCfg.PhyMode == PHY_11A)
-	    || (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-	    || (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)
-	    || (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED)
-	    || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
-	    || (pAd->CommonCfg.PhyMode == PHY_11N_5G)
-	    ) {
-		switch (pAd->CommonCfg.CountryRegionForABand & 0x7f) {
-		case REGION_0_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_0_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_0_CHANNEL_LIST;
-			break;
-		case REGION_1_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_1_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_1_CHANNEL_LIST;
-			break;
-		case REGION_2_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_2_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_2_CHANNEL_LIST;
-			break;
-		case REGION_3_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_3_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_3_CHANNEL_LIST;
-			break;
-		case REGION_4_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_4_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_4_CHANNEL_LIST;
-			break;
-		case REGION_5_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_5_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_5_CHANNEL_LIST;
-			break;
-		case REGION_6_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_6_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_6_CHANNEL_LIST;
-			break;
-		case REGION_7_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_7_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_7_CHANNEL_LIST;
-			break;
-		case REGION_8_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_8_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_8_CHANNEL_LIST;
-			break;
-		case REGION_9_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_9_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_9_CHANNEL_LIST;
-			break;
-
-		case REGION_10_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_10_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_10_CHANNEL_LIST;
-			break;
-
-		case REGION_11_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_11_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_11_CHANNEL_LIST;
-			break;
-		case REGION_12_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_12_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_12_CHANNEL_LIST;
-			break;
-		case REGION_13_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_13_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_13_CHANNEL_LIST;
-			break;
-		case REGION_14_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_14_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_14_CHANNEL_LIST;
-			break;
-		case REGION_15_A_BAND:
-			num =
-			    sizeof(A_BAND_REGION_15_CHANNEL_LIST) /
-			    sizeof(u8);
-			pChannelList = A_BAND_REGION_15_CHANNEL_LIST;
-			break;
-		default:	/* Error. should never happen */
-			DBGPRINT(RT_DEBUG_WARN,
-				 ("countryregion=%d not support",
-				  pAd->CommonCfg.CountryRegionForABand));
-			break;
-		}
-
-		if (num != 0) {
-			u8 RadarCh[15] =
-			    { 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124,
-		    128, 132, 136, 140 };
-			for (i = 0; i < num; i++) {
-				for (j = 0; j < MAX_NUM_OF_CHANNELS; j++) {
-					if (pChannelList[i] ==
-					    pAd->TxPower[j].Channel)
-						NdisMoveMemory(&pAd->
-							       ChannelList[index
-									   + i],
-							       &pAd->TxPower[j],
-							       sizeof
-							       (struct rt_channel_tx_power));
-				}
-				for (j = 0; j < 15; j++) {
-					if (pChannelList[i] == RadarCh[j])
-						pAd->ChannelList[index +
-								 i].DfsReq =
-						    TRUE;
-				}
-				pAd->ChannelList[index + i].MaxTxPwr = 20;
-			}
-			index += num;
-		}
-	}
-
-	pAd->ChannelListNum = index;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("country code=%d/%d, RFIC=%d, PHY mode=%d, support %d channels\n",
-		  pAd->CommonCfg.CountryRegion,
-		  pAd->CommonCfg.CountryRegionForABand, pAd->RfIcType,
-		  pAd->CommonCfg.PhyMode, pAd->ChannelListNum));
-#ifdef DBG
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("BuildChannel # %d :: Pwr0 = %d, Pwr1 =%d, \n ",
-			      pAd->ChannelList[i].Channel,
-			      pAd->ChannelList[i].Power,
-			      pAd->ChannelList[i].Power2));
-	}
-#endif
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine return the first channel number according to the country
-		code selection and RF IC selection (signal band or dual band). It is called
-		whenever driver need to start a site survey of all supported channels.
-	Return:
-		ch - the first channel number of current country code setting
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
- */
-u8 FirstChannel(struct rt_rtmp_adapter *pAd)
-{
-	return pAd->ChannelList[0].Channel;
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine returns the next channel number. This routine is called
-		during driver need to start a site survey of all supported channels.
-	Return:
-		next_channel - the next channel number valid in current country code setting.
-	Note:
-		return 0 if no more next channel
-	==========================================================================
- */
-u8 NextChannel(struct rt_rtmp_adapter *pAd, u8 channel)
-{
-	int i;
-	u8 next_channel = 0;
-
-	for (i = 0; i < (pAd->ChannelListNum - 1); i++)
-		if (channel == pAd->ChannelList[i].Channel) {
-			next_channel = pAd->ChannelList[i + 1].Channel;
-			break;
-		}
-	return next_channel;
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine is for Cisco Compatible Extensions 2.X
-		Spec31. AP Control of Client Transmit Power
-	Return:
-		None
-	Note:
-	   Required by Aironet dBm(mW)
-		   0dBm(1mW),   1dBm(5mW), 13dBm(20mW), 15dBm(30mW),
-		  17dBm(50mw), 20dBm(100mW)
-
-	   We supported
-		   3dBm(Lowest), 6dBm(10%), 9dBm(25%), 12dBm(50%),
-		  14dBm(75%),   15dBm(100%)
-
-		The client station's actual transmit power shall be within +/- 5dB of
-		the minimum value or next lower value.
-	==========================================================================
- */
-void ChangeToCellPowerLimit(struct rt_rtmp_adapter *pAd,
-			    u8 AironetCellPowerLimit)
-{
-	/*valud 0xFF means that hasn't found power limit information */
-	/*from the AP's Beacon/Probe response. */
-	if (AironetCellPowerLimit == 0xFF)
-		return;
-
-	if (AironetCellPowerLimit < 6)	/*Used Lowest Power Percentage. */
-		pAd->CommonCfg.TxPowerPercentage = 6;
-	else if (AironetCellPowerLimit < 9)
-		pAd->CommonCfg.TxPowerPercentage = 10;
-	else if (AironetCellPowerLimit < 12)
-		pAd->CommonCfg.TxPowerPercentage = 25;
-	else if (AironetCellPowerLimit < 14)
-		pAd->CommonCfg.TxPowerPercentage = 50;
-	else if (AironetCellPowerLimit < 15)
-		pAd->CommonCfg.TxPowerPercentage = 75;
-	else
-		pAd->CommonCfg.TxPowerPercentage = 100;	/*else used maximum */
-
-	if (pAd->CommonCfg.TxPowerPercentage > pAd->CommonCfg.TxPowerDefault)
-		pAd->CommonCfg.TxPowerPercentage =
-		    pAd->CommonCfg.TxPowerDefault;
-
-}
-
-char ConvertToRssi(struct rt_rtmp_adapter *pAd, char Rssi, u8 RssiNumber)
-{
-	u8 RssiOffset, LNAGain;
-
-	/* Rssi equals to zero should be an invalid value */
-	if (Rssi == 0)
-		return -99;
-
-	LNAGain = GET_LNA_GAIN(pAd);
-	if (pAd->LatchRfRegs.Channel > 14) {
-		if (RssiNumber == 0)
-			RssiOffset = pAd->ARssiOffset0;
-		else if (RssiNumber == 1)
-			RssiOffset = pAd->ARssiOffset1;
-		else
-			RssiOffset = pAd->ARssiOffset2;
-	} else {
-		if (RssiNumber == 0)
-			RssiOffset = pAd->BGRssiOffset0;
-		else if (RssiNumber == 1)
-			RssiOffset = pAd->BGRssiOffset1;
-		else
-			RssiOffset = pAd->BGRssiOffset2;
-	}
-
-	return (-12 - RssiOffset - LNAGain - Rssi);
-}
-
-/*
-	==========================================================================
-	Description:
-		Scan next channel
-	==========================================================================
- */
-void ScanNextChannel(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_header_802_11 Hdr80211;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	u8 SsidLen = 0, ScanType = pAd->MlmeAux.ScanType, BBPValue = 0;
-	u16 Status;
-	struct rt_header_802_11 * pHdr80211;
-	u32 ScanTimeIn5gChannel = SHORT_CHANNEL_TIME;
-
-	{
-		if (MONITOR_ON(pAd))
-			return;
-	}
-
-	if (pAd->MlmeAux.Channel == 0) {
-		if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
-		    && (INFRA_ON(pAd)
-			|| (pAd->OpMode == OPMODE_AP))
-		    ) {
-			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel,
-					  FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-			BBPValue &= (~0x18);
-			BBPValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",
-				  pAd->CommonCfg.CentralChannel,
-				  pAd->ScanTab.BssNr));
-		} else {
-			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("SYNC - End of SCAN, restore to channel %d, Total BSS[%02d]\n",
-				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
-		}
-
-		{
-			/* */
-			/* To prevent data lost. */
-			/* Send an NULL data with turned PSM bit on to current associated AP before SCAN progress. */
-			/* Now, we need to send an NULL data with turned PSM bit off to AP, when scan progress done */
-			/* */
-			if (OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-			    && (INFRA_ON(pAd))) {
-				NStatus =
-				    MlmeAllocateMemory(pAd,
-						       (void *)& pOutBuffer);
-				if (NStatus == NDIS_STATUS_SUCCESS) {
-					pHdr80211 = (struct rt_header_802_11 *) pOutBuffer;
-					MgtMacHeaderInit(pAd, pHdr80211,
-							 SUBTYPE_NULL_FUNC, 1,
-							 pAd->CommonCfg.Bssid,
-							 pAd->CommonCfg.Bssid);
-					pHdr80211->Duration = 0;
-					pHdr80211->FC.Type = BTYPE_DATA;
-					pHdr80211->FC.PwrMgmt =
-					    (pAd->StaCfg.Psm == PWR_SAVE);
-
-					/* Send using priority queue */
-					MiniportMMRequest(pAd, 0, pOutBuffer,
-							  sizeof
-							  (struct rt_header_802_11));
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("MlmeScanReqAction -- Send PSM Data frame\n"));
-					MlmeFreeMemory(pAd, pOutBuffer);
-					RTMPusecDelay(5000);
-				}
-			}
-
-			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-			Status = MLME_SUCCESS;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF,
-				    2, &Status);
-		}
-
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	}
-#ifdef RTMP_MAC_USB
-	else if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
-		 && (pAd->OpMode == OPMODE_STA)) {
-		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
-	}
-#endif /* RTMP_MAC_USB // */
-	else {
-		{
-			/* BBP and RF are not accessible in PS mode, we has to wake them up first */
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-				AsicForceWakeup(pAd, TRUE);
-
-			/* leave PSM during scanning. otherwise we may lost ProbeRsp & BEACON */
-			if (pAd->StaCfg.Psm == PWR_SAVE)
-				RTMP_SET_PSM_BIT(pAd, PWR_ACTIVE);
-		}
-
-		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, TRUE);
-		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
-
-		{
-			if (pAd->MlmeAux.Channel > 14) {
-				if ((pAd->CommonCfg.bIEEE80211H == 1)
-				    && RadarChannelCheck(pAd,
-							 pAd->MlmeAux.
-							 Channel)) {
-					ScanType = SCAN_PASSIVE;
-					ScanTimeIn5gChannel = MIN_CHANNEL_TIME;
-				}
-			}
-		}
-
-		/*Global country domain(ch1-11:active scan, ch12-14 passive scan) */
-		if ((pAd->MlmeAux.Channel <= 14) && (pAd->MlmeAux.Channel >= 12)
-		    && ((pAd->CommonCfg.CountryRegion & 0x7f) ==
-			REGION_31_BG_BAND)) {
-			ScanType = SCAN_PASSIVE;
-		}
-		/* We need to shorten active scan time in order for WZC connect issue */
-		/* Chnage the channel scan time for CISCO stuff based on its IAPP announcement */
-		if (ScanType == FAST_SCAN_ACTIVE)
-			RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
-				     FAST_ACTIVE_SCAN_TIME);
-		else		/* must be SCAN_PASSIVE or SCAN_ACTIVE */
-		{
-			if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-			    || (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)
-			    || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
-			    ) {
-				if (pAd->MlmeAux.Channel > 14)
-					RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
-						     ScanTimeIn5gChannel);
-				else
-					RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
-						     MIN_CHANNEL_TIME);
-			} else
-				RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
-					     MAX_CHANNEL_TIME);
-		}
-
-		if ((ScanType == SCAN_ACTIVE)
-		    || (ScanType == FAST_SCAN_ACTIVE)
-		    ) {
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-			if (NStatus != NDIS_STATUS_SUCCESS) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("SYNC - ScanNextChannel() allocate memory fail\n"));
-
-				{
-					pAd->Mlme.SyncMachine.CurrState =
-					    SYNC_IDLE;
-					Status = MLME_FAIL_NO_RESOURCE;
-					MlmeEnqueue(pAd,
-						    MLME_CNTL_STATE_MACHINE,
-						    MT2_SCAN_CONF, 2, &Status);
-				}
-
-				return;
-			}
-			/* There is no need to send broadcast probe request if active scan is in effect. */
-			if ((ScanType == SCAN_ACTIVE)
-			    || (ScanType == FAST_SCAN_ACTIVE)
-			    )
-				SsidLen = pAd->MlmeAux.SsidLen;
-			else
-				SsidLen = 0;
-
-			MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0,
-					 BROADCAST_ADDR, BROADCAST_ADDR);
-			MakeOutgoingFrame(pOutBuffer, &FrameLen,
-					  sizeof(struct rt_header_802_11), &Hdr80211, 1,
-					  &SsidIe, 1, &SsidLen, SsidLen,
-					  pAd->MlmeAux.Ssid, 1, &SupRateIe, 1,
-					  &pAd->CommonCfg.SupRateLen,
-					  pAd->CommonCfg.SupRateLen,
-					  pAd->CommonCfg.SupRate, END_OF_ARGS);
-
-			if (pAd->CommonCfg.ExtRateLen) {
-				unsigned long Tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &Tmp,
-						  1, &ExtRateIe,
-						  1, &pAd->CommonCfg.ExtRateLen,
-						  pAd->CommonCfg.ExtRateLen,
-						  pAd->CommonCfg.ExtRate,
-						  END_OF_ARGS);
-				FrameLen += Tmp;
-			}
-
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
-				unsigned long Tmp;
-				u8 HtLen;
-				u8 BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
-
-				if (pAd->bBroadComHT == TRUE) {
-					HtLen =
-					    pAd->MlmeAux.HtCapabilityLen + 4;
-
-					MakeOutgoingFrame(pOutBuffer + FrameLen,
-							  &Tmp, 1, &WpaIe, 1,
-							  &HtLen, 4,
-							  &BROADCOM[0],
-							  pAd->MlmeAux.
-							  HtCapabilityLen,
-							  &pAd->MlmeAux.
-							  HtCapability,
-							  END_OF_ARGS);
-				} else {
-					HtLen = pAd->MlmeAux.HtCapabilityLen;
-
-					MakeOutgoingFrame(pOutBuffer + FrameLen,
-							  &Tmp, 1, &HtCapIe, 1,
-							  &HtLen, HtLen,
-							  &pAd->CommonCfg.
-							  HtCapability,
-							  END_OF_ARGS);
-				}
-				FrameLen += Tmp;
-			}
-
-			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-			MlmeFreeMemory(pAd, pOutBuffer);
-		}
-		/* For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe response */
-
-		pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
-	}
-}
-
-void MgtProbReqMacHeaderInit(struct rt_rtmp_adapter *pAd,
-			     struct rt_header_802_11 * pHdr80211,
-			     u8 SubType,
-			     u8 ToDs, u8 *pDA, u8 *pBssid)
-{
-	NdisZeroMemory(pHdr80211, sizeof(struct rt_header_802_11));
-
-	pHdr80211->FC.Type = BTYPE_MGMT;
-	pHdr80211->FC.SubType = SubType;
-	if (SubType == SUBTYPE_ACK)
-		pHdr80211->FC.Type = BTYPE_CNTL;
-	pHdr80211->FC.ToDs = ToDs;
-	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
-	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
-	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
-}
diff --git a/drivers/staging/rt2860/common/cmm_tkip.c b/drivers/staging/rt2860/common/cmm_tkip.c
deleted file mode 100644
index 4881ef9..0000000
--- a/drivers/staging/rt2860/common/cmm_tkip.c
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	cmm_tkip.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Paul Wu		02-25-02		Initial
-*/
-
-#include	"../rt_config.h"
-
-/* Rotation functions on 32 bit values */
-#define ROL32( A, n ) \
-	( ((A) << (n)) | ( ((A)>>(32-(n))) & ( (1UL << (n)) - 1 ) ) )
-#define ROR32( A, n ) ROL32( (A), 32-(n) )
-
-u32 Tkip_Sbox_Lower[256] = {
-	0xA5, 0x84, 0x99, 0x8D, 0x0D, 0xBD, 0xB1, 0x54,
-	0x50, 0x03, 0xA9, 0x7D, 0x19, 0x62, 0xE6, 0x9A,
-	0x45, 0x9D, 0x40, 0x87, 0x15, 0xEB, 0xC9, 0x0B,
-	0xEC, 0x67, 0xFD, 0xEA, 0xBF, 0xF7, 0x96, 0x5B,
-	0xC2, 0x1C, 0xAE, 0x6A, 0x5A, 0x41, 0x02, 0x4F,
-	0x5C, 0xF4, 0x34, 0x08, 0x93, 0x73, 0x53, 0x3F,
-	0x0C, 0x52, 0x65, 0x5E, 0x28, 0xA1, 0x0F, 0xB5,
-	0x09, 0x36, 0x9B, 0x3D, 0x26, 0x69, 0xCD, 0x9F,
-	0x1B, 0x9E, 0x74, 0x2E, 0x2D, 0xB2, 0xEE, 0xFB,
-	0xF6, 0x4D, 0x61, 0xCE, 0x7B, 0x3E, 0x71, 0x97,
-	0xF5, 0x68, 0x00, 0x2C, 0x60, 0x1F, 0xC8, 0xED,
-	0xBE, 0x46, 0xD9, 0x4B, 0xDE, 0xD4, 0xE8, 0x4A,
-	0x6B, 0x2A, 0xE5, 0x16, 0xC5, 0xD7, 0x55, 0x94,
-	0xCF, 0x10, 0x06, 0x81, 0xF0, 0x44, 0xBA, 0xE3,
-	0xF3, 0xFE, 0xC0, 0x8A, 0xAD, 0xBC, 0x48, 0x04,
-	0xDF, 0xC1, 0x75, 0x63, 0x30, 0x1A, 0x0E, 0x6D,
-	0x4C, 0x14, 0x35, 0x2F, 0xE1, 0xA2, 0xCC, 0x39,
-	0x57, 0xF2, 0x82, 0x47, 0xAC, 0xE7, 0x2B, 0x95,
-	0xA0, 0x98, 0xD1, 0x7F, 0x66, 0x7E, 0xAB, 0x83,
-	0xCA, 0x29, 0xD3, 0x3C, 0x79, 0xE2, 0x1D, 0x76,
-	0x3B, 0x56, 0x4E, 0x1E, 0xDB, 0x0A, 0x6C, 0xE4,
-	0x5D, 0x6E, 0xEF, 0xA6, 0xA8, 0xA4, 0x37, 0x8B,
-	0x32, 0x43, 0x59, 0xB7, 0x8C, 0x64, 0xD2, 0xE0,
-	0xB4, 0xFA, 0x07, 0x25, 0xAF, 0x8E, 0xE9, 0x18,
-	0xD5, 0x88, 0x6F, 0x72, 0x24, 0xF1, 0xC7, 0x51,
-	0x23, 0x7C, 0x9C, 0x21, 0xDD, 0xDC, 0x86, 0x85,
-	0x90, 0x42, 0xC4, 0xAA, 0xD8, 0x05, 0x01, 0x12,
-	0xA3, 0x5F, 0xF9, 0xD0, 0x91, 0x58, 0x27, 0xB9,
-	0x38, 0x13, 0xB3, 0x33, 0xBB, 0x70, 0x89, 0xA7,
-	0xB6, 0x22, 0x92, 0x20, 0x49, 0xFF, 0x78, 0x7A,
-	0x8F, 0xF8, 0x80, 0x17, 0xDA, 0x31, 0xC6, 0xB8,
-	0xC3, 0xB0, 0x77, 0x11, 0xCB, 0xFC, 0xD6, 0x3A
-};
-
-u32 Tkip_Sbox_Upper[256] = {
-	0xC6, 0xF8, 0xEE, 0xF6, 0xFF, 0xD6, 0xDE, 0x91,
-	0x60, 0x02, 0xCE, 0x56, 0xE7, 0xB5, 0x4D, 0xEC,
-	0x8F, 0x1F, 0x89, 0xFA, 0xEF, 0xB2, 0x8E, 0xFB,
-	0x41, 0xB3, 0x5F, 0x45, 0x23, 0x53, 0xE4, 0x9B,
-	0x75, 0xE1, 0x3D, 0x4C, 0x6C, 0x7E, 0xF5, 0x83,
-	0x68, 0x51, 0xD1, 0xF9, 0xE2, 0xAB, 0x62, 0x2A,
-	0x08, 0x95, 0x46, 0x9D, 0x30, 0x37, 0x0A, 0x2F,
-	0x0E, 0x24, 0x1B, 0xDF, 0xCD, 0x4E, 0x7F, 0xEA,
-	0x12, 0x1D, 0x58, 0x34, 0x36, 0xDC, 0xB4, 0x5B,
-	0xA4, 0x76, 0xB7, 0x7D, 0x52, 0xDD, 0x5E, 0x13,
-	0xA6, 0xB9, 0x00, 0xC1, 0x40, 0xE3, 0x79, 0xB6,
-	0xD4, 0x8D, 0x67, 0x72, 0x94, 0x98, 0xB0, 0x85,
-	0xBB, 0xC5, 0x4F, 0xED, 0x86, 0x9A, 0x66, 0x11,
-	0x8A, 0xE9, 0x04, 0xFE, 0xA0, 0x78, 0x25, 0x4B,
-	0xA2, 0x5D, 0x80, 0x05, 0x3F, 0x21, 0x70, 0xF1,
-	0x63, 0x77, 0xAF, 0x42, 0x20, 0xE5, 0xFD, 0xBF,
-	0x81, 0x18, 0x26, 0xC3, 0xBE, 0x35, 0x88, 0x2E,
-	0x93, 0x55, 0xFC, 0x7A, 0xC8, 0xBA, 0x32, 0xE6,
-	0xC0, 0x19, 0x9E, 0xA3, 0x44, 0x54, 0x3B, 0x0B,
-	0x8C, 0xC7, 0x6B, 0x28, 0xA7, 0xBC, 0x16, 0xAD,
-	0xDB, 0x64, 0x74, 0x14, 0x92, 0x0C, 0x48, 0xB8,
-	0x9F, 0xBD, 0x43, 0xC4, 0x39, 0x31, 0xD3, 0xF2,
-	0xD5, 0x8B, 0x6E, 0xDA, 0x01, 0xB1, 0x9C, 0x49,
-	0xD8, 0xAC, 0xF3, 0xCF, 0xCA, 0xF4, 0x47, 0x10,
-	0x6F, 0xF0, 0x4A, 0x5C, 0x38, 0x57, 0x73, 0x97,
-	0xCB, 0xA1, 0xE8, 0x3E, 0x96, 0x61, 0x0D, 0x0F,
-	0xE0, 0x7C, 0x71, 0xCC, 0x90, 0x06, 0xF7, 0x1C,
-	0xC2, 0x6A, 0xAE, 0x69, 0x17, 0x99, 0x3A, 0x27,
-	0xD9, 0xEB, 0x2B, 0x22, 0xD2, 0xA9, 0x07, 0x33,
-	0x2D, 0x3C, 0x15, 0xC9, 0x87, 0xAA, 0x50, 0xA5,
-	0x03, 0x59, 0x09, 0x1A, 0x65, 0xD7, 0x84, 0xD0,
-	0x82, 0x29, 0x5A, 0x1E, 0x7B, 0xA8, 0x6D, 0x2C
-};
-
-/* */
-/* Expanded IV for TKIP function. */
-/* */
-struct PACKED rt_tkip_iv {
-	union PACKED {
-		struct PACKED {
-			u8 rc0;
-			u8 rc1;
-			u8 rc2;
-
-			union PACKED {
-				struct PACKED {
-					u8 Rsvd:5;
-					u8 ExtIV:1;
-					u8 KeyID:2;
-				} field;
-				u8 Byte;
-			} CONTROL;
-		} field;
-
-		unsigned long word;
-	} IV16;
-
-	unsigned long IV32;
-};
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Convert from u8[] to unsigned long in a portable way
-
-	Arguments:
-      pMICKey		pointer to MIC Key
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-unsigned long RTMPTkipGetUInt32(u8 *pMICKey)
-{
-	unsigned long res = 0;
-	int i;
-
-	for (i = 0; i < 4; i++) {
-		res |= (*pMICKey++) << (8 * i);
-	}
-
-	return res;
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Convert from unsigned long to u8[] in a portable way
-
-	Arguments:
-      pDst			pointer to destination for convert unsigned long to u8[]
-      val			the value for convert
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPTkipPutUInt32(IN u8 *pDst, unsigned long val)
-{
-	int i;
-
-	for (i = 0; i < 4; i++) {
-		*pDst++ = (u8)(val & 0xff);
-		val >>= 8;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Set the MIC Key.
-
-	Arguments:
-      pAd		Pointer to our adapter
-      pMICKey		pointer to MIC Key
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPTkipSetMICKey(struct rt_tkip_key_info *pTkip, u8 *pMICKey)
-{
-	/* Set the key */
-	pTkip->K0 = RTMPTkipGetUInt32(pMICKey);
-	pTkip->K1 = RTMPTkipGetUInt32(pMICKey + 4);
-	/* and reset the message */
-	pTkip->L = pTkip->K0;
-	pTkip->R = pTkip->K1;
-	pTkip->nBytesInM = 0;
-	pTkip->M = 0;
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Calculate the MIC Value.
-
-	Arguments:
-      pAd		Pointer to our adapter
-      uChar			Append this uChar
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPTkipAppendByte(struct rt_tkip_key_info *pTkip, u8 uChar)
-{
-	/* Append the byte to our word-sized buffer */
-	pTkip->M |= (uChar << (8 * pTkip->nBytesInM));
-	pTkip->nBytesInM++;
-	/* Process the word if it is full. */
-	if (pTkip->nBytesInM >= 4) {
-		pTkip->L ^= pTkip->M;
-		pTkip->R ^= ROL32(pTkip->L, 17);
-		pTkip->L += pTkip->R;
-		pTkip->R ^=
-		    ((pTkip->L & 0xff00ff00) >> 8) | ((pTkip->
-						       L & 0x00ff00ff) << 8);
-		pTkip->L += pTkip->R;
-		pTkip->R ^= ROL32(pTkip->L, 3);
-		pTkip->L += pTkip->R;
-		pTkip->R ^= ROR32(pTkip->L, 2);
-		pTkip->L += pTkip->R;
-		/* Clear the buffer */
-		pTkip->M = 0;
-		pTkip->nBytesInM = 0;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Calculate the MIC Value.
-
-	Arguments:
-      pAd		Pointer to our adapter
-      pSrc			Pointer to source data for Calculate MIC Value
-      Len			Indicate the length of the source data
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPTkipAppend(struct rt_tkip_key_info *pTkip, u8 *pSrc, u32 nBytes)
-{
-	/* This is simple */
-	while (nBytes > 0) {
-		RTMPTkipAppendByte(pTkip, *pSrc++);
-		nBytes--;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Get the MIC Value.
-
-	Arguments:
-      pAd		Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		the MIC Value is store in pAd->PrivateInfo.MIC
-	========================================================================
-*/
-void RTMPTkipGetMIC(struct rt_tkip_key_info *pTkip)
-{
-	/* Append the minimum padding */
-	RTMPTkipAppendByte(pTkip, 0x5a);
-	RTMPTkipAppendByte(pTkip, 0);
-	RTMPTkipAppendByte(pTkip, 0);
-	RTMPTkipAppendByte(pTkip, 0);
-	RTMPTkipAppendByte(pTkip, 0);
-	/* and then zeroes until the length is a multiple of 4 */
-	while (pTkip->nBytesInM != 0) {
-		RTMPTkipAppendByte(pTkip, 0);
-	}
-	/* The appendByte function has already computed the result. */
-	RTMPTkipPutUInt32(pTkip->MIC, pTkip->L);
-	RTMPTkipPutUInt32(pTkip->MIC + 4, pTkip->R);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Init Tkip function.
-
-	Arguments:
-      pAd		Pointer to our adapter
-		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
-		KeyId		TK Key ID
-		pTA			Pointer to transmitter address
-		pMICKey		pointer to MIC Key
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPInitTkipEngine(struct rt_rtmp_adapter *pAd,
-			u8 *pKey,
-			u8 KeyId,
-			u8 *pTA,
-			u8 *pMICKey,
-			u8 *pTSC, unsigned long *pIV16, unsigned long *pIV32)
-{
-	struct rt_tkip_iv tkipIv;
-
-	/* Prepare 8 bytes TKIP encapsulation for MPDU */
-	NdisZeroMemory(&tkipIv, sizeof(struct rt_tkip_iv));
-	tkipIv.IV16.field.rc0 = *(pTSC + 1);
-	tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;
-	tkipIv.IV16.field.rc2 = *pTSC;
-	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;	/* 0: non-extended IV, 1: an extended IV */
-	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
-/*      tkipIv.IV32 = *(unsigned long *)(pTSC + 2); */
-	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);	/* Copy IV */
-
-	*pIV16 = tkipIv.IV16.word;
-	*pIV32 = tkipIv.IV32;
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Init MIC Value calculation function which include set MIC key &
-		calculate first 16 bytes (DA + SA + priority +  0)
-
-	Arguments:
-      pAd		Pointer to our adapter
-		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
-		pDA			Pointer to DA address
-		pSA			Pointer to SA address
-		pMICKey		pointer to MIC Key
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void RTMPInitMICEngine(struct rt_rtmp_adapter *pAd,
-		       u8 *pKey,
-		       u8 *pDA,
-		       u8 *pSA, u8 UserPriority, u8 *pMICKey)
-{
-	unsigned long Priority = UserPriority;
-
-	/* Init MIC value calculation */
-	RTMPTkipSetMICKey(&pAd->PrivateInfo.Tx, pMICKey);
-	/* DA */
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pDA, MAC_ADDR_LEN);
-	/* SA */
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSA, MAC_ADDR_LEN);
-	/* Priority + 3 bytes of 0 */
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, (u8 *)& Priority, 4);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Compare MIC value of received MSDU
-
-	Arguments:
-		pAd	Pointer to our adapter
-		pSrc        Pointer to the received Plain text data
-		pDA			Pointer to DA address
-		pSA			Pointer to SA address
-		pMICKey		pointer to MIC Key
-		Len         the length of the received plain text data exclude MIC value
-
-	Return Value:
-		TRUE        MIC value matched
-		FALSE       MIC value mismatched
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-BOOLEAN RTMPTkipCompareMICValue(struct rt_rtmp_adapter *pAd,
-				u8 *pSrc,
-				u8 *pDA,
-				u8 *pSA,
-				u8 *pMICKey,
-				u8 UserPriority, u32 Len)
-{
-	u8 OldMic[8];
-	unsigned long Priority = UserPriority;
-
-	/* Init MIC value calculation */
-	RTMPTkipSetMICKey(&pAd->PrivateInfo.Rx, pMICKey);
-	/* DA */
-	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pDA, MAC_ADDR_LEN);
-	/* SA */
-	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
-	/* Priority + 3 bytes of 0 */
-	RTMPTkipAppend(&pAd->PrivateInfo.Rx, (u8 *)& Priority, 4);
-
-	/* Calculate MIC value from plain text data */
-	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSrc, Len);
-
-	/* Get MIC valude from received frame */
-	NdisMoveMemory(OldMic, pSrc + Len, 8);
-
-	/* Get MIC value from decrypted plain data */
-	RTMPTkipGetMIC(&pAd->PrivateInfo.Rx);
-
-	/* Move MIC value from MSDU, this steps should move to data path. */
-	/* Since the MIC value might cross MPDUs. */
-	if (!NdisEqualMemory(pAd->PrivateInfo.Rx.MIC, OldMic, 8)) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTMPTkipCompareMICValue(): TKIP MIC Error !\n"));	/*MIC error. */
-
-		return (FALSE);
-	}
-	return (TRUE);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Copy frame from waiting queue into relative ring buffer and set
-	appropriate ASIC register to kick hardware transmit function
-
-	Arguments:
-		pAd		Pointer	to our adapter
-		void *	Pointer to Ndis Packet for MIC calculation
-		pEncap			Pointer to LLC encap data
-		LenEncap		Total encap length, might be 0 which indicates no encap
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPCalculateMICValue(struct rt_rtmp_adapter *pAd,
-			   void *pPacket,
-			   u8 *pEncap,
-			   struct rt_cipher_key *pKey, u8 apidx)
-{
-	struct rt_packet_info PacketInfo;
-	u8 *pSrcBufVA;
-	u32 SrcBufLen;
-	u8 *pSrc;
-	u8 UserPriority;
-	u8 vlan_offset = 0;
-
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
-
-	UserPriority = RTMP_GET_PACKET_UP(pPacket);
-	pSrc = pSrcBufVA;
-
-	/* determine if this is a vlan packet */
-	if (((*(pSrc + 12) << 8) + *(pSrc + 13)) == 0x8100)
-		vlan_offset = 4;
-
-	{
-		RTMPInitMICEngine(pAd,
-				  pKey->Key,
-				  pSrc, pSrc + 6, UserPriority, pKey->TxMic);
-	}
-
-	if (pEncap != NULL) {
-		/* LLC encapsulation */
-		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pEncap, 6);
-		/* Protocol Type */
-		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc + 12 + vlan_offset,
-			       2);
-	}
-	SrcBufLen -= (14 + vlan_offset);
-	pSrc += (14 + vlan_offset);
-	do {
-		if (SrcBufLen > 0) {
-			RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc, SrcBufLen);
-		}
-
-		break;		/* No need handle next packet */
-
-	} while (TRUE);		/* End of copying payload */
-
-	/* Compute the final MIC Value */
-	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
-}
-
-/************************************************************/
-/* tkip_sbox()																*/
-/* Returns a 16 bit value from a 64K entry table. The Table */
-/* is synthesized from two 256 entry byte wide tables.		*/
-/************************************************************/
-
-u32 tkip_sbox(u32 index)
-{
-	u32 index_low;
-	u32 index_high;
-	u32 left, right;
-
-	index_low = (index % 256);
-	index_high = ((index >> 8) % 256);
-
-	left = Tkip_Sbox_Lower[index_low] + (Tkip_Sbox_Upper[index_low] * 256);
-	right =
-	    Tkip_Sbox_Upper[index_high] + (Tkip_Sbox_Lower[index_high] * 256);
-
-	return (left ^ right);
-}
-
-u32 rotr1(u32 a)
-{
-	unsigned int b;
-
-	if ((a & 0x01) == 0x01) {
-		b = (a >> 1) | 0x8000;
-	} else {
-		b = (a >> 1) & 0x7fff;
-	}
-	b = b % 65536;
-	return b;
-}
-
-void RTMPTkipMixKey(u8 * key, u8 * ta, unsigned long pnl,	/* Least significant 16 bits of PN */
-		    unsigned long pnh,	/* Most significant 32 bits of PN */
-		    u8 * rc4key, u32 * p1k)
-{
-
-	u32 tsc0;
-	u32 tsc1;
-	u32 tsc2;
-
-	u32 ppk0;
-	u32 ppk1;
-	u32 ppk2;
-	u32 ppk3;
-	u32 ppk4;
-	u32 ppk5;
-
-	int i;
-	int j;
-
-	tsc0 = (unsigned int)((pnh >> 16) % 65536);	/* msb */
-	tsc1 = (unsigned int)(pnh % 65536);
-	tsc2 = (unsigned int)(pnl % 65536);	/* lsb */
-
-	/* Phase 1, step 1 */
-	p1k[0] = tsc1;
-	p1k[1] = tsc0;
-	p1k[2] = (u32)(ta[0] + (ta[1] * 256));
-	p1k[3] = (u32)(ta[2] + (ta[3] * 256));
-	p1k[4] = (u32)(ta[4] + (ta[5] * 256));
-
-	/* Phase 1, step 2 */
-	for (i = 0; i < 8; i++) {
-		j = 2 * (i & 1);
-		p1k[0] =
-		    (p1k[0] +
-		     tkip_sbox((p1k[4] ^ ((256 * key[1 + j]) + key[j])) %
-			       65536)) % 65536;
-		p1k[1] =
-		    (p1k[1] +
-		     tkip_sbox((p1k[0] ^ ((256 * key[5 + j]) + key[4 + j])) %
-			       65536)) % 65536;
-		p1k[2] =
-		    (p1k[2] +
-		     tkip_sbox((p1k[1] ^ ((256 * key[9 + j]) + key[8 + j])) %
-			       65536)) % 65536;
-		p1k[3] =
-		    (p1k[3] +
-		     tkip_sbox((p1k[2] ^ ((256 * key[13 + j]) + key[12 + j])) %
-			       65536)) % 65536;
-		p1k[4] =
-		    (p1k[4] +
-		     tkip_sbox((p1k[3] ^ (((256 * key[1 + j]) + key[j]))) %
-			       65536)) % 65536;
-		p1k[4] = (p1k[4] + i) % 65536;
-	}
-
-	/* Phase 2, Step 1 */
-	ppk0 = p1k[0];
-	ppk1 = p1k[1];
-	ppk2 = p1k[2];
-	ppk3 = p1k[3];
-	ppk4 = p1k[4];
-	ppk5 = (p1k[4] + tsc2) % 65536;
-
-	/* Phase2, Step 2 */
-	ppk0 = ppk0 + tkip_sbox((ppk5 ^ ((256 * key[1]) + key[0])) % 65536);
-	ppk1 = ppk1 + tkip_sbox((ppk0 ^ ((256 * key[3]) + key[2])) % 65536);
-	ppk2 = ppk2 + tkip_sbox((ppk1 ^ ((256 * key[5]) + key[4])) % 65536);
-	ppk3 = ppk3 + tkip_sbox((ppk2 ^ ((256 * key[7]) + key[6])) % 65536);
-	ppk4 = ppk4 + tkip_sbox((ppk3 ^ ((256 * key[9]) + key[8])) % 65536);
-	ppk5 = ppk5 + tkip_sbox((ppk4 ^ ((256 * key[11]) + key[10])) % 65536);
-
-	ppk0 = ppk0 + rotr1(ppk5 ^ ((256 * key[13]) + key[12]));
-	ppk1 = ppk1 + rotr1(ppk0 ^ ((256 * key[15]) + key[14]));
-	ppk2 = ppk2 + rotr1(ppk1);
-	ppk3 = ppk3 + rotr1(ppk2);
-	ppk4 = ppk4 + rotr1(ppk3);
-	ppk5 = ppk5 + rotr1(ppk4);
-
-	/* Phase 2, Step 3 */
-	/* Phase 2, Step 3 */
-
-	tsc0 = (unsigned int)((pnh >> 16) % 65536);	/* msb */
-	tsc1 = (unsigned int)(pnh % 65536);
-	tsc2 = (unsigned int)(pnl % 65536);	/* lsb */
-
-	rc4key[0] = (tsc2 >> 8) % 256;
-	rc4key[1] = (((tsc2 >> 8) % 256) | 0x20) & 0x7f;
-	rc4key[2] = tsc2 % 256;
-	rc4key[3] = ((ppk5 ^ ((256 * key[1]) + key[0])) >> 1) % 256;
-
-	rc4key[4] = ppk0 % 256;
-	rc4key[5] = (ppk0 >> 8) % 256;
-
-	rc4key[6] = ppk1 % 256;
-	rc4key[7] = (ppk1 >> 8) % 256;
-
-	rc4key[8] = ppk2 % 256;
-	rc4key[9] = (ppk2 >> 8) % 256;
-
-	rc4key[10] = ppk3 % 256;
-	rc4key[11] = (ppk3 >> 8) % 256;
-
-	rc4key[12] = ppk4 % 256;
-	rc4key[13] = (ppk4 >> 8) % 256;
-
-	rc4key[14] = ppk5 % 256;
-	rc4key[15] = (ppk5 >> 8) % 256;
-}
-
-/* */
-/* TRUE: Success! */
-/* FALSE: Decrypt Error! */
-/* */
-BOOLEAN RTMPSoftDecryptTKIP(struct rt_rtmp_adapter *pAd,
-			    u8 *pData,
-			    unsigned long DataByteCnt,
-			    u8 UserPriority, struct rt_cipher_key *pWpaKey)
-{
-	u8 KeyID;
-	u32 HeaderLen;
-	u8 fc0;
-	u8 fc1;
-	u16 fc;
-	u32 frame_type;
-	u32 frame_subtype;
-	u32 from_ds;
-	u32 to_ds;
-	int a4_exists;
-	int qc_exists;
-	u16 duration;
-	u16 seq_control;
-	u16 qos_control;
-	u8 TA[MAC_ADDR_LEN];
-	u8 DA[MAC_ADDR_LEN];
-	u8 SA[MAC_ADDR_LEN];
-	u8 RC4Key[16];
-	u32 p1k[5];		/*for mix_key; */
-	unsigned long pnl;		/* Least significant 16 bits of PN */
-	unsigned long pnh;		/* Most significant 32 bits of PN */
-	u32 num_blocks;
-	u32 payload_remainder;
-	struct rt_arcfourcontext ArcFourContext;
-	u32 crc32 = 0;
-	u32 trailfcs = 0;
-	u8 MIC[8];
-	u8 TrailMIC[8];
-
-	fc0 = *pData;
-	fc1 = *(pData + 1);
-
-	fc = *((u16 *)pData);
-
-	frame_type = ((fc0 >> 2) & 0x03);
-	frame_subtype = ((fc0 >> 4) & 0x0f);
-
-	from_ds = (fc1 & 0x2) >> 1;
-	to_ds = (fc1 & 0x1);
-
-	a4_exists = (from_ds & to_ds);
-	qc_exists = ((frame_subtype == 0x08) ||	/* Assumed QoS subtypes */
-		     (frame_subtype == 0x09) ||	/* Likely to change.    */
-		     (frame_subtype == 0x0a) || (frame_subtype == 0x0b)
-	    );
-
-	HeaderLen = 24;
-	if (a4_exists)
-		HeaderLen += 6;
-
-	KeyID = *((u8 *)(pData + HeaderLen + 3));
-	KeyID = KeyID >> 6;
-
-	if (pWpaKey[KeyID].KeyLen == 0) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTMPSoftDecryptTKIP failed!(KeyID[%d] Length can not be 0)\n",
-			  KeyID));
-		return FALSE;
-	}
-
-	duration = *((u16 *)(pData + 2));
-
-	seq_control = *((u16 *)(pData + 22));
-
-	if (qc_exists) {
-		if (a4_exists) {
-			qos_control = *((u16 *)(pData + 30));
-		} else {
-			qos_control = *((u16 *)(pData + 24));
-		}
-	}
-
-	if (to_ds == 0 && from_ds == 1) {
-		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData + 16, MAC_ADDR_LEN);
-		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);	/*BSSID */
-	} else if (to_ds == 0 && from_ds == 0) {
-		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData + 10, MAC_ADDR_LEN);
-	} else if (to_ds == 1 && from_ds == 0) {
-		NdisMoveMemory(SA, pData + 10, MAC_ADDR_LEN);
-		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData + 16, MAC_ADDR_LEN);
-	} else if (to_ds == 1 && from_ds == 1) {
-		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData + 16, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData + 22, MAC_ADDR_LEN);
-	}
-
-	num_blocks = (DataByteCnt - 16) / 16;
-	payload_remainder = (DataByteCnt - 16) % 16;
-
-	pnl = (*(pData + HeaderLen)) * 256 + *(pData + HeaderLen + 2);
-	pnh = *((unsigned long *)(pData + HeaderLen + 4));
-	pnh = cpu2le32(pnh);
-	RTMPTkipMixKey(pWpaKey[KeyID].Key, TA, pnl, pnh, RC4Key, p1k);
-
-	ARCFOUR_INIT(&ArcFourContext, RC4Key, 16);
-
-	ARCFOUR_DECRYPT(&ArcFourContext, pData + HeaderLen,
-			pData + HeaderLen + 8, DataByteCnt - HeaderLen - 8);
-	NdisMoveMemory(&trailfcs, pData + DataByteCnt - 8 - 4, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);	/*Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS). */
-	crc32 ^= 0xffffffff;	/* complement */
-
-	if (crc32 != cpu2le32(trailfcs)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP, WEP Data ICV Error !\n"));	/*ICV error. */
-
-		return (FALSE);
-	}
-
-	NdisMoveMemory(TrailMIC, pData + DataByteCnt - 8 - 8 - 4, 8);
-	RTMPInitMICEngine(pAd, pWpaKey[KeyID].Key, DA, SA, UserPriority,
-			  pWpaKey[KeyID].RxMic);
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pData + HeaderLen,
-		       DataByteCnt - HeaderLen - 8 - 12);
-	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
-	NdisMoveMemory(MIC, pAd->PrivateInfo.Tx.MIC, 8);
-
-	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	/*MIC error. */
-		/*RTMPReportMicError(pAd, &pWpaKey[KeyID]);     // marked by AlbertY @ 20060630 */
-		return (FALSE);
-	}
-	/*DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!\n"); */
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/common/cmm_wep.c b/drivers/staging/rt2860/common/cmm_wep.c
deleted file mode 100644
index 76f880c..0000000
--- a/drivers/staging/rt2860/common/cmm_wep.c
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_wep.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Paul Wu		10-28-02		Initial
-*/
-
-#include	"../rt_config.h"
-
-u32 FCSTAB_32[256] = {
-	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
-	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
-	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
-	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
-	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
-	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
-	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
-	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
-	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
-	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
-	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
-	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
-	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
-	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
-	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
-	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
-	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
-	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
-	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
-	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
-	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
-	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
-	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
-	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
-	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
-	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
-	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
-	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
-	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
-	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
-	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
-	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
-	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
-	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
-	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
-	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
-	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
-	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
-	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
-	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
-	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
-	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
-	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
-	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
-	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
-	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
-	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
-	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
-	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
-	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
-	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
-	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
-	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
-	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
-	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
-	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
-	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
-	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
-	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
-	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
-	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
-	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
-	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
-	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
-};
-
-/*
-u8   WEPKEY[] = {
-		//IV
-		0x00, 0x11, 0x22,
-		//WEP KEY
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
-	};
- */
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Init WEP function.
-
-	Arguments:
-      pAd		Pointer to our adapter
-		pKey        Pointer to the WEP KEY
-		KeyId		   WEP Key ID
-		KeyLen      the length of WEP KEY
-		pDest       Pointer to the destination which Encryption data will store in.
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPInitWepEngine(struct rt_rtmp_adapter *pAd,
-		       u8 *pKey,
-		       u8 KeyId, u8 KeyLen, IN u8 *pDest)
-{
-	u32 i;
-	u8 WEPKEY[] = {
-		/*IV */
-		0x00, 0x11, 0x22,
-		/*WEP KEY */
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
-		    0xAA, 0xBB, 0xCC
-	};
-
-	pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	/*Init crc32. */
-
-	{
-		NdisMoveMemory(WEPKEY + 3, pKey, KeyLen);
-
-		for (i = 0; i < 3; i++)
-			WEPKEY[i] = RandomByte(pAd);	/*Call mlme RandomByte() function. */
-		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);	/*INIT SBOX, KEYLEN+3(IV) */
-
-		NdisMoveMemory(pDest, WEPKEY, 3);	/*Append Init Vector */
-	}
-	*(pDest + 3) = (KeyId << 6);	/*Append KEYID */
-
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Encrypt transimitted data
-
-	Arguments:
-      pAd		Pointer to our adapter
-      pSrc        Pointer to the transimitted source data that will be encrypt
-      pDest       Pointer to the destination where entryption data will be store in.
-      Len			Indicate the length of the source data
-
-	Return Value:
-      None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPEncryptData(struct rt_rtmp_adapter *pAd,
-		     u8 *pSrc, u8 *pDest, u32 Len)
-{
-	pAd->PrivateInfo.FCSCRC32 =
-	    RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, pSrc, Len);
-	ARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, pDest, pSrc, Len);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Decrypt received WEP data
-
-	Arguments:
-		pAdapter		Pointer to our adapter
-		pSrc        Pointer to the received data
-		Len         the length of the received data
-
-	Return Value:
-		TRUE        Decrypt WEP data success
-		FALSE       Decrypt WEP data failed
-
-	Note:
-
-	========================================================================
-*/
-BOOLEAN RTMPSoftDecryptWEP(struct rt_rtmp_adapter *pAd,
-			   u8 *pData,
-			   unsigned long DataByteCnt, struct rt_cipher_key *pGroupKey)
-{
-	u32 trailfcs;
-	u32 crc32;
-	u8 KeyIdx;
-	u8 WEPKEY[] = {
-		/*IV */
-		0x00, 0x11, 0x22,
-		/*WEP KEY */
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
-		    0xAA, 0xBB, 0xCC
-	};
-	u8 *pPayload = (u8 *) pData + LENGTH_802_11;
-	unsigned long payload_len = DataByteCnt - LENGTH_802_11;
-
-	NdisMoveMemory(WEPKEY, pPayload, 3);	/*Get WEP IV */
-
-	KeyIdx = (*(pPayload + 3) & 0xc0) >> 6;
-	if (pGroupKey[KeyIdx].KeyLen == 0)
-		return (FALSE);
-
-	NdisMoveMemory(WEPKEY + 3, pGroupKey[KeyIdx].Key,
-		       pGroupKey[KeyIdx].KeyLen);
-	ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY,
-		     pGroupKey[KeyIdx].KeyLen + 3);
-	ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, pPayload, pPayload + 4,
-			payload_len - 4);
-	NdisMoveMemory(&trailfcs, pPayload + payload_len - 8, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pPayload, payload_len - 8);	/*Skip last 4 bytes(FCS). */
-	crc32 ^= 0xffffffff;	/* complement */
-
-	if (crc32 != cpu2le32(trailfcs)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("WEP Data CRC Error!\n"));	/*CRC error. */
-		return (FALSE);
-	}
-	return (TRUE);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		The Stream Cipher Encryption Algorithm "struct rt_arcfour" initialize
-
-	Arguments:
-	   Ctx         Pointer to struct rt_arcfour CONTEXT (SBOX)
-		pKey        Pointer to the WEP KEY
-		KeyLen      Indicate the length fo the WEP KEY
-
-	Return Value:
-	   None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void ARCFOUR_INIT(struct rt_arcfourcontext *Ctx, u8 *pKey, u32 KeyLen)
-{
-	u8 t, u;
-	u32 keyindex;
-	u32 stateindex;
-	u8 *state;
-	u32 counter;
-
-	state = Ctx->STATE;
-	Ctx->X = 0;
-	Ctx->Y = 0;
-	for (counter = 0; counter < 256; counter++)
-		state[counter] = (u8)counter;
-	keyindex = 0;
-	stateindex = 0;
-	for (counter = 0; counter < 256; counter++) {
-		t = state[counter];
-		stateindex = (stateindex + pKey[keyindex] + t) & 0xff;
-		u = state[stateindex];
-		state[stateindex] = t;
-		state[counter] = u;
-		if (++keyindex >= KeyLen)
-			keyindex = 0;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Get bytes from struct rt_arcfour CONTEXT (S-BOX)
-
-	Arguments:
-	   Ctx         Pointer to struct rt_arcfour CONTEXT (SBOX)
-
-	Return Value:
-	   u8  - the value of the struct rt_arcfour CONTEXT (S-BOX)
-
-	Note:
-
-	========================================================================
-*/
-u8 ARCFOUR_BYTE(struct rt_arcfourcontext *Ctx)
-{
-	u32 x;
-	u32 y;
-	u8 sx, sy;
-	u8 *state;
-
-	state = Ctx->STATE;
-	x = (Ctx->X + 1) & 0xff;
-	sx = state[x];
-	y = (sx + Ctx->Y) & 0xff;
-	sy = state[y];
-	Ctx->X = x;
-	Ctx->Y = y;
-	state[y] = sx;
-	state[x] = sy;
-
-	return (state[(sx + sy) & 0xff]);
-
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		The Stream Cipher Decryption Algorithm
-
-	Arguments:
-		Ctx         Pointer to struct rt_arcfour CONTEXT (SBOX)
-		pDest			Pointer to the Destination
-		pSrc        Pointer to the Source data
-		Len         Indicate the length of the Source data
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void ARCFOUR_DECRYPT(struct rt_arcfourcontext *Ctx,
-		     u8 *pDest, u8 *pSrc, u32 Len)
-{
-	u32 i;
-
-	for (i = 0; i < Len; i++)
-		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		The Stream Cipher Encryption Algorithm
-
-	Arguments:
-		Ctx         Pointer to struct rt_arcfour CONTEXT (SBOX)
-		pDest			Pointer to the Destination
-		pSrc        Pointer to the Source data
-		Len         Indicate the length of the Source dta
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void ARCFOUR_ENCRYPT(struct rt_arcfourcontext *Ctx,
-		     u8 *pDest, u8 *pSrc, u32 Len)
-{
-	u32 i;
-
-	for (i = 0; i < Len; i++)
-		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		The Stream Cipher Encryption Algorithm which conform to the special requirement to encrypt  GTK.
-
-	Arguments:
-		Ctx         Pointer to struct rt_arcfour CONTEXT (SBOX)
-		pDest			Pointer to the Destination
-		pSrc        Pointer to the Source data
-		Len         Indicate the length of the Source dta
-
-	========================================================================
-*/
-
-void WPAARCFOUR_ENCRYPT(struct rt_arcfourcontext *Ctx,
-			u8 *pDest, u8 *pSrc, u32 Len)
-{
-	u32 i;
-	/*discard first 256 bytes */
-	for (i = 0; i < 256; i++)
-		ARCFOUR_BYTE(Ctx);
-
-	for (i = 0; i < Len; i++)
-		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Calculate a new FCS given the current FCS and the new data.
-
-	Arguments:
-		Fcs	      the original FCS value
-		Cp          pointer to the data which will be calculate the FCS
-		Len         the length of the data
-
-	Return Value:
-		u32 - FCS 32 bits
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-u32 RTMP_CALC_FCS32(u32 Fcs, u8 *Cp, int Len)
-{
-	while (Len--)
-		Fcs = (((Fcs) >> 8) ^ FCSTAB_32[((Fcs) ^ (*Cp++)) & 0xff]);
-
-	return (Fcs);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Get last FCS and encrypt it to the destination
-
-	Arguments:
-		pDest			Pointer to the Destination
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void RTMPSetICV(struct rt_rtmp_adapter *pAd, u8 *pDest)
-{
-	pAd->PrivateInfo.FCSCRC32 ^= 0xffffffff;	/* complement */
-	pAd->PrivateInfo.FCSCRC32 = cpu2le32(pAd->PrivateInfo.FCSCRC32);
-
-	ARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, pDest,
-			(u8 *)& pAd->PrivateInfo.FCSCRC32, 4);
-}
diff --git a/drivers/staging/rt2860/common/cmm_wpa.c b/drivers/staging/rt2860/common/cmm_wpa.c
deleted file mode 100644
index 616ebec..0000000
--- a/drivers/staging/rt2860/common/cmm_wpa.c
+++ /dev/null
@@ -1,3010 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	wpa.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Jan	Lee		03-07-22		Initial
-	Paul Lin	03-11-28		Modify for supplicant
-*/
-#include "../rt_config.h"
-/* WPA OUI */
-u8 OUI_WPA_NONE_AKM[4] = { 0x00, 0x50, 0xF2, 0x00 };
-u8 OUI_WPA_VERSION[4] = { 0x00, 0x50, 0xF2, 0x01 };
-u8 OUI_WPA_WEP40[4] = { 0x00, 0x50, 0xF2, 0x01 };
-u8 OUI_WPA_TKIP[4] = { 0x00, 0x50, 0xF2, 0x02 };
-u8 OUI_WPA_CCMP[4] = { 0x00, 0x50, 0xF2, 0x04 };
-u8 OUI_WPA_WEP104[4] = { 0x00, 0x50, 0xF2, 0x05 };
-u8 OUI_WPA_8021X_AKM[4] = { 0x00, 0x50, 0xF2, 0x01 };
-u8 OUI_WPA_PSK_AKM[4] = { 0x00, 0x50, 0xF2, 0x02 };
-
-/* WPA2 OUI */
-u8 OUI_WPA2_WEP40[4] = { 0x00, 0x0F, 0xAC, 0x01 };
-u8 OUI_WPA2_TKIP[4] = { 0x00, 0x0F, 0xAC, 0x02 };
-u8 OUI_WPA2_CCMP[4] = { 0x00, 0x0F, 0xAC, 0x04 };
-u8 OUI_WPA2_8021X_AKM[4] = { 0x00, 0x0F, 0xAC, 0x01 };
-u8 OUI_WPA2_PSK_AKM[4] = { 0x00, 0x0F, 0xAC, 0x02 };
-u8 OUI_WPA2_WEP104[4] = { 0x00, 0x0F, 0xAC, 0x05 };
-
-static void ConstructEapolKeyData(struct rt_mac_table_entry *pEntry,
-				  u8 GroupKeyWepStatus,
-				  u8 keyDescVer,
-				  u8 MsgType,
-				  u8 DefaultKeyIdx,
-				  u8 * GTK,
-				  u8 * RSNIE,
-				  u8 RSNIE_LEN, struct rt_eapol_packet * pMsg);
-
-static void CalculateMIC(u8 KeyDescVer,
-			 u8 * PTK, struct rt_eapol_packet * pMsg);
-
-static void WpaEAPPacketAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-static void WpaEAPOLASFAlertAction(struct rt_rtmp_adapter *pAd,
-				   struct rt_mlme_queue_elem *Elem);
-
-static void WpaEAPOLLogoffAction(struct rt_rtmp_adapter *pAd,
-				 struct rt_mlme_queue_elem *Elem);
-
-static void WpaEAPOLStartAction(struct rt_rtmp_adapter *pAd,
-				struct rt_mlme_queue_elem *Elem);
-
-static void WpaEAPOLKeyAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-/*
-    ==========================================================================
-    Description:
-        association state machine init, including state transition and timer init
-    Parameters:
-        S - pointer to the association state machine
-    ==========================================================================
- */
-void WpaStateMachineInit(struct rt_rtmp_adapter *pAd,
-			 struct rt_state_machine *S, OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(S, (STATE_MACHINE_FUNC *) Trans, MAX_WPA_PTK_STATE,
-			 MAX_WPA_MSG, (STATE_MACHINE_FUNC) Drop, WPA_PTK,
-			 WPA_MACHINE_BASE);
-
-	StateMachineSetAction(S, WPA_PTK, MT2_EAPPacket,
-			      (STATE_MACHINE_FUNC) WpaEAPPacketAction);
-	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLStart,
-			      (STATE_MACHINE_FUNC) WpaEAPOLStartAction);
-	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLLogoff,
-			      (STATE_MACHINE_FUNC) WpaEAPOLLogoffAction);
-	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLKey,
-			      (STATE_MACHINE_FUNC) WpaEAPOLKeyAction);
-	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLASFAlert,
-			      (STATE_MACHINE_FUNC) WpaEAPOLASFAlertAction);
-}
-
-/*
-    ==========================================================================
-    Description:
-        this is state machine function.
-        When receiving EAP packets which is  for 802.1x authentication use.
-        Not use in PSK case
-    Return:
-    ==========================================================================
-*/
-void WpaEAPPacketAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-void WpaEAPOLASFAlertAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-void WpaEAPOLLogoffAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-/*
-    ==========================================================================
-    Description:
-       Start 4-way HS when rcv EAPOL_START which may create by our driver in assoc.c
-    Return:
-    ==========================================================================
-*/
-void WpaEAPOLStartAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mac_table_entry *pEntry;
-	struct rt_header_802_11 * pHeader;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLStartAction ===> \n"));
-
-	pHeader = (struct rt_header_802_11 *) Elem->Msg;
-
-	/*For normaol PSK, we enqueue an EAPOL-Start command to trigger the process. */
-	if (Elem->MsgLen == 6)
-		pEntry = MacTableLookup(pAd, Elem->Msg);
-	else {
-		pEntry = MacTableLookup(pAd, pHeader->Addr2);
-	}
-
-	if (pEntry) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 (" PortSecured(%d), WpaState(%d), AuthMode(%d), PMKID_CacheIdx(%d) \n",
-			  pEntry->PortSecured, pEntry->WpaState,
-			  pEntry->AuthMode, pEntry->PMKID_CacheIdx));
-
-		if ((pEntry->PortSecured == WPA_802_1X_PORT_NOT_SECURED)
-		    && (pEntry->WpaState < AS_PTKSTART)
-		    && ((pEntry->AuthMode == Ndis802_11AuthModeWPAPSK)
-			|| (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)
-			|| ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
-			    && (pEntry->PMKID_CacheIdx != ENTRY_NOT_FOUND)))) {
-			pEntry->PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
-			pEntry->WpaState = AS_INITPSK;
-			pEntry->PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-			NdisZeroMemory(pEntry->R_Counter,
-				       sizeof(pEntry->R_Counter));
-			pEntry->ReTryCounter = PEER_MSG1_RETRY_TIMER_CTR;
-
-			WPAStart4WayHS(pAd, pEntry, PEER_MSG1_RETRY_EXEC_INTV);
-		}
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-        This is state machine function.
-        When receiving EAPOL packets which is  for 802.1x key management.
-        Use both in WPA, and WPAPSK case.
-        In this function, further dispatch to different functions according to the received packet.  3 categories are :
-          1.  normal 4-way pairwisekey and 2-way groupkey handshake
-          2.  MIC error (Countermeasures attack)  report packet from STA.
-          3.  Request for pairwise/group key update from STA
-    Return:
-    ==========================================================================
-*/
-void WpaEAPOLKeyAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mac_table_entry *pEntry;
-	struct rt_header_802_11 * pHeader;
-	struct rt_eapol_packet * pEapol_packet;
-	struct rt_key_info peerKeyInfo;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLKeyAction ===>\n"));
-
-	pHeader = (struct rt_header_802_11 *) Elem->Msg;
-	pEapol_packet =
-	    (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-
-	NdisZeroMemory((u8 *)& peerKeyInfo, sizeof(peerKeyInfo));
-	NdisMoveMemory((u8 *)& peerKeyInfo,
-		       (u8 *)& pEapol_packet->KeyDesc.KeyInfo,
-		       sizeof(struct rt_key_info));
-
-	hex_dump("Received Eapol frame", (unsigned char *)pEapol_packet,
-		 (Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H));
-
-	*((u16 *) & peerKeyInfo) = cpu2le16(*((u16 *) & peerKeyInfo));
-
-	do {
-		pEntry = MacTableLookup(pAd, pHeader->Addr2);
-
-		if (!pEntry
-		    || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-			break;
-
-		if (pEntry->AuthMode < Ndis802_11AuthModeWPA)
-			break;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			("Receive EAPoL-Key frame from STA %pMF\n",
-				pEntry->Addr));
-
-		if (((pEapol_packet->ProVer != EAPOL_VER)
-		     && (pEapol_packet->ProVer != EAPOL_VER2))
-		    || ((pEapol_packet->KeyDesc.Type != WPA1_KEY_DESC)
-			&& (pEapol_packet->KeyDesc.Type != WPA2_KEY_DESC))) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Key descripter does not match with WPA rule\n"));
-			break;
-		}
-		/* The value 1 shall be used for all EAPOL-Key frames to and from a STA when */
-		/* neither the group nor pairwise ciphers are CCMP for Key Descriptor 1. */
-		if ((pEntry->WepStatus == Ndis802_11Encryption2Enabled)
-		    && (peerKeyInfo.KeyDescVer != DESC_TYPE_TKIP)) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Key descripter version not match(TKIP) \n"));
-			break;
-		}
-		/* The value 2 shall be used for all EAPOL-Key frames to and from a STA when */
-		/* either the pairwise or the group cipher is AES-CCMP for Key Descriptor 2. */
-		else if ((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
-			 && (peerKeyInfo.KeyDescVer != DESC_TYPE_AES)) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Key descripter version not match(AES) \n"));
-			break;
-		}
-		/* Check if this STA is in class 3 state and the WPA state is started */
-		if ((pEntry->Sst == SST_ASSOC)
-		    && (pEntry->WpaState >= AS_INITPSK)) {
-			/* Check the Key Ack (bit 7) of the Key Information to determine the Authenticator */
-			/* or not. */
-			/* An EAPOL-Key frame that is sent by the Supplicant in response to an EAPOL- */
-			/* Key frame from the Authenticator must not have the Ack bit set. */
-			if (peerKeyInfo.KeyAck == 1) {
-				/* The frame is snet by Authenticator. */
-				/* So the Supplicant side shall handle this. */
-
-				if ((peerKeyInfo.Secure == 0)
-				    && (peerKeyInfo.Request == 0)
-				    && (peerKeyInfo.Error == 0)
-				    && (peerKeyInfo.KeyType == PAIRWISEKEY)) {
-					/* Process 1. the message 1 of 4-way HS in WPA or WPA2 */
-					/*                        EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1) */
-					/*                 2. the message 3 of 4-way HS in WPA */
-					/*                        EAPOL-Key(0,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3) */
-					if (peerKeyInfo.KeyMic == 0)
-						PeerPairMsg1Action(pAd, pEntry,
-								   Elem);
-					else
-						PeerPairMsg3Action(pAd, pEntry,
-								   Elem);
-				} else if ((peerKeyInfo.Secure == 1)
-					   && (peerKeyInfo.KeyMic == 1)
-					   && (peerKeyInfo.Request == 0)
-					   && (peerKeyInfo.Error == 0)) {
-					/* Process 1. the message 3 of 4-way HS in WPA2 */
-					/*                        EAPOL-Key(1,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3) */
-					/*                 2. the message 1 of group KS in WPA or WPA2 */
-					/*                        EAPOL-Key(1,1,1,0,G,0,Key RSC,0, MIC,GTK[N]) */
-					if (peerKeyInfo.KeyType == PAIRWISEKEY)
-						PeerPairMsg3Action(pAd, pEntry,
-								   Elem);
-					else
-						PeerGroupMsg1Action(pAd, pEntry,
-								    Elem);
-				}
-			} else {
-				/* The frame is snet by Supplicant. */
-				/* So the Authenticator side shall handle this. */
-				if ((peerKeyInfo.Request == 0) &&
-				    (peerKeyInfo.Error == 0) &&
-				    (peerKeyInfo.KeyMic == 1)) {
-					if (peerKeyInfo.Secure == 0
-					    && peerKeyInfo.KeyType ==
-					    PAIRWISEKEY) {
-						/* EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,Data) */
-						/* Process 1. message 2 of 4-way HS in WPA or WPA2 */
-						/*                 2. message 4 of 4-way HS in WPA */
-						if (CONV_ARRARY_TO_u16
-						    (pEapol_packet->KeyDesc.
-						     KeyDataLen) == 0) {
-							PeerPairMsg4Action(pAd,
-									   pEntry,
-									   Elem);
-						} else {
-							PeerPairMsg2Action(pAd,
-									   pEntry,
-									   Elem);
-						}
-					} else if (peerKeyInfo.Secure == 1
-						   && peerKeyInfo.KeyType ==
-						   PAIRWISEKEY) {
-						/* EAPOL-Key(1,1,0,0,P,0,0,0,MIC,0) */
-						/* Process message 4 of 4-way HS in WPA2 */
-						PeerPairMsg4Action(pAd, pEntry,
-								   Elem);
-					} else if (peerKeyInfo.Secure == 1
-						   && peerKeyInfo.KeyType ==
-						   GROUPKEY) {
-						/* EAPOL-Key(1,1,0,0,G,0,0,0,MIC,0) */
-						/* Process message 2 of Group key HS in WPA or WPA2 */
-						PeerGroupMsg2Action(pAd, pEntry,
-								    &Elem->
-								    Msg
-								    [LENGTH_802_11],
-								    (Elem->
-								     MsgLen -
-								     LENGTH_802_11));
-					}
-				}
-			}
-		}
-	} while (FALSE);
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Copy frame from waiting queue into relative ring buffer and set
-	appropriate ASIC register to kick hardware encryption before really
-	sent out to air.
-
-	Arguments:
-		pAd		Pointer	to our adapter
-		void *	Pointer to outgoing Ndis frame
-		NumberOfFrag	Number of fragment required
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void RTMPToWirelessSta(struct rt_rtmp_adapter *pAd,
-		       struct rt_mac_table_entry *pEntry,
-		       u8 *pHeader802_3,
-		       u32 HdrLen,
-		       u8 *pData, u32 DataLen, IN BOOLEAN bClearFrame)
-{
-	void *pPacket;
-	int Status;
-
-	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-		return;
-
-	do {
-		/* build a NDIS packet */
-		Status =
-		    RTMPAllocateNdisPacket(pAd, &pPacket, pHeader802_3, HdrLen,
-					   pData, DataLen);
-		if (Status != NDIS_STATUS_SUCCESS)
-			break;
-
-		if (bClearFrame)
-			RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 1);
-		else
-			RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 0);
-		{
-			RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-
-			RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, MAIN_MBSSID);	/* set a default value */
-			if (pEntry->apidx != 0)
-				RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket,
-								  pEntry->
-								  apidx);
-
-			RTMP_SET_PACKET_WCID(pPacket, (u8)pEntry->Aid);
-			RTMP_SET_PACKET_MOREDATA(pPacket, FALSE);
-		}
-
-		{
-			/* send out the packet */
-			Status = STASendPacket(pAd, pPacket);
-			if (Status == NDIS_STATUS_SUCCESS) {
-				u8 Index;
-
-				/* Dequeue one frame from TxSwQueue0..3 queue and process it */
-				/* There are three place calling dequeue for TX ring. */
-				/* 1. Here, right after queueing the frame. */
-				/* 2. At the end of TxRingTxDone service routine. */
-				/* 3. Upon NDIS call RTMPSendPackets */
-				if ((!RTMP_TEST_FLAG
-				     (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-				    &&
-				    (!RTMP_TEST_FLAG
-				     (pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS))) {
-					for (Index = 0; Index < 5; Index++)
-						if (pAd->TxSwQueue[Index].
-						    Number > 0)
-							RTMPDeQueuePacket(pAd,
-									  FALSE,
-									  Index,
-									  MAX_TX_PROCESS);
-				}
-			}
-		}
-
-	} while (FALSE);
-}
-
-/*
-    ==========================================================================
-    Description:
-        This is a function to initialize 4-way handshake
-
-    Return:
-
-    ==========================================================================
-*/
-void WPAStart4WayHS(struct rt_rtmp_adapter *pAd,
-		    struct rt_mac_table_entry *pEntry, unsigned long TimeInterval)
-{
-	u8 Header802_3[14];
-	struct rt_eapol_packet EAPOLPKT;
-	u8 *pBssid = NULL;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> WPAStart4WayHS\n"));
-
-	if (RTMP_TEST_FLAG
-	    (pAd,
-	     fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_HALT_IN_PROGRESS))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("[ERROR]WPAStart4WayHS : The interface is closed...\n"));
-		return;
-	}
-
-	if (pBssid == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("[ERROR]WPAStart4WayHS : No corresponding Authenticator.\n"));
-		return;
-	}
-	/* Check the status */
-	if ((pEntry->WpaState > AS_PTKSTART) || (pEntry->WpaState < AS_INITPMK)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("[ERROR]WPAStart4WayHS : Not expect calling\n"));
-		return;
-	}
-
-	/* Increment replay counter by 1 */
-	ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
-
-	/* Randomly generate ANonce */
-	GenRandom(pAd, (u8 *) pBssid, pEntry->ANonce);
-
-	/* Construct EAPoL message - Pairwise Msg 1 */
-	/* EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1) */
-	NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_1, 0,	/* Default key index */
-			  pEntry->ANonce, NULL,	/* TxRSC */
-			  NULL,	/* GTK */
-			  NULL,	/* RSNIE */
-			  0,	/* RSNIE length */
-			  &EAPOLPKT);
-
-	/* Make outgoing frame */
-	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-	RTMPToWirelessSta(pAd, pEntry, Header802_3,
-			  LENGTH_802_3, (u8 *)& EAPOLPKT,
-			  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4,
-			  (pEntry->PortSecured ==
-			   WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
-
-	/* Trigger Retry Timer */
-	RTMPModTimer(&pEntry->RetryTimer, TimeInterval);
-
-	/* Update State */
-	pEntry->WpaState = AS_PTKSTART;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== WPAStart4WayHS: send Msg1 of 4-way \n"));
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process Pairwise key Msg-1 of 4-way handshaking and send Msg-2
-
-	Arguments:
-		pAd			Pointer	to our adapter
-		Elem		Message body
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void PeerPairMsg1Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem)
-{
-	u8 PTK[80];
-	u8 Header802_3[14];
-	struct rt_eapol_packet * pMsg1;
-	u32 MsgLen;
-	struct rt_eapol_packet EAPOLPKT;
-	u8 *pCurrentAddr = NULL;
-	u8 *pmk_ptr = NULL;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-	u8 *rsnie_ptr = NULL;
-	u8 rsnie_len = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg1Action \n"));
-
-	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-		return;
-
-	if (Elem->MsgLen <
-	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
-	     sizeof(struct rt_key_descripter) - MAX_LEN_OF_RSNIE - 2))
-		return;
-
-	{
-		pCurrentAddr = pAd->CurrentAddress;
-		pmk_ptr = pAd->StaCfg.PMK;
-		group_cipher = pAd->StaCfg.GroupCipher;
-		rsnie_ptr = pAd->StaCfg.RSN_IE;
-		rsnie_len = pAd->StaCfg.RSNIE_Len;
-	}
-
-	/* Store the received frame */
-	pMsg1 = (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
-
-	/* Sanity Check peer Pairwise message 1 - Replay Counter */
-	if (PeerWpaMessageSanity(pAd, pMsg1, MsgLen, EAPOL_PAIR_MSG_1, pEntry)
-	    == FALSE)
-		return;
-
-	/* Store Replay counter, it will use to verify message 3 and construct message 2 */
-	NdisMoveMemory(pEntry->R_Counter, pMsg1->KeyDesc.ReplayCounter,
-		       LEN_KEY_DESC_REPLAY);
-
-	/* Store ANonce */
-	NdisMoveMemory(pEntry->ANonce, pMsg1->KeyDesc.KeyNonce,
-		       LEN_KEY_DESC_NONCE);
-
-	/* Generate random SNonce */
-	GenRandom(pAd, (u8 *) pCurrentAddr, pEntry->SNonce);
-
-	{
-		/* Calculate PTK(ANonce, SNonce) */
-		WpaDerivePTK(pAd,
-			     pmk_ptr,
-			     pEntry->ANonce,
-			     pEntry->Addr,
-			     pEntry->SNonce, pCurrentAddr, PTK, LEN_PTK);
-
-		/* Save key to PTK entry */
-		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
-	}
-
-	/* Update WpaState */
-	pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
-
-	/* Construct EAPoL message - Pairwise Msg 2 */
-	/*  EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,DataKD_M2) */
-	NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_2, 0,	/* DefaultKeyIdx */
-			  pEntry->SNonce, NULL,	/* TxRsc */
-			  NULL,	/* GTK */
-			  (u8 *) rsnie_ptr, rsnie_len, &EAPOLPKT);
-
-	/* Make outgoing frame */
-	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
-
-	RTMPToWirelessSta(pAd, pEntry,
-			  Header802_3, sizeof(Header802_3), (u8 *)& EAPOLPKT,
-			  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4, TRUE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== PeerPairMsg1Action: send Msg2 of 4-way \n"));
-}
-
-/*
-    ==========================================================================
-    Description:
-        When receiving the second packet of 4-way pairwisekey handshake.
-    Return:
-    ==========================================================================
-*/
-void PeerPairMsg2Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem)
-{
-	u8 PTK[80];
-	BOOLEAN Cancelled;
-	struct rt_header_802_11 * pHeader;
-	struct rt_eapol_packet EAPOLPKT;
-	struct rt_eapol_packet * pMsg2;
-	u32 MsgLen;
-	u8 Header802_3[LENGTH_802_3];
-	u8 TxTsc[6];
-	u8 *pBssid = NULL;
-	u8 *pmk_ptr = NULL;
-	u8 *gtk_ptr = NULL;
-	u8 default_key = 0;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-	u8 *rsnie_ptr = NULL;
-	u8 rsnie_len = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg2Action \n"));
-
-	if ((!pEntry) || (!pEntry->ValidAsCLI))
-		return;
-
-	if (Elem->MsgLen <
-	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
-	     sizeof(struct rt_key_descripter) - MAX_LEN_OF_RSNIE - 2))
-		return;
-
-	/* check Entry in valid State */
-	if (pEntry->WpaState < AS_PTKSTART)
-		return;
-
-	/* pointer to 802.11 header */
-	pHeader = (struct rt_header_802_11 *) Elem->Msg;
-
-	/* skip 802.11_header(24-byte) and LLC_header(8) */
-	pMsg2 = (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
-
-	/* Store SNonce */
-	NdisMoveMemory(pEntry->SNonce, pMsg2->KeyDesc.KeyNonce,
-		       LEN_KEY_DESC_NONCE);
-
-	{
-		/* Derive PTK */
-		WpaDerivePTK(pAd, (u8 *) pmk_ptr, pEntry->ANonce,	/* ANONCE */
-			     (u8 *) pBssid, pEntry->SNonce,	/* SNONCE */
-			     pEntry->Addr, PTK, LEN_PTK);
-
-		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
-	}
-
-	/* Sanity Check peer Pairwise message 2 - Replay Counter, MIC, RSNIE */
-	if (PeerWpaMessageSanity(pAd, pMsg2, MsgLen, EAPOL_PAIR_MSG_2, pEntry)
-	    == FALSE)
-		return;
-
-	do {
-		/* delete retry timer */
-		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
-
-		/* Change state */
-		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
-
-		/* Increment replay counter by 1 */
-		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
-
-		/* Construct EAPoL message - Pairwise Msg 3 */
-		NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-		ConstructEapolMsg(pEntry,
-				  group_cipher,
-				  EAPOL_PAIR_MSG_3,
-				  default_key,
-				  pEntry->ANonce,
-				  TxTsc,
-				  (u8 *) gtk_ptr,
-				  (u8 *) rsnie_ptr, rsnie_len, &EAPOLPKT);
-
-		/* Make outgoing frame */
-		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-		RTMPToWirelessSta(pAd, pEntry, Header802_3, LENGTH_802_3,
-				  (u8 *)& EAPOLPKT,
-				  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4,
-				  (pEntry->PortSecured ==
-				   WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
-
-		pEntry->ReTryCounter = PEER_MSG3_RETRY_TIMER_CTR;
-		RTMPSetTimer(&pEntry->RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);
-
-		/* Update State */
-		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
-	} while (FALSE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== PeerPairMsg2Action: send Msg3 of 4-way \n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process Pairwise key Msg 3 of 4-way handshaking and send Msg 4
-
-	Arguments:
-		pAd	Pointer	to our adapter
-		Elem		Message body
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void PeerPairMsg3Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_header_802_11 * pHeader;
-	u8 Header802_3[14];
-	struct rt_eapol_packet EAPOLPKT;
-	struct rt_eapol_packet * pMsg3;
-	u32 MsgLen;
-	u8 *pCurrentAddr = NULL;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg3Action \n"));
-
-	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-		return;
-
-	if (Elem->MsgLen <
-	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
-	     sizeof(struct rt_key_descripter) - MAX_LEN_OF_RSNIE - 2))
-		return;
-
-	{
-		pCurrentAddr = pAd->CurrentAddress;
-		group_cipher = pAd->StaCfg.GroupCipher;
-
-	}
-
-	/* Record 802.11 header & the received EAPOL packet Msg3 */
-	pHeader = (struct rt_header_802_11 *) Elem->Msg;
-	pMsg3 = (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
-
-	/* Sanity Check peer Pairwise message 3 - Replay Counter, MIC, RSNIE */
-	if (PeerWpaMessageSanity(pAd, pMsg3, MsgLen, EAPOL_PAIR_MSG_3, pEntry)
-	    == FALSE)
-		return;
-
-	/* Save Replay counter, it will use construct message 4 */
-	NdisMoveMemory(pEntry->R_Counter, pMsg3->KeyDesc.ReplayCounter,
-		       LEN_KEY_DESC_REPLAY);
-
-	/* Double check ANonce */
-	if (!NdisEqualMemory
-	    (pEntry->ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE)) {
-		return;
-	}
-	/* Construct EAPoL message - Pairwise Msg 4 */
-	NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_4, 0,	/* group key index not used in message 4 */
-			  NULL,	/* Nonce not used in message 4 */
-			  NULL,	/* TxRSC not used in message 4 */
-			  NULL,	/* GTK not used in message 4 */
-			  NULL,	/* RSN IE not used in message 4 */
-			  0, &EAPOLPKT);
-
-	/* Update WpaState */
-	pEntry->WpaState = AS_PTKINITDONE;
-
-	/* Update pairwise key */
-	{
-		struct rt_cipher_key *pSharedKey;
-
-		pSharedKey = &pAd->SharedKey[BSS0][0];
-
-		NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
-
-		/* Prepare pair-wise key information into shared key table */
-		NdisZeroMemory(pSharedKey, sizeof(struct rt_cipher_key));
-		pSharedKey->KeyLen = LEN_TKIP_EK;
-		NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32],
-			       LEN_TKIP_EK);
-		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48],
-			       LEN_TKIP_RXMICK);
-		NdisMoveMemory(pSharedKey->TxMic,
-			       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK],
-			       LEN_TKIP_TXMICK);
-
-		/* Decide its ChiperAlg */
-		if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-			pSharedKey->CipherAlg = CIPHER_TKIP;
-		else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
-			pSharedKey->CipherAlg = CIPHER_AES;
-		else
-			pSharedKey->CipherAlg = CIPHER_NONE;
-
-		/* Update these related information to struct rt_mac_table_entry */
-		pEntry = &pAd->MacTab.Content[BSSID_WCID];
-		NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
-			       LEN_TKIP_EK);
-		NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48],
-			       LEN_TKIP_RXMICK);
-		NdisMoveMemory(pEntry->PairwiseKey.TxMic,
-			       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK],
-			       LEN_TKIP_TXMICK);
-		pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
-
-		/* Update pairwise key information to ASIC Shared Key Table */
-		AsicAddSharedKeyEntry(pAd,
-				      BSS0,
-				      0,
-				      pSharedKey->CipherAlg,
-				      pSharedKey->Key,
-				      pSharedKey->TxMic, pSharedKey->RxMic);
-
-		/* Update ASIC WCID attribute table and IVEIV table */
-		RTMPAddWcidAttributeEntry(pAd,
-					  BSS0,
-					  0, pSharedKey->CipherAlg, pEntry);
-
-	}
-
-	/* open 802.1x port control and privacy filter */
-	if (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK ||
-	    pEntry->AuthMode == Ndis802_11AuthModeWPA2) {
-		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
-		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-
-		STA_PORT_SECURED(pAd);
-		/* Indicate Connected for GUI */
-		pAd->IndicateMediaState = NdisMediaStateConnected;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PeerPairMsg3Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
-			  GetAuthMode(pEntry->AuthMode),
-			  GetEncryptType(pEntry->WepStatus),
-			  GetEncryptType(group_cipher)));
-	} else {
-	}
-
-	/* Init 802.3 header and send out */
-	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
-	RTMPToWirelessSta(pAd, pEntry,
-			  Header802_3, sizeof(Header802_3),
-			  (u8 *)& EAPOLPKT,
-			  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4, TRUE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== PeerPairMsg3Action: send Msg4 of 4-way \n"));
-}
-
-/*
-    ==========================================================================
-    Description:
-        When receiving the last packet of 4-way pairwisekey handshake.
-        Initialize 2-way groupkey handshake following.
-    Return:
-    ==========================================================================
-*/
-void PeerPairMsg4Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_eapol_packet * pMsg4;
-	struct rt_header_802_11 * pHeader;
-	u32 MsgLen;
-	BOOLEAN Cancelled;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg4Action\n"));
-
-	do {
-		if ((!pEntry) || (!pEntry->ValidAsCLI))
-			break;
-
-		if (Elem->MsgLen <
-		    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
-		     sizeof(struct rt_key_descripter) - MAX_LEN_OF_RSNIE - 2))
-			break;
-
-		if (pEntry->WpaState < AS_PTKINIT_NEGOTIATING)
-			break;
-
-		/* pointer to 802.11 header */
-		pHeader = (struct rt_header_802_11 *) Elem->Msg;
-
-		/* skip 802.11_header(24-byte) and LLC_header(8) */
-		pMsg4 =
-		    (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-		MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
-
-		/* Sanity Check peer Pairwise message 4 - Replay Counter, MIC */
-		if (PeerWpaMessageSanity
-		    (pAd, pMsg4, MsgLen, EAPOL_PAIR_MSG_4, pEntry) == FALSE)
-			break;
-
-		/* 3. uses the MLME.SETKEYS.request to configure PTK into MAC */
-		NdisZeroMemory(&pEntry->PairwiseKey, sizeof(struct rt_cipher_key));
-
-		/* reset IVEIV in Asic */
-		AsicUpdateWCIDIVEIV(pAd, pEntry->Aid, 1, 0);
-
-		pEntry->PairwiseKey.KeyLen = LEN_TKIP_EK;
-		NdisMoveMemory(pEntry->PairwiseKey.Key, &pEntry->PTK[32],
-			       LEN_TKIP_EK);
-		NdisMoveMemory(pEntry->PairwiseKey.RxMic,
-			       &pEntry->PTK[TKIP_AP_RXMICK_OFFSET],
-			       LEN_TKIP_RXMICK);
-		NdisMoveMemory(pEntry->PairwiseKey.TxMic,
-			       &pEntry->PTK[TKIP_AP_TXMICK_OFFSET],
-			       LEN_TKIP_TXMICK);
-
-		/* Set pairwise key to Asic */
-		{
-			pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
-			if (pEntry->WepStatus == Ndis802_11Encryption2Enabled)
-				pEntry->PairwiseKey.CipherAlg = CIPHER_TKIP;
-			else if (pEntry->WepStatus ==
-				 Ndis802_11Encryption3Enabled)
-				pEntry->PairwiseKey.CipherAlg = CIPHER_AES;
-
-			/* Add Pair-wise key to Asic */
-			AsicAddPairwiseKeyEntry(pAd,
-						pEntry->Addr,
-						(u8)pEntry->Aid,
-						&pEntry->PairwiseKey);
-
-			/* update WCID attribute table and IVEIV table for this entry */
-			RTMPAddWcidAttributeEntry(pAd,
-						  pEntry->apidx,
-						  0,
-						  pEntry->PairwiseKey.CipherAlg,
-						  pEntry);
-		}
-
-		/* 4. upgrade state */
-		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-		pEntry->WpaState = AS_PTKINITDONE;
-		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
-
-		if (pEntry->AuthMode == Ndis802_11AuthModeWPA2 ||
-		    pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK) {
-			pEntry->GTKState = REKEY_ESTABLISHED;
-			RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
-
-			/* send wireless event - for set key done WPA2 */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
-						      pEntry->Addr,
-						      pEntry->apidx, 0);
-
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-				  pEntry->AuthMode,
-				  GetAuthMode(pEntry->AuthMode),
-				  pEntry->WepStatus,
-				  GetEncryptType(pEntry->WepStatus),
-				  group_cipher, GetEncryptType(group_cipher)));
-		} else {
-			/* 5. init Group 2-way handshake if necessary. */
-			WPAStart2WayGroupHS(pAd, pEntry);
-
-			pEntry->ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;
-			RTMPModTimer(&pEntry->RetryTimer,
-				     PEER_MSG3_RETRY_EXEC_INTV);
-		}
-	} while (FALSE);
-
-}
-
-/*
-    ==========================================================================
-    Description:
-        This is a function to send the first packet of 2-way groupkey handshake
-    Return:
-
-    ==========================================================================
-*/
-void WPAStart2WayGroupHS(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry)
-{
-	u8 Header802_3[14];
-	u8 TxTsc[6];
-	struct rt_eapol_packet EAPOLPKT;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-	u8 default_key = 0;
-	u8 *gnonce_ptr = NULL;
-	u8 *gtk_ptr = NULL;
-	u8 *pBssid = NULL;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> WPAStart2WayGroupHS\n"));
-
-	if ((!pEntry) || (!pEntry->ValidAsCLI))
-		return;
-
-	do {
-		/* Increment replay counter by 1 */
-		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
-
-		/* Construct EAPoL message - Group Msg 1 */
-		NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-		ConstructEapolMsg(pEntry,
-				  group_cipher,
-				  EAPOL_GROUP_MSG_1,
-				  default_key,
-				  (u8 *) gnonce_ptr,
-				  TxTsc, (u8 *) gtk_ptr, NULL, 0, &EAPOLPKT);
-
-		/* Make outgoing frame */
-		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-		RTMPToWirelessSta(pAd, pEntry,
-				  Header802_3, LENGTH_802_3,
-				  (u8 *)& EAPOLPKT,
-				  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4,
-				  FALSE);
-
-	} while (FALSE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== WPAStart2WayGroupHS : send out Group Message 1 \n"));
-
-	return;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process Group key 2-way handshaking
-
-	Arguments:
-		pAd	Pointer	to our adapter
-		Elem		Message body
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void PeerGroupMsg1Action(struct rt_rtmp_adapter *pAd,
-			 struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Header802_3[14];
-	struct rt_eapol_packet EAPOLPKT;
-	struct rt_eapol_packet * pGroup;
-	u32 MsgLen;
-	BOOLEAN Cancelled;
-	u8 default_key = 0;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-	u8 *pCurrentAddr = NULL;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerGroupMsg1Action \n"));
-
-	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-		return;
-
-	{
-		pCurrentAddr = pAd->CurrentAddress;
-		group_cipher = pAd->StaCfg.GroupCipher;
-		default_key = pAd->StaCfg.DefaultKeyId;
-	}
-
-	/* Process Group Message 1 frame. skip 802.11 header(24) & LLC_SNAP header(8) */
-	pGroup = (struct rt_eapol_packet *) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
-	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
-
-	/* Sanity Check peer group message 1 - Replay Counter, MIC, RSNIE */
-	if (PeerWpaMessageSanity(pAd, pGroup, MsgLen, EAPOL_GROUP_MSG_1, pEntry)
-	    == FALSE)
-		return;
-
-	/* delete retry timer */
-	RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
-
-	/* Save Replay counter, it will use to construct message 2 */
-	NdisMoveMemory(pEntry->R_Counter, pGroup->KeyDesc.ReplayCounter,
-		       LEN_KEY_DESC_REPLAY);
-
-	/* Construct EAPoL message - Group Msg 2 */
-	NdisZeroMemory(&EAPOLPKT, sizeof(struct rt_eapol_packet));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_GROUP_MSG_2, default_key, NULL,	/* Nonce not used */
-			  NULL,	/* TxRSC not used */
-			  NULL,	/* GTK not used */
-			  NULL,	/* RSN IE not used */
-			  0, &EAPOLPKT);
-
-	/* open 802.1x port control and privacy filter */
-	pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
-	pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-
-	STA_PORT_SECURED(pAd);
-	/* Indicate Connected for GUI */
-	pAd->IndicateMediaState = NdisMediaStateConnected;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("PeerGroupMsg1Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
-		  GetAuthMode(pEntry->AuthMode),
-		  GetEncryptType(pEntry->WepStatus),
-		  GetEncryptType(group_cipher)));
-
-	/* init header and Fill Packet and send Msg 2 to authenticator */
-	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
-	RTMPToWirelessSta(pAd, pEntry,
-			  Header802_3, sizeof(Header802_3),
-			  (u8 *)& EAPOLPKT,
-			  CONV_ARRARY_TO_u16(EAPOLPKT.Body_Len) + 4, FALSE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<=== PeerGroupMsg1Action: sned group message 2\n"));
-}
-
-/*
-    ==========================================================================
-    Description:
-        When receiving the last packet of 2-way groupkey handshake.
-    Return:
-    ==========================================================================
-*/
-void PeerGroupMsg2Action(struct rt_rtmp_adapter *pAd,
-			 struct rt_mac_table_entry *pEntry,
-			 void * Msg, u32 MsgLen)
-{
-	u32 Len;
-	u8 *pData;
-	BOOLEAN Cancelled;
-	struct rt_eapol_packet * pMsg2;
-	u8 group_cipher = Ndis802_11WEPDisabled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerGroupMsg2Action \n"));
-
-	do {
-		if ((!pEntry) || (!pEntry->ValidAsCLI))
-			break;
-
-		if (MsgLen <
-		    (LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(struct rt_key_descripter) -
-		     MAX_LEN_OF_RSNIE - 2))
-			break;
-
-		if (pEntry->WpaState != AS_PTKINITDONE)
-			break;
-
-		pData = (u8 *)Msg;
-		pMsg2 = (struct rt_eapol_packet *) (pData + LENGTH_802_1_H);
-		Len = MsgLen - LENGTH_802_1_H;
-
-		/* Sanity Check peer group message 2 - Replay Counter, MIC */
-		if (PeerWpaMessageSanity
-		    (pAd, pMsg2, Len, EAPOL_GROUP_MSG_2, pEntry) == FALSE)
-			break;
-
-		/* 3.  upgrade state */
-
-		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
-		pEntry->GTKState = REKEY_ESTABLISHED;
-
-		if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
-		    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)) {
-			/* send wireless event - for set key done WPA2 */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
-						      pEntry->Addr,
-						      pEntry->apidx, 0);
-
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-				  pEntry->AuthMode,
-				  GetAuthMode(pEntry->AuthMode),
-				  pEntry->WepStatus,
-				  GetEncryptType(pEntry->WepStatus),
-				  group_cipher, GetEncryptType(group_cipher)));
-		} else {
-			/* send wireless event - for set key done WPA */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_SET_KEY_DONE_WPA1_EVENT_FLAG,
-						      pEntry->Addr,
-						      pEntry->apidx, 0);
-
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("AP SETKEYS DONE - WPA1, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-				  pEntry->AuthMode,
-				  GetAuthMode(pEntry->AuthMode),
-				  pEntry->WepStatus,
-				  GetEncryptType(pEntry->WepStatus),
-				  group_cipher, GetEncryptType(group_cipher)));
-		}
-	} while (FALSE);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Classify WPA EAP message type
-
-	Arguments:
-		EAPType		Value of EAP message type
-		MsgType		Internal Message definition for MLME state machine
-
-	Return Value:
-		TRUE		Found appropriate message type
-		FALSE		No appropriate message type
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		All these constants are defined in wpa.h
-		For supplicant, there is only EAPOL Key message available
-
-	========================================================================
-*/
-BOOLEAN WpaMsgTypeSubst(u8 EAPType, int * MsgType)
-{
-	switch (EAPType) {
-	case EAPPacket:
-		*MsgType = MT2_EAPPacket;
-		break;
-	case EAPOLStart:
-		*MsgType = MT2_EAPOLStart;
-		break;
-	case EAPOLLogoff:
-		*MsgType = MT2_EAPOLLogoff;
-		break;
-	case EAPOLKey:
-		*MsgType = MT2_EAPOLKey;
-		break;
-	case EAPOLASFAlert:
-		*MsgType = MT2_EAPOLASFAlert;
-		break;
-	default:
-		return FALSE;
-	}
-	return TRUE;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		The pseudo-random function(PRF) that hashes various inputs to
-		derive a pseudo-random value. To add liveness to the pseudo-random
-		value, a nonce should be one of the inputs.
-
-		It is used to generate PTK, GTK or some specific random value.
-
-	Arguments:
-		u8	*key,		-	the key material for HMAC_SHA1 use
-		int		key_len		-	the length of key
-		u8	*prefix		-	a prefix label
-		int		prefix_len	-	the length of the label
-		u8	*data		-	a specific data with variable length
-		int		data_len	-	the length of a specific data
-		int		len			-	the output length
-
-	Return Value:
-		u8	*output		-	the calculated result
-
-	Note:
-		802.11i-2004	Annex H.3
-
-	========================================================================
-*/
-void PRF(u8 * key,
-	 int key_len,
-	 u8 * prefix,
-	 int prefix_len,
-	 u8 * data, int data_len, u8 * output, int len)
-{
-	int i;
-	u8 *input;
-	int currentindex = 0;
-	int total_len;
-
-	/* Allocate memory for input */
-	os_alloc_mem(NULL, (u8 **) & input, 1024);
-
-	if (input == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("PRF: no memory!\n"));
-		return;
-	}
-	/* Generate concatenation input */
-	NdisMoveMemory(input, prefix, prefix_len);
-
-	/* Concatenate a single octet containing 0 */
-	input[prefix_len] = 0;
-
-	/* Concatenate specific data */
-	NdisMoveMemory(&input[prefix_len + 1], data, data_len);
-	total_len = prefix_len + 1 + data_len;
-
-	/* Concatenate a single octet containing 0 */
-	/* This octet shall be update later */
-	input[total_len] = 0;
-	total_len++;
-
-	/* Iterate to calculate the result by hmac-sha-1 */
-	/* Then concatenate to last result */
-	for (i = 0; i < (len + 19) / 20; i++) {
-		HMAC_SHA1(key, key_len, input, total_len, &output[currentindex],
-			  SHA1_DIGEST_SIZE);
-		currentindex += 20;
-
-		/* update the last octet */
-		input[total_len - 1]++;
-	}
-	os_free_mem(NULL, input);
-}
-
-/*
-* F(P, S, c, i) = U1 xor U2 xor ... Uc
-* U1 = PRF(P, S || Int(i))
-* U2 = PRF(P, U1)
-* Uc = PRF(P, Uc-1)
-*/
-
-static void F(char *password, unsigned char *ssid, int ssidlength,
-	      int iterations, int count, unsigned char *output)
-{
-	unsigned char digest[36], digest1[SHA1_DIGEST_SIZE];
-	int i, j;
-
-	/* U1 = PRF(P, S || int(i)) */
-	memcpy(digest, ssid, ssidlength);
-	digest[ssidlength] = (unsigned char)((count >> 24) & 0xff);
-	digest[ssidlength + 1] = (unsigned char)((count >> 16) & 0xff);
-	digest[ssidlength + 2] = (unsigned char)((count >> 8) & 0xff);
-	digest[ssidlength + 3] = (unsigned char)(count & 0xff);
-	HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest, ssidlength + 4, digest1, SHA1_DIGEST_SIZE);	/* for WPA update */
-
-	/* output = U1 */
-	memcpy(output, digest1, SHA1_DIGEST_SIZE);
-
-	for (i = 1; i < iterations; i++) {
-		/* Un = PRF(P, Un-1) */
-		HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest1, SHA1_DIGEST_SIZE, digest, SHA1_DIGEST_SIZE);	/* for WPA update */
-		memcpy(digest1, digest, SHA1_DIGEST_SIZE);
-
-		/* output = output xor Un */
-		for (j = 0; j < SHA1_DIGEST_SIZE; j++) {
-			output[j] ^= digest[j];
-		}
-	}
-}
-
-/*
-* password - ascii string up to 63 characters in length
-* ssid - octet string up to 32 octets
-* ssidlength - length of ssid in octets
-* output must be 40 octets in length and outputs 256 bits of key
-*/
-int PasswordHash(char *password, u8 *ssid, int ssidlength, u8 *output)
-{
-	if ((strlen(password) > 63) || (ssidlength > 32))
-		return 0;
-
-	F(password, ssid, ssidlength, 4096, 1, output);
-	F(password, ssid, ssidlength, 4096, 2, &output[SHA1_DIGEST_SIZE]);
-	return 1;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		It utilizes PRF-384 or PRF-512 to derive session-specific keys from a PMK.
-		It shall be called by 4-way handshake processing.
-
-	Arguments:
-		pAd	-	pointer to our pAdapter context
-		PMK		-	pointer to PMK
-		ANonce	-	pointer to ANonce
-		AA		-	pointer to Authenticator Address
-		SNonce	-	pointer to SNonce
-		SA		-	pointer to Supplicant Address
-		len		-	indicate the length of PTK (octet)
-
-	Return Value:
-		Output		pointer to the PTK
-
-	Note:
-		Refer to IEEE 802.11i-2004 8.5.1.2
-
-	========================================================================
-*/
-void WpaDerivePTK(struct rt_rtmp_adapter *pAd,
-		  u8 * PMK,
-		  u8 * ANonce,
-		  u8 * AA,
-		  u8 * SNonce,
-		  u8 * SA, u8 * output, u32 len)
-{
-	u8 concatenation[76];
-	u32 CurrPos = 0;
-	u8 temp[32];
-	u8 Prefix[] =
-	    { 'P', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 'k', 'e', 'y', ' ',
-		'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'
-	};
-
-	/* initiate the concatenation input */
-	NdisZeroMemory(temp, sizeof(temp));
-	NdisZeroMemory(concatenation, 76);
-
-	/* Get smaller address */
-	if (RTMPCompareMemory(SA, AA, 6) == 1)
-		NdisMoveMemory(concatenation, AA, 6);
-	else
-		NdisMoveMemory(concatenation, SA, 6);
-	CurrPos += 6;
-
-	/* Get larger address */
-	if (RTMPCompareMemory(SA, AA, 6) == 1)
-		NdisMoveMemory(&concatenation[CurrPos], SA, 6);
-	else
-		NdisMoveMemory(&concatenation[CurrPos], AA, 6);
-
-	/* store the larger mac address for backward compatible of */
-	/* ralink proprietary STA-key issue */
-	NdisMoveMemory(temp, &concatenation[CurrPos], MAC_ADDR_LEN);
-	CurrPos += 6;
-
-	/* Get smaller Nonce */
-	if (RTMPCompareMemory(ANonce, SNonce, 32) == 0)
-		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	/* patch for ralink proprietary STA-key issue */
-	else if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
-		NdisMoveMemory(&concatenation[CurrPos], SNonce, 32);
-	else
-		NdisMoveMemory(&concatenation[CurrPos], ANonce, 32);
-	CurrPos += 32;
-
-	/* Get larger Nonce */
-	if (RTMPCompareMemory(ANonce, SNonce, 32) == 0)
-		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	/* patch for ralink proprietary STA-key issue */
-	else if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
-		NdisMoveMemory(&concatenation[CurrPos], ANonce, 32);
-	else
-		NdisMoveMemory(&concatenation[CurrPos], SNonce, 32);
-	CurrPos += 32;
-
-	hex_dump("concatenation=", concatenation, 76);
-
-	/* Use PRF to generate PTK */
-	PRF(PMK, LEN_MASTER_KEY, Prefix, 22, concatenation, 76, output, len);
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Generate random number by software.
-
-	Arguments:
-		pAd		-	pointer to our pAdapter context
-		macAddr	-	pointer to local MAC address
-
-	Return Value:
-
-	Note:
-		802.1ii-2004  Annex H.5
-
-	========================================================================
-*/
-void GenRandom(struct rt_rtmp_adapter *pAd, u8 * macAddr, u8 * random)
-{
-	int i, curr;
-	u8 local[80], KeyCounter[32];
-	u8 result[80];
-	unsigned long CurrentTime;
-	u8 prefix[] =
-	    { 'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r' };
-
-	/* Zero the related information */
-	NdisZeroMemory(result, 80);
-	NdisZeroMemory(local, 80);
-	NdisZeroMemory(KeyCounter, 32);
-
-	for (i = 0; i < 32; i++) {
-		/* copy the local MAC address */
-		COPY_MAC_ADDR(local, macAddr);
-		curr = MAC_ADDR_LEN;
-
-		/* concatenate the current time */
-		NdisGetSystemUpTime(&CurrentTime);
-		NdisMoveMemory(&local[curr], &CurrentTime, sizeof(CurrentTime));
-		curr += sizeof(CurrentTime);
-
-		/* concatenate the last result */
-		NdisMoveMemory(&local[curr], result, 32);
-		curr += 32;
-
-		/* concatenate a variable */
-		NdisMoveMemory(&local[curr], &i, 2);
-		curr += 2;
-
-		/* calculate the result */
-		PRF(KeyCounter, 32, prefix, 12, local, curr, result, 32);
-	}
-
-	NdisMoveMemory(random, result, 32);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Build cipher suite in RSN-IE.
-		It only shall be called by RTMPMakeRSNIE.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	ElementID	-	indicate the WPA1 or WPA2
-	WepStatus	-	indicate the encryption type
-		bMixCipher	-	a boolean to indicate the pairwise cipher and group
-						cipher are the same or not
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-static void RTMPMakeRsnIeCipher(struct rt_rtmp_adapter *pAd,
-				u8 ElementID,
-				u32 WepStatus,
-				IN BOOLEAN bMixCipher,
-				u8 FlexibleCipher,
-				u8 *pRsnIe, u8 * rsn_len)
-{
-	u8 PairwiseCnt;
-
-	*rsn_len = 0;
-
-	/* decide WPA2 or WPA1 */
-	if (ElementID == Wpa2Ie) {
-		struct rt_rsnie2 *pRsnie_cipher = (struct rt_rsnie2 *)pRsnIe;
-
-		/* Assign the verson as 1 */
-		pRsnie_cipher->version = 1;
-
-		switch (WepStatus) {
-			/* TKIP mode */
-		case Ndis802_11Encryption2Enabled:
-			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
-			pRsnie_cipher->ucount = 1;
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-				       OUI_WPA2_TKIP, 4);
-			*rsn_len = sizeof(struct rt_rsnie2);
-			break;
-
-			/* AES mode */
-		case Ndis802_11Encryption3Enabled:
-			if (bMixCipher)
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA2_TKIP, 4);
-			else
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA2_CCMP, 4);
-			pRsnie_cipher->ucount = 1;
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-				       OUI_WPA2_CCMP, 4);
-			*rsn_len = sizeof(struct rt_rsnie2);
-			break;
-
-			/* TKIP-AES mix mode */
-		case Ndis802_11Encryption4Enabled:
-			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
-
-			PairwiseCnt = 1;
-			/* Insert WPA2 TKIP as the first pairwise cipher */
-			if (MIX_CIPHER_WPA2_TKIP_ON(FlexibleCipher)) {
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-					       OUI_WPA2_TKIP, 4);
-				/* Insert WPA2 AES as the secondary pairwise cipher */
-				if (MIX_CIPHER_WPA2_AES_ON(FlexibleCipher)) {
-					NdisMoveMemory(pRsnie_cipher->ucast[0].
-						       oui + 4, OUI_WPA2_CCMP,
-						       4);
-					PairwiseCnt = 2;
-				}
-			} else {
-				/* Insert WPA2 AES as the first pairwise cipher */
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-					       OUI_WPA2_CCMP, 4);
-			}
-
-			pRsnie_cipher->ucount = PairwiseCnt;
-			*rsn_len = sizeof(struct rt_rsnie2) + (4 * (PairwiseCnt - 1));
-			break;
-		}
-
-		if ((pAd->OpMode == OPMODE_STA) &&
-		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
-		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)) {
-			u32 GroupCipher = pAd->StaCfg.GroupCipher;
-			switch (GroupCipher) {
-			case Ndis802_11GroupWEP40Enabled:
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA2_WEP40, 4);
-				break;
-			case Ndis802_11GroupWEP104Enabled:
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA2_WEP104, 4);
-				break;
-			}
-		}
-		/* swap for big-endian platform */
-		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
-		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
-	} else {
-		struct rt_rsnie *pRsnie_cipher = (struct rt_rsnie *)pRsnIe;
-
-		/* Assign OUI and version */
-		NdisMoveMemory(pRsnie_cipher->oui, OUI_WPA_VERSION, 4);
-		pRsnie_cipher->version = 1;
-
-		switch (WepStatus) {
-			/* TKIP mode */
-		case Ndis802_11Encryption2Enabled:
-			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
-			pRsnie_cipher->ucount = 1;
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-				       OUI_WPA_TKIP, 4);
-			*rsn_len = sizeof(struct rt_rsnie);
-			break;
-
-			/* AES mode */
-		case Ndis802_11Encryption3Enabled:
-			if (bMixCipher)
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA_TKIP, 4);
-			else
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA_CCMP, 4);
-			pRsnie_cipher->ucount = 1;
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-				       OUI_WPA_CCMP, 4);
-			*rsn_len = sizeof(struct rt_rsnie);
-			break;
-
-			/* TKIP-AES mix mode */
-		case Ndis802_11Encryption4Enabled:
-			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
-
-			PairwiseCnt = 1;
-			/* Insert WPA TKIP as the first pairwise cipher */
-			if (MIX_CIPHER_WPA_TKIP_ON(FlexibleCipher)) {
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-					       OUI_WPA_TKIP, 4);
-				/* Insert WPA AES as the secondary pairwise cipher */
-				if (MIX_CIPHER_WPA_AES_ON(FlexibleCipher)) {
-					NdisMoveMemory(pRsnie_cipher->ucast[0].
-						       oui + 4, OUI_WPA_CCMP,
-						       4);
-					PairwiseCnt = 2;
-				}
-			} else {
-				/* Insert WPA AES as the first pairwise cipher */
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
-					       OUI_WPA_CCMP, 4);
-			}
-
-			pRsnie_cipher->ucount = PairwiseCnt;
-			*rsn_len = sizeof(struct rt_rsnie) + (4 * (PairwiseCnt - 1));
-			break;
-		}
-
-		if ((pAd->OpMode == OPMODE_STA) &&
-		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
-		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)) {
-			u32 GroupCipher = pAd->StaCfg.GroupCipher;
-			switch (GroupCipher) {
-			case Ndis802_11GroupWEP40Enabled:
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA_WEP40, 4);
-				break;
-			case Ndis802_11GroupWEP104Enabled:
-				NdisMoveMemory(pRsnie_cipher->mcast,
-					       OUI_WPA_WEP104, 4);
-				break;
-			}
-		}
-		/* swap for big-endian platform */
-		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
-		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Build AKM suite in RSN-IE.
-		It only shall be called by RTMPMakeRSNIE.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	ElementID	-	indicate the WPA1 or WPA2
-	AuthMode	-	indicate the authentication mode
-		apidx		-	indicate the interface index
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-static void RTMPMakeRsnIeAKM(struct rt_rtmp_adapter *pAd,
-			     u8 ElementID,
-			     u32 AuthMode,
-			     u8 apidx,
-			     u8 *pRsnIe, u8 * rsn_len)
-{
-	struct rt_rsnie_auth *pRsnie_auth;
-	u8 AkmCnt = 1;	/* default as 1 */
-
-	pRsnie_auth = (struct rt_rsnie_auth *) (pRsnIe + (*rsn_len));
-
-	/* decide WPA2 or WPA1 */
-	if (ElementID == Wpa2Ie) {
-
-		switch (AuthMode) {
-		case Ndis802_11AuthModeWPA2:
-		case Ndis802_11AuthModeWPA1WPA2:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui,
-				       OUI_WPA2_8021X_AKM, 4);
-			break;
-
-		case Ndis802_11AuthModeWPA2PSK:
-		case Ndis802_11AuthModeWPA1PSKWPA2PSK:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui,
-				       OUI_WPA2_PSK_AKM, 4);
-			break;
-		default:
-			AkmCnt = 0;
-			break;
-
-		}
-	} else {
-		switch (AuthMode) {
-		case Ndis802_11AuthModeWPA:
-		case Ndis802_11AuthModeWPA1WPA2:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui,
-				       OUI_WPA_8021X_AKM, 4);
-			break;
-
-		case Ndis802_11AuthModeWPAPSK:
-		case Ndis802_11AuthModeWPA1PSKWPA2PSK:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui,
-				       OUI_WPA_PSK_AKM, 4);
-			break;
-
-		case Ndis802_11AuthModeWPANone:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui,
-				       OUI_WPA_NONE_AKM, 4);
-			break;
-		default:
-			AkmCnt = 0;
-			break;
-		}
-	}
-
-	pRsnie_auth->acount = AkmCnt;
-	pRsnie_auth->acount = cpu2le16(pRsnie_auth->acount);
-
-	/* update current RSNIE length */
-	(*rsn_len) += (sizeof(struct rt_rsnie_auth) + (4 * (AkmCnt - 1)));
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Build capability in RSN-IE.
-		It only shall be called by RTMPMakeRSNIE.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	ElementID	-	indicate the WPA1 or WPA2
-		apidx		-	indicate the interface index
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-static void RTMPMakeRsnIeCap(struct rt_rtmp_adapter *pAd,
-			     u8 ElementID,
-			     u8 apidx,
-			     u8 *pRsnIe, u8 * rsn_len)
-{
-	RSN_CAPABILITIES *pRSN_Cap;
-
-	/* it could be ignored in WPA1 mode */
-	if (ElementID == WpaIe)
-		return;
-
-	pRSN_Cap = (RSN_CAPABILITIES *) (pRsnIe + (*rsn_len));
-
-	pRSN_Cap->word = cpu2le16(pRSN_Cap->word);
-
-	(*rsn_len) += sizeof(RSN_CAPABILITIES);	/* update current RSNIE length */
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Build RSN IE context. It is not included element-ID and length.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	AuthMode	-	indicate the authentication mode
-	WepStatus	-	indicate the encryption type
-		apidx		-	indicate the interface index
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTMPMakeRSNIE(struct rt_rtmp_adapter *pAd,
-		   u32 AuthMode, u32 WepStatus, u8 apidx)
-{
-	u8 *pRsnIe = NULL;	/* primary RSNIE */
-	u8 *rsnielen_cur_p = 0;	/* the length of the primary RSNIE */
-	u8 *rsnielen_ex_cur_p = 0;	/* the length of the secondary RSNIE */
-	u8 PrimaryRsnie;
-	BOOLEAN bMixCipher = FALSE;	/* indicate the pairwise and group cipher are different */
-	u8 p_offset;
-	WPA_MIX_PAIR_CIPHER FlexibleCipher = WPA_TKIPAES_WPA2_TKIPAES;	/* it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode */
-
-	rsnielen_cur_p = NULL;
-	rsnielen_ex_cur_p = NULL;
-
-	{
-		{
-			if (pAd->StaCfg.WpaSupplicantUP !=
-			    WPA_SUPPLICANT_DISABLE) {
-				if (AuthMode < Ndis802_11AuthModeWPA)
-					return;
-			} else {
-				/* Support WPAPSK or WPA2PSK in STA-Infra mode */
-				/* Support WPANone in STA-Adhoc mode */
-				if ((AuthMode != Ndis802_11AuthModeWPAPSK) &&
-				    (AuthMode != Ndis802_11AuthModeWPA2PSK) &&
-				    (AuthMode != Ndis802_11AuthModeWPANone)
-				    )
-					return;
-			}
-
-			DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPMakeRSNIE(STA)\n"));
-
-			/* Zero RSNIE context */
-			pAd->StaCfg.RSNIE_Len = 0;
-			NdisZeroMemory(pAd->StaCfg.RSN_IE, MAX_LEN_OF_RSNIE);
-
-			/* Pointer to RSNIE */
-			rsnielen_cur_p = &pAd->StaCfg.RSNIE_Len;
-			pRsnIe = pAd->StaCfg.RSN_IE;
-
-			bMixCipher = pAd->StaCfg.bMixCipher;
-		}
-	}
-
-	/* indicate primary RSNIE as WPA or WPA2 */
-	if ((AuthMode == Ndis802_11AuthModeWPA) ||
-	    (AuthMode == Ndis802_11AuthModeWPAPSK) ||
-	    (AuthMode == Ndis802_11AuthModeWPANone) ||
-	    (AuthMode == Ndis802_11AuthModeWPA1WPA2) ||
-	    (AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
-		PrimaryRsnie = WpaIe;
-	else
-		PrimaryRsnie = Wpa2Ie;
-
-	{
-		/* Build the primary RSNIE */
-		/* 1. insert cipher suite */
-		RTMPMakeRsnIeCipher(pAd, PrimaryRsnie, WepStatus, bMixCipher,
-				    FlexibleCipher, pRsnIe, &p_offset);
-
-		/* 2. insert AKM */
-		RTMPMakeRsnIeAKM(pAd, PrimaryRsnie, AuthMode, apidx, pRsnIe,
-				 &p_offset);
-
-		/* 3. insert capability */
-		RTMPMakeRsnIeCap(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);
-	}
-
-	/* 4. update the RSNIE length */
-	*rsnielen_cur_p = p_offset;
-
-	hex_dump("The primary RSNIE", pRsnIe, (*rsnielen_cur_p));
-
-}
-
-/*
-    ==========================================================================
-    Description:
-		Check whether the received frame is EAP frame.
-
-	Arguments:
-		pAd				-	pointer to our pAdapter context
-		pEntry			-	pointer to active entry
-		pData			-	the received frame
-		DataByteCount	-	the received frame's length
-		FromWhichBSSID	-	indicate the interface index
-
-    Return:
-         TRUE			-	This frame is EAP frame
-         FALSE			-	otherwise
-    ==========================================================================
-*/
-BOOLEAN RTMPCheckWPAframe(struct rt_rtmp_adapter *pAd,
-			  struct rt_mac_table_entry *pEntry,
-			  u8 *pData,
-			  unsigned long DataByteCount, u8 FromWhichBSSID)
-{
-	unsigned long Body_len;
-	BOOLEAN Cancelled;
-
-	if (DataByteCount < (LENGTH_802_1_H + LENGTH_EAPOL_H))
-		return FALSE;
-
-	/* Skip LLC header */
-	if (NdisEqualMemory(SNAP_802_1H, pData, 6) ||
-	    /* Cisco 1200 AP may send packet with SNAP_BRIDGE_TUNNEL */
-	    NdisEqualMemory(SNAP_BRIDGE_TUNNEL, pData, 6)) {
-		pData += 6;
-	}
-	/* Skip 2-bytes EAPoL type */
-	if (NdisEqualMemory(EAPOL, pData, 2)) {
-		pData += 2;
-	} else
-		return FALSE;
-
-	switch (*(pData + 1)) {
-	case EAPPacket:
-		Body_len = (*(pData + 2) << 8) | (*(pData + 3));
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Receive EAP-Packet frame, TYPE = 0, Length = %ld\n",
-			  Body_len));
-		break;
-	case EAPOLStart:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Receive EAPOL-Start frame, TYPE = 1 \n"));
-		if (pEntry->EnqueueEapolStartTimerRunning !=
-		    EAPOL_START_DISABLE) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Cancel the EnqueueEapolStartTimerRunning \n"));
-			RTMPCancelTimer(&pEntry->EnqueueStartForPSKTimer,
-					&Cancelled);
-			pEntry->EnqueueEapolStartTimerRunning =
-			    EAPOL_START_DISABLE;
-		}
-		break;
-	case EAPOLLogoff:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Receive EAPOLLogoff frame, TYPE = 2 \n"));
-		break;
-	case EAPOLKey:
-		Body_len = (*(pData + 2) << 8) | (*(pData + 3));
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Receive EAPOL-Key frame, TYPE = 3, Length = %ld\n",
-			  Body_len));
-		break;
-	case EAPOLASFAlert:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Receive EAPOLASFAlert frame, TYPE = 4 \n"));
-		break;
-	default:
-		return FALSE;
-
-	}
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-		Report the EAP message type
-
-	Arguments:
-		msg		-	EAPOL_PAIR_MSG_1
-					EAPOL_PAIR_MSG_2
-					EAPOL_PAIR_MSG_3
-					EAPOL_PAIR_MSG_4
-					EAPOL_GROUP_MSG_1
-					EAPOL_GROUP_MSG_2
-
-    Return:
-         message type string
-
-    ==========================================================================
-*/
-char *GetEapolMsgType(char msg)
-{
-	if (msg == EAPOL_PAIR_MSG_1)
-		return "Pairwise Message 1";
-	else if (msg == EAPOL_PAIR_MSG_2)
-		return "Pairwise Message 2";
-	else if (msg == EAPOL_PAIR_MSG_3)
-		return "Pairwise Message 3";
-	else if (msg == EAPOL_PAIR_MSG_4)
-		return "Pairwise Message 4";
-	else if (msg == EAPOL_GROUP_MSG_1)
-		return "Group Message 1";
-	else if (msg == EAPOL_GROUP_MSG_2)
-		return "Group Message 2";
-	else
-		return "Invalid Message";
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-    Check Sanity RSN IE of EAPoL message
-
-	Arguments:
-
-	Return Value:
-
-	========================================================================
-*/
-BOOLEAN RTMPCheckRSNIE(struct rt_rtmp_adapter *pAd,
-		       u8 *pData,
-		       u8 DataLen,
-		       struct rt_mac_table_entry *pEntry, u8 * Offset)
-{
-	u8 *pVIE;
-	u8 len;
-	struct rt_eid * pEid;
-	BOOLEAN result = FALSE;
-
-	pVIE = pData;
-	len = DataLen;
-	*Offset = 0;
-
-	while (len > sizeof(struct rt_rsnie2)) {
-		pEid = (struct rt_eid *) pVIE;
-		/* WPA RSN IE */
-		if ((pEid->Eid == IE_WPA)
-		    && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))) {
-			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA
-			     || pEntry->AuthMode == Ndis802_11AuthModeWPAPSK)
-			    &&
-			    (NdisEqualMemory
-			     (pVIE, pEntry->RSN_IE, pEntry->RSNIE_Len))
-			    && (pEntry->RSNIE_Len == (pEid->Len + 2))) {
-				result = TRUE;
-			}
-
-			*Offset += (pEid->Len + 2);
-		}
-		/* WPA2 RSN IE */
-		else if ((pEid->Eid == IE_RSN)
-			 && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3))) {
-			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2
-			     || pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)
-			    && (pEid->Eid == pEntry->RSN_IE[0])
-			    && ((pEid->Len + 2) >= pEntry->RSNIE_Len)
-			    &&
-			    (NdisEqualMemory
-			     (pEid->Octet, &pEntry->RSN_IE[2],
-			      pEntry->RSNIE_Len - 2))) {
-
-				result = TRUE;
-			}
-
-			*Offset += (pEid->Len + 2);
-		} else {
-			break;
-		}
-
-		pVIE += (pEid->Len + 2);
-		len -= (pEid->Len + 2);
-	}
-
-	return result;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-    Parse KEYDATA field.  KEYDATA[] May contain 2 RSN IE and optionally GTK.
-    GTK  is encaptulated in KDE format at  p.83 802.11i D10
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-        802.11i D10
-
-	========================================================================
-*/
-BOOLEAN RTMPParseEapolKeyData(struct rt_rtmp_adapter *pAd,
-			      u8 *pKeyData,
-			      u8 KeyDataLen,
-			      u8 GroupKeyIndex,
-			      u8 MsgType,
-			      IN BOOLEAN bWPA2, struct rt_mac_table_entry *pEntry)
-{
-	struct rt_kde_encap * pKDE = NULL;
-	u8 *pMyKeyData = pKeyData;
-	u8 KeyDataLength = KeyDataLen;
-	u8 GTKLEN = 0;
-	u8 DefaultIdx = 0;
-	u8 skip_offset;
-
-	/* Verify The RSN IE contained in pairewise_msg_2 && pairewise_msg_3 and skip it */
-	if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_3) {
-		/* Check RSN IE whether it is WPA2/WPA2PSK */
-		if (!RTMPCheckRSNIE
-		    (pAd, pKeyData, KeyDataLen, pEntry, &skip_offset)) {
-			/* send wireless event - for RSN IE different */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_RSNIE_DIFF_EVENT_FLAG,
-						      pEntry->Addr,
-						      pEntry->apidx, 0);
-
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("RSN_IE Different in msg %d of 4-way handshake!\n",
-				  MsgType));
-			hex_dump("Receive RSN_IE ", pKeyData, KeyDataLen);
-			hex_dump("Desired RSN_IE ", pEntry->RSN_IE,
-				 pEntry->RSNIE_Len);
-
-			return FALSE;
-		} else {
-			if (bWPA2 && MsgType == EAPOL_PAIR_MSG_3) {
-				WpaShowAllsuite(pMyKeyData, skip_offset);
-
-				/* skip RSN IE */
-				pMyKeyData += skip_offset;
-				KeyDataLength -= skip_offset;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("RTMPParseEapolKeyData ==> WPA2/WPA2PSK RSN IE matched in Msg 3, Length(%d) \n",
-					  skip_offset));
-			} else
-				return TRUE;
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPParseEapolKeyData ==> KeyDataLength %d without RSN_IE \n",
-		  KeyDataLength));
-	/*hex_dump("remain data", pMyKeyData, KeyDataLength); */
-
-	/* Parse EKD format in pairwise_msg_3_WPA2 && group_msg_1_WPA2 */
-	if (bWPA2
-	    && (MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)) {
-		if (KeyDataLength >= 8)	/* KDE format exclude GTK length */
-		{
-			pKDE = (struct rt_kde_encap *) pMyKeyData;
-
-			DefaultIdx = pKDE->GTKEncap.Kid;
-
-			/* Sanity check - KED length */
-			if (KeyDataLength < (pKDE->Len + 2)) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("ERROR: The len from KDE is too short \n"));
-				return FALSE;
-			}
-			/* Get GTK length - refer to IEEE 802.11i-2004 p.82 */
-			GTKLEN = pKDE->Len - 6;
-			if (GTKLEN < LEN_AES_KEY) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("ERROR: GTK Key length is too short (%d) \n",
-					  GTKLEN));
-				return FALSE;
-			}
-
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("ERROR: KDE format length is too short \n"));
-			return FALSE;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("GTK in KDE format ,DefaultKeyID=%d, KeyLen=%d \n",
-			  DefaultIdx, GTKLEN));
-		/* skip it */
-		pMyKeyData += 8;
-		KeyDataLength -= 8;
-
-	} else if (!bWPA2 && MsgType == EAPOL_GROUP_MSG_1) {
-		DefaultIdx = GroupKeyIndex;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("GTK DefaultKeyID=%d \n", DefaultIdx));
-	}
-	/* Sanity check - shared key index must be 1 ~ 3 */
-	if (DefaultIdx < 1 || DefaultIdx > 3) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("ERROR: GTK Key index(%d) is invalid in %s %s \n",
-			  DefaultIdx, ((bWPA2) ? "WPA2" : "WPA"),
-			  GetEapolMsgType(MsgType)));
-		return FALSE;
-	}
-
-	{
-		struct rt_cipher_key *pSharedKey;
-
-		/* set key material, TxMic and RxMic */
-		NdisMoveMemory(pAd->StaCfg.GTK, pMyKeyData, 32);
-		pAd->StaCfg.DefaultKeyId = DefaultIdx;
-
-		pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
-
-		/* Prepare pair-wise key information into shared key table */
-		NdisZeroMemory(pSharedKey, sizeof(struct rt_cipher_key));
-		pSharedKey->KeyLen = LEN_TKIP_EK;
-		NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
-		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16],
-			       LEN_TKIP_RXMICK);
-		NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
-			       LEN_TKIP_TXMICK);
-
-		/* Update Shared Key CipherAlg */
-		pSharedKey->CipherAlg = CIPHER_NONE;
-		if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
-			pSharedKey->CipherAlg = CIPHER_TKIP;
-		else if (pAd->StaCfg.GroupCipher ==
-			 Ndis802_11Encryption3Enabled)
-			pSharedKey->CipherAlg = CIPHER_AES;
-		else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled)
-			pSharedKey->CipherAlg = CIPHER_WEP64;
-		else if (pAd->StaCfg.GroupCipher ==
-			 Ndis802_11GroupWEP104Enabled)
-			pSharedKey->CipherAlg = CIPHER_WEP128;
-
-		/* Update group key information to ASIC Shared Key Table */
-		AsicAddSharedKeyEntry(pAd,
-				      BSS0,
-				      pAd->StaCfg.DefaultKeyId,
-				      pSharedKey->CipherAlg,
-				      pSharedKey->Key,
-				      pSharedKey->TxMic, pSharedKey->RxMic);
-
-		/* Update ASIC WCID attribute table and IVEIV table */
-		RTMPAddWcidAttributeEntry(pAd,
-					  BSS0,
-					  pAd->StaCfg.DefaultKeyId,
-					  pSharedKey->CipherAlg, NULL);
-	}
-
-	return TRUE;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Construct EAPoL message for WPA handshaking
-		Its format is below,
-
-		+--------------------+
-		| Protocol Version	 |  1 octet
-		+--------------------+
-		| Protocol Type		 |	1 octet
-		+--------------------+
-		| Body Length		 |  2 octets
-		+--------------------+
-		| Descriptor Type	 |	1 octet
-		+--------------------+
-		| Key Information    |	2 octets
-		+--------------------+
-		| Key Length	     |  1 octet
-		+--------------------+
-		| Key Repaly Counter |	8 octets
-		+--------------------+
-		| Key Nonce		     |  32 octets
-		+--------------------+
-		| Key IV			 |  16 octets
-		+--------------------+
-		| Key RSC			 |  8 octets
-		+--------------------+
-		| Key ID or Reserved |	8 octets
-		+--------------------+
-		| Key MIC			 |	16 octets
-		+--------------------+
-		| Key Data Length	 |	2 octets
-		+--------------------+
-		| Key Data			 |	n octets
-		+--------------------+
-
-	Arguments:
-		pAd			Pointer	to our adapter
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void ConstructEapolMsg(struct rt_mac_table_entry *pEntry,
-		       u8 GroupKeyWepStatus,
-		       u8 MsgType,
-		       u8 DefaultKeyIdx,
-		       u8 * KeyNonce,
-		       u8 * TxRSC,
-		       u8 * GTK,
-		       u8 * RSNIE,
-		       u8 RSNIE_Len, struct rt_eapol_packet * pMsg)
-{
-	BOOLEAN bWPA2 = FALSE;
-	u8 KeyDescVer;
-
-	/* Choose WPA2 or not */
-	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
-	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
-		bWPA2 = TRUE;
-
-	/* Init Packet and Fill header */
-	pMsg->ProVer = EAPOL_VER;
-	pMsg->ProType = EAPOLKey;
-
-	/* Default 95 bytes, the EAPoL-Key descriptor exclude Key-data field */
-	SET_u16_TO_ARRARY(pMsg->Body_Len, LEN_EAPOL_KEY_MSG);
-
-	/* Fill in EAPoL descriptor */
-	if (bWPA2)
-		pMsg->KeyDesc.Type = WPA2_KEY_DESC;
-	else
-		pMsg->KeyDesc.Type = WPA1_KEY_DESC;
-
-	/* Key Descriptor Version (bits 0-2) specifies the key descriptor version type */
-	{
-		/* Fill in Key information, refer to IEEE Std 802.11i-2004 page 78 */
-		/* When either the pairwise or the group cipher is AES, the DESC_TYPE_AES(2) shall be used. */
-		KeyDescVer =
-		    (((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
-		      || (GroupKeyWepStatus ==
-			  Ndis802_11Encryption3Enabled)) ? (DESC_TYPE_AES)
-		     : (DESC_TYPE_TKIP));
-	}
-
-	pMsg->KeyDesc.KeyInfo.KeyDescVer = KeyDescVer;
-
-	/* Specify Key Type as Group(0) or Pairwise(1) */
-	if (MsgType >= EAPOL_GROUP_MSG_1)
-		pMsg->KeyDesc.KeyInfo.KeyType = GROUPKEY;
-	else
-		pMsg->KeyDesc.KeyInfo.KeyType = PAIRWISEKEY;
-
-	/* Specify Key Index, only group_msg1_WPA1 */
-	if (!bWPA2 && (MsgType >= EAPOL_GROUP_MSG_1))
-		pMsg->KeyDesc.KeyInfo.KeyIndex = DefaultKeyIdx;
-
-	if (MsgType == EAPOL_PAIR_MSG_3)
-		pMsg->KeyDesc.KeyInfo.Install = 1;
-
-	if ((MsgType == EAPOL_PAIR_MSG_1) || (MsgType == EAPOL_PAIR_MSG_3)
-	    || (MsgType == EAPOL_GROUP_MSG_1))
-		pMsg->KeyDesc.KeyInfo.KeyAck = 1;
-
-	if (MsgType != EAPOL_PAIR_MSG_1)
-		pMsg->KeyDesc.KeyInfo.KeyMic = 1;
-
-	if ((bWPA2 && (MsgType >= EAPOL_PAIR_MSG_3)) ||
-	    (!bWPA2 && (MsgType >= EAPOL_GROUP_MSG_1))) {
-		pMsg->KeyDesc.KeyInfo.Secure = 1;
-	}
-
-	if (bWPA2 && ((MsgType == EAPOL_PAIR_MSG_3) ||
-		      (MsgType == EAPOL_GROUP_MSG_1))) {
-		pMsg->KeyDesc.KeyInfo.EKD_DL = 1;
-	}
-	/* key Information element has done. */
-	*(u16 *) (&pMsg->KeyDesc.KeyInfo) =
-	    cpu2le16(*(u16 *) (&pMsg->KeyDesc.KeyInfo));
-
-	/* Fill in Key Length */
-	{
-		if (MsgType >= EAPOL_GROUP_MSG_1) {
-			/* the length of group key cipher */
-			pMsg->KeyDesc.KeyLength[1] =
-			    ((GroupKeyWepStatus ==
-			      Ndis802_11Encryption2Enabled) ? TKIP_GTK_LENGTH :
-			     LEN_AES_KEY);
-		} else {
-			/* the length of pairwise key cipher */
-			pMsg->KeyDesc.KeyLength[1] =
-			    ((pEntry->WepStatus ==
-			      Ndis802_11Encryption2Enabled) ? LEN_TKIP_KEY :
-			     LEN_AES_KEY);
-		}
-	}
-
-	/* Fill in replay counter */
-	NdisMoveMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
-		       LEN_KEY_DESC_REPLAY);
-
-	/* Fill Key Nonce field */
-	/* ANonce : pairwise_msg1 & pairwise_msg3 */
-	/* SNonce : pairwise_msg2 */
-	/* GNonce : group_msg1_wpa1 */
-	if ((MsgType <= EAPOL_PAIR_MSG_3)
-	    || ((!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))))
-		NdisMoveMemory(pMsg->KeyDesc.KeyNonce, KeyNonce,
-			       LEN_KEY_DESC_NONCE);
-
-	/* Fill key IV - WPA2 as 0, WPA1 as random */
-	if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1)) {
-		/* Suggest IV be random number plus some number, */
-		NdisMoveMemory(pMsg->KeyDesc.KeyIv, &KeyNonce[16],
-			       LEN_KEY_DESC_IV);
-		pMsg->KeyDesc.KeyIv[15] += 2;
-	}
-	/* Fill Key RSC field */
-	/* It contains the RSC for the GTK being installed. */
-	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
-	    || (MsgType == EAPOL_GROUP_MSG_1)) {
-		NdisMoveMemory(pMsg->KeyDesc.KeyRsc, TxRSC, 6);
-	}
-	/* Clear Key MIC field for MIC calculation later */
-	NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
-
-	ConstructEapolKeyData(pEntry,
-			      GroupKeyWepStatus,
-			      KeyDescVer,
-			      MsgType,
-			      DefaultKeyIdx, GTK, RSNIE, RSNIE_Len, pMsg);
-
-	/* Calculate MIC and fill in KeyMic Field except Pairwise Msg 1. */
-	if (MsgType != EAPOL_PAIR_MSG_1) {
-		CalculateMIC(KeyDescVer, pEntry->PTK, pMsg);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("===> ConstructEapolMsg for %s %s\n",
-		  ((bWPA2) ? "WPA2" : "WPA"), GetEapolMsgType(MsgType)));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("	     Body length = %d \n",
-		  CONV_ARRARY_TO_u16(pMsg->Body_Len)));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("	     Key length  = %d \n",
-		  CONV_ARRARY_TO_u16(pMsg->KeyDesc.KeyLength)));
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Construct the Key Data field of EAPoL message
-
-	Arguments:
-		pAd			Pointer	to our adapter
-		Elem		Message body
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void ConstructEapolKeyData(struct rt_mac_table_entry *pEntry,
-			   u8 GroupKeyWepStatus,
-			   u8 keyDescVer,
-			   u8 MsgType,
-			   u8 DefaultKeyIdx,
-			   u8 * GTK,
-			   u8 * RSNIE,
-			   u8 RSNIE_LEN, struct rt_eapol_packet * pMsg)
-{
-	u8 *mpool, *Key_Data, *Rc4GTK;
-	u8 ekey[(LEN_KEY_DESC_IV + LEN_EAP_EK)];
-	unsigned long data_offset;
-	BOOLEAN bWPA2Capable = FALSE;
-	struct rt_rtmp_adapter *pAd = pEntry->pAd;
-	BOOLEAN GTK_Included = FALSE;
-
-	/* Choose WPA2 or not */
-	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
-	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
-		bWPA2Capable = TRUE;
-
-	if (MsgType == EAPOL_PAIR_MSG_1 ||
-	    MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)
-		return;
-
-	/* allocate memory pool */
-	os_alloc_mem(NULL, (u8 **) & mpool, 1500);
-
-	if (mpool == NULL)
-		return;
-
-	/* Rc4GTK Len = 512 */
-	Rc4GTK = (u8 *) ROUND_UP(mpool, 4);
-	/* Key_Data Len = 512 */
-	Key_Data = (u8 *) ROUND_UP(Rc4GTK + 512, 4);
-
-	NdisZeroMemory(Key_Data, 512);
-	SET_u16_TO_ARRARY(pMsg->KeyDesc.KeyDataLen, 0);
-	data_offset = 0;
-
-	/* Encapsulate RSNIE in pairwise_msg2 & pairwise_msg3 */
-	if (RSNIE_LEN
-	    && ((MsgType == EAPOL_PAIR_MSG_2)
-		|| (MsgType == EAPOL_PAIR_MSG_3))) {
-		u8 *pmkid_ptr = NULL;
-		u8 pmkid_len = 0;
-
-		RTMPInsertRSNIE(&Key_Data[data_offset],
-				&data_offset,
-				RSNIE, RSNIE_LEN, pmkid_ptr, pmkid_len);
-	}
-
-	/* Encapsulate KDE format in pairwise_msg3_WPA2 & group_msg1_WPA2 */
-	if (bWPA2Capable
-	    && ((MsgType == EAPOL_PAIR_MSG_3)
-		|| (MsgType == EAPOL_GROUP_MSG_1))) {
-		/* Key Data Encapsulation (KDE) format - 802.11i-2004  Figure-43w and Table-20h */
-		Key_Data[data_offset + 0] = 0xDD;
-
-		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
-			Key_Data[data_offset + 1] = 0x16;	/* 4+2+16(OUI+DataType+DataField) */
-		} else {
-			Key_Data[data_offset + 1] = 0x26;	/* 4+2+32(OUI+DataType+DataField) */
-		}
-
-		Key_Data[data_offset + 2] = 0x00;
-		Key_Data[data_offset + 3] = 0x0F;
-		Key_Data[data_offset + 4] = 0xAC;
-		Key_Data[data_offset + 5] = 0x01;
-
-		/* GTK KDE format - 802.11i-2004  Figure-43x */
-		Key_Data[data_offset + 6] = (DefaultKeyIdx & 0x03);
-		Key_Data[data_offset + 7] = 0x00;	/* Reserved Byte */
-
-		data_offset += 8;
-	}
-
-	/* Encapsulate GTK */
-	/* Only for pairwise_msg3_WPA2 and group_msg1 */
-	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2Capable)
-	    || (MsgType == EAPOL_GROUP_MSG_1)) {
-		/* Fill in GTK */
-		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
-			NdisMoveMemory(&Key_Data[data_offset], GTK,
-				       LEN_AES_KEY);
-			data_offset += LEN_AES_KEY;
-		} else {
-			NdisMoveMemory(&Key_Data[data_offset], GTK,
-				       TKIP_GTK_LENGTH);
-			data_offset += TKIP_GTK_LENGTH;
-		}
-
-		GTK_Included = TRUE;
-	}
-
-	/* This whole key-data field shall be encrypted if a GTK is included. */
-	/* Encrypt the data material in key data field with KEK */
-	if (GTK_Included) {
-		/*hex_dump("GTK_Included", Key_Data, data_offset); */
-
-		if ((keyDescVer == DESC_TYPE_AES)) {
-			u8 remainder = 0;
-			u8 pad_len = 0;
-
-			/* Key Descriptor Version 2 or 3: AES key wrap, defined in IETF RFC 3394, */
-			/* shall be used to encrypt the Key Data field using the KEK field from */
-			/* the derived PTK. */
-
-			/* If the Key Data field uses the NIST AES key wrap, then the Key Data field */
-			/* shall be padded before encrypting if the key data length is less than 16 */
-			/* octets or if it is not a multiple of 8. The padding consists of appending */
-			/* a single octet 0xdd followed by zero or more 0x00 octets. */
-			if ((remainder = data_offset & 0x07) != 0) {
-				int i;
-
-				pad_len = (8 - remainder);
-				Key_Data[data_offset] = 0xDD;
-				for (i = 1; i < pad_len; i++)
-					Key_Data[data_offset + i] = 0;
-
-				data_offset += pad_len;
-			}
-
-			AES_GTK_KEY_WRAP(&pEntry->PTK[16], Key_Data,
-					 data_offset, Rc4GTK);
-			/* AES wrap function will grow 8 bytes in length */
-			data_offset += 8;
-		} else {
-			/*      Key Descriptor Version 1: ARC4 is used to encrypt the Key Data field
-			   using the KEK field from the derived PTK. */
-
-			/* PREPARE Encrypted  "Key DATA" field.  (Encrypt GTK with RC4, usinf PTK[16]->[31] as Key, IV-field as IV) */
-			/* put TxTsc in Key RSC field */
-			pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	/*Init crc32. */
-
-			/* ekey is the contanetion of IV-field, and PTK[16]->PTK[31] */
-			NdisMoveMemory(ekey, pMsg->KeyDesc.KeyIv,
-				       LEN_KEY_DESC_IV);
-			NdisMoveMemory(&ekey[LEN_KEY_DESC_IV], &pEntry->PTK[16],
-				       LEN_EAP_EK);
-			ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, ekey, sizeof(ekey));	/*INIT SBOX, KEYLEN+3(IV) */
-			pAd->PrivateInfo.FCSCRC32 =
-			    RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, Key_Data,
-					    data_offset);
-			WPAARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, Rc4GTK,
-					   Key_Data, data_offset);
-		}
-
-		NdisMoveMemory(pMsg->KeyDesc.KeyData, Rc4GTK, data_offset);
-	} else {
-		NdisMoveMemory(pMsg->KeyDesc.KeyData, Key_Data, data_offset);
-	}
-
-	/* Update key data length field and total body length */
-	SET_u16_TO_ARRARY(pMsg->KeyDesc.KeyDataLen, data_offset);
-	INC_u16_TO_ARRARY(pMsg->Body_Len, data_offset);
-
-	os_free_mem(NULL, mpool);
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Calcaulate MIC. It is used during 4-ways handsharking.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	PeerWepStatus	-	indicate the encryption type
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-static void CalculateMIC(u8 KeyDescVer,
-			 u8 * PTK, struct rt_eapol_packet * pMsg)
-{
-	u8 *OutBuffer;
-	unsigned long FrameLen = 0;
-	u8 mic[LEN_KEY_DESC_MIC];
-	u8 digest[80];
-
-	/* allocate memory for MIC calculation */
-	os_alloc_mem(NULL, (u8 **) & OutBuffer, 512);
-
-	if (OutBuffer == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("CalculateMIC: no memory!\n"));
-		return;
-	}
-	/* make a frame for calculating MIC. */
-	MakeOutgoingFrame(OutBuffer, &FrameLen,
-			  CONV_ARRARY_TO_u16(pMsg->Body_Len) + 4, pMsg,
-			  END_OF_ARGS);
-
-	NdisZeroMemory(mic, sizeof(mic));
-
-	/* Calculate MIC */
-	if (KeyDescVer == DESC_TYPE_AES) {
-		HMAC_SHA1(PTK, LEN_EAP_MICK, OutBuffer, FrameLen, digest,
-			  SHA1_DIGEST_SIZE);
-		NdisMoveMemory(mic, digest, LEN_KEY_DESC_MIC);
-	} else {
-		HMAC_MD5(PTK, LEN_EAP_MICK, OutBuffer, FrameLen, mic,
-			 MD5_DIGEST_SIZE);
-	}
-
-	/* store the calculated MIC */
-	NdisMoveMemory(pMsg->KeyDesc.KeyMic, mic, LEN_KEY_DESC_MIC);
-
-	os_free_mem(NULL, OutBuffer);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Some received frames can't decrypt by Asic, so decrypt them by software.
-
-	Arguments:
-		pAd			-	pointer to our pAdapter context
-	PeerWepStatus	-	indicate the encryption type
-
-	Return Value:
-		NDIS_STATUS_SUCCESS		-	decryption successful
-		NDIS_STATUS_FAILURE		-	decryption failure
-
-	========================================================================
-*/
-int RTMPSoftDecryptBroadCastData(struct rt_rtmp_adapter *pAd,
-					 struct rt_rx_blk *pRxBlk,
-					 IN NDIS_802_11_ENCRYPTION_STATUS
-					 GroupCipher, struct rt_cipher_key *pShard_key)
-{
-	struct rt_rxwi * pRxWI = pRxBlk->pRxWI;
-
-	/* handle WEP decryption */
-	if (GroupCipher == Ndis802_11Encryption1Enabled) {
-		if (RTMPSoftDecryptWEP
-		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
-		     pShard_key)) {
-
-			/*Minus IV[4] & ICV[4] */
-			pRxWI->MPDUtotalByteCount -= 8;
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("ERROR : Software decrypt WEP data fails.\n"));
-			/* give up this frame */
-			return NDIS_STATUS_FAILURE;
-		}
-	}
-	/* handle TKIP decryption */
-	else if (GroupCipher == Ndis802_11Encryption2Enabled) {
-		if (RTMPSoftDecryptTKIP
-		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount, 0,
-		     pShard_key)) {
-
-			/*Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV */
-			pRxWI->MPDUtotalByteCount -= 20;
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("ERROR : RTMPSoftDecryptTKIP Failed\n"));
-			/* give up this frame */
-			return NDIS_STATUS_FAILURE;
-		}
-	}
-	/* handle AES decryption */
-	else if (GroupCipher == Ndis802_11Encryption3Enabled) {
-		if (RTMPSoftDecryptAES
-		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
-		     pShard_key)) {
-
-			/*8 bytes MIC, 8 bytes IV/EIV (CCMP Header) */
-			pRxWI->MPDUtotalByteCount -= 16;
-		} else {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("ERROR : RTMPSoftDecryptAES Failed\n"));
-			/* give up this frame */
-			return NDIS_STATUS_FAILURE;
-		}
-	} else {
-		/* give up this frame */
-		return NDIS_STATUS_FAILURE;
-	}
-
-	return NDIS_STATUS_SUCCESS;
-
-}
-
-u8 *GetSuiteFromRSNIE(u8 *rsnie,
-			 u32 rsnie_len, u8 type, u8 * count)
-{
-	struct rt_eid * pEid;
-	int len;
-	u8 *pBuf;
-	int offset = 0;
-	struct rt_rsnie_auth *pAkm;
-	u16 acount;
-	BOOLEAN isWPA2 = FALSE;
-
-	pEid = (struct rt_eid *) rsnie;
-	len = rsnie_len - 2;	/* exclude IE and length */
-	pBuf = (u8 *)& pEid->Octet[0];
-
-	/* set default value */
-	*count = 0;
-
-	/* Check length */
-	if ((len <= 0) || (pEid->Len != len)) {
-		DBGPRINT_ERR("%s : The length is invalid\n", __func__);
-		return NULL;
-	}
-	/* Check WPA or WPA2 */
-	if (pEid->Eid == IE_WPA) {
-		struct rt_rsnie *pRsnie = (struct rt_rsnie *)pBuf;
-		u16 ucount;
-
-		if (len < sizeof(struct rt_rsnie)) {
-			DBGPRINT_ERR("%s : The length is too short for WPA\n", __func__);
-			return NULL;
-		}
-		/* Get the count of pairwise cipher */
-		ucount = cpu2le16(pRsnie->ucount);
-		if (ucount > 2) {
-			DBGPRINT_ERR("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount);
-			return NULL;
-		}
-		/* Get the group cipher */
-		if (type == GROUP_SUITE) {
-			*count = 1;
-			return pRsnie->mcast;
-		}
-		/* Get the pairwise cipher suite */
-		else if (type == PAIRWISE_SUITE) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s : The count of pairwise cipher is %d\n",
-				  __func__, ucount));
-			*count = ucount;
-			return pRsnie->ucast[0].oui;
-		}
-
-		offset = sizeof(struct rt_rsnie) + (4 * (ucount - 1));
-
-	} else if (pEid->Eid == IE_RSN) {
-		struct rt_rsnie2 *pRsnie = (struct rt_rsnie2 *)pBuf;
-		u16 ucount;
-
-		isWPA2 = TRUE;
-
-		if (len < sizeof(struct rt_rsnie2)) {
-			DBGPRINT_ERR("%s : The length is too short for WPA2\n", __func__);
-			return NULL;
-		}
-		/* Get the count of pairwise cipher */
-		ucount = cpu2le16(pRsnie->ucount);
-		if (ucount > 2) {
-			DBGPRINT_ERR("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount);
-			return NULL;
-		}
-		/* Get the group cipher */
-		if (type == GROUP_SUITE) {
-			*count = 1;
-			return pRsnie->mcast;
-		}
-		/* Get the pairwise cipher suite */
-		else if (type == PAIRWISE_SUITE) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s : The count of pairwise cipher is %d\n",
-				  __func__, ucount));
-			*count = ucount;
-			return pRsnie->ucast[0].oui;
-		}
-
-		offset = sizeof(struct rt_rsnie2) + (4 * (ucount - 1));
-
-	} else {
-		DBGPRINT_ERR("%s : Unknown IE (%d)\n", __func__, pEid->Eid);
-		return NULL;
-	}
-
-	/* skip group cipher and pairwise cipher suite */
-	pBuf += offset;
-	len -= offset;
-
-	if (len < sizeof(struct rt_rsnie_auth)) {
-		DBGPRINT_ERR("%s : The length of RSNIE is too short\n", __func__);
-		return NULL;
-	}
-	/* pointer to AKM count */
-	pAkm = (struct rt_rsnie_auth *)pBuf;
-
-	/* Get the count of pairwise cipher */
-	acount = cpu2le16(pAkm->acount);
-	if (acount > 2) {
-		DBGPRINT_ERR("%s : The count(%d) of AKM is invlaid\n", __func__, acount);
-		return NULL;
-	}
-	/* Get the AKM suite */
-	if (type == AKM_SUITE) {
-		DBGPRINT(RT_DEBUG_TRACE, ("%s : The count of AKM is %d\n",
-					  __func__, acount));
-		*count = acount;
-		return pAkm->auth[0].oui;
-	}
-	offset = sizeof(struct rt_rsnie_auth) + (4 * (acount - 1));
-
-	pBuf += offset;
-	len -= offset;
-
-	/* The remaining length must larger than (RSN-Capability(2) + PMKID-Count(2) + PMKID(16~)) */
-	if (len >= (sizeof(RSN_CAPABILITIES) + 2 + LEN_PMKID)) {
-		/* Skip RSN capability and PMKID-Count */
-		pBuf += (sizeof(RSN_CAPABILITIES) + 2);
-		len -= (sizeof(RSN_CAPABILITIES) + 2);
-
-		/* Get PMKID */
-		if (type == PMKID_LIST) {
-			*count = 1;
-			return pBuf;
-		}
-	} else {
-		DBGPRINT_ERR("%s : it can't get any more information beyond AKM \n", __func__);
-		return NULL;
-	}
-
-	*count = 0;
-	/*DBGPRINT_ERR(("%s : The type(%d) doesn't support \n", __func__, type)); */
-	return NULL;
-
-}
-
-void WpaShowAllsuite(u8 *rsnie, u32 rsnie_len)
-{
-	u8 *pSuite = NULL;
-	u8 count;
-
-	hex_dump("RSNIE", rsnie, rsnie_len);
-
-	/* group cipher */
-	pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, GROUP_SUITE, &count);
-	if (pSuite != NULL) {
-		hex_dump("group cipher", pSuite, 4 * count);
-	}
-	/* pairwise cipher */
-	pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, PAIRWISE_SUITE, &count);
-	if (pSuite != NULL) {
-		hex_dump("pairwise cipher", pSuite, 4 * count);
-	}
-	/* AKM */
-	pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, AKM_SUITE, &count);
-	if (pSuite != NULL) {
-		hex_dump("AKM suite", pSuite, 4 * count);
-	}
-	/* PMKID */
-	pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, PMKID_LIST, &count);
-	if (pSuite != NULL) {
-		hex_dump("PMKID", pSuite, LEN_PMKID);
-	}
-
-}
-
-void RTMPInsertRSNIE(u8 *pFrameBuf,
-		     unsigned long *pFrameLen,
-		     u8 *rsnie_ptr,
-		     u8 rsnie_len,
-		     u8 *pmkid_ptr, u8 pmkid_len)
-{
-	u8 *pTmpBuf;
-	unsigned long TempLen = 0;
-	u8 extra_len = 0;
-	u16 pmk_count = 0;
-	u8 ie_num;
-	u8 total_len = 0;
-	u8 WPA2_OUI[3] = { 0x00, 0x0F, 0xAC };
-
-	pTmpBuf = pFrameBuf;
-
-	/* PMKID-List Must larger than 0 and the multiple of 16. */
-	if (pmkid_len > 0 && ((pmkid_len & 0x0f) == 0)) {
-		extra_len = sizeof(u16)+ pmkid_len;
-
-		pmk_count = (pmkid_len >> 4);
-		pmk_count = cpu2le16(pmk_count);
-	} else {
-		DBGPRINT(RT_DEBUG_WARN,
-			 ("%s : The length is PMKID-List is invalid (%d), so don't insert it.\n",
-			  __func__, pmkid_len));
-	}
-
-	if (rsnie_len != 0) {
-		ie_num = IE_WPA;
-		total_len = rsnie_len;
-
-		if (NdisEqualMemory(rsnie_ptr + 2, WPA2_OUI, sizeof(WPA2_OUI))) {
-			ie_num = IE_RSN;
-			total_len += extra_len;
-		}
-
-		/* construct RSNIE body */
-		MakeOutgoingFrame(pTmpBuf, &TempLen,
-				  1, &ie_num,
-				  1, &total_len,
-				  rsnie_len, rsnie_ptr, END_OF_ARGS);
-
-		pTmpBuf += TempLen;
-		*pFrameLen = *pFrameLen + TempLen;
-
-		if (ie_num == IE_RSN) {
-			/* Insert PMKID-List field */
-			if (extra_len > 0) {
-				MakeOutgoingFrame(pTmpBuf, &TempLen,
-						  2, &pmk_count,
-						  pmkid_len, pmkid_ptr,
-						  END_OF_ARGS);
-
-				pTmpBuf += TempLen;
-				*pFrameLen = *pFrameLen + TempLen;
-			}
-		}
-	}
-
-	return;
-}
diff --git a/drivers/staging/rt2860/common/crypt_hmac.c b/drivers/staging/rt2860/common/crypt_hmac.c
deleted file mode 100644
index d7ab08e..0000000
--- a/drivers/staging/rt2860/common/crypt_hmac.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************/
-
-#include "../crypt_hmac.h"
-
-#ifdef HMAC_SHA1_SUPPORT
-/*
-========================================================================
-Routine Description:
-    HMAC using SHA1 hash function
-
-Arguments:
-    key             Secret key
-    key_len         The length of the key in bytes
-    message         Message context
-    message_len     The length of message in bytes
-    macLen          Request the length of message authentication code
-
-Return Value:
-    mac             Message authentication code
-
-Note:
-    None
-========================================================================
-*/
-void HMAC_SHA1(IN const u8 Key[],
-	       u32 KeyLen,
-	       IN const u8 Message[],
-	       u32 MessageLen, u8 MAC[], u32 MACLen)
-{
-	struct rt_sha1_ctx sha_ctx1;
-	struct rt_sha1_ctx sha_ctx2;
-	u8 K0[SHA1_BLOCK_SIZE];
-	u8 Digest[SHA1_DIGEST_SIZE];
-	u32 index;
-
-	NdisZeroMemory(&sha_ctx1, sizeof(struct rt_sha1_ctx));
-	NdisZeroMemory(&sha_ctx2, sizeof(struct rt_sha1_ctx));
-	/*
-	 * If the length of K = B(Block size): K0 = K.
-	 * If the length of K > B: hash K to obtain an L byte string,
-	 * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
-	 * If the length of K < B: append zeros to the end of K to create a B-byte string K0
-	 */
-	NdisZeroMemory(K0, SHA1_BLOCK_SIZE);
-	if (KeyLen <= SHA1_BLOCK_SIZE)
-		NdisMoveMemory(K0, Key, KeyLen);
-	else
-		RT_SHA1(Key, KeyLen, K0);
-	/* End of if */
-
-	/* Exclusive-Or K0 with ipad */
-	/* ipad: Inner pad; the byte x36 repeated B times. */
-	for (index = 0; index < SHA1_BLOCK_SIZE; index++)
-		K0[index] ^= 0x36;
-	/* End of for */
-
-	RT_SHA1_Init(&sha_ctx1);
-	/* H(K0^ipad) */
-	SHA1_Append(&sha_ctx1, K0, sizeof(K0));
-	/* H((K0^ipad)||text) */
-	SHA1_Append(&sha_ctx1, Message, MessageLen);
-	SHA1_End(&sha_ctx1, Digest);
-
-	/* Exclusive-Or K0 with opad and remove ipad */
-	/* opad: Outer pad; the byte x5c repeated B times. */
-	for (index = 0; index < SHA1_BLOCK_SIZE; index++)
-		K0[index] ^= 0x36 ^ 0x5c;
-	/* End of for */
-
-	RT_SHA1_Init(&sha_ctx2);
-	/* H(K0^opad) */
-	SHA1_Append(&sha_ctx2, K0, sizeof(K0));
-	/* H( (K0^opad) || H((K0^ipad)||text) ) */
-	SHA1_Append(&sha_ctx2, Digest, SHA1_DIGEST_SIZE);
-	SHA1_End(&sha_ctx2, Digest);
-
-	if (MACLen > SHA1_DIGEST_SIZE)
-		NdisMoveMemory(MAC, Digest, SHA1_DIGEST_SIZE);
-	else
-		NdisMoveMemory(MAC, Digest, MACLen);
-}				/* End of HMAC_SHA1 */
-#endif /* HMAC_SHA1_SUPPORT */
-
-#ifdef HMAC_MD5_SUPPORT
-/*
-========================================================================
-Routine Description:
-    HMAC using MD5 hash function
-
-Arguments:
-    key             Secret key
-    key_len         The length of the key in bytes
-    message         Message context
-    message_len     The length of message in bytes
-    macLen          Request the length of message authentication code
-
-Return Value:
-    mac             Message authentication code
-
-Note:
-    None
-========================================================================
-*/
-void HMAC_MD5(IN const u8 Key[],
-	      u32 KeyLen,
-	      IN const u8 Message[],
-	      u32 MessageLen, u8 MAC[], u32 MACLen)
-{
-	struct rt_md5_ctx_struc md5_ctx1;
-	struct rt_md5_ctx_struc md5_ctx2;
-	u8 K0[MD5_BLOCK_SIZE];
-	u8 Digest[MD5_DIGEST_SIZE];
-	u32 index;
-
-	NdisZeroMemory(&md5_ctx1, sizeof(struct rt_md5_ctx_struc));
-	NdisZeroMemory(&md5_ctx2, sizeof(struct rt_md5_ctx_struc));
-	/*
-	 * If the length of K = B(Block size): K0 = K.
-	 * If the length of K > B: hash K to obtain an L byte string,
-	 * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
-	 * If the length of K < B: append zeros to the end of K to create a B-byte string K0
-	 */
-	NdisZeroMemory(K0, MD5_BLOCK_SIZE);
-	if (KeyLen <= MD5_BLOCK_SIZE) {
-		NdisMoveMemory(K0, Key, KeyLen);
-	} else {
-		RT_MD5(Key, KeyLen, K0);
-	}
-
-	/* Exclusive-Or K0 with ipad */
-	/* ipad: Inner pad; the byte x36 repeated B times. */
-	for (index = 0; index < MD5_BLOCK_SIZE; index++)
-		K0[index] ^= 0x36;
-	/* End of for */
-
-	MD5_Init(&md5_ctx1);
-	/* H(K0^ipad) */
-	MD5_Append(&md5_ctx1, K0, sizeof(K0));
-	/* H((K0^ipad)||text) */
-	MD5_Append(&md5_ctx1, Message, MessageLen);
-	MD5_End(&md5_ctx1, Digest);
-
-	/* Exclusive-Or K0 with opad and remove ipad */
-	/* opad: Outer pad; the byte x5c repeated B times. */
-	for (index = 0; index < MD5_BLOCK_SIZE; index++)
-		K0[index] ^= 0x36 ^ 0x5c;
-	/* End of for */
-
-	MD5_Init(&md5_ctx2);
-	/* H(K0^opad) */
-	MD5_Append(&md5_ctx2, K0, sizeof(K0));
-	/* H( (K0^opad) || H((K0^ipad)||text) ) */
-	MD5_Append(&md5_ctx2, Digest, MD5_DIGEST_SIZE);
-	MD5_End(&md5_ctx2, Digest);
-
-	if (MACLen > MD5_DIGEST_SIZE)
-		NdisMoveMemory(MAC, Digest, MD5_DIGEST_SIZE);
-	else
-		NdisMoveMemory(MAC, Digest, MACLen);
-}				/* End of HMAC_SHA256 */
-#endif /* HMAC_MD5_SUPPORT */
-
-/* End of crypt_hmac.c */
diff --git a/drivers/staging/rt2860/common/crypt_md5.c b/drivers/staging/rt2860/common/crypt_md5.c
deleted file mode 100644
index 6deab65..0000000
--- a/drivers/staging/rt2860/common/crypt_md5.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************/
-
-#include "../crypt_md5.h"
-
-#ifdef MD5_SUPPORT
-/*
- * F, G, H and I are basic MD5 functions.
- */
-#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
-#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
-#define H(x, y, z) ((x) ^ (y) ^ (z))
-#define I(x, y, z) ((y) ^ ((x) | (~z)))
-
-#define ROTL(x,n,w) ((x << n) | (x >> (w - n)))
-#define ROTL32(x,n) ROTL(x,n,32)	/* 32 bits word */
-
-#define ROUND1(a, b, c, d, x, s, ac) {          \
-    (a) += F((b),(c),(d)) + (x) + (u32)(ac); \
-    (a)  = ROTL32((a),(s));                     \
-    (a) += (b);                                 \
-}
-#define ROUND2(a, b, c, d, x, s, ac) {          \
-    (a) += G((b),(c),(d)) + (x) + (u32)(ac); \
-    (a)  = ROTL32((a),(s));                     \
-    (a) += (b);                                 \
-}
-#define ROUND3(a, b, c, d, x, s, ac) {          \
-    (a) += H((b),(c),(d)) + (x) + (u32)(ac); \
-    (a)  = ROTL32((a),(s));                     \
-    (a) += (b);                                 \
-}
-#define ROUND4(a, b, c, d, x, s, ac) {          \
-    (a) += I((b),(c),(d)) + (x) + (u32)(ac); \
-    (a)  = ROTL32((a),(s));                     \
-    (a) += (b);                                 \
-}
-static const u32 MD5_DefaultHashValue[4] = {
-	0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL
-};
-#endif /* MD5_SUPPORT */
-
-#ifdef MD5_SUPPORT
-/*
-========================================================================
-Routine Description:
-    Initial Md5_CTX_STRUC
-
-Arguments:
-    pMD5_CTX        Pointer to Md5_CTX_STRUC
-
-Return Value:
-    None
-
-Note:
-    None
-========================================================================
-*/
-void MD5_Init(struct rt_md5_ctx_struc *pMD5_CTX)
-{
-	NdisMoveMemory(pMD5_CTX->HashValue, MD5_DefaultHashValue,
-		       sizeof(MD5_DefaultHashValue));
-	NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
-	pMD5_CTX->BlockLen = 0;
-	pMD5_CTX->MessageLen = 0;
-}				/* End of MD5_Init */
-
-/*
-========================================================================
-Routine Description:
-    MD5 computation for one block (512 bits)
-
-Arguments:
-    pMD5_CTX        Pointer to Md5_CTX_STRUC
-
-Return Value:
-    None
-
-Note:
-    T[i] := floor(abs(sin(i + 1)) * (2 pow 32)), i is number of round
-========================================================================
-*/
-void MD5_Hash(struct rt_md5_ctx_struc *pMD5_CTX)
-{
-	u32 X_i;
-	u32 X[16];
-	u32 a, b, c, d;
-
-	/* Prepare the message schedule, {X_i} */
-	NdisMoveMemory(X, pMD5_CTX->Block, MD5_BLOCK_SIZE);
-	for (X_i = 0; X_i < 16; X_i++)
-		X[X_i] = cpu2le32(X[X_i]);	/* Endian Swap */
-	/* End of for */
-
-	/* MD5 hash computation */
-	/* Initialize the working variables */
-	a = pMD5_CTX->HashValue[0];
-	b = pMD5_CTX->HashValue[1];
-	c = pMD5_CTX->HashValue[2];
-	d = pMD5_CTX->HashValue[3];
-
-	/*
-	 *  Round 1
-	 *  Let [abcd k s i] denote the operation
-	 *  a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
-	 */
-	ROUND1(a, b, c, d, X[0], 7, 0xd76aa478);	/* 1 */
-	ROUND1(d, a, b, c, X[1], 12, 0xe8c7b756);	/* 2 */
-	ROUND1(c, d, a, b, X[2], 17, 0x242070db);	/* 3 */
-	ROUND1(b, c, d, a, X[3], 22, 0xc1bdceee);	/* 4 */
-	ROUND1(a, b, c, d, X[4], 7, 0xf57c0faf);	/* 5 */
-	ROUND1(d, a, b, c, X[5], 12, 0x4787c62a);	/* 6 */
-	ROUND1(c, d, a, b, X[6], 17, 0xa8304613);	/* 7 */
-	ROUND1(b, c, d, a, X[7], 22, 0xfd469501);	/* 8 */
-	ROUND1(a, b, c, d, X[8], 7, 0x698098d8);	/* 9 */
-	ROUND1(d, a, b, c, X[9], 12, 0x8b44f7af);	/* 10 */
-	ROUND1(c, d, a, b, X[10], 17, 0xffff5bb1);	/* 11 */
-	ROUND1(b, c, d, a, X[11], 22, 0x895cd7be);	/* 12 */
-	ROUND1(a, b, c, d, X[12], 7, 0x6b901122);	/* 13 */
-	ROUND1(d, a, b, c, X[13], 12, 0xfd987193);	/* 14 */
-	ROUND1(c, d, a, b, X[14], 17, 0xa679438e);	/* 15 */
-	ROUND1(b, c, d, a, X[15], 22, 0x49b40821);	/* 16 */
-
-	/*
-	 *  Round 2
-	 *  Let [abcd k s i] denote the operation
-	 *  a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
-	 */
-	ROUND2(a, b, c, d, X[1], 5, 0xf61e2562);	/* 17 */
-	ROUND2(d, a, b, c, X[6], 9, 0xc040b340);	/* 18 */
-	ROUND2(c, d, a, b, X[11], 14, 0x265e5a51);	/* 19 */
-	ROUND2(b, c, d, a, X[0], 20, 0xe9b6c7aa);	/* 20 */
-	ROUND2(a, b, c, d, X[5], 5, 0xd62f105d);	/* 21 */
-	ROUND2(d, a, b, c, X[10], 9, 0x2441453);	/* 22 */
-	ROUND2(c, d, a, b, X[15], 14, 0xd8a1e681);	/* 23 */
-	ROUND2(b, c, d, a, X[4], 20, 0xe7d3fbc8);	/* 24 */
-	ROUND2(a, b, c, d, X[9], 5, 0x21e1cde6);	/* 25 */
-	ROUND2(d, a, b, c, X[14], 9, 0xc33707d6);	/* 26 */
-	ROUND2(c, d, a, b, X[3], 14, 0xf4d50d87);	/* 27 */
-	ROUND2(b, c, d, a, X[8], 20, 0x455a14ed);	/* 28 */
-	ROUND2(a, b, c, d, X[13], 5, 0xa9e3e905);	/* 29 */
-	ROUND2(d, a, b, c, X[2], 9, 0xfcefa3f8);	/* 30 */
-	ROUND2(c, d, a, b, X[7], 14, 0x676f02d9);	/* 31 */
-	ROUND2(b, c, d, a, X[12], 20, 0x8d2a4c8a);	/* 32 */
-
-	/*
-	 *  Round 3
-	 *  Let [abcd k s t] denote the operation
-	 *  a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
-	 */
-	ROUND3(a, b, c, d, X[5], 4, 0xfffa3942);	/* 33 */
-	ROUND3(d, a, b, c, X[8], 11, 0x8771f681);	/* 34 */
-	ROUND3(c, d, a, b, X[11], 16, 0x6d9d6122);	/* 35 */
-	ROUND3(b, c, d, a, X[14], 23, 0xfde5380c);	/* 36 */
-	ROUND3(a, b, c, d, X[1], 4, 0xa4beea44);	/* 37 */
-	ROUND3(d, a, b, c, X[4], 11, 0x4bdecfa9);	/* 38 */
-	ROUND3(c, d, a, b, X[7], 16, 0xf6bb4b60);	/* 39 */
-	ROUND3(b, c, d, a, X[10], 23, 0xbebfbc70);	/* 40 */
-	ROUND3(a, b, c, d, X[13], 4, 0x289b7ec6);	/* 41 */
-	ROUND3(d, a, b, c, X[0], 11, 0xeaa127fa);	/* 42 */
-	ROUND3(c, d, a, b, X[3], 16, 0xd4ef3085);	/* 43 */
-	ROUND3(b, c, d, a, X[6], 23, 0x4881d05);	/* 44 */
-	ROUND3(a, b, c, d, X[9], 4, 0xd9d4d039);	/* 45 */
-	ROUND3(d, a, b, c, X[12], 11, 0xe6db99e5);	/* 46 */
-	ROUND3(c, d, a, b, X[15], 16, 0x1fa27cf8);	/* 47 */
-	ROUND3(b, c, d, a, X[2], 23, 0xc4ac5665);	/* 48 */
-
-	/*
-	 *  Round 4
-	 *  Let [abcd k s t] denote the operation
-	 *  a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
-	 */
-	ROUND4(a, b, c, d, X[0], 6, 0xf4292244);	/* 49 */
-	ROUND4(d, a, b, c, X[7], 10, 0x432aff97);	/* 50 */
-	ROUND4(c, d, a, b, X[14], 15, 0xab9423a7);	/* 51 */
-	ROUND4(b, c, d, a, X[5], 21, 0xfc93a039);	/* 52 */
-	ROUND4(a, b, c, d, X[12], 6, 0x655b59c3);	/* 53 */
-	ROUND4(d, a, b, c, X[3], 10, 0x8f0ccc92);	/* 54 */
-	ROUND4(c, d, a, b, X[10], 15, 0xffeff47d);	/* 55 */
-	ROUND4(b, c, d, a, X[1], 21, 0x85845dd1);	/* 56 */
-	ROUND4(a, b, c, d, X[8], 6, 0x6fa87e4f);	/* 57 */
-	ROUND4(d, a, b, c, X[15], 10, 0xfe2ce6e0);	/* 58 */
-	ROUND4(c, d, a, b, X[6], 15, 0xa3014314);	/* 59 */
-	ROUND4(b, c, d, a, X[13], 21, 0x4e0811a1);	/* 60 */
-	ROUND4(a, b, c, d, X[4], 6, 0xf7537e82);	/* 61 */
-	ROUND4(d, a, b, c, X[11], 10, 0xbd3af235);	/* 62 */
-	ROUND4(c, d, a, b, X[2], 15, 0x2ad7d2bb);	/* 63 */
-	ROUND4(b, c, d, a, X[9], 21, 0xeb86d391);	/* 64 */
-
-	/* Compute the i^th intermediate hash value H^(i) */
-	pMD5_CTX->HashValue[0] += a;
-	pMD5_CTX->HashValue[1] += b;
-	pMD5_CTX->HashValue[2] += c;
-	pMD5_CTX->HashValue[3] += d;
-
-	NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
-	pMD5_CTX->BlockLen = 0;
-}				/* End of MD5_Hash */
-
-/*
-========================================================================
-Routine Description:
-    The message is appended to block. If block size > 64 bytes, the MD5_Hash
-will be called.
-
-Arguments:
-    pMD5_CTX        Pointer to struct rt_md5_ctx_struc
-    message         Message context
-    messageLen      The length of message in bytes
-
-Return Value:
-    None
-
-Note:
-    None
-========================================================================
-*/
-void MD5_Append(struct rt_md5_ctx_struc *pMD5_CTX,
-		IN const u8 Message[], u32 MessageLen)
-{
-	u32 appendLen = 0;
-	u32 diffLen = 0;
-
-	while (appendLen != MessageLen) {
-		diffLen = MessageLen - appendLen;
-		if ((pMD5_CTX->BlockLen + diffLen) < MD5_BLOCK_SIZE) {
-			NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
-				       Message + appendLen, diffLen);
-			pMD5_CTX->BlockLen += diffLen;
-			appendLen += diffLen;
-		} else {
-			NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
-				       Message + appendLen,
-				       MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
-			appendLen += (MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
-			pMD5_CTX->BlockLen = MD5_BLOCK_SIZE;
-			MD5_Hash(pMD5_CTX);
-		}		/* End of if */
-	}			/* End of while */
-	pMD5_CTX->MessageLen += MessageLen;
-}				/* End of MD5_Append */
-
-/*
-========================================================================
-Routine Description:
-    1. Append bit 1 to end of the message
-    2. Append the length of message in rightmost 64 bits
-    3. Transform the Hash Value to digest message
-
-Arguments:
-    pMD5_CTX        Pointer to struct rt_md5_ctx_struc
-
-Return Value:
-    digestMessage   Digest message
-
-Note:
-    None
-========================================================================
-*/
-void MD5_End(struct rt_md5_ctx_struc *pMD5_CTX, u8 DigestMessage[])
-{
-	u32 index;
-	u64 message_length_bits;
-
-	/* append 1 bits to end of the message */
-	NdisFillMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen, 1, 0x80);
-
-	/* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
-	if (pMD5_CTX->BlockLen > 55)
-		MD5_Hash(pMD5_CTX);
-	/* End of if */
-
-	/* Append the length of message in rightmost 64 bits */
-	message_length_bits = pMD5_CTX->MessageLen * 8;
-	message_length_bits = cpu2le64(message_length_bits);
-	NdisMoveMemory(&pMD5_CTX->Block[56], &message_length_bits, 8);
-	MD5_Hash(pMD5_CTX);
-
-	/* Return message digest, transform the u32 hash value to bytes */
-	for (index = 0; index < 4; index++)
-		pMD5_CTX->HashValue[index] =
-		    cpu2le32(pMD5_CTX->HashValue[index]);
-	/* End of for */
-	NdisMoveMemory(DigestMessage, pMD5_CTX->HashValue, MD5_DIGEST_SIZE);
-}				/* End of MD5_End */
-
-/*
-========================================================================
-Routine Description:
-    MD5 algorithm
-
-Arguments:
-    message         Message context
-    messageLen      The length of message in bytes
-
-Return Value:
-    digestMessage   Digest message
-
-Note:
-    None
-========================================================================
-*/
-void RT_MD5(IN const u8 Message[],
-	    u32 MessageLen, u8 DigestMessage[])
-{
-	struct rt_md5_ctx_struc md5_ctx;
-
-	NdisZeroMemory(&md5_ctx, sizeof(struct rt_md5_ctx_struc));
-	MD5_Init(&md5_ctx);
-	MD5_Append(&md5_ctx, Message, MessageLen);
-	MD5_End(&md5_ctx, DigestMessage);
-}				/* End of RT_MD5 */
-
-#endif /* MD5_SUPPORT */
-
-/* End of crypt_md5.c */
diff --git a/drivers/staging/rt2860/common/crypt_sha2.c b/drivers/staging/rt2860/common/crypt_sha2.c
deleted file mode 100644
index fa83fb2..0000000
--- a/drivers/staging/rt2860/common/crypt_sha2.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************/
-
-#include "../crypt_sha2.h"
-
-/* Basic operations */
-#define SHR(x,n) (x >> n)	/* SHR(x)^n, right shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTR(x,n,w) ((x >> n) | (x << (w - n)))	/* ROTR(x)^n, circular right shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTL(x,n,w) ((x << n) | (x >> (w - n)))	/* ROTL(x)^n, circular left shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTR32(x,n) ROTR(x,n,32)	/* 32 bits word */
-#define ROTL32(x,n) ROTL(x,n,32)	/* 32 bits word */
-
-/* Basic functions */
-#define Ch(x,y,z) ((x & y) ^ ((~x) & z))
-#define Maj(x,y,z) ((x & y) ^ (x & z) ^ (y & z))
-#define Parity(x,y,z) (x ^ y ^ z)
-
-#ifdef SHA1_SUPPORT
-/* SHA1 constants */
-#define SHA1_MASK 0x0000000f
-static const u32 SHA1_K[4] = {
-	0x5a827999UL, 0x6ed9eba1UL, 0x8f1bbcdcUL, 0xca62c1d6UL
-};
-
-static const u32 SHA1_DefaultHashValue[5] = {
-	0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL, 0xc3d2e1f0UL
-};
-
-/*
-========================================================================
-Routine Description:
-    Initial struct rt_sha1_ctx
-
-Arguments:
-    pSHA_CTX        Pointer to struct rt_sha1_ctx
-
-Return Value:
-    None
-
-Note:
-    None
-========================================================================
-*/
-void RT_SHA1_Init(struct rt_sha1_ctx *pSHA_CTX)
-{
-	NdisMoveMemory(pSHA_CTX->HashValue, SHA1_DefaultHashValue,
-		       sizeof(SHA1_DefaultHashValue));
-	NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-	pSHA_CTX->MessageLen = 0;
-	pSHA_CTX->BlockLen = 0;
-}				/* End of RT_SHA1_Init */
-
-/*
-========================================================================
-Routine Description:
-    SHA1 computation for one block (512 bits)
-
-Arguments:
-    pSHA_CTX        Pointer to struct rt_sha1_ctx
-
-Return Value:
-    None
-
-Note:
-    None
-========================================================================
-*/
-void SHA1_Hash(struct rt_sha1_ctx *pSHA_CTX)
-{
-	u32 W_i, t, s;
-	u32 W[16];
-	u32 a, b, c, d, e, T, f_t = 0;
-
-	/* Prepare the message schedule, {W_i}, 0 < t < 15 */
-	NdisMoveMemory(W, pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-	for (W_i = 0; W_i < 16; W_i++)
-		W[W_i] = cpu2be32(W[W_i]);	/* Endian Swap */
-	/* End of for */
-
-	/* SHA256 hash computation */
-	/* Initialize the working variables */
-	a = pSHA_CTX->HashValue[0];
-	b = pSHA_CTX->HashValue[1];
-	c = pSHA_CTX->HashValue[2];
-	d = pSHA_CTX->HashValue[3];
-	e = pSHA_CTX->HashValue[4];
-
-	/* 80 rounds */
-	for (t = 0; t < 80; t++) {
-		s = t & SHA1_MASK;
-		if (t > 15) {	/* Prepare the message schedule, {W_i}, 16 < t < 79 */
-			W[s] =
-			    (W[(s + 13) & SHA1_MASK]) ^ (W[(s + 8) & SHA1_MASK])
-			    ^ (W[(s + 2) & SHA1_MASK]) ^ W[s];
-			W[s] = ROTL32(W[s], 1);
-		}		/* End of if */
-		switch (t / 20) {
-		case 0:
-			f_t = Ch(b, c, d);
-			break;
-		case 1:
-			f_t = Parity(b, c, d);
-			break;
-		case 2:
-			f_t = Maj(b, c, d);
-			break;
-		case 3:
-			f_t = Parity(b, c, d);
-			break;
-		}		/* End of switch */
-		T = ROTL32(a, 5) + f_t + e + SHA1_K[t / 20] + W[s];
-		e = d;
-		d = c;
-		c = ROTL32(b, 30);
-		b = a;
-		a = T;
-	}			/* End of for */
-
-	/* Compute the i^th intermediate hash value H^(i) */
-	pSHA_CTX->HashValue[0] += a;
-	pSHA_CTX->HashValue[1] += b;
-	pSHA_CTX->HashValue[2] += c;
-	pSHA_CTX->HashValue[3] += d;
-	pSHA_CTX->HashValue[4] += e;
-
-	NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-	pSHA_CTX->BlockLen = 0;
-}				/* End of SHA1_Hash */
-
-/*
-========================================================================
-Routine Description:
-    The message is appended to block. If block size > 64 bytes, the SHA1_Hash
-will be called.
-
-Arguments:
-    pSHA_CTX        Pointer to struct rt_sha1_ctx
-    message         Message context
-    messageLen      The length of message in bytes
-
-Return Value:
-    None
-
-Note:
-    None
-========================================================================
-*/
-void SHA1_Append(struct rt_sha1_ctx *pSHA_CTX,
-		 IN const u8 Message[], u32 MessageLen)
-{
-	u32 appendLen = 0;
-	u32 diffLen = 0;
-
-	while (appendLen != MessageLen) {
-		diffLen = MessageLen - appendLen;
-		if ((pSHA_CTX->BlockLen + diffLen) < SHA1_BLOCK_SIZE) {
-			NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
-				       Message + appendLen, diffLen);
-			pSHA_CTX->BlockLen += diffLen;
-			appendLen += diffLen;
-		} else {
-			NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
-				       Message + appendLen,
-				       SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
-			appendLen += (SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
-			pSHA_CTX->BlockLen = SHA1_BLOCK_SIZE;
-			SHA1_Hash(pSHA_CTX);
-		}		/* End of if */
-	}			/* End of while */
-	pSHA_CTX->MessageLen += MessageLen;
-}				/* End of SHA1_Append */
-
-/*
-========================================================================
-Routine Description:
-    1. Append bit 1 to end of the message
-    2. Append the length of message in rightmost 64 bits
-    3. Transform the Hash Value to digest message
-
-Arguments:
-    pSHA_CTX        Pointer to struct rt_sha1_ctx
-
-Return Value:
-    digestMessage   Digest message
-
-Note:
-    None
-========================================================================
-*/
-void SHA1_End(struct rt_sha1_ctx *pSHA_CTX, u8 DigestMessage[])
-{
-	u32 index;
-	u64 message_length_bits;
-
-	/* Append bit 1 to end of the message */
-	NdisFillMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen, 1, 0x80);
-
-	/* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
-	if (pSHA_CTX->BlockLen > 55)
-		SHA1_Hash(pSHA_CTX);
-	/* End of if */
-
-	/* Append the length of message in rightmost 64 bits */
-	message_length_bits = pSHA_CTX->MessageLen * 8;
-	message_length_bits = cpu2be64(message_length_bits);
-	NdisMoveMemory(&pSHA_CTX->Block[56], &message_length_bits, 8);
-	SHA1_Hash(pSHA_CTX);
-
-	/* Return message digest, transform the u32 hash value to bytes */
-	for (index = 0; index < 5; index++)
-		pSHA_CTX->HashValue[index] =
-		    cpu2be32(pSHA_CTX->HashValue[index]);
-	/* End of for */
-	NdisMoveMemory(DigestMessage, pSHA_CTX->HashValue, SHA1_DIGEST_SIZE);
-}				/* End of SHA1_End */
-
-/*
-========================================================================
-Routine Description:
-    SHA1 algorithm
-
-Arguments:
-    message         Message context
-    messageLen      The length of message in bytes
-
-Return Value:
-    digestMessage   Digest message
-
-Note:
-    None
-========================================================================
-*/
-void RT_SHA1(IN const u8 Message[],
-	     u32 MessageLen, u8 DigestMessage[])
-{
-
-	struct rt_sha1_ctx sha_ctx;
-
-	NdisZeroMemory(&sha_ctx, sizeof(struct rt_sha1_ctx));
-	RT_SHA1_Init(&sha_ctx);
-	SHA1_Append(&sha_ctx, Message, MessageLen);
-	SHA1_End(&sha_ctx, DigestMessage);
-}				/* End of RT_SHA1 */
-#endif /* SHA1_SUPPORT */
-
-/* End of crypt_sha2.c */
diff --git a/drivers/staging/rt2860/common/dfs.c b/drivers/staging/rt2860/common/dfs.c
deleted file mode 100644
index 71cbb26..0000000
--- a/drivers/staging/rt2860/common/dfs.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    ap_dfs.c
-
-    Abstract:
-    Support DFS function.
-
-    Revision History:
-    Who       When            What
-    --------  ----------      ----------------------------------------------
-*/
-
-#include "../rt_config.h"
-
-/*
-	========================================================================
-
-	Routine Description:
-		Radar channel check routine
-
-	Arguments:
-		pAd 	Pointer to our adapter
-
-	Return Value:
-		TRUE	need to do radar detect
-		FALSE	need not to do radar detect
-
-	========================================================================
-*/
-BOOLEAN RadarChannelCheck(struct rt_rtmp_adapter *pAd, u8 Ch)
-{
-	int i;
-	BOOLEAN result = FALSE;
-
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		if (Ch == pAd->ChannelList[i].Channel) {
-			result = pAd->ChannelList[i].DfsReq;
-			break;
-		}
-	}
-
-	return result;
-}
diff --git a/drivers/staging/rt2860/common/ee_efuse.c b/drivers/staging/rt2860/common/ee_efuse.c
deleted file mode 100644
index fed0ba4..0000000
--- a/drivers/staging/rt2860/common/ee_efuse.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	ee_efuse.c
-
-	Abstract:
-	Miniport generic portion header file
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#include	"../rt_config.h"
-
-#define EFUSE_USAGE_MAP_START	0x2d0
-#define EFUSE_USAGE_MAP_END		0x2fc
-#define EFUSE_USAGE_MAP_SIZE	45
-
-#define EFUSE_EEPROM_DEFULT_FILE	"RT30xxEEPROM.bin"
-#define MAX_EEPROM_BIN_FILE_SIZE	1024
-
-#define EFUSE_TAG				0x2fe
-
-typedef union _EFUSE_CTRL_STRUC {
-	struct {
-		u32 EFSROM_AOUT:6;
-		u32 EFSROM_MODE:2;
-		u32 EFSROM_LDO_OFF_TIME:6;
-		u32 EFSROM_LDO_ON_TIME:2;
-		u32 EFSROM_AIN:10;
-		u32 RESERVED:4;
-		u32 EFSROM_KICK:1;
-		u32 SEL_EFUSE:1;
-	} field;
-	u32 word;
-} EFUSE_CTRL_STRUC, *PEFUSE_CTRL_STRUC;
-
-/*
-========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-========================================================================
-*/
-u8 eFuseReadRegisters(struct rt_rtmp_adapter *pAd,
-			 u16 Offset, u16 Length, u16 * pData)
-{
-	EFUSE_CTRL_STRUC eFuseCtrlStruc;
-	int i;
-	u16 efuseDataOffset;
-	u32 data;
-
-	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-
-	/*Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment. */
-	/*Use the eeprom logical address and covert to address to block number */
-	eFuseCtrlStruc.field.EFSROM_AIN = Offset & 0xfff0;
-
-	/*Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 0. */
-	eFuseCtrlStruc.field.EFSROM_MODE = 0;
-
-	/*Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure. */
-	eFuseCtrlStruc.field.EFSROM_KICK = 1;
-
-	NdisMoveMemory(&data, &eFuseCtrlStruc, 4);
-	RTMP_IO_WRITE32(pAd, EFUSE_CTRL, data);
-
-	/*Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again. */
-	i = 0;
-	while (i < 500) {
-		/*rtmp.HwMemoryReadDword(EFUSE_CTRL, (DWORD *) &eFuseCtrlStruc, 4); */
-		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-		if (eFuseCtrlStruc.field.EFSROM_KICK == 0) {
-			break;
-		}
-		RTMPusecDelay(2);
-		i++;
-	}
-
-	/*if EFSROM_AOUT is not found in physical address, write 0xffff */
-	if (eFuseCtrlStruc.field.EFSROM_AOUT == 0x3f) {
-		for (i = 0; i < Length / 2; i++)
-			*(pData + 2 * i) = 0xffff;
-	} else {
-		/*Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x590-0x59C) */
-		efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
-		/*data hold 4 bytes data. */
-		/*In RTMP_IO_READ32 will automatically execute 32-bytes swapping */
-		RTMP_IO_READ32(pAd, efuseDataOffset, &data);
-		/*Decide the upper 2 bytes or the bottom 2 bytes. */
-		/* Little-endian                S       |       S       Big-endian */
-		/* addr 3       2       1       0       |       0       1       2       3 */
-		/* Ori-V        D       C       B       A       |       A       B       C       D */
-		/*After swapping */
-		/*              D       C       B       A       |       D       C       B       A */
-		/*Return 2-bytes */
-		/*The return byte statrs from S. Therefore, the little-endian will return BA, the Big-endian will return DC. */
-		/*For returning the bottom 2 bytes, the Big-endian should shift right 2-bytes. */
-		data = data >> (8 * (Offset & 0x3));
-
-		NdisMoveMemory(pData, &data, Length);
-	}
-
-	return (u8)eFuseCtrlStruc.field.EFSROM_AOUT;
-
-}
-
-/*
-========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-========================================================================
-*/
-void eFusePhysicalReadRegisters(struct rt_rtmp_adapter *pAd,
-				u16 Offset,
-				u16 Length, u16 * pData)
-{
-	EFUSE_CTRL_STRUC eFuseCtrlStruc;
-	int i;
-	u16 efuseDataOffset;
-	u32 data;
-
-	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-
-	/*Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment. */
-	eFuseCtrlStruc.field.EFSROM_AIN = Offset & 0xfff0;
-
-	/*Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 1. */
-	/*Read in physical view */
-	eFuseCtrlStruc.field.EFSROM_MODE = 1;
-
-	/*Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure. */
-	eFuseCtrlStruc.field.EFSROM_KICK = 1;
-
-	NdisMoveMemory(&data, &eFuseCtrlStruc, 4);
-	RTMP_IO_WRITE32(pAd, EFUSE_CTRL, data);
-
-	/*Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again. */
-	i = 0;
-	while (i < 500) {
-		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-		if (eFuseCtrlStruc.field.EFSROM_KICK == 0)
-			break;
-		RTMPusecDelay(2);
-		i++;
-	}
-
-	/*Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x59C-0x590) */
-	/*Because the size of each EFUSE_DATA is 4 Bytes, the size of address of each is 2 bits. */
-	/*The previous 2 bits is the EFUSE_DATA number, the last 2 bits is used to decide which bytes */
-	/*Decide which EFUSE_DATA to read */
-	/*590:F E D C */
-	/*594:B A 9 8 */
-	/*598:7 6 5 4 */
-	/*59C:3 2 1 0 */
-	efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
-
-	RTMP_IO_READ32(pAd, efuseDataOffset, &data);
-
-	data = data >> (8 * (Offset & 0x3));
-
-	NdisMoveMemory(pData, &data, Length);
-
-}
-
-/*
-========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-========================================================================
-*/
-static void eFuseReadPhysical(struct rt_rtmp_adapter *pAd,
-			      u16 *lpInBuffer,
-			      unsigned long nInBufferSize,
-			      u16 *lpOutBuffer, unsigned long nOutBufferSize)
-{
-	u16 *pInBuf = (u16 *) lpInBuffer;
-	u16 *pOutBuf = (u16 *) lpOutBuffer;
-
-	u16 Offset = pInBuf[0];	/*addr */
-	u16 Length = pInBuf[1];	/*length */
-	int i;
-
-	for (i = 0; i < Length; i += 2) {
-		eFusePhysicalReadRegisters(pAd, Offset + i, 2, &pOutBuf[i / 2]);
-	}
-}
-
-/*
-========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-========================================================================
-*/
-int set_eFuseGetFreeBlockCount_Proc(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	u16 i;
-	u16 LogicalAddress;
-	u16 efusefreenum = 0;
-	if (!pAd->bUseEfuse)
-		return FALSE;
-	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i += 2) {
-		eFusePhysicalReadRegisters(pAd, i, 2, &LogicalAddress);
-		if ((LogicalAddress & 0xff) == 0) {
-			efusefreenum = (u8)(EFUSE_USAGE_MAP_END - i + 1);
-			break;
-		} else if (((LogicalAddress >> 8) & 0xff) == 0) {
-			efusefreenum = (u8)(EFUSE_USAGE_MAP_END - i);
-			break;
-		}
-
-		if (i == EFUSE_USAGE_MAP_END)
-			efusefreenum = 0;
-	}
-	printk(KERN_DEBUG "efuseFreeNumber is %d\n", efusefreenum);
-	return TRUE;
-}
-
-int set_eFusedump_Proc(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	u16 InBuf[3];
-	int i = 0;
-	if (!pAd->bUseEfuse)
-		return FALSE;
-
-	printk(KERN_DEBUG "Block 0: ");
-
-	for (i = 0; i < EFUSE_USAGE_MAP_END / 2; i++) {
-		InBuf[0] = 2 * i;
-		InBuf[1] = 2;
-		InBuf[2] = 0x0;
-
-		eFuseReadPhysical(pAd, &InBuf[0], 4, &InBuf[2], 2);
-		if (i && i % 4 == 0) {
-			printk(KERN_CONT "\n");
-			printk(KERN_DEBUG "Block %x:", i / 8);
-		}
-		printk(KERN_CONT "%04x ", InBuf[2]);
-	}
-	printk(KERN_CONT "\n");
-
-	return TRUE;
-}
-
-int rtmp_ee_efuse_read16(struct rt_rtmp_adapter *pAd,
-			 u16 Offset, u16 * pValue)
-{
-	eFuseReadRegisters(pAd, Offset, 2, pValue);
-	return (*pValue);
-}
-
-int RtmpEfuseSupportCheck(struct rt_rtmp_adapter *pAd)
-{
-	u16 value;
-
-	if (IS_RT30xx(pAd)) {
-		eFusePhysicalReadRegisters(pAd, EFUSE_TAG, 2, &value);
-		pAd->EFuseTag = (value & 0xff);
-	}
-	return 0;
-}
-
-void eFuseGetFreeBlockCount(struct rt_rtmp_adapter *pAd, u32 *EfuseFreeBlock)
-{
-	u16 i;
-	u16 LogicalAddress;
-	if (!pAd->bUseEfuse) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("eFuseGetFreeBlockCount Only supports efuse Mode\n"));
-		return;
-	}
-	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i += 2) {
-		eFusePhysicalReadRegisters(pAd, i, 2, &LogicalAddress);
-		if ((LogicalAddress & 0xff) == 0) {
-			*EfuseFreeBlock = (u8)(EFUSE_USAGE_MAP_END - i + 1);
-			break;
-		} else if (((LogicalAddress >> 8) & 0xff) == 0) {
-			*EfuseFreeBlock = (u8)(EFUSE_USAGE_MAP_END - i);
-			break;
-		}
-
-		if (i == EFUSE_USAGE_MAP_END)
-			*EfuseFreeBlock = 0;
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("eFuseGetFreeBlockCount is 0x%x\n", *EfuseFreeBlock));
-}
-
-int eFuse_init(struct rt_rtmp_adapter *pAd)
-{
-	u32 EfuseFreeBlock = 0;
-	DBGPRINT(RT_DEBUG_ERROR,
-		 ("NVM is Efuse and its size =%x[%x-%x] \n",
-		  EFUSE_USAGE_MAP_SIZE, EFUSE_USAGE_MAP_START,
-		  EFUSE_USAGE_MAP_END));
-	eFuseGetFreeBlockCount(pAd, &EfuseFreeBlock);
-
-	return 0;
-}
diff --git a/drivers/staging/rt2860/common/ee_prom.c b/drivers/staging/rt2860/common/ee_prom.c
deleted file mode 100644
index 2083740..0000000
--- a/drivers/staging/rt2860/common/ee_prom.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	ee_prom.c
-
-	Abstract:
-	Miniport generic portion header file
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#include	"../rt_config.h"
-
-/* IRQL = PASSIVE_LEVEL */
-static inline void RaiseClock(struct rt_rtmp_adapter *pAd, u32 * x)
-{
-	*x = *x | EESK;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, *x);
-	RTMPusecDelay(1);	/* Max frequency = 1MHz in Spec. definition */
-}
-
-/* IRQL = PASSIVE_LEVEL */
-static inline void LowerClock(struct rt_rtmp_adapter *pAd, u32 * x)
-{
-	*x = *x & ~EESK;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, *x);
-	RTMPusecDelay(1);
-}
-
-/* IRQL = PASSIVE_LEVEL */
-static inline u16 ShiftInBits(struct rt_rtmp_adapter *pAd)
-{
-	u32 x, i;
-	u16 data = 0;
-
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-
-	x &= ~(EEDO | EEDI);
-
-	for (i = 0; i < 16; i++) {
-		data = data << 1;
-		RaiseClock(pAd, &x);
-
-		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-		LowerClock(pAd, &x);	/*prevent read failed */
-
-		x &= ~(EEDI);
-		if (x & EEDO)
-			data |= 1;
-	}
-
-	return data;
-}
-
-/* IRQL = PASSIVE_LEVEL */
-static inline void ShiftOutBits(struct rt_rtmp_adapter *pAd,
-				u16 data, u16 count)
-{
-	u32 x, mask;
-
-	mask = 0x01 << (count - 1);
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-
-	x &= ~(EEDO | EEDI);
-
-	do {
-		x &= ~EEDI;
-		if (data & mask)
-			x |= EEDI;
-
-		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-
-		RaiseClock(pAd, &x);
-		LowerClock(pAd, &x);
-
-		mask = mask >> 1;
-	} while (mask);
-
-	x &= ~EEDI;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-}
-
-/* IRQL = PASSIVE_LEVEL */
-static inline void EEpromCleanup(struct rt_rtmp_adapter *pAd)
-{
-	u32 x;
-
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-
-	x &= ~(EECS | EEDI);
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-
-	RaiseClock(pAd, &x);
-	LowerClock(pAd, &x);
-}
-
-static inline void EWEN(struct rt_rtmp_adapter *pAd)
-{
-	u32 x;
-
-	/* reset bits and set EECS */
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-	x &= ~(EEDI | EEDO | EESK);
-	x |= EECS;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-
-	/* kick a pulse */
-	RaiseClock(pAd, &x);
-	LowerClock(pAd, &x);
-
-	/* output the read_opcode and six pulse in that order */
-	ShiftOutBits(pAd, EEPROM_EWEN_OPCODE, 5);
-	ShiftOutBits(pAd, 0, 6);
-
-	EEpromCleanup(pAd);
-}
-
-static inline void EWDS(struct rt_rtmp_adapter *pAd)
-{
-	u32 x;
-
-	/* reset bits and set EECS */
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-	x &= ~(EEDI | EEDO | EESK);
-	x |= EECS;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-
-	/* kick a pulse */
-	RaiseClock(pAd, &x);
-	LowerClock(pAd, &x);
-
-	/* output the read_opcode and six pulse in that order */
-	ShiftOutBits(pAd, EEPROM_EWDS_OPCODE, 5);
-	ShiftOutBits(pAd, 0, 6);
-
-	EEpromCleanup(pAd);
-}
-
-/* IRQL = PASSIVE_LEVEL */
-int rtmp_ee_prom_read16(struct rt_rtmp_adapter *pAd,
-			u16 Offset, u16 * pValue)
-{
-	u32 x;
-	u16 data;
-
-	Offset /= 2;
-	/* reset bits and set EECS */
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-	x &= ~(EEDI | EEDO | EESK);
-	x |= EECS;
-	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
-
-	/* patch can not access e-Fuse issue */
-	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
-		/* kick a pulse */
-		RaiseClock(pAd, &x);
-		LowerClock(pAd, &x);
-	}
-	/* output the read_opcode and register number in that order */
-	ShiftOutBits(pAd, EEPROM_READ_OPCODE, 3);
-	ShiftOutBits(pAd, Offset, pAd->EEPROMAddressNum);
-
-	/* Now read the data (16 bits) in from the selected EEPROM word */
-	data = ShiftInBits(pAd);
-
-	EEpromCleanup(pAd);
-
-	*pValue = data;
-
-	return NDIS_STATUS_SUCCESS;
-}
diff --git a/drivers/staging/rt2860/common/eeprom.c b/drivers/staging/rt2860/common/eeprom.c
deleted file mode 100644
index 9467007..0000000
--- a/drivers/staging/rt2860/common/eeprom.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	eeprom.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name		Date			Modification logs
-*/
-#include "../rt_config.h"
-
-int RtmpChipOpsEepromHook(struct rt_rtmp_adapter *pAd, int infType)
-{
-	struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-#ifdef RT30xx
-#ifdef RTMP_EFUSE_SUPPORT
-	u32 eFuseCtrl, MacCsr0;
-	int index;
-
-	index = 0;
-	do {
-		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
-		pAd->MACVersion = MacCsr0;
-
-		if ((pAd->MACVersion != 0x00)
-		    && (pAd->MACVersion != 0xFFFFFFFF))
-			break;
-
-		RTMPusecDelay(10);
-	} while (index++ < 100);
-
-	pAd->bUseEfuse = FALSE;
-	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrl);
-	pAd->bUseEfuse = ((eFuseCtrl & 0x80000000) == 0x80000000) ? 1 : 0;
-	if (pAd->bUseEfuse) {
-		pChipOps->eeinit = eFuse_init;
-		pChipOps->eeread = rtmp_ee_efuse_read16;
-		return 0;
-	} else
-		DBGPRINT(RT_DEBUG_TRACE, ("NVM is EEPROM\n"));
-#endif /* RTMP_EFUSE_SUPPORT // */
-#endif /* RT30xx // */
-
-	switch (infType) {
-#ifdef RTMP_PCI_SUPPORT
-	case RTMP_DEV_INF_PCI:
-		pChipOps->eeinit = NULL;
-		pChipOps->eeread = rtmp_ee_prom_read16;
-		break;
-#endif /* RTMP_PCI_SUPPORT // */
-#ifdef RTMP_USB_SUPPORT
-	case RTMP_DEV_INF_USB:
-		pChipOps->eeinit = NULL;
-		pChipOps->eeread = RTUSBReadEEPROM16;
-		break;
-#endif /* RTMP_USB_SUPPORT // */
-
-	default:
-		DBGPRINT(RT_DEBUG_ERROR, ("RtmpChipOpsEepromHook() failed!\n"));
-		break;
-	}
-
-	return 0;
-}
diff --git a/drivers/staging/rt2860/common/mlme.c b/drivers/staging/rt2860/common/mlme.c
deleted file mode 100644
index e48eac0..0000000
--- a/drivers/staging/rt2860/common/mlme.c
+++ /dev/null
@@ -1,6068 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	mlme.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John Chang	2004-08-25		Modify from RT2500 code base
-	John Chang	2004-09-06		modified for RT2600
-*/
-
-#include "../rt_config.h"
-#include <stdarg.h>
-#include <linux/kernel.h>
-
-u8 CISCO_OUI[] = { 0x00, 0x40, 0x96 };
-
-u8 WPA_OUI[] = { 0x00, 0x50, 0xf2, 0x01 };
-u8 RSN_OUI[] = { 0x00, 0x0f, 0xac };
-u8 WME_INFO_ELEM[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01 };
-u8 WME_PARM_ELEM[] = { 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01 };
-u8 Ccx2QosInfo[] = { 0x00, 0x40, 0x96, 0x04 };
-u8 RALINK_OUI[] = { 0x00, 0x0c, 0x43 };
-u8 BROADCOM_OUI[] = { 0x00, 0x90, 0x4c };
-u8 WPS_OUI[] = { 0x00, 0x50, 0xf2, 0x04 };
-u8 PRE_N_HT_OUI[] = { 0x00, 0x90, 0x4c };
-
-u8 RateSwitchTable[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x11, 0x00, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 35, 45,
-	0x03, 0x00, 3, 20, 45,
-	0x04, 0x21, 0, 30, 50,
-	0x05, 0x21, 1, 20, 50,
-	0x06, 0x21, 2, 20, 50,
-	0x07, 0x21, 3, 15, 50,
-	0x08, 0x21, 4, 15, 30,
-	0x09, 0x21, 5, 10, 25,
-	0x0a, 0x21, 6, 8, 25,
-	0x0b, 0x21, 7, 8, 25,
-	0x0c, 0x20, 12, 15, 30,
-	0x0d, 0x20, 13, 8, 20,
-	0x0e, 0x20, 14, 8, 20,
-	0x0f, 0x20, 15, 8, 25,
-	0x10, 0x22, 15, 8, 25,
-	0x11, 0x00, 0, 0, 0,
-	0x12, 0x00, 0, 0, 0,
-	0x13, 0x00, 0, 0, 0,
-	0x14, 0x00, 0, 0, 0,
-	0x15, 0x00, 0, 0, 0,
-	0x16, 0x00, 0, 0, 0,
-	0x17, 0x00, 0, 0, 0,
-	0x18, 0x00, 0, 0, 0,
-	0x19, 0x00, 0, 0, 0,
-	0x1a, 0x00, 0, 0, 0,
-	0x1b, 0x00, 0, 0, 0,
-	0x1c, 0x00, 0, 0, 0,
-	0x1d, 0x00, 0, 0, 0,
-	0x1e, 0x00, 0, 0, 0,
-	0x1f, 0x00, 0, 0, 0,
-};
-
-u8 RateSwitchTable11B[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x04, 0x03, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 35, 45,
-	0x03, 0x00, 3, 20, 45,
-};
-
-u8 RateSwitchTable11BG[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0a, 0x00, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 35, 45,
-	0x03, 0x00, 3, 20, 45,
-	0x04, 0x10, 2, 20, 35,
-	0x05, 0x10, 3, 16, 35,
-	0x06, 0x10, 4, 10, 25,
-	0x07, 0x10, 5, 16, 25,
-	0x08, 0x10, 6, 10, 25,
-	0x09, 0x10, 7, 10, 13,
-};
-
-u8 RateSwitchTable11G[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x08, 0x00, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x10, 0, 20, 101,
-	0x01, 0x10, 1, 20, 35,
-	0x02, 0x10, 2, 20, 35,
-	0x03, 0x10, 3, 16, 35,
-	0x04, 0x10, 4, 10, 25,
-	0x05, 0x10, 5, 16, 25,
-	0x06, 0x10, 6, 10, 25,
-	0x07, 0x10, 7, 10, 13,
-};
-
-u8 RateSwitchTable11N1S[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0c, 0x0a, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 25, 45,
-	0x03, 0x21, 0, 20, 35,
-	0x04, 0x21, 1, 20, 35,
-	0x05, 0x21, 2, 20, 35,
-	0x06, 0x21, 3, 15, 35,
-	0x07, 0x21, 4, 15, 30,
-	0x08, 0x21, 5, 10, 25,
-	0x09, 0x21, 6, 8, 14,
-	0x0a, 0x21, 7, 8, 14,
-	0x0b, 0x23, 7, 8, 14,
-};
-
-u8 RateSwitchTable11N2S[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0e, 0x0c, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 25, 45,
-	0x03, 0x21, 0, 20, 35,
-	0x04, 0x21, 1, 20, 35,
-	0x05, 0x21, 2, 20, 35,
-	0x06, 0x21, 3, 15, 35,
-	0x07, 0x21, 4, 15, 30,
-	0x08, 0x20, 11, 15, 30,
-	0x09, 0x20, 12, 15, 30,
-	0x0a, 0x20, 13, 8, 20,
-	0x0b, 0x20, 14, 8, 20,
-	0x0c, 0x20, 15, 8, 25,
-	0x0d, 0x22, 15, 8, 15,
-};
-
-u8 RateSwitchTable11N3S[] = {
-/* Item No.     Mode    Curr-MCS        TrainUp TrainDown       // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0b, 0x00, 0, 0, 0,	/* 0x0a, 0x00,  0,  0,  0,      // Initial used item after association */
-	0x00, 0x21, 0, 30, 101,
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 15, 50,
-	0x04, 0x21, 4, 15, 30,
-	0x05, 0x20, 11, 15, 30,	/* Required by System-Alan @ 20080812 */
-	0x06, 0x20, 12, 15, 30,	/* 0x05, 0x20, 12, 15, 30, */
-	0x07, 0x20, 13, 8, 20,	/* 0x06, 0x20, 13,  8, 20, */
-	0x08, 0x20, 14, 8, 20,	/* 0x07, 0x20, 14,  8, 20, */
-	0x09, 0x20, 15, 8, 25,	/* 0x08, 0x20, 15,  8, 25, */
-	0x0a, 0x22, 15, 8, 25,	/* 0x09, 0x22, 15,  8, 25, */
-};
-
-u8 RateSwitchTable11N2SForABand[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x21, 0, 30, 101,
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 15, 50,
-	0x04, 0x21, 4, 15, 30,
-	0x05, 0x21, 5, 15, 30,
-	0x06, 0x20, 12, 15, 30,
-	0x07, 0x20, 13, 8, 20,
-	0x08, 0x20, 14, 8, 20,
-	0x09, 0x20, 15, 8, 25,
-	0x0a, 0x22, 15, 8, 25,
-};
-
-u8 RateSwitchTable11N3SForABand[] = {	/* 3*3 */
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x21, 0, 30, 101,
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 15, 50,
-	0x04, 0x21, 4, 15, 30,
-	0x05, 0x21, 5, 15, 30,
-	0x06, 0x20, 12, 15, 30,
-	0x07, 0x20, 13, 8, 20,
-	0x08, 0x20, 14, 8, 20,
-	0x09, 0x20, 15, 8, 25,
-	0x0a, 0x22, 15, 8, 25,
-};
-
-u8 RateSwitchTable11BGN1S[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0c, 0x0a, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 25, 45,
-	0x03, 0x21, 0, 20, 35,
-	0x04, 0x21, 1, 20, 35,
-	0x05, 0x21, 2, 20, 35,
-	0x06, 0x21, 3, 15, 35,
-	0x07, 0x21, 4, 15, 30,
-	0x08, 0x21, 5, 10, 25,
-	0x09, 0x21, 6, 8, 14,
-	0x0a, 0x21, 7, 8, 14,
-	0x0b, 0x23, 7, 8, 14,
-};
-
-u8 RateSwitchTable11BGN2S[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0e, 0x0c, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x00, 0, 40, 101,
-	0x01, 0x00, 1, 40, 50,
-	0x02, 0x00, 2, 25, 45,
-	0x03, 0x21, 0, 20, 35,
-	0x04, 0x21, 1, 20, 35,
-	0x05, 0x21, 2, 20, 35,
-	0x06, 0x21, 3, 15, 35,
-	0x07, 0x21, 4, 15, 30,
-	0x08, 0x20, 11, 15, 30,
-	0x09, 0x20, 12, 15, 30,
-	0x0a, 0x20, 13, 8, 20,
-	0x0b, 0x20, 14, 8, 20,
-	0x0c, 0x20, 15, 8, 25,
-	0x0d, 0x22, 15, 8, 15,
-};
-
-u8 RateSwitchTable11BGN3S[] = {	/* 3*3 */
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0a, 0x00, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x21, 0, 30, 101,	/*50 */
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 20, 50,
-	0x04, 0x21, 4, 15, 50,
-	0x05, 0x20, 20, 15, 30,
-	0x06, 0x20, 21, 8, 20,
-	0x07, 0x20, 22, 8, 20,
-	0x08, 0x20, 23, 8, 25,
-	0x09, 0x22, 23, 8, 25,
-};
-
-u8 RateSwitchTable11BGN2SForABand[] = {
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x21, 0, 30, 101,	/*50 */
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 15, 50,
-	0x04, 0x21, 4, 15, 30,
-	0x05, 0x21, 5, 15, 30,
-	0x06, 0x20, 12, 15, 30,
-	0x07, 0x20, 13, 8, 20,
-	0x08, 0x20, 14, 8, 20,
-	0x09, 0x20, 15, 8, 25,
-	0x0a, 0x22, 15, 8, 25,
-};
-
-u8 RateSwitchTable11BGN3SForABand[] = {	/* 3*3 */
-/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
-	0x0c, 0x09, 0, 0, 0,	/* Initial used item after association */
-	0x00, 0x21, 0, 30, 101,	/*50 */
-	0x01, 0x21, 1, 20, 50,
-	0x02, 0x21, 2, 20, 50,
-	0x03, 0x21, 3, 15, 50,
-	0x04, 0x21, 4, 15, 30,
-	0x05, 0x21, 5, 15, 30,
-	0x06, 0x21, 12, 15, 30,
-	0x07, 0x20, 20, 15, 30,
-	0x08, 0x20, 21, 8, 20,
-	0x09, 0x20, 22, 8, 20,
-	0x0a, 0x20, 23, 8, 25,
-	0x0b, 0x22, 23, 8, 25,
-};
-
-extern u8 OfdmRateToRxwiMCS[];
-/* since RT61 has better RX sensibility, we have to limit TX ACK rate not to exceed our normal data TX rate. */
-/* otherwise the WLAN peer may not be able to receive the ACK thus downgrade its data TX rate */
-unsigned long BasicRateMask[12] =
-    { 0xfffff001 /* 1-Mbps */ , 0xfffff003 /* 2 Mbps */ , 0xfffff007 /* 5.5 */ ,
-0xfffff00f /* 11 */ ,
-	0xfffff01f /* 6 */ , 0xfffff03f /* 9 */ , 0xfffff07f /* 12 */ ,
-	    0xfffff0ff /* 18 */ ,
-	0xfffff1ff /* 24 */ , 0xfffff3ff /* 36 */ , 0xfffff7ff /* 48 */ ,
-	    0xffffffff /* 54 */
-};
-
-u8 BROADCAST_ADDR[MAC_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-u8 ZERO_MAC_ADDR[MAC_ADDR_LEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-/* e.g. RssiSafeLevelForTxRate[RATE_36]" means if the current RSSI is greater than */
-/*              this value, then it's quaranteed capable of operating in 36 mbps TX rate in */
-/*              clean environment. */
-/*                                                                TxRate: 1   2   5.5   11       6        9    12       18       24   36   48   54       72  100 */
-char RssiSafeLevelForTxRate[] =
-    { -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
-
-u8 RateIdToMbps[] = { 1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54, 72, 100 };
-u16 RateIdTo500Kbps[] =
-    { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 144, 200 };
-
-u8 SsidIe = IE_SSID;
-u8 SupRateIe = IE_SUPP_RATES;
-u8 ExtRateIe = IE_EXT_SUPP_RATES;
-u8 HtCapIe = IE_HT_CAP;
-u8 AddHtInfoIe = IE_ADD_HT;
-u8 NewExtChanIe = IE_SECONDARY_CH_OFFSET;
-u8 ErpIe = IE_ERP;
-u8 DsIe = IE_DS_PARM;
-u8 TimIe = IE_TIM;
-u8 WpaIe = IE_WPA;
-u8 Wpa2Ie = IE_WPA2;
-u8 IbssIe = IE_IBSS_PARM;
-
-extern u8 WPA_OUI[];
-
-u8 SES_OUI[] = { 0x00, 0x90, 0x4c };
-
-u8 ZeroSsid[32] =
-    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00
-};
-
-/*
-	==========================================================================
-	Description:
-		initialize the MLME task and its data structure (queue, spinlock,
-		timer, state machines).
-
-	IRQL = PASSIVE_LEVEL
-
-	Return:
-		always return NDIS_STATUS_SUCCESS
-
-	==========================================================================
-*/
-int MlmeInit(struct rt_rtmp_adapter *pAd)
-{
-	int Status = NDIS_STATUS_SUCCESS;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> MLME Initialize\n"));
-
-	do {
-		Status = MlmeQueueInit(&pAd->Mlme.Queue);
-		if (Status != NDIS_STATUS_SUCCESS)
-			break;
-
-		pAd->Mlme.bRunning = FALSE;
-		NdisAllocateSpinLock(&pAd->Mlme.TaskLock);
-
-		{
-			BssTableInit(&pAd->ScanTab);
-
-			/* init STA state machines */
-			AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine,
-					      pAd->Mlme.AssocFunc);
-			AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine,
-					     pAd->Mlme.AuthFunc);
-			AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine,
-						pAd->Mlme.AuthRspFunc);
-			SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine,
-					     pAd->Mlme.SyncFunc);
-
-			/* Since we are using switch/case to implement it, the init is different from the above */
-			/* state machine init */
-			MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
-		}
-
-		WpaStateMachineInit(pAd, &pAd->Mlme.WpaMachine,
-				    pAd->Mlme.WpaFunc);
-
-		ActionStateMachineInit(pAd, &pAd->Mlme.ActMachine,
-				       pAd->Mlme.ActFunc);
-
-		/* Init mlme periodic timer */
-		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer,
-			      GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
-
-		/* Set mlme periodic timer */
-		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
-
-		/* software-based RX Antenna diversity */
-		RTMPInitTimer(pAd, &pAd->Mlme.RxAntEvalTimer,
-			      GET_TIMER_FUNCTION(AsicRxAntEvalTimeout), pAd,
-			      FALSE);
-
-		{
-#ifdef RTMP_PCI_SUPPORT
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-				/* only PCIe cards need these two timers */
-				RTMPInitTimer(pAd, &pAd->Mlme.PsPollTimer,
-					      GET_TIMER_FUNCTION
-					      (PsPollWakeExec), pAd, FALSE);
-				RTMPInitTimer(pAd, &pAd->Mlme.RadioOnOffTimer,
-					      GET_TIMER_FUNCTION(RadioOnExec),
-					      pAd, FALSE);
-			}
-#endif /* RTMP_PCI_SUPPORT // */
-
-			RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer,
-				      GET_TIMER_FUNCTION(LinkDownExec), pAd,
-				      FALSE);
-
-#ifdef RTMP_MAC_USB
-			RTMPInitTimer(pAd, &pAd->Mlme.AutoWakeupTimer,
-				      GET_TIMER_FUNCTION
-				      (RtmpUsbStaAsicForceWakeupTimeout), pAd,
-				      FALSE);
-			pAd->Mlme.AutoWakeupTimerRunning = FALSE;
-#endif /* RTMP_MAC_USB // */
-		}
-
-	} while (FALSE);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- MLME Initialize\n"));
-
-	return Status;
-}
-
-/*
-	==========================================================================
-	Description:
-		main loop of the MLME
-	Pre:
-		Mlme has to be initialized, and there are something inside the queue
-	Note:
-		This function is invoked from MPSetInformation and MPReceive;
-		This task guarantee only one MlmeHandler will run.
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void MlmeHandler(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_mlme_queue_elem *Elem = NULL;
-
-	/* Only accept MLME and Frame from peer side, no other (control/data) frame should */
-	/* get into this state machine */
-
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	if (pAd->Mlme.bRunning) {
-		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-		return;
-	} else {
-		pAd->Mlme.bRunning = TRUE;
-	}
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-
-	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS) ||
-		    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
-		    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %ld)\n",
-				  pAd->Mlme.Queue.Num));
-			break;
-		}
-		/*From message type, determine which state machine I should drive */
-		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
-#ifdef RTMP_MAC_USB
-			if (Elem->MsgType == MT2_RESET_CONF) {
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("reset MLME state machine!\n"));
-				MlmeRestartStateMachine(pAd);
-				Elem->Occupied = FALSE;
-				Elem->MsgLen = 0;
-				continue;
-			}
-#endif /* RTMP_MAC_USB // */
-
-			/* if dequeue success */
-			switch (Elem->Machine) {
-				/* STA state machines */
-			case ASSOC_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.
-							  AssocMachine, Elem);
-				break;
-			case AUTH_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.
-							  AuthMachine, Elem);
-				break;
-			case AUTH_RSP_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.
-							  AuthRspMachine, Elem);
-				break;
-			case SYNC_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.
-							  SyncMachine, Elem);
-				break;
-			case MLME_CNTL_STATE_MACHINE:
-				MlmeCntlMachinePerformAction(pAd,
-							     &pAd->Mlme.
-							     CntlMachine, Elem);
-				break;
-			case WPA_PSK_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.
-							  WpaPskMachine, Elem);
-				break;
-
-			case ACTION_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.ActMachine,
-							  Elem);
-				break;
-
-			case WPA_STATE_MACHINE:
-				StateMachinePerformAction(pAd,
-							  &pAd->Mlme.WpaMachine,
-							  Elem);
-				break;
-
-			default:
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("ERROR: Illegal machine %ld in MlmeHandler()\n",
-					  Elem->Machine));
-				break;
-			}	/* end of switch */
-
-			/* free MLME element */
-			Elem->Occupied = FALSE;
-			Elem->MsgLen = 0;
-
-		} else {
-			DBGPRINT_ERR("MlmeHandler: MlmeQueue empty\n");
-		}
-	}
-
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	pAd->Mlme.bRunning = FALSE;
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-}
-
-/*
-	==========================================================================
-	Description:
-		Destructor of MLME (Destroy queue, state machine, spin lock and timer)
-	Parameters:
-		Adapter - NIC Adapter pointer
-	Post:
-		The MLME task will no longer work properly
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
- */
-void MlmeHalt(struct rt_rtmp_adapter *pAd)
-{
-	BOOLEAN Cancelled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeHalt\n"));
-
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		/* disable BEACON generation and other BEACON related hardware timers */
-		AsicDisableSync(pAd);
-	}
-
-	{
-		/* Cancel pending timers */
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
-
-#ifdef RTMP_MAC_PCI
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-			RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-			RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
-		}
-#endif /* RTMP_MAC_PCI // */
-
-		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer, &Cancelled);
-
-#ifdef RTMP_MAC_USB
-		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Cancelled);
-#endif /* RTMP_MAC_USB // */
-	}
-
-	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
-	RTMPCancelTimer(&pAd->Mlme.RxAntEvalTimer, &Cancelled);
-
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-
-		/* Set LED */
-		RTMPSetLED(pAd, LED_HALT);
-		RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, firmware is not done it. */
-#ifdef RTMP_MAC_USB
-		{
-			LED_CFG_STRUC LedCfg;
-			RTMP_IO_READ32(pAd, LED_CFG, &LedCfg.word);
-			LedCfg.field.LedPolar = 0;
-			LedCfg.field.RLedMode = 0;
-			LedCfg.field.GLedMode = 0;
-			LedCfg.field.YLedMode = 0;
-			RTMP_IO_WRITE32(pAd, LED_CFG, LedCfg.word);
-		}
-#endif /* RTMP_MAC_USB // */
-
-		if (pChipOps->AsicHaltAction)
-			pChipOps->AsicHaltAction(pAd);
-	}
-
-	RTMPusecDelay(5000);	/*  5 msec to guarantee Ant Diversity timer canceled */
-
-	MlmeQueueDestroy(&pAd->Mlme.Queue);
-	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<== MlmeHalt\n"));
-}
-
-void MlmeResetRalinkCounters(struct rt_rtmp_adapter *pAd)
-{
-	pAd->RalinkCounters.LastOneSecRxOkDataCnt =
-	    pAd->RalinkCounters.OneSecRxOkDataCnt;
-	/* clear all OneSecxxx counters. */
-	pAd->RalinkCounters.OneSecBeaconSentCnt = 0;
-	pAd->RalinkCounters.OneSecFalseCCACnt = 0;
-	pAd->RalinkCounters.OneSecRxFcsErrCnt = 0;
-	pAd->RalinkCounters.OneSecRxOkCnt = 0;
-	pAd->RalinkCounters.OneSecTxFailCount = 0;
-	pAd->RalinkCounters.OneSecTxNoRetryOkCount = 0;
-	pAd->RalinkCounters.OneSecTxRetryOkCount = 0;
-	pAd->RalinkCounters.OneSecRxOkDataCnt = 0;
-	pAd->RalinkCounters.OneSecReceivedByteCount = 0;
-	pAd->RalinkCounters.OneSecTransmittedByteCount = 0;
-
-	/* TODO: for debug only. to be removed */
-	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] = 0;
-	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] = 0;
-	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] = 0;
-	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] = 0;
-	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BE] = 0;
-	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BK] = 0;
-	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VI] = 0;
-	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VO] = 0;
-	pAd->RalinkCounters.OneSecTxDoneCount = 0;
-	pAd->RalinkCounters.OneSecRxCount = 0;
-	pAd->RalinkCounters.OneSecTxAggregationCount = 0;
-	pAd->RalinkCounters.OneSecRxAggregationCount = 0;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine is executed periodically to -
-		1. Decide if it's a right time to turn on PwrMgmt bit of all
-		   outgoiing frames
-		2. Calculate ChannelQuality based on statistics of the last
-		   period, so that TX rate won't toggling very frequently between a
-		   successful TX and a failed TX.
-		3. If the calculated ChannelQuality indicated current connection not
-		   healthy, then a ROAMing attempt is tried here.
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-#define ADHOC_BEACON_LOST_TIME		(8*OS_HZ)	/* 8 sec */
-void MlmePeriodicExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3)
-{
-	unsigned long TxTotalCnt;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-#ifdef RTMP_MAC_PCI
-	{
-		/* If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second. */
-		/* Move code to here, because following code will return when radio is off */
-		if ((pAd->Mlme.PeriodicRound % (MLME_TASK_EXEC_MULTIPLE * 2) ==
-		     0) && (pAd->StaCfg.bHardwareRadio == TRUE)
-		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-		    /*&&(pAd->bPCIclkOff == FALSE) */
-		    ) {
-			u32 data = 0;
-
-			/* Read GPIO pin2 as Hardware controlled radio state */
-#ifndef RT3090
-			RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &data);
-#endif /* RT3090 // */
-/*KH(PCIE PS):Added based on Jane<-- */
-#ifdef RT3090
-/* Read GPIO pin2 as Hardware controlled radio state */
-/* We need to Read GPIO if HW said so no mater what advance power saving */
-			if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
-			    &&
-			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))
-			    && (pAd->StaCfg.PSControl.field.EnablePSinIdle ==
-				TRUE)) {
-				/* Want to make sure device goes to L0 state before reading register. */
-				RTMPPCIeLinkCtrlValueRestore(pAd, 0);
-				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
-				RTMPPCIeLinkCtrlSetting(pAd, 3);
-			} else
-				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
-#endif /* RT3090 // */
-/*KH(PCIE PS):Added based on Jane--> */
-
-			if (data & 0x04) {
-				pAd->StaCfg.bHwRadio = TRUE;
-			} else {
-				pAd->StaCfg.bHwRadio = FALSE;
-			}
-			if (pAd->StaCfg.bRadio !=
-			    (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio)) {
-				pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio
-						      && pAd->StaCfg.bSwRadio);
-				if (pAd->StaCfg.bRadio == TRUE) {
-					MlmeRadioOn(pAd);
-					/* Update extra information */
-					pAd->ExtraInfo = EXTRA_INFO_CLEAR;
-				} else {
-					MlmeRadioOff(pAd);
-					/* Update extra information */
-					pAd->ExtraInfo = HW_RADIO_OFF;
-				}
-			}
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_RADIO_OFF |
-				  fRTMP_ADAPTER_RADIO_MEASUREMENT |
-				  fRTMP_ADAPTER_RESET_IN_PROGRESS))))
-		return;
-
-	RTMP_MLME_PRE_SANITY_CHECK(pAd);
-
-	{
-		/* Do nothing if monitor mode is on */
-		if (MONITOR_ON(pAd))
-			return;
-
-		if (pAd->Mlme.PeriodicRound & 0x1) {
-			/* This is the fix for wifi 11n extension channel overlapping test case.  for 2860D */
-			if (((pAd->MACVersion & 0xffff) == 0x0101) &&
-			    (STA_TGN_WIFI_ON(pAd)) &&
-			    (pAd->CommonCfg.IOTestParm.bToggle == FALSE))
-			{
-				RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x24Bf);
-				pAd->CommonCfg.IOTestParm.bToggle = TRUE;
-			} else if ((STA_TGN_WIFI_ON(pAd)) &&
-				   ((pAd->MACVersion & 0xffff) == 0x0101)) {
-				RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x243f);
-				pAd->CommonCfg.IOTestParm.bToggle = FALSE;
-			}
-		}
-	}
-
-	pAd->bUpdateBcnCntDone = FALSE;
-
-/*      RECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3); */
-	pAd->Mlme.PeriodicRound++;
-
-#ifdef RTMP_MAC_USB
-	/* execute every 100ms, update the Tx FIFO Cnt for update Tx Rate. */
-	NICUpdateFifoStaCounters(pAd);
-#endif /* RTMP_MAC_USB // */
-
-	/* execute every 500ms */
-	if ((pAd->Mlme.PeriodicRound % 5 == 0)
-	    && RTMPAutoRateSwitchCheck(pAd)
-	    /*(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */ )
-	{
-		/* perform dynamic tx rate switching based on past TX history */
-		{
-			if ((OPSTATUS_TEST_FLAG
-			     (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-			    )
-			    && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)))
-				MlmeDynamicTxRateSwitching(pAd);
-		}
-	}
-	/* Normal 1 second Mlme PeriodicExec. */
-	if (pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0) {
-		pAd->Mlme.OneSecPeriodicRound++;
-
-		/*ORIBATimerTimeout(pAd); */
-
-		/* Media status changed, report to NDIS */
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE)) {
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
-			if (OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-				pAd->IndicateMediaState =
-				    NdisMediaStateConnected;
-				RTMP_IndicateMediaState(pAd);
-
-			} else {
-				pAd->IndicateMediaState =
-				    NdisMediaStateDisconnected;
-				RTMP_IndicateMediaState(pAd);
-			}
-		}
-
-		NdisGetSystemUpTime(&pAd->Mlme.Now32);
-
-		/* add the most up-to-date h/w raw counters into software variable, so that */
-		/* the dynamic tuning mechanism below are based on most up-to-date information */
-		NICUpdateRawCounters(pAd);
-
-#ifdef RTMP_MAC_USB
-		RTUSBWatchDog(pAd);
-#endif /* RTMP_MAC_USB // */
-
-		/* Need statistics after read counter. So put after NICUpdateRawCounters */
-		ORIBATimerTimeout(pAd);
-
-		/* if MGMT RING is full more than twice within 1 second, we consider there's */
-		/* a hardware problem stucking the TX path. In this case, try a hardware reset */
-		/* to recover the system */
-		/*      if (pAd->RalinkCounters.MgmtRingFullCount >= 2) */
-		/*              RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR); */
-		/*      else */
-		/*              pAd->RalinkCounters.MgmtRingFullCount = 0; */
-
-		/* The time period for checking antenna is according to traffic */
-		{
-			if (pAd->Mlme.bEnableAutoAntennaCheck) {
-				TxTotalCnt =
-				    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-				    pAd->RalinkCounters.OneSecTxRetryOkCount +
-				    pAd->RalinkCounters.OneSecTxFailCount;
-
-				/* dynamic adjust antenna evaluation period according to the traffic */
-				if (TxTotalCnt > 50) {
-					if (pAd->Mlme.OneSecPeriodicRound %
-					    10 == 0) {
-						AsicEvaluateRxAnt(pAd);
-					}
-				} else {
-					if (pAd->Mlme.OneSecPeriodicRound % 3 ==
-					    0) {
-						AsicEvaluateRxAnt(pAd);
-					}
-				}
-			}
-		}
-
-		STAMlmePeriodicExec(pAd);
-
-		MlmeResetRalinkCounters(pAd);
-
-		{
-#ifdef RTMP_MAC_PCI
-			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
-			    && (pAd->bPCIclkOff == FALSE))
-#endif /* RTMP_MAC_PCI // */
-			{
-				/* When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock */
-				/* and sending CTS-to-self over and over. */
-				/* Software Patch Solution: */
-				/* 1. Polling debug state register 0x10F4 every one second. */
-				/* 2. If in 0x10F4 the ((bit29==1) && (bit7==1)) OR ((bit29==1) && (bit5==1)), it means the deadlock has occurred. */
-				/* 3. If the deadlock occurred, reset MAC/BBP by setting 0x1004 to 0x0001 for a while then setting it back to 0x000C again. */
-
-				u32 MacReg = 0;
-
-				RTMP_IO_READ32(pAd, 0x10F4, &MacReg);
-				if (((MacReg & 0x20000000) && (MacReg & 0x80))
-				    || ((MacReg & 0x20000000)
-					&& (MacReg & 0x20))) {
-					RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
-					RTMPusecDelay(1);
-					RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0xC);
-
-					DBGPRINT(RT_DEBUG_WARN,
-						 ("Warning, MAC specific condition occurs \n"));
-				}
-			}
-		}
-
-		RTMP_MLME_HANDLER(pAd);
-	}
-
-	pAd->bUpdateBcnCntDone = FALSE;
-}
-
-/*
-	==========================================================================
-	Validate SSID for connection try and rescan purpose
-	Valid SSID will have visible chars only.
-	The valid length is from 0 to 32.
-	IRQL = DISPATCH_LEVEL
-	==========================================================================
- */
-BOOLEAN MlmeValidateSSID(u8 *pSsid, u8 SsidLen)
-{
-	int index;
-
-	if (SsidLen > MAX_LEN_OF_SSID)
-		return (FALSE);
-
-	/* Check each character value */
-	for (index = 0; index < SsidLen; index++) {
-		if (pSsid[index] < 0x20)
-			return (FALSE);
-	}
-
-	/* All checked */
-	return (TRUE);
-}
-
-void MlmeSelectTxRateTable(struct rt_rtmp_adapter *pAd,
-			   struct rt_mac_table_entry *pEntry,
-			   u8 ** ppTable,
-			   u8 *pTableSize, u8 *pInitTxRateIdx)
-{
-	do {
-		/* decide the rate table for tuning */
-		if (pAd->CommonCfg.TxRateTableSize > 0) {
-			*ppTable = RateSwitchTable;
-			*pTableSize = RateSwitchTable[0];
-			*pInitTxRateIdx = RateSwitchTable[1];
-
-			break;
-		}
-
-		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd)) {
-			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) {	/* 11N 1S Adhoc */
-				*ppTable = RateSwitchTable11N1S;
-				*pTableSize = RateSwitchTable11N1S[0];
-				*pInitTxRateIdx = RateSwitchTable11N1S[1];
-
-			} else if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) {	/* 11N 2S Adhoc */
-				if (pAd->LatchRfRegs.Channel <= 14) {
-					*ppTable = RateSwitchTable11N2S;
-					*pTableSize = RateSwitchTable11N2S[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N2S[1];
-				} else {
-					*ppTable = RateSwitchTable11N2SForABand;
-					*pTableSize =
-					    RateSwitchTable11N2SForABand[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N2SForABand[1];
-				}
-
-			} else if ((pEntry->RateLen == 4)
-				   && (pEntry->HTCapability.MCSSet[0] == 0)
-				   && (pEntry->HTCapability.MCSSet[1] == 0)
-			    ) {
-				*ppTable = RateSwitchTable11B;
-				*pTableSize = RateSwitchTable11B[0];
-				*pInitTxRateIdx = RateSwitchTable11B[1];
-
-			} else if (pAd->LatchRfRegs.Channel <= 14) {
-				*ppTable = RateSwitchTable11BG;
-				*pTableSize = RateSwitchTable11BG[0];
-				*pInitTxRateIdx = RateSwitchTable11BG[1];
-
-			} else {
-				*ppTable = RateSwitchTable11G;
-				*pTableSize = RateSwitchTable11G[0];
-				*pInitTxRateIdx = RateSwitchTable11G[1];
-
-			}
-			break;
-		}
-		/*if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && */
-		/*      ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) */
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	/* 11BGN 1S AP */
-			*ppTable = RateSwitchTable11BGN1S;
-			*pTableSize = RateSwitchTable11BGN1S[0];
-			*pInitTxRateIdx = RateSwitchTable11BGN1S[1];
-
-			break;
-		}
-		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && */
-		/*      (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) */
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	/* 11BGN 2S AP */
-			if (pAd->LatchRfRegs.Channel <= 14) {
-				*ppTable = RateSwitchTable11BGN2S;
-				*pTableSize = RateSwitchTable11BGN2S[0];
-				*pInitTxRateIdx = RateSwitchTable11BGN2S[1];
-
-			} else {
-				*ppTable = RateSwitchTable11BGN2SForABand;
-				*pTableSize = RateSwitchTable11BGN2SForABand[0];
-				*pInitTxRateIdx =
-				    RateSwitchTable11BGN2SForABand[1];
-
-			}
-			break;
-		}
-		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) */
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	/* 11N 1S AP */
-			*ppTable = RateSwitchTable11N1S;
-			*pTableSize = RateSwitchTable11N1S[0];
-			*pInitTxRateIdx = RateSwitchTable11N1S[1];
-
-			break;
-		}
-		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) */
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	/* 11N 2S AP */
-			if (pAd->LatchRfRegs.Channel <= 14) {
-				*ppTable = RateSwitchTable11N2S;
-				*pTableSize = RateSwitchTable11N2S[0];
-				*pInitTxRateIdx = RateSwitchTable11N2S[1];
-			} else {
-				*ppTable = RateSwitchTable11N2SForABand;
-				*pTableSize = RateSwitchTable11N2SForABand[0];
-				*pInitTxRateIdx =
-				    RateSwitchTable11N2SForABand[1];
-			}
-
-			break;
-		}
-		/*else if ((pAd->StaActive.SupRateLen == 4) && (pAd->StaActive.ExtRateLen == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
-		if ((pEntry->RateLen == 4 || pAd->CommonCfg.PhyMode == PHY_11B)
-		    /*Iverson mark for Adhoc b mode,sta will use rate 54  Mbps when connect with sta b/g/n mode */
-		    /* && (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0) */
-		    ) {		/* B only AP */
-			*ppTable = RateSwitchTable11B;
-			*pTableSize = RateSwitchTable11B[0];
-			*pInitTxRateIdx = RateSwitchTable11B[1];
-
-			break;
-		}
-		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
-		if ((pEntry->RateLen > 8)
-		    && (pEntry->HTCapability.MCSSet[0] == 0)
-		    && (pEntry->HTCapability.MCSSet[1] == 0)
-		    ) {		/* B/G  mixed AP */
-			*ppTable = RateSwitchTable11BG;
-			*pTableSize = RateSwitchTable11BG[0];
-			*pInitTxRateIdx = RateSwitchTable11BG[1];
-
-			break;
-		}
-		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
-		if ((pEntry->RateLen == 8)
-		    && (pEntry->HTCapability.MCSSet[0] == 0)
-		    && (pEntry->HTCapability.MCSSet[1] == 0)
-		    ) {		/* G only AP */
-			*ppTable = RateSwitchTable11G;
-			*pTableSize = RateSwitchTable11G[0];
-			*pInitTxRateIdx = RateSwitchTable11G[1];
-
-			break;
-		}
-
-		{
-			/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
-			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)) {	/* Legacy mode */
-				if (pAd->CommonCfg.MaxTxRate <= RATE_11) {
-					*ppTable = RateSwitchTable11B;
-					*pTableSize = RateSwitchTable11B[0];
-					*pInitTxRateIdx = RateSwitchTable11B[1];
-				} else if ((pAd->CommonCfg.MaxTxRate > RATE_11)
-					   && (pAd->CommonCfg.MinTxRate >
-					       RATE_11)) {
-					*ppTable = RateSwitchTable11G;
-					*pTableSize = RateSwitchTable11G[0];
-					*pInitTxRateIdx = RateSwitchTable11G[1];
-
-				} else {
-					*ppTable = RateSwitchTable11BG;
-					*pTableSize = RateSwitchTable11BG[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11BG[1];
-				}
-				break;
-			}
-			if (pAd->LatchRfRegs.Channel <= 14) {
-				if (pAd->CommonCfg.TxStream == 1) {
-					*ppTable = RateSwitchTable11N1S;
-					*pTableSize = RateSwitchTable11N1S[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N1S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unknown mode,default use 11N 1S AP \n"));
-				} else {
-					*ppTable = RateSwitchTable11N2S;
-					*pTableSize = RateSwitchTable11N2S[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N2S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unknown mode,default use 11N 2S AP \n"));
-				}
-			} else {
-				if (pAd->CommonCfg.TxStream == 1) {
-					*ppTable = RateSwitchTable11N1S;
-					*pTableSize = RateSwitchTable11N1S[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N1S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unknown mode,default use 11N 1S AP \n"));
-				} else {
-					*ppTable = RateSwitchTable11N2SForABand;
-					*pTableSize =
-					    RateSwitchTable11N2SForABand[0];
-					*pInitTxRateIdx =
-					    RateSwitchTable11N2SForABand[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unknown mode,default use 11N 2S AP \n"));
-				}
-			}
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("DRS: unknown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
-				      pAd->StaActive.SupRateLen,
-				      pAd->StaActive.ExtRateLen,
-				      pAd->StaActive.SupportedPhyInfo.MCSSet[0],
-				      pAd->StaActive.SupportedPhyInfo.
-				      MCSSet[1]));
-		}
-	} while (FALSE);
-}
-
-void STAMlmePeriodicExec(struct rt_rtmp_adapter *pAd)
-{
-	unsigned long TxTotalCnt;
-	int i;
-
-	/*
-	   We return here in ATE mode, because the statistics
-	   that ATE need are not collected via this routine.
-	 */
-#if defined(RT305x)||defined(RT3070)
-	/* request by Gary, if Rssi0 > -42, BBP 82 need to be changed from 0x62 to 0x42, , bbp 67 need to be changed from 0x20 to 0x18 */
-	if (!pAd->CommonCfg.HighPowerPatchDisabled) {
-#ifdef RT3070
-		if ((IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
-#endif /* RT3070 // */
-		{
-			if ((pAd->StaCfg.RssiSample.AvgRssi0 != 0)
-			    && (pAd->StaCfg.RssiSample.AvgRssi0 >
-				(pAd->BbpRssiToDbmDelta - 35))) {
-				RT30xxWriteRFRegister(pAd, RF_R27, 0x20);
-			} else {
-				RT30xxWriteRFRegister(pAd, RF_R27, 0x23);
-			}
-		}
-	}
-#endif
-#ifdef PCIE_PS_SUPPORT
-/* don't perform idle-power-save mechanism within 3 min after driver initialization. */
-/* This can make rebooter test more robust */
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-		if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
-		    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
-		    && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
-			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
-				if (pAd->StaCfg.PSControl.field.EnableNewPS ==
-				    TRUE) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("%s\n", __func__));
-					RT28xxPciAsicRadioOff(pAd,
-							      GUI_IDLE_POWER_SAVE,
-							      0);
-				} else {
-					AsicSendCommandToMcu(pAd, 0x30,
-							     PowerSafeCID, 0xff,
-							     0x2);
-					/* Wait command success */
-					AsicCheckCommanOk(pAd, PowerSafeCID);
-					RTMP_SET_FLAG(pAd,
-						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("PSM - rt30xx Issue Sleep command)\n"));
-				}
-			} else if (pAd->Mlme.OneSecPeriodicRound > 180) {
-				if (pAd->StaCfg.PSControl.field.EnableNewPS ==
-				    TRUE) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("%s\n", __func__));
-					RT28xxPciAsicRadioOff(pAd,
-							      GUI_IDLE_POWER_SAVE,
-							      0);
-				} else {
-					AsicSendCommandToMcu(pAd, 0x30,
-							     PowerSafeCID, 0xff,
-							     0x02);
-					/* Wait command success */
-					AsicCheckCommanOk(pAd, PowerSafeCID);
-					RTMP_SET_FLAG(pAd,
-						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("PSM -  rt28xx Issue Sleep command)\n"));
-				}
-			}
-		} else {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("STAMlmePeriodicExec MMCHK - CommonCfg.Ssid[%d]=%c%c%c%c... MlmeAux.Ssid[%d]=%c%c%c%c...\n",
-				  pAd->CommonCfg.SsidLen,
-				  pAd->CommonCfg.Ssid[0],
-				  pAd->CommonCfg.Ssid[1],
-				  pAd->CommonCfg.Ssid[2],
-				  pAd->CommonCfg.Ssid[3], pAd->MlmeAux.SsidLen,
-				  pAd->MlmeAux.Ssid[0], pAd->MlmeAux.Ssid[1],
-				  pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]));
-		}
-	}
-#endif /* PCIE_PS_SUPPORT // */
-
-	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) {
-		/* WPA MIC error should block association attempt for 60 seconds */
-		if (pAd->StaCfg.bBlockAssoc &&
-		    RTMP_TIME_AFTER(pAd->Mlme.Now32,
-				    pAd->StaCfg.LastMicErrorTime +
-				    (60 * OS_HZ)))
-			pAd->StaCfg.bBlockAssoc = FALSE;
-	}
-
-	if ((pAd->PreMediaState != pAd->IndicateMediaState)
-	    && (pAd->CommonCfg.bWirelessEvent)) {
-		if (pAd->IndicateMediaState == NdisMediaStateConnected) {
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		}
-		pAd->PreMediaState = pAd->IndicateMediaState;
-	}
-
-	if (pAd->CommonCfg.PSPXlink && ADHOC_ON(pAd)) {
-	} else {
-		AsicStaBbpTuning(pAd);
-	}
-
-	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-	    pAd->RalinkCounters.OneSecTxRetryOkCount +
-	    pAd->RalinkCounters.OneSecTxFailCount;
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-		/* update channel quality for Roaming and UI LinkQuality display */
-		MlmeCalculateChannelQuality(pAd, NULL, pAd->Mlme.Now32);
-	}
-	/* must be AFTER MlmeDynamicTxRateSwitching() because it needs to know if */
-	/* Radio is currently in noisy environment */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		AsicAdjustTxPower(pAd);
-
-	if (INFRA_ON(pAd)) {
-
-		/* Is PSM bit consistent with user power management policy? */
-		/* This is the only place that will set PSM bit ON. */
-		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-			MlmeCheckPsmChange(pAd, pAd->Mlme.Now32);
-
-		pAd->RalinkCounters.LastOneSecTotalTxCount = TxTotalCnt;
-
-		if ((RTMP_TIME_AFTER
-		     (pAd->Mlme.Now32,
-		      pAd->StaCfg.LastBeaconRxTime + (1 * OS_HZ)))
-		    &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		    &&
-		    (((TxTotalCnt + pAd->RalinkCounters.OneSecRxOkCnt) <
-		      600))) {
-			RTMPSetAGCInitValue(pAd, BW_20);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n",
-				  (0x2E + GET_LNA_GAIN(pAd))));
-		}
-		/*if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) && */
-		/*    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0)) */
-		{
-			if (pAd->CommonCfg.bAPSDCapable
-			    && pAd->CommonCfg.APEdcaParm.bAPSDCapable) {
-				/* When APSD is enabled, the period changes as 20 sec */
-				if ((pAd->Mlme.OneSecPeriodicRound % 20) == 8)
-					RTMPSendNullFrame(pAd,
-							  pAd->CommonCfg.TxRate,
-							  TRUE);
-			} else {
-				/* Send out a NULL frame every 10 sec to inform AP that STA is still alive (Avoid being age out) */
-				if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8) {
-					if (pAd->CommonCfg.bWmmCapable)
-						RTMPSendNullFrame(pAd,
-								  pAd->
-								  CommonCfg.
-								  TxRate, TRUE);
-					else
-						RTMPSendNullFrame(pAd,
-								  pAd->
-								  CommonCfg.
-								  TxRate,
-								  FALSE);
-				}
-			}
-		}
-
-		if (CQI_IS_DEAD(pAd->Mlme.ChannelQuality)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%ld\n",
-				  pAd->RalinkCounters.BadCQIAutoRecoveryCount));
-
-			/* Lost AP, send disconnect & link down event */
-			LinkDown(pAd, FALSE);
-
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
-						0);
-
-			/* RTMPPatchMacBbpBug(pAd); */
-			MlmeAutoReconnectLastSSID(pAd);
-		} else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality)) {
-			pAd->RalinkCounters.BadCQIAutoRecoveryCount++;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - Bad CQI. Auto Recovery attempt #%ld\n",
-				  pAd->RalinkCounters.BadCQIAutoRecoveryCount));
-			MlmeAutoReconnectLastSSID(pAd);
-		}
-
-		if (pAd->StaCfg.bAutoRoaming) {
-			BOOLEAN rv = FALSE;
-			char dBmToRoam = pAd->StaCfg.dBmToRoam;
-			char MaxRssi = RTMPMaxRssi(pAd,
-						   pAd->StaCfg.RssiSample.
-						   LastRssi0,
-						   pAd->StaCfg.RssiSample.
-						   LastRssi1,
-						   pAd->StaCfg.RssiSample.
-						   LastRssi2);
-
-			/* Scanning, ignore Roaming */
-			if (!RTMP_TEST_FLAG
-			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)
-			    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
-			    && (MaxRssi <= dBmToRoam)) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Rssi=%d, dBmToRoam=%d\n", MaxRssi,
-					  (char)dBmToRoam));
-
-				/* Add auto seamless roaming */
-				if (rv == FALSE)
-					rv = MlmeCheckForFastRoaming(pAd);
-
-				if (rv == FALSE) {
-					if ((pAd->StaCfg.LastScanTime +
-					     10 * OS_HZ) < pAd->Mlme.Now32) {
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("MMCHK - Roaming, No eligible entry, try new scan!\n"));
-						pAd->StaCfg.ScanCnt = 2;
-						pAd->StaCfg.LastScanTime =
-						    pAd->Mlme.Now32;
-						MlmeAutoScan(pAd);
-					}
-				}
-			}
-		}
-	} else if (ADHOC_ON(pAd)) {
-		/* If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState */
-		/* to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can */
-		/* join later. */
-		if (RTMP_TIME_AFTER
-		    (pAd->Mlme.Now32,
-		     pAd->StaCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME)
-		    && OPSTATUS_TEST_FLAG(pAd,
-					  fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-			struct rt_mlme_start_req StartReq;
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - excessive BEACON lost, last STA in this IBSS, MediaState=Disconnected\n"));
-			LinkDown(pAd, FALSE);
-
-			StartParmFill(pAd, &StartReq,
-				      (char *) pAd->MlmeAux.Ssid,
-				      pAd->MlmeAux.SsidLen);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
-				    sizeof(struct rt_mlme_start_req), &StartReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
-		}
-
-		for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
-			struct rt_mac_table_entry *pEntry = &pAd->MacTab.Content[i];
-
-			if (pEntry->ValidAsCLI == FALSE)
-				continue;
-
-			if (RTMP_TIME_AFTER
-			    (pAd->Mlme.Now32,
-			     pEntry->LastBeaconRxTime + ADHOC_BEACON_LOST_TIME))
-				MacTableDeleteEntry(pAd, pEntry->Aid,
-						    pEntry->Addr);
-		}
-	} else			/* no INFRA nor ADHOC connection */
-	{
-
-		if (pAd->StaCfg.bScanReqIsFromWebUI &&
-		    RTMP_TIME_BEFORE(pAd->Mlme.Now32,
-				     pAd->StaCfg.LastScanTime + (30 * OS_HZ)))
-			goto SKIP_AUTO_SCAN_CONN;
-		else
-			pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
-
-		if ((pAd->StaCfg.bAutoReconnect == TRUE)
-		    && RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)
-		    &&
-		    (MlmeValidateSSID
-		     (pAd->MlmeAux.AutoReconnectSsid,
-		      pAd->MlmeAux.AutoReconnectSsidLen) == TRUE)) {
-			if ((pAd->ScanTab.BssNr == 0)
-			    && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)) {
-				struct rt_mlme_scan_req ScanReq;
-
-				if (RTMP_TIME_AFTER
-				    (pAd->Mlme.Now32,
-				     pAd->StaCfg.LastScanTime + (10 * OS_HZ))) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("STAMlmePeriodicExec():CNTL - ScanTab.BssNr==0, start a new ACTIVE scan SSID[%s]\n",
-						  pAd->MlmeAux.
-						  AutoReconnectSsid));
-					ScanParmFill(pAd, &ScanReq,
-						     (char *)pAd->MlmeAux.
-						     AutoReconnectSsid,
-						     pAd->MlmeAux.
-						     AutoReconnectSsidLen,
-						     BSS_ANY, SCAN_ACTIVE);
-					MlmeEnqueue(pAd, SYNC_STATE_MACHINE,
-						    MT2_MLME_SCAN_REQ,
-						    sizeof
-						    (struct rt_mlme_scan_req),
-						    &ScanReq);
-					pAd->Mlme.CntlMachine.CurrState =
-					    CNTL_WAIT_OID_LIST_SCAN;
-					/* Reset Missed scan number */
-					pAd->StaCfg.LastScanTime =
-					    pAd->Mlme.Now32;
-				} else if (pAd->StaCfg.BssType == BSS_ADHOC)	/* Quit the forever scan when in a very clean room */
-					MlmeAutoReconnectLastSSID(pAd);
-			} else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
-				if ((pAd->Mlme.OneSecPeriodicRound % 7) == 0) {
-					MlmeAutoScan(pAd);
-					pAd->StaCfg.LastScanTime =
-					    pAd->Mlme.Now32;
-				} else {
-					MlmeAutoReconnectLastSSID(pAd);
-				}
-			}
-		}
-	}
-
-SKIP_AUTO_SCAN_CONN:
-
-	if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap != 0)
-	    && (pAd->MacTab.fAnyBASession == FALSE)) {
-		pAd->MacTab.fAnyBASession = TRUE;
-		AsicUpdateProtect(pAd, HT_FORCERTSCTS, ALLN_SETPROTECT, FALSE,
-				  FALSE);
-	} else if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap == 0)
-		   && (pAd->MacTab.fAnyBASession == TRUE)) {
-		pAd->MacTab.fAnyBASession = FALSE;
-		AsicUpdateProtect(pAd,
-				  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-				  OperaionMode, ALLN_SETPROTECT, FALSE, FALSE);
-	}
-
-	return;
-}
-
-/* Link down report */
-void LinkDownExec(void *SystemSpecific1,
-		  void *FunctionContext,
-		  void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	if (pAd != NULL) {
-		struct rt_mlme_disassoc_req DisassocReq;
-
-		if ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) &&
-		    (INFRA_ON(pAd))) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("LinkDownExec(): disassociate with current AP...\n"));
-			DisassocParmFill(pAd, &DisassocReq,
-					 pAd->CommonCfg.Bssid,
-					 REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-				    MT2_MLME_DISASSOC_REQ,
-				    sizeof(struct rt_mlme_disassoc_req),
-				    &DisassocReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-
-			pAd->IndicateMediaState = NdisMediaStateDisconnected;
-			RTMP_IndicateMediaState(pAd);
-			pAd->ExtraInfo = GENERAL_LINK_DOWN;
-		}
-	}
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeAutoScan(struct rt_rtmp_adapter *pAd)
-{
-	/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
-	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
-		DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Driver auto scan\n"));
-		MlmeEnqueue(pAd,
-			    MLME_CNTL_STATE_MACHINE,
-			    OID_802_11_BSSID_LIST_SCAN,
-			    pAd->MlmeAux.AutoReconnectSsidLen,
-			    pAd->MlmeAux.AutoReconnectSsid);
-		RTMP_MLME_HANDLER(pAd);
-	}
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeAutoReconnectLastSSID(struct rt_rtmp_adapter *pAd)
-{
-	if (pAd->StaCfg.bAutoConnectByBssid) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			("Driver auto reconnect to last OID_802_11_BSSID "
-				"setting - %pM\n", pAd->MlmeAux.Bssid));
-
-		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
-		MlmeEnqueue(pAd,
-			    MLME_CNTL_STATE_MACHINE,
-			    OID_802_11_BSSID, MAC_ADDR_LEN, pAd->MlmeAux.Bssid);
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-
-		RTMP_MLME_HANDLER(pAd);
-	}
-	/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
-	else if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
-		 (MlmeValidateSSID
-		  (pAd->MlmeAux.AutoReconnectSsid,
-		   pAd->MlmeAux.AutoReconnectSsidLen) == TRUE)) {
-		struct rt_ndis_802_11_ssid OidSsid;
-		OidSsid.SsidLength = pAd->MlmeAux.AutoReconnectSsidLen;
-		NdisMoveMemory(OidSsid.Ssid, pAd->MlmeAux.AutoReconnectSsid,
-			       pAd->MlmeAux.AutoReconnectSsidLen);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Driver auto reconnect to last OID_802_11_SSID setting - %s, len - %d\n",
-			  pAd->MlmeAux.AutoReconnectSsid,
-			  pAd->MlmeAux.AutoReconnectSsidLen));
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, OID_802_11_SSID,
-			    sizeof(struct rt_ndis_802_11_ssid), &OidSsid);
-		RTMP_MLME_HANDLER(pAd);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine checks if there're other APs out there capable for
-		roaming. Caller should call this routine only when Link up in INFRA mode
-		and channel quality is below CQI_GOOD_THRESHOLD.
-
-	IRQL = DISPATCH_LEVEL
-
-	Output:
-	==========================================================================
- */
-void MlmeCheckForRoaming(struct rt_rtmp_adapter *pAd, unsigned long Now32)
-{
-	u16 i;
-	struct rt_bss_table *pRoamTab = &pAd->MlmeAux.RoamTab;
-	struct rt_bss_entry *pBss;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForRoaming\n"));
-	/* put all roaming candidates into RoamTab, and sort in RSSI order */
-	BssTableInit(pRoamTab);
-	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
-		pBss = &pAd->ScanTab.BssEntry[i];
-
-		if ((pBss->LastBeaconRxTime + pAd->StaCfg.BeaconLostTime) <
-		    Now32)
-			continue;	/* AP disappear */
-		if (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)
-			continue;	/* RSSI too weak. forget it. */
-		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	/* skip current AP */
-		if (pBss->Rssi <
-		    (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))
-			continue;	/* only AP with stronger RSSI is eligible for roaming */
-
-		/* AP passing all above rules is put into roaming candidate table */
-		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
-			       sizeof(struct rt_bss_entry));
-		pRoamTab->BssNr += 1;
-	}
-
-	if (pRoamTab->BssNr > 0) {
-		/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
-		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
-			pAd->RalinkCounters.PoorCQIRoamingCount++;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - Roaming attempt #%ld\n",
-				  pAd->RalinkCounters.PoorCQIRoamingCount));
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_MLME_ROAMING_REQ, 0, NULL);
-			RTMP_MLME_HANDLER(pAd);
-		}
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<== MlmeCheckForRoaming(# of candidate= %d)\n",
-		  pRoamTab->BssNr));
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine checks if there're other APs out there capable for
-		roaming. Caller should call this routine only when link up in INFRA mode
-		and channel quality is below CQI_GOOD_THRESHOLD.
-
-	IRQL = DISPATCH_LEVEL
-
-	Output:
-	==========================================================================
- */
-BOOLEAN MlmeCheckForFastRoaming(struct rt_rtmp_adapter *pAd)
-{
-	u16 i;
-	struct rt_bss_table *pRoamTab = &pAd->MlmeAux.RoamTab;
-	struct rt_bss_entry *pBss;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForFastRoaming\n"));
-	/* put all roaming candidates into RoamTab, and sort in RSSI order */
-	BssTableInit(pRoamTab);
-	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
-		pBss = &pAd->ScanTab.BssEntry[i];
-
-		if ((pBss->Rssi <= -50)
-		    && (pBss->Channel == pAd->CommonCfg.Channel))
-			continue;	/* RSSI too weak. forget it. */
-		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	/* skip current AP */
-		if (!SSID_EQUAL
-		    (pBss->Ssid, pBss->SsidLen, pAd->CommonCfg.Ssid,
-		     pAd->CommonCfg.SsidLen))
-			continue;	/* skip different SSID */
-		if (pBss->Rssi <
-		    (RTMPMaxRssi
-		     (pAd, pAd->StaCfg.RssiSample.LastRssi0,
-		      pAd->StaCfg.RssiSample.LastRssi1,
-		      pAd->StaCfg.RssiSample.LastRssi2) + RSSI_DELTA))
-			continue;	/* skip AP without better RSSI */
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("LastRssi0 = %d, pBss->Rssi = %d\n",
-			  RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0,
-				      pAd->StaCfg.RssiSample.LastRssi1,
-				      pAd->StaCfg.RssiSample.LastRssi2),
-			  pBss->Rssi));
-		/* AP passing all above rules is put into roaming candidate table */
-		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
-			       sizeof(struct rt_bss_entry));
-		pRoamTab->BssNr += 1;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<== MlmeCheckForFastRoaming (BssNr=%d)\n", pRoamTab->BssNr));
-	if (pRoamTab->BssNr > 0) {
-		/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
-		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
-			pAd->RalinkCounters.PoorCQIRoamingCount++;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MMCHK - Roaming attempt #%ld\n",
-				  pAd->RalinkCounters.PoorCQIRoamingCount));
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_MLME_ROAMING_REQ, 0, NULL);
-			RTMP_MLME_HANDLER(pAd);
-			return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-void MlmeSetTxRate(struct rt_rtmp_adapter *pAd,
-		   struct rt_mac_table_entry *pEntry, struct rt_rtmp_tx_rate_switch * pTxRate)
-{
-	u8 MaxMode = MODE_OFDM;
-
-	MaxMode = MODE_HTGREENFIELD;
-
-	if (pTxRate->STBC && (pAd->StaCfg.MaxHTPhyMode.field.STBC)
-	    && (pAd->Antenna.field.TxPath == 2))
-		pAd->StaCfg.HTPhyMode.field.STBC = STBC_USE;
-	else
-		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
-
-	if (pTxRate->CurrMCS < MCS_AUTO)
-		pAd->StaCfg.HTPhyMode.field.MCS = pTxRate->CurrMCS;
-
-	if (pAd->StaCfg.HTPhyMode.field.MCS > 7)
-		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
-
-	if (ADHOC_ON(pAd)) {
-		/* If peer adhoc is b-only mode, we can't send 11g rate. */
-		pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-		pEntry->HTPhyMode.field.STBC = STBC_NONE;
-
-		/* */
-		/* For Adhoc MODE_CCK, driver will use AdhocBOnlyJoined flag to roll back to B only if necessary */
-		/* */
-		pEntry->HTPhyMode.field.MODE = pTxRate->Mode;
-		pEntry->HTPhyMode.field.ShortGI =
-		    pAd->StaCfg.HTPhyMode.field.ShortGI;
-		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
-
-		/* Patch speed error in status page */
-		pAd->StaCfg.HTPhyMode.field.MODE = pEntry->HTPhyMode.field.MODE;
-	} else {
-		if (pTxRate->Mode <= MaxMode)
-			pAd->StaCfg.HTPhyMode.field.MODE = pTxRate->Mode;
-
-		if (pTxRate->ShortGI
-		    && (pAd->StaCfg.MaxHTPhyMode.field.ShortGI))
-			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_400;
-		else
-			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-
-		/* Reexam each bandwidth's SGI support. */
-		if (pAd->StaCfg.HTPhyMode.field.ShortGI == GI_400) {
-			if ((pEntry->HTPhyMode.field.BW == BW_20)
-			    &&
-			    (!CLIENT_STATUS_TEST_FLAG
-			     (pEntry, fCLIENT_STATUS_SGI20_CAPABLE)))
-				pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-			if ((pEntry->HTPhyMode.field.BW == BW_40)
-			    &&
-			    (!CLIENT_STATUS_TEST_FLAG
-			     (pEntry, fCLIENT_STATUS_SGI40_CAPABLE)))
-				pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-		}
-		/* Turn RTS/CTS rate to 6Mbps. */
-		if ((pEntry->HTPhyMode.field.MCS == 0)
-		    && (pAd->StaCfg.HTPhyMode.field.MCS != 0)) {
-			pEntry->HTPhyMode.field.MCS =
-			    pAd->StaCfg.HTPhyMode.field.MCS;
-			if (pAd->MacTab.fAnyBASession) {
-				AsicUpdateProtect(pAd, HT_FORCERTSCTS,
-						  ALLN_SETPROTECT, TRUE,
-						  (BOOLEAN) pAd->MlmeAux.
-						  AddHtInfo.AddHtInfo2.
-						  NonGfPresent);
-			} else {
-				AsicUpdateProtect(pAd,
-						  pAd->MlmeAux.AddHtInfo.
-						  AddHtInfo2.OperaionMode,
-						  ALLN_SETPROTECT, TRUE,
-						  (BOOLEAN) pAd->MlmeAux.
-						  AddHtInfo.AddHtInfo2.
-						  NonGfPresent);
-			}
-		} else if ((pEntry->HTPhyMode.field.MCS == 8)
-			   && (pAd->StaCfg.HTPhyMode.field.MCS != 8)) {
-			pEntry->HTPhyMode.field.MCS =
-			    pAd->StaCfg.HTPhyMode.field.MCS;
-			if (pAd->MacTab.fAnyBASession) {
-				AsicUpdateProtect(pAd, HT_FORCERTSCTS,
-						  ALLN_SETPROTECT, TRUE,
-						  (BOOLEAN) pAd->MlmeAux.
-						  AddHtInfo.AddHtInfo2.
-						  NonGfPresent);
-			} else {
-				AsicUpdateProtect(pAd,
-						  pAd->MlmeAux.AddHtInfo.
-						  AddHtInfo2.OperaionMode,
-						  ALLN_SETPROTECT, TRUE,
-						  (BOOLEAN) pAd->MlmeAux.
-						  AddHtInfo.AddHtInfo2.
-						  NonGfPresent);
-			}
-		} else if ((pEntry->HTPhyMode.field.MCS != 0)
-			   && (pAd->StaCfg.HTPhyMode.field.MCS == 0)) {
-			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT,
-					  TRUE,
-					  (BOOLEAN) pAd->MlmeAux.AddHtInfo.
-					  AddHtInfo2.NonGfPresent);
-
-		} else if ((pEntry->HTPhyMode.field.MCS != 8)
-			   && (pAd->StaCfg.HTPhyMode.field.MCS == 8)) {
-			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT,
-					  TRUE,
-					  (BOOLEAN) pAd->MlmeAux.AddHtInfo.
-					  AddHtInfo2.NonGfPresent);
-		}
-
-		pEntry->HTPhyMode.field.STBC = pAd->StaCfg.HTPhyMode.field.STBC;
-		pEntry->HTPhyMode.field.ShortGI =
-		    pAd->StaCfg.HTPhyMode.field.ShortGI;
-		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
-		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
-		if ((pAd->StaCfg.MaxHTPhyMode.field.MODE == MODE_HTGREENFIELD)
-		    && pAd->WIFItestbed.bGreenField)
-			pEntry->HTPhyMode.field.MODE = MODE_HTGREENFIELD;
-	}
-
-	pAd->LastTxRate = (u16)(pEntry->HTPhyMode.word);
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine calculates the acumulated TxPER of eaxh TxRate. And
-		according to the calculation result, change CommonCfg.TxRate which
-		is the stable TX Rate we expect the Radio situation could sustained.
-
-		CommonCfg.TxRate will change dynamically within {RATE_1/RATE_6, MaxTxRate}
-	Output:
-		CommonCfg.TxRate -
-
-	IRQL = DISPATCH_LEVEL
-
-	NOTE:
-		call this routine every second
-	==========================================================================
- */
-void MlmeDynamicTxRateSwitching(struct rt_rtmp_adapter *pAd)
-{
-	u8 UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx;
-	unsigned long i, AccuTxTotalCnt = 0, TxTotalCnt;
-	unsigned long TxErrorRatio = 0;
-	BOOLEAN bTxRateChanged = FALSE, bUpgradeQuality = FALSE;
-	struct rt_rtmp_tx_rate_switch *pCurrTxRate, *pNextTxRate = NULL;
-	u8 *pTable;
-	u8 TableSize = 0;
-	u8 InitTxRateIdx = 0, TrainUp, TrainDown;
-	char Rssi, RssiOffset = 0;
-	TX_STA_CNT1_STRUC StaTx1;
-	TX_STA_CNT0_STRUC TxStaCnt0;
-	unsigned long TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
-	struct rt_mac_table_entry *pEntry;
-	struct rt_rssi_sample *pRssi = &pAd->StaCfg.RssiSample;
-
-	/* */
-	/* walk through MAC table, see if need to change AP's TX rate toward each entry */
-	/* */
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
-		pEntry = &pAd->MacTab.Content[i];
-
-		/* check if this entry need to switch rate automatically */
-		if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pEntry) == FALSE)
-			continue;
-
-		if ((pAd->MacTab.Size == 1) || (pEntry->ValidAsDls)) {
-			Rssi = RTMPMaxRssi(pAd,
-					   pRssi->AvgRssi0,
-					   pRssi->AvgRssi1, pRssi->AvgRssi2);
-
-			/* Update statistic counter */
-			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
-			RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
-			pAd->bUpdateBcnCntDone = TRUE;
-			TxRetransmit = StaTx1.field.TxRetransmit;
-			TxSuccess = StaTx1.field.TxSuccess;
-			TxFailCount = TxStaCnt0.field.TxFailCount;
-			TxTotalCnt = TxRetransmit + TxSuccess + TxFailCount;
-
-			pAd->RalinkCounters.OneSecTxRetryOkCount +=
-			    StaTx1.field.TxRetransmit;
-			pAd->RalinkCounters.OneSecTxNoRetryOkCount +=
-			    StaTx1.field.TxSuccess;
-			pAd->RalinkCounters.OneSecTxFailCount +=
-			    TxStaCnt0.field.TxFailCount;
-			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
-			    StaTx1.field.TxSuccess;
-			pAd->WlanCounters.RetryCount.u.LowPart +=
-			    StaTx1.field.TxRetransmit;
-			pAd->WlanCounters.FailedCount.u.LowPart +=
-			    TxStaCnt0.field.TxFailCount;
-
-			/* if no traffic in the past 1-sec period, don't change TX rate, */
-			/* but clear all bad history. because the bad history may affect the next */
-			/* Chariot throughput test */
-			AccuTxTotalCnt =
-			    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-			    pAd->RalinkCounters.OneSecTxRetryOkCount +
-			    pAd->RalinkCounters.OneSecTxFailCount;
-
-			if (TxTotalCnt)
-				TxErrorRatio =
-				    ((TxRetransmit +
-				      TxFailCount) * 100) / TxTotalCnt;
-		} else {
-			if (INFRA_ON(pAd) && (i == 1))
-				Rssi = RTMPMaxRssi(pAd,
-						   pRssi->AvgRssi0,
-						   pRssi->AvgRssi1,
-						   pRssi->AvgRssi2);
-			else
-				Rssi = RTMPMaxRssi(pAd,
-						   pEntry->RssiSample.AvgRssi0,
-						   pEntry->RssiSample.AvgRssi1,
-						   pEntry->RssiSample.AvgRssi2);
-
-			TxTotalCnt = pEntry->OneSecTxNoRetryOkCount +
-			    pEntry->OneSecTxRetryOkCount +
-			    pEntry->OneSecTxFailCount;
-
-			if (TxTotalCnt)
-				TxErrorRatio =
-				    ((pEntry->OneSecTxRetryOkCount +
-				      pEntry->OneSecTxFailCount) * 100) /
-				    TxTotalCnt;
-		}
-
-		if (TxTotalCnt) {
-			/*
-			   Three AdHoc connections can not work normally if one AdHoc connection is disappeared from a heavy traffic environment generated by ping tool
-			   We force to set LongRtyLimit and ShortRtyLimit to 0 to stop retransmitting packet, after a while, resoring original settings
-			 */
-			if (TxErrorRatio == 100) {
-				TX_RTY_CFG_STRUC TxRtyCfg, TxRtyCfgtmp;
-				unsigned long Index;
-				unsigned long MACValue;
-
-				RTMP_IO_READ32(pAd, TX_RTY_CFG, &TxRtyCfg.word);
-				TxRtyCfgtmp.word = TxRtyCfg.word;
-				TxRtyCfg.field.LongRtyLimit = 0x0;
-				TxRtyCfg.field.ShortRtyLimit = 0x0;
-				RTMP_IO_WRITE32(pAd, TX_RTY_CFG, TxRtyCfg.word);
-
-				RTMPusecDelay(1);
-
-				Index = 0;
-				MACValue = 0;
-				do {
-					RTMP_IO_READ32(pAd, TXRXQ_PCNT,
-						       &MACValue);
-					if ((MACValue & 0xffffff) == 0)
-						break;
-					Index++;
-					RTMPusecDelay(1000);
-				} while ((Index < 330)
-					 &&
-					 (!RTMP_TEST_FLAG
-					  (pAd,
-					   fRTMP_ADAPTER_HALT_IN_PROGRESS)));
-
-				RTMP_IO_READ32(pAd, TX_RTY_CFG, &TxRtyCfg.word);
-				TxRtyCfg.field.LongRtyLimit =
-				    TxRtyCfgtmp.field.LongRtyLimit;
-				TxRtyCfg.field.ShortRtyLimit =
-				    TxRtyCfgtmp.field.ShortRtyLimit;
-				RTMP_IO_WRITE32(pAd, TX_RTY_CFG, TxRtyCfg.word);
-			}
-		}
-
-		CurrRateIdx = pEntry->CurrTxRateIndex;
-
-		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
-				      &InitTxRateIdx);
-
-		if (CurrRateIdx >= TableSize) {
-			CurrRateIdx = TableSize - 1;
-		}
-		/* When switch from Fixed rate -> auto rate, the REAL TX rate might be different from pAd->CommonCfg.TxRateIndex. */
-		/* So need to sync here. */
-		pCurrTxRate =
-		    (struct rt_rtmp_tx_rate_switch *) & pTable[(CurrRateIdx + 1) * 5];
-		if ((pEntry->HTPhyMode.field.MCS != pCurrTxRate->CurrMCS)
-		    /*&& (pAd->StaCfg.bAutoTxRateSwitch == TRUE) */
-		    ) {
-
-			/* Need to sync Real Tx rate and our record. */
-			/* Then return for next DRS. */
-			pCurrTxRate =
-			    (struct rt_rtmp_tx_rate_switch *) & pTable[(InitTxRateIdx + 1)
-							    * 5];
-			pEntry->CurrTxRateIndex = InitTxRateIdx;
-			MlmeSetTxRate(pAd, pEntry, pCurrTxRate);
-
-			/* reset all OneSecTx counters */
-			RESET_ONE_SEC_TX_CNT(pEntry);
-			continue;
-		}
-		/* decide the next upgrade rate and downgrade rate, if any */
-		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
-			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx - 1;
-		} else if (CurrRateIdx == 0) {
-			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx;
-		} else if (CurrRateIdx == (TableSize - 1)) {
-			UpRateIdx = CurrRateIdx;
-			DownRateIdx = CurrRateIdx - 1;
-		}
-
-		pCurrTxRate =
-		    (struct rt_rtmp_tx_rate_switch *) & pTable[(CurrRateIdx + 1) * 5];
-
-		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX)) {
-			TrainUp =
-			    (pCurrTxRate->TrainUp +
-			     (pCurrTxRate->TrainUp >> 1));
-			TrainDown =
-			    (pCurrTxRate->TrainDown +
-			     (pCurrTxRate->TrainDown >> 1));
-		} else {
-			TrainUp = pCurrTxRate->TrainUp;
-			TrainDown = pCurrTxRate->TrainDown;
-		}
-
-		/*pAd->DrsCounters.LastTimeTxRateChangeAction = pAd->DrsCounters.LastSecTxRateChangeAction; */
-
-		/* */
-		/* Keep the last time TxRateChangeAction status. */
-		/* */
-		pEntry->LastTimeTxRateChangeAction =
-		    pEntry->LastSecTxRateChangeAction;
-
-		/* */
-		/* CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI */
-		/*         (criteria copied from RT2500 for Netopia case) */
-		/* */
-		if (TxTotalCnt <= 15) {
-			char idx = 0;
-			u8 TxRateIdx;
-			u8 MCS0 = 0, MCS1 = 0, MCS2 = 0, MCS3 = 0, MCS4 =
-			    0, MCS5 = 0, MCS6 = 0, MCS7 = 0;
-			u8 MCS12 = 0, MCS13 = 0, MCS14 = 0, MCS15 = 0;
-			u8 MCS20 = 0, MCS21 = 0, MCS22 = 0, MCS23 = 0;	/* 3*3 */
-
-			/* check the existence and index of each needed MCS */
-			while (idx < pTable[0]) {
-				pCurrTxRate =
-				    (struct rt_rtmp_tx_rate_switch *) & pTable[(idx + 1) *
-								    5];
-
-				if (pCurrTxRate->CurrMCS == MCS_0) {
-					MCS0 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_1) {
-					MCS1 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_2) {
-					MCS2 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_3) {
-					MCS3 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_4) {
-					MCS4 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_5) {
-					MCS5 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_6) {
-					MCS6 = idx;
-				}
-				/*else if (pCurrTxRate->CurrMCS == MCS_7) */
-				else if ((pCurrTxRate->CurrMCS == MCS_7) && (pCurrTxRate->ShortGI == GI_800))	/* prevent the highest MCS using short GI when 1T and low throughput */
-				{
-					MCS7 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_12) {
-					MCS12 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_13) {
-					MCS13 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_14) {
-					MCS14 = idx;
-				}
-				else if ((pCurrTxRate->CurrMCS == MCS_15) && (pCurrTxRate->ShortGI == GI_800))	/*we hope to use ShortGI as initial rate, however Atheros's chip has bugs when short GI */
-				{
-					MCS15 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_20)	/* 3*3 */
-				{
-					MCS20 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_21) {
-					MCS21 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_22) {
-					MCS22 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_23) {
-					MCS23 = idx;
-				}
-				idx++;
-			}
-
-			if (pAd->LatchRfRegs.Channel <= 14) {
-				if (pAd->NicConfig2.field.ExternalLNAForG) {
-					RssiOffset = 2;
-				} else {
-					RssiOffset = 5;
-				}
-			} else {
-				if (pAd->NicConfig2.field.ExternalLNAForA) {
-					RssiOffset = 5;
-				} else {
-					RssiOffset = 8;
-				}
-			}
-
-			/*if (MCS15) */
-			if ((pTable == RateSwitchTable11BGN3S) || (pTable == RateSwitchTable11N3S) || (pTable == RateSwitchTable)) {	/* N mode with 3 stream // 3*3 */
-				if (MCS23 && (Rssi >= -70))
-					TxRateIdx = MCS23;
-				else if (MCS22 && (Rssi >= -72))
-					TxRateIdx = MCS22;
-				else if (MCS21 && (Rssi >= -76))
-					TxRateIdx = MCS21;
-				else if (MCS20 && (Rssi >= -78))
-					TxRateIdx = MCS20;
-				else if (MCS4 && (Rssi >= -82))
-					TxRateIdx = MCS4;
-				else if (MCS3 && (Rssi >= -84))
-					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi >= -86))
-					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi >= -88))
-					TxRateIdx = MCS1;
-				else
-					TxRateIdx = MCS0;
-			}
-/*              else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable)) */
-			else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) || (pTable == RateSwitchTable11N2S) || (pTable == RateSwitchTable11N2SForABand))	/* 3*3 */
-			{	/* N mode with 2 stream */
-				if (MCS15 && (Rssi >= (-70 + RssiOffset)))
-					TxRateIdx = MCS15;
-				else if (MCS14 && (Rssi >= (-72 + RssiOffset)))
-					TxRateIdx = MCS14;
-				else if (MCS13 && (Rssi >= (-76 + RssiOffset)))
-					TxRateIdx = MCS13;
-				else if (MCS12 && (Rssi >= (-78 + RssiOffset)))
-					TxRateIdx = MCS12;
-				else if (MCS4 && (Rssi >= (-82 + RssiOffset)))
-					TxRateIdx = MCS4;
-				else if (MCS3 && (Rssi >= (-84 + RssiOffset)))
-					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi >= (-86 + RssiOffset)))
-					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi >= (-88 + RssiOffset)))
-					TxRateIdx = MCS1;
-				else
-					TxRateIdx = MCS0;
-			} else if ((pTable == RateSwitchTable11BGN1S) || (pTable == RateSwitchTable11N1S)) {	/* N mode with 1 stream */
-				if (MCS7 && (Rssi > (-72 + RssiOffset)))
-					TxRateIdx = MCS7;
-				else if (MCS6 && (Rssi > (-74 + RssiOffset)))
-					TxRateIdx = MCS6;
-				else if (MCS5 && (Rssi > (-77 + RssiOffset)))
-					TxRateIdx = MCS5;
-				else if (MCS4 && (Rssi > (-79 + RssiOffset)))
-					TxRateIdx = MCS4;
-				else if (MCS3 && (Rssi > (-81 + RssiOffset)))
-					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi > (-83 + RssiOffset)))
-					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi > (-86 + RssiOffset)))
-					TxRateIdx = MCS1;
-				else
-					TxRateIdx = MCS0;
-			} else {	/* Legacy mode */
-				if (MCS7 && (Rssi > -70))
-					TxRateIdx = MCS7;
-				else if (MCS6 && (Rssi > -74))
-					TxRateIdx = MCS6;
-				else if (MCS5 && (Rssi > -78))
-					TxRateIdx = MCS5;
-				else if (MCS4 && (Rssi > -82))
-					TxRateIdx = MCS4;
-				else if (MCS4 == 0)	/* for B-only mode */
-					TxRateIdx = MCS3;
-				else if (MCS3 && (Rssi > -85))
-					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi > -87))
-					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi > -90))
-					TxRateIdx = MCS1;
-				else
-					TxRateIdx = MCS0;
-			}
-
-			/*              if (TxRateIdx != pAd->CommonCfg.TxRateIndex) */
-			{
-				pEntry->CurrTxRateIndex = TxRateIdx;
-				pNextTxRate =
-				    (struct rt_rtmp_tx_rate_switch *) &
-				    pTable[(pEntry->CurrTxRateIndex + 1) * 5];
-				MlmeSetTxRate(pAd, pEntry, pNextTxRate);
-			}
-
-			NdisZeroMemory(pEntry->TxQuality,
-				       sizeof(u16)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pEntry->PER,
-				       sizeof(u8)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			pEntry->fLastSecAccordingRSSI = TRUE;
-			/* reset all OneSecTx counters */
-			RESET_ONE_SEC_TX_CNT(pEntry);
-
-			continue;
-		}
-
-		if (pEntry->fLastSecAccordingRSSI == TRUE) {
-			pEntry->fLastSecAccordingRSSI = FALSE;
-			pEntry->LastSecTxRateChangeAction = 0;
-			/* reset all OneSecTx counters */
-			RESET_ONE_SEC_TX_CNT(pEntry);
-
-			continue;
-		}
-
-		do {
-			BOOLEAN bTrainUpDown = FALSE;
-
-			pEntry->CurrTxRateStableTime++;
-
-			/* downgrade TX quality if PER >= Rate-Down threshold */
-			if (TxErrorRatio >= TrainDown) {
-				bTrainUpDown = TRUE;
-				pEntry->TxQuality[CurrRateIdx] =
-				    DRS_TX_QUALITY_WORST_BOUND;
-			}
-			/* upgrade TX quality if PER <= Rate-Up threshold */
-			else if (TxErrorRatio <= TrainUp) {
-				bTrainUpDown = TRUE;
-				bUpgradeQuality = TRUE;
-				if (pEntry->TxQuality[CurrRateIdx])
-					pEntry->TxQuality[CurrRateIdx]--;	/* quality very good in CurrRate */
-
-				if (pEntry->TxRateUpPenalty)
-					pEntry->TxRateUpPenalty--;
-				else if (pEntry->TxQuality[UpRateIdx])
-					pEntry->TxQuality[UpRateIdx]--;	/* may improve next UP rate's quality */
-			}
-
-			pEntry->PER[CurrRateIdx] = (u8)TxErrorRatio;
-
-			if (bTrainUpDown) {
-				/* perform DRS - consider TxRate Down first, then rate up. */
-				if ((CurrRateIdx != DownRateIdx)
-				    && (pEntry->TxQuality[CurrRateIdx] >=
-					DRS_TX_QUALITY_WORST_BOUND)) {
-					pEntry->CurrTxRateIndex = DownRateIdx;
-				} else if ((CurrRateIdx != UpRateIdx)
-					   && (pEntry->TxQuality[UpRateIdx] <=
-					       0)) {
-					pEntry->CurrTxRateIndex = UpRateIdx;
-				}
-			}
-		} while (FALSE);
-
-		/* if rate-up happen, clear all bad history of all TX rates */
-		if (pEntry->CurrTxRateIndex > CurrRateIdx) {
-			pEntry->CurrTxRateStableTime = 0;
-			pEntry->TxRateUpPenalty = 0;
-			pEntry->LastSecTxRateChangeAction = 1;	/* rate UP */
-			NdisZeroMemory(pEntry->TxQuality,
-				       sizeof(u16)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pEntry->PER,
-				       sizeof(u8)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-
-			/* */
-			/* For TxRate fast train up */
-			/* */
-			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
-				RTMPSetTimer(&pAd->StaCfg.
-					     StaQuickResponeForRateUpTimer,
-					     100);
-
-				pAd->StaCfg.
-				    StaQuickResponeForRateUpTimerRunning = TRUE;
-			}
-			bTxRateChanged = TRUE;
-		}
-		/* if rate-down happen, only clear DownRate's bad history */
-		else if (pEntry->CurrTxRateIndex < CurrRateIdx) {
-			pEntry->CurrTxRateStableTime = 0;
-			pEntry->TxRateUpPenalty = 0;	/* no penalty */
-			pEntry->LastSecTxRateChangeAction = 2;	/* rate DOWN */
-			pEntry->TxQuality[pEntry->CurrTxRateIndex] = 0;
-			pEntry->PER[pEntry->CurrTxRateIndex] = 0;
-
-			/* */
-			/* For TxRate fast train down */
-			/* */
-			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
-				RTMPSetTimer(&pAd->StaCfg.
-					     StaQuickResponeForRateUpTimer,
-					     100);
-
-				pAd->StaCfg.
-				    StaQuickResponeForRateUpTimerRunning = TRUE;
-			}
-			bTxRateChanged = TRUE;
-		} else {
-			pEntry->LastSecTxRateChangeAction = 0;	/* rate no change */
-			bTxRateChanged = FALSE;
-		}
-
-		pEntry->LastTxOkCount = TxSuccess;
-		{
-			u8 tmpTxRate;
-
-			/* to fix tcp ack issue */
-			if (!bTxRateChanged
-			    && (pAd->RalinkCounters.OneSecReceivedByteCount >
-				(pAd->RalinkCounters.
-				 OneSecTransmittedByteCount * 5))) {
-				tmpTxRate = DownRateIdx;
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("DRS: Rx(%d) is 5 times larger than Tx(%d), use low rate (curr=%d, tmp=%d)\n",
-					      pAd->RalinkCounters.
-					      OneSecReceivedByteCount,
-					      pAd->RalinkCounters.
-					      OneSecTransmittedByteCount,
-					      pEntry->CurrTxRateIndex,
-					      tmpTxRate));
-			} else {
-				tmpTxRate = pEntry->CurrTxRateIndex;
-			}
-
-			pNextTxRate =
-			    (struct rt_rtmp_tx_rate_switch *) & pTable[(tmpTxRate + 1) *
-							    5];
-		}
-		if (bTxRateChanged && pNextTxRate) {
-			MlmeSetTxRate(pAd, pEntry, pNextTxRate);
-		}
-		/* reset all OneSecTx counters */
-		RESET_ONE_SEC_TX_CNT(pEntry);
-	}
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Station side, Auto TxRate faster train up timer call back function.
-
-	Arguments:
-		SystemSpecific1			- Not used.
-		FunctionContext			- Pointer to our Adapter context.
-		SystemSpecific2			- Not used.
-		SystemSpecific3			- Not used.
-
-	Return Value:
-		None
-
-	========================================================================
-*/
-void StaQuickResponeForRateUpExec(void *SystemSpecific1,
-				  void *FunctionContext,
-				  void *SystemSpecific2,
-				  void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	u8 UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx = 0;
-	unsigned long TxTotalCnt;
-	unsigned long TxErrorRatio = 0;
-	BOOLEAN bTxRateChanged;	/*, bUpgradeQuality = FALSE; */
-	struct rt_rtmp_tx_rate_switch *pCurrTxRate, *pNextTxRate = NULL;
-	u8 *pTable;
-	u8 TableSize = 0;
-	u8 InitTxRateIdx = 0, TrainUp, TrainDown;
-	TX_STA_CNT1_STRUC StaTx1;
-	TX_STA_CNT0_STRUC TxStaCnt0;
-	char Rssi, ratio;
-	unsigned long TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
-	struct rt_mac_table_entry *pEntry;
-	unsigned long i;
-
-	pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
-
-	/* */
-	/* walk through MAC table, see if need to change AP's TX rate toward each entry */
-	/* */
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
-		pEntry = &pAd->MacTab.Content[i];
-
-		/* check if this entry need to switch rate automatically */
-		if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pEntry) == FALSE)
-			continue;
-
-		if (INFRA_ON(pAd) && (i == 1))
-			Rssi = RTMPMaxRssi(pAd,
-					   pAd->StaCfg.RssiSample.AvgRssi0,
-					   pAd->StaCfg.RssiSample.AvgRssi1,
-					   pAd->StaCfg.RssiSample.AvgRssi2);
-		else
-			Rssi = RTMPMaxRssi(pAd,
-					   pEntry->RssiSample.AvgRssi0,
-					   pEntry->RssiSample.AvgRssi1,
-					   pEntry->RssiSample.AvgRssi2);
-
-		CurrRateIdx = pAd->CommonCfg.TxRateIndex;
-
-		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
-				      &InitTxRateIdx);
-
-		/* decide the next upgrade rate and downgrade rate, if any */
-		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
-			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx - 1;
-		} else if (CurrRateIdx == 0) {
-			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx;
-		} else if (CurrRateIdx == (TableSize - 1)) {
-			UpRateIdx = CurrRateIdx;
-			DownRateIdx = CurrRateIdx - 1;
-		}
-
-		pCurrTxRate =
-		    (struct rt_rtmp_tx_rate_switch *) & pTable[(CurrRateIdx + 1) * 5];
-
-		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX)) {
-			TrainUp =
-			    (pCurrTxRate->TrainUp +
-			     (pCurrTxRate->TrainUp >> 1));
-			TrainDown =
-			    (pCurrTxRate->TrainDown +
-			     (pCurrTxRate->TrainDown >> 1));
-		} else {
-			TrainUp = pCurrTxRate->TrainUp;
-			TrainDown = pCurrTxRate->TrainDown;
-		}
-
-		if (pAd->MacTab.Size == 1) {
-			/* Update statistic counter */
-			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
-			RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
-
-			TxRetransmit = StaTx1.field.TxRetransmit;
-			TxSuccess = StaTx1.field.TxSuccess;
-			TxFailCount = TxStaCnt0.field.TxFailCount;
-			TxTotalCnt = TxRetransmit + TxSuccess + TxFailCount;
-
-			pAd->RalinkCounters.OneSecTxRetryOkCount +=
-			    StaTx1.field.TxRetransmit;
-			pAd->RalinkCounters.OneSecTxNoRetryOkCount +=
-			    StaTx1.field.TxSuccess;
-			pAd->RalinkCounters.OneSecTxFailCount +=
-			    TxStaCnt0.field.TxFailCount;
-			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
-			    StaTx1.field.TxSuccess;
-			pAd->WlanCounters.RetryCount.u.LowPart +=
-			    StaTx1.field.TxRetransmit;
-			pAd->WlanCounters.FailedCount.u.LowPart +=
-			    TxStaCnt0.field.TxFailCount;
-
-			if (TxTotalCnt)
-				TxErrorRatio =
-				    ((TxRetransmit +
-				      TxFailCount) * 100) / TxTotalCnt;
-		} else {
-			TxTotalCnt = pEntry->OneSecTxNoRetryOkCount +
-			    pEntry->OneSecTxRetryOkCount +
-			    pEntry->OneSecTxFailCount;
-
-			if (TxTotalCnt)
-				TxErrorRatio =
-				    ((pEntry->OneSecTxRetryOkCount +
-				      pEntry->OneSecTxFailCount) * 100) /
-				    TxTotalCnt;
-		}
-
-		/* */
-		/* CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI */
-		/*         (criteria copied from RT2500 for Netopia case) */
-		/* */
-		if (TxTotalCnt <= 12) {
-			NdisZeroMemory(pAd->DrsCounters.TxQuality,
-				       sizeof(u16)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pAd->DrsCounters.PER,
-				       sizeof(u8)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-
-			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1)
-			    && (CurrRateIdx != DownRateIdx)) {
-				pAd->CommonCfg.TxRateIndex = DownRateIdx;
-				pAd->DrsCounters.TxQuality[CurrRateIdx] =
-				    DRS_TX_QUALITY_WORST_BOUND;
-			} else
-			    if ((pAd->DrsCounters.LastSecTxRateChangeAction ==
-				 2) && (CurrRateIdx != UpRateIdx)) {
-				pAd->CommonCfg.TxRateIndex = UpRateIdx;
-			}
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("QuickDRS: TxTotalCnt <= 15, train back to original rate \n"));
-			return;
-		}
-
-		do {
-			unsigned long OneSecTxNoRetryOKRationCount;
-
-			if (pAd->DrsCounters.LastTimeTxRateChangeAction == 0)
-				ratio = 5;
-			else
-				ratio = 4;
-
-			/* downgrade TX quality if PER >= Rate-Down threshold */
-			if (TxErrorRatio >= TrainDown) {
-				pAd->DrsCounters.TxQuality[CurrRateIdx] =
-				    DRS_TX_QUALITY_WORST_BOUND;
-			}
-
-			pAd->DrsCounters.PER[CurrRateIdx] =
-			    (u8)TxErrorRatio;
-
-			OneSecTxNoRetryOKRationCount = (TxSuccess * ratio);
-
-			/* perform DRS - consider TxRate Down first, then rate up. */
-			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1)
-			    && (CurrRateIdx != DownRateIdx)) {
-				if ((pAd->DrsCounters.LastTxOkCount + 2) >=
-				    OneSecTxNoRetryOKRationCount) {
-					pAd->CommonCfg.TxRateIndex =
-					    DownRateIdx;
-					pAd->DrsCounters.
-					    TxQuality[CurrRateIdx] =
-					    DRS_TX_QUALITY_WORST_BOUND;
-
-				}
-
-			} else
-			    if ((pAd->DrsCounters.LastSecTxRateChangeAction ==
-				 2) && (CurrRateIdx != UpRateIdx)) {
-				if ((TxErrorRatio >= 50)
-				    || (TxErrorRatio >= TrainDown)) {
-
-				} else if ((pAd->DrsCounters.LastTxOkCount + 2)
-					   >= OneSecTxNoRetryOKRationCount) {
-					pAd->CommonCfg.TxRateIndex = UpRateIdx;
-				}
-			}
-		} while (FALSE);
-
-		/* if rate-up happen, clear all bad history of all TX rates */
-		if (pAd->CommonCfg.TxRateIndex > CurrRateIdx) {
-			pAd->DrsCounters.TxRateUpPenalty = 0;
-			NdisZeroMemory(pAd->DrsCounters.TxQuality,
-				       sizeof(u16)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pAd->DrsCounters.PER,
-				       sizeof(u8)*
-				       MAX_STEP_OF_TX_RATE_SWITCH);
-			bTxRateChanged = TRUE;
-		}
-		/* if rate-down happen, only clear DownRate's bad history */
-		else if (pAd->CommonCfg.TxRateIndex < CurrRateIdx) {
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("QuickDRS: --TX rate from %d to %d \n",
-				      CurrRateIdx, pAd->CommonCfg.TxRateIndex));
-
-			pAd->DrsCounters.TxRateUpPenalty = 0;	/* no penalty */
-			pAd->DrsCounters.TxQuality[pAd->CommonCfg.TxRateIndex] =
-			    0;
-			pAd->DrsCounters.PER[pAd->CommonCfg.TxRateIndex] = 0;
-			bTxRateChanged = TRUE;
-		} else {
-			bTxRateChanged = FALSE;
-		}
-
-		pNextTxRate =
-		    (struct rt_rtmp_tx_rate_switch *) &
-		    pTable[(pAd->CommonCfg.TxRateIndex + 1) * 5];
-		if (bTxRateChanged && pNextTxRate) {
-			MlmeSetTxRate(pAd, pEntry, pNextTxRate);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine is executed periodically inside MlmePeriodicExec() after
-		association with an AP.
-		It checks if StaCfg.Psm is consistent with user policy (recorded in
-		StaCfg.WindowsPowerMode). If not, enforce user policy. However,
-		there're some conditions to consider:
-		1. we don't support power-saving in ADHOC mode, so Psm=PWR_ACTIVE all
-		   the time when Mibss==TRUE
-		2. When link up in INFRA mode, Psm should not be switch to PWR_SAVE
-		   if outgoing traffic available in TxRing or MgmtRing.
-	Output:
-		1. change pAd->StaCfg.Psm to PWR_SAVE or leave it untouched
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void MlmeCheckPsmChange(struct rt_rtmp_adapter *pAd, unsigned long Now32)
-{
-	unsigned long PowerMode;
-
-	/* condition - */
-	/* 1. Psm maybe ON only happen in INFRASTRUCTURE mode */
-	/* 2. user wants either MAX_PSP or FAST_PSP */
-	/* 3. but current psm is not in PWR_SAVE */
-	/* 4. CNTL state machine is not doing SCANning */
-	/* 5. no TX SUCCESS event for the past 1-sec period */
-	PowerMode = pAd->StaCfg.WindowsPowerMode;
-
-	if (INFRA_ON(pAd) &&
-	    (PowerMode != Ndis802_11PowerModeCAM) &&
-	    (pAd->StaCfg.Psm == PWR_ACTIVE) &&
-/*              (! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) */
-	    (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
-	    RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)
-	    /*&&
-	       (pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-	       (pAd->RalinkCounters.OneSecTxRetryOkCount == 0) */
-	    ) {
-		NdisGetSystemUpTime(&pAd->Mlme.LastSendNULLpsmTime);
-		pAd->RalinkCounters.RxCountSinceLastNULL = 0;
-		RTMP_SET_PSM_BIT(pAd, PWR_SAVE);
-		if (!
-		    (pAd->CommonCfg.bAPSDCapable
-		     && pAd->CommonCfg.APEdcaParm.bAPSDCapable)) {
-			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, FALSE);
-		} else {
-			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-		}
-	}
-}
-
-/* IRQL = PASSIVE_LEVEL */
-/* IRQL = DISPATCH_LEVEL */
-void MlmeSetPsmBit(struct rt_rtmp_adapter *pAd, u16 psm)
-{
-	AUTO_RSP_CFG_STRUC csr4;
-
-	pAd->StaCfg.Psm = psm;
-	RTMP_IO_READ32(pAd, AUTO_RSP_CFG, &csr4.word);
-	csr4.field.AckCtsPsmBit = (psm == PWR_SAVE) ? 1 : 0;
-	RTMP_IO_WRITE32(pAd, AUTO_RSP_CFG, csr4.word);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("MlmeSetPsmBit = %d\n", psm));
-}
-
-/*
-	==========================================================================
-	Description:
-		This routine calculates TxPER, RxPER of the past N-sec period. And
-		according to the calculation result, ChannelQuality is calculated here
-		to decide if current AP is still doing the job.
-
-		If ChannelQuality is not good, a ROAMing attempt may be tried later.
-	Output:
-		StaCfg.ChannelQuality - 0..100
-
-	IRQL = DISPATCH_LEVEL
-
-	NOTE: This routine decide channle quality based on RX CRC error ratio.
-		Caller should make sure a function call to NICUpdateRawCounters(pAd)
-		is performed right before this routine, so that this routine can decide
-		channel quality based on the most up-to-date information
-	==========================================================================
- */
-void MlmeCalculateChannelQuality(struct rt_rtmp_adapter *pAd,
-				 struct rt_mac_table_entry *pMacEntry, unsigned long Now32)
-{
-	unsigned long TxOkCnt, TxCnt, TxPER, TxPRR;
-	unsigned long RxCnt, RxPER;
-	u8 NorRssi;
-	char MaxRssi;
-	struct rt_rssi_sample *pRssiSample = NULL;
-	u32 OneSecTxNoRetryOkCount = 0;
-	u32 OneSecTxRetryOkCount = 0;
-	u32 OneSecTxFailCount = 0;
-	u32 OneSecRxOkCnt = 0;
-	u32 OneSecRxFcsErrCnt = 0;
-	unsigned long ChannelQuality = 0;	/* 0..100, Channel Quality Indication for Roaming */
-	unsigned long BeaconLostTime = pAd->StaCfg.BeaconLostTime;
-
-	if (pAd->OpMode == OPMODE_STA) {
-		pRssiSample = &pAd->StaCfg.RssiSample;
-		OneSecTxNoRetryOkCount =
-		    pAd->RalinkCounters.OneSecTxNoRetryOkCount;
-		OneSecTxRetryOkCount = pAd->RalinkCounters.OneSecTxRetryOkCount;
-		OneSecTxFailCount = pAd->RalinkCounters.OneSecTxFailCount;
-		OneSecRxOkCnt = pAd->RalinkCounters.OneSecRxOkCnt;
-		OneSecRxFcsErrCnt = pAd->RalinkCounters.OneSecRxFcsErrCnt;
-	}
-
-	MaxRssi = RTMPMaxRssi(pAd, pRssiSample->LastRssi0,
-			      pRssiSample->LastRssi1, pRssiSample->LastRssi2);
-
-	/* */
-	/* calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics */
-	/* */
-	TxOkCnt = OneSecTxNoRetryOkCount + OneSecTxRetryOkCount;
-	TxCnt = TxOkCnt + OneSecTxFailCount;
-	if (TxCnt < 5) {
-		TxPER = 0;
-		TxPRR = 0;
-	} else {
-		TxPER = (OneSecTxFailCount * 100) / TxCnt;
-		TxPRR = ((TxCnt - OneSecTxNoRetryOkCount) * 100) / TxCnt;
-	}
-
-	/* */
-	/* calculate RX PER - don't take RxPER into consideration if too few sample */
-	/* */
-	RxCnt = OneSecRxOkCnt + OneSecRxFcsErrCnt;
-	if (RxCnt < 5)
-		RxPER = 0;
-	else
-		RxPER = (OneSecRxFcsErrCnt * 100) / RxCnt;
-
-	/* */
-	/* decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER */
-	/* */
-	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && (OneSecTxNoRetryOkCount < 2) &&	/* no heavy traffic */
-	    ((pAd->StaCfg.LastBeaconRxTime + BeaconLostTime) < Now32)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BEACON lost > %ld msec with TxOkCnt=%ld -> CQI=0\n",
-			  BeaconLostTime, TxOkCnt));
-		ChannelQuality = 0;
-	} else {
-		/* Normalize Rssi */
-		if (MaxRssi > -40)
-			NorRssi = 100;
-		else if (MaxRssi < -90)
-			NorRssi = 0;
-		else
-			NorRssi = (MaxRssi + 90) * 2;
-
-		/* ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER        (RSSI 0..100), (TxPER 100..0), (RxPER 100..0) */
-		ChannelQuality = (RSSI_WEIGHTING * NorRssi +
-				  TX_WEIGHTING * (100 - TxPRR) +
-				  RX_WEIGHTING * (100 - RxPER)) / 100;
-	}
-
-	if (pAd->OpMode == OPMODE_STA)
-		pAd->Mlme.ChannelQuality =
-		    (ChannelQuality > 100) ? 100 : ChannelQuality;
-
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeSetTxPreamble(struct rt_rtmp_adapter *pAd, u16 TxPreamble)
-{
-	AUTO_RSP_CFG_STRUC csr4;
-
-	/* */
-	/* Always use Long preamble before verifiation short preamble functionality works well. */
-	/* Todo: remove the following line if short preamble functionality works */
-	/* */
-	/*TxPreamble = Rt802_11PreambleLong; */
-
-	RTMP_IO_READ32(pAd, AUTO_RSP_CFG, &csr4.word);
-	if (TxPreamble == Rt802_11PreambleLong) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeSetTxPreamble (= long PREAMBLE)\n"));
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
-		csr4.field.AutoResponderPreamble = 0;
-	} else {
-		/* NOTE: 1Mbps should always use long preamble */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeSetTxPreamble (= short PREAMBLE)\n"));
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
-		csr4.field.AutoResponderPreamble = 1;
-	}
-
-	RTMP_IO_WRITE32(pAd, AUTO_RSP_CFG, csr4.word);
-}
-
-/*
-    ==========================================================================
-    Description:
-        Update basic rate bitmap
-    ==========================================================================
- */
-
-void UpdateBasicRateBitmap(struct rt_rtmp_adapter *pAdapter)
-{
-	int i, j;
-	/* 1  2  5.5, 11,  6,  9, 12, 18, 24, 36, 48,  54 */
-	u8 rate[] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 };
-	u8 *sup_p = pAdapter->CommonCfg.SupRate;
-	u8 *ext_p = pAdapter->CommonCfg.ExtRate;
-	unsigned long bitmap = pAdapter->CommonCfg.BasicRateBitmap;
-
-	/* if A mode, always use fix BasicRateBitMap */
-	/*if (pAdapter->CommonCfg.Channel == PHY_11A) */
-	if (pAdapter->CommonCfg.Channel > 14)
-		pAdapter->CommonCfg.BasicRateBitmap = 0x150;	/* 6, 12, 24M */
-	/* End of if */
-
-	if (pAdapter->CommonCfg.BasicRateBitmap > 4095) {
-		/* (2 ^ MAX_LEN_OF_SUPPORTED_RATES) -1 */
-		return;
-	}
-	/* End of if */
-	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
-		sup_p[i] &= 0x7f;
-		ext_p[i] &= 0x7f;
-	}			/* End of for */
-
-	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
-		if (bitmap & (1 << i)) {
-			for (j = 0; j < MAX_LEN_OF_SUPPORTED_RATES; j++) {
-				if (sup_p[j] == rate[i])
-					sup_p[j] |= 0x80;
-				/* End of if */
-			}	/* End of for */
-
-			for (j = 0; j < MAX_LEN_OF_SUPPORTED_RATES; j++) {
-				if (ext_p[j] == rate[i])
-					ext_p[j] |= 0x80;
-				/* End of if */
-			}	/* End of for */
-		}		/* End of if */
-	}			/* End of for */
-}				/* End of UpdateBasicRateBitmap */
-
-/* IRQL = PASSIVE_LEVEL */
-/* IRQL = DISPATCH_LEVEL */
-/* bLinkUp is to identify the initial link speed. */
-/* TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps. */
-void MlmeUpdateTxRates(struct rt_rtmp_adapter *pAd, IN BOOLEAN bLinkUp, u8 apidx)
-{
-	int i, num;
-	u8 Rate = RATE_6, MaxDesire = RATE_1, MaxSupport = RATE_1;
-	u8 MinSupport = RATE_54;
-	unsigned long BasicRateBitmap = 0;
-	u8 CurrBasicRate = RATE_1;
-	u8 *pSupRate, SupRateLen, *pExtRate, ExtRateLen;
-	PHTTRANSMIT_SETTING pHtPhy = NULL;
-	PHTTRANSMIT_SETTING pMaxHtPhy = NULL;
-	PHTTRANSMIT_SETTING pMinHtPhy = NULL;
-	BOOLEAN *auto_rate_cur_p;
-	u8 HtMcs = MCS_AUTO;
-
-	/* find max desired rate */
-	UpdateBasicRateBitmap(pAd);
-
-	num = 0;
-	auto_rate_cur_p = NULL;
-	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
-		switch (pAd->CommonCfg.DesireRate[i] & 0x7f) {
-		case 2:
-			Rate = RATE_1;
-			num++;
-			break;
-		case 4:
-			Rate = RATE_2;
-			num++;
-			break;
-		case 11:
-			Rate = RATE_5_5;
-			num++;
-			break;
-		case 22:
-			Rate = RATE_11;
-			num++;
-			break;
-		case 12:
-			Rate = RATE_6;
-			num++;
-			break;
-		case 18:
-			Rate = RATE_9;
-			num++;
-			break;
-		case 24:
-			Rate = RATE_12;
-			num++;
-			break;
-		case 36:
-			Rate = RATE_18;
-			num++;
-			break;
-		case 48:
-			Rate = RATE_24;
-			num++;
-			break;
-		case 72:
-			Rate = RATE_36;
-			num++;
-			break;
-		case 96:
-			Rate = RATE_48;
-			num++;
-			break;
-		case 108:
-			Rate = RATE_54;
-			num++;
-			break;
-			/*default: Rate = RATE_1;   break; */
-		}
-		if (MaxDesire < Rate)
-			MaxDesire = Rate;
-	}
-
-/*=========================================================================== */
-/*=========================================================================== */
-	{
-		pHtPhy = &pAd->StaCfg.HTPhyMode;
-		pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
-		pMinHtPhy = &pAd->StaCfg.MinHTPhyMode;
-
-		auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
-		HtMcs = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
-
-		if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
-		    (pAd->CommonCfg.PhyMode == PHY_11B) &&
-		    (MaxDesire > RATE_11)) {
-			MaxDesire = RATE_11;
-		}
-	}
-
-	pAd->CommonCfg.MaxDesiredRate = MaxDesire;
-	pMinHtPhy->word = 0;
-	pMaxHtPhy->word = 0;
-	pHtPhy->word = 0;
-
-	/* Auto rate switching is enabled only if more than one DESIRED RATES are */
-	/* specified; otherwise disabled */
-	if (num <= 1) {
-		/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
-		/*pAd->CommonCfg.bAutoTxRateSwitch      = FALSE; */
-		*auto_rate_cur_p = FALSE;
-	} else {
-		/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
-		/*pAd->CommonCfg.bAutoTxRateSwitch      = TRUE; */
-		*auto_rate_cur_p = TRUE;
-	}
-
-	if (HtMcs != MCS_AUTO) {
-		/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
-		/*pAd->CommonCfg.bAutoTxRateSwitch      = FALSE; */
-		*auto_rate_cur_p = FALSE;
-	} else {
-		/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
-		/*pAd->CommonCfg.bAutoTxRateSwitch      = TRUE; */
-		*auto_rate_cur_p = TRUE;
-	}
-
-	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) {
-		pSupRate = &pAd->StaActive.SupRate[0];
-		pExtRate = &pAd->StaActive.ExtRate[0];
-		SupRateLen = pAd->StaActive.SupRateLen;
-		ExtRateLen = pAd->StaActive.ExtRateLen;
-	} else {
-		pSupRate = &pAd->CommonCfg.SupRate[0];
-		pExtRate = &pAd->CommonCfg.ExtRate[0];
-		SupRateLen = pAd->CommonCfg.SupRateLen;
-		ExtRateLen = pAd->CommonCfg.ExtRateLen;
-	}
-
-	/* find max supported rate */
-	for (i = 0; i < SupRateLen; i++) {
-		switch (pSupRate[i] & 0x7f) {
-		case 2:
-			Rate = RATE_1;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0001;
-			break;
-		case 4:
-			Rate = RATE_2;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0002;
-			break;
-		case 11:
-			Rate = RATE_5_5;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0004;
-			break;
-		case 22:
-			Rate = RATE_11;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0008;
-			break;
-		case 12:
-			Rate = RATE_6;	/*if (pSupRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0010;
-			break;
-		case 18:
-			Rate = RATE_9;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0020;
-			break;
-		case 24:
-			Rate = RATE_12;	/*if (pSupRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0040;
-			break;
-		case 36:
-			Rate = RATE_18;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0080;
-			break;
-		case 48:
-			Rate = RATE_24;	/*if (pSupRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0100;
-			break;
-		case 72:
-			Rate = RATE_36;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0200;
-			break;
-		case 96:
-			Rate = RATE_48;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0400;
-			break;
-		case 108:
-			Rate = RATE_54;
-			if (pSupRate[i] & 0x80)
-				BasicRateBitmap |= 0x0800;
-			break;
-		default:
-			Rate = RATE_1;
-			break;
-		}
-		if (MaxSupport < Rate)
-			MaxSupport = Rate;
-
-		if (MinSupport > Rate)
-			MinSupport = Rate;
-	}
-
-	for (i = 0; i < ExtRateLen; i++) {
-		switch (pExtRate[i] & 0x7f) {
-		case 2:
-			Rate = RATE_1;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0001;
-			break;
-		case 4:
-			Rate = RATE_2;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0002;
-			break;
-		case 11:
-			Rate = RATE_5_5;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0004;
-			break;
-		case 22:
-			Rate = RATE_11;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0008;
-			break;
-		case 12:
-			Rate = RATE_6;	/*if (pExtRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0010;
-			break;
-		case 18:
-			Rate = RATE_9;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0020;
-			break;
-		case 24:
-			Rate = RATE_12;	/*if (pExtRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0040;
-			break;
-		case 36:
-			Rate = RATE_18;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0080;
-			break;
-		case 48:
-			Rate = RATE_24;	/*if (pExtRate[i] & 0x80) */
-			BasicRateBitmap |= 0x0100;
-			break;
-		case 72:
-			Rate = RATE_36;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0200;
-			break;
-		case 96:
-			Rate = RATE_48;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0400;
-			break;
-		case 108:
-			Rate = RATE_54;
-			if (pExtRate[i] & 0x80)
-				BasicRateBitmap |= 0x0800;
-			break;
-		default:
-			Rate = RATE_1;
-			break;
-		}
-		if (MaxSupport < Rate)
-			MaxSupport = Rate;
-
-		if (MinSupport > Rate)
-			MinSupport = Rate;
-	}
-
-	RTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);
-
-	/* bug fix */
-	/* pAd->CommonCfg.BasicRateBitmap = BasicRateBitmap; */
-
-	/* calculate the exptected ACK rate for each TX rate. This info is used to caculate */
-	/* the DURATION field of outgoing uniicast DATA/MGMT frame */
-	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
-		if (BasicRateBitmap & (0x01 << i))
-			CurrBasicRate = (u8)i;
-		pAd->CommonCfg.ExpectedACKRate[i] = CurrBasicRate;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("MlmeUpdateTxRates[MaxSupport = %d] = MaxDesire %d Mbps\n",
-		  RateIdToMbps[MaxSupport], RateIdToMbps[MaxDesire]));
-	/* max tx rate = min {max desire rate, max supported rate} */
-	if (MaxSupport < MaxDesire)
-		pAd->CommonCfg.MaxTxRate = MaxSupport;
-	else
-		pAd->CommonCfg.MaxTxRate = MaxDesire;
-
-	pAd->CommonCfg.MinTxRate = MinSupport;
-	/* 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success */
-	/* ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending */
-	/* on average RSSI */
-	/*       1. RSSI >= -70db, start at 54 Mbps (short distance) */
-	/*       2. -70 > RSSI >= -75, start at 24 Mbps (mid distance) */
-	/*       3. -75 > RSSI, start at 11 Mbps (long distance) */
-	if (*auto_rate_cur_p) {
-		short dbm = 0;
-
-		dbm = pAd->StaCfg.RssiSample.AvgRssi0 - pAd->BbpRssiToDbmDelta;
-
-		if (bLinkUp == TRUE)
-			pAd->CommonCfg.TxRate = RATE_24;
-		else
-			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
-
-		if (dbm < -75)
-			pAd->CommonCfg.TxRate = RATE_11;
-		else if (dbm < -70)
-			pAd->CommonCfg.TxRate = RATE_24;
-
-		/* should never exceed MaxTxRate (consider 11B-only mode) */
-		if (pAd->CommonCfg.TxRate > pAd->CommonCfg.MaxTxRate)
-			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
-
-		pAd->CommonCfg.TxRateIndex = 0;
-	} else {
-		pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
-		pHtPhy->field.MCS =
-		    (pAd->CommonCfg.MaxTxRate >
-		     3) ? (pAd->CommonCfg.MaxTxRate -
-			   4) : pAd->CommonCfg.MaxTxRate;
-		pHtPhy->field.MODE =
-		    (pAd->CommonCfg.MaxTxRate > 3) ? MODE_OFDM : MODE_CCK;
-
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC =
-		    pHtPhy->field.STBC;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI =
-		    pHtPhy->field.ShortGI;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS =
-		    pHtPhy->field.MCS;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE =
-		    pHtPhy->field.MODE;
-	}
-
-	if (pAd->CommonCfg.TxRate <= RATE_11) {
-		pMaxHtPhy->field.MODE = MODE_CCK;
-		pMaxHtPhy->field.MCS = pAd->CommonCfg.TxRate;
-		pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
-	} else {
-		pMaxHtPhy->field.MODE = MODE_OFDM;
-		pMaxHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.TxRate];
-		if (pAd->CommonCfg.MinTxRate >= RATE_6
-		    && (pAd->CommonCfg.MinTxRate <= RATE_54)) {
-			pMinHtPhy->field.MCS =
-			    OfdmRateToRxwiMCS[pAd->CommonCfg.MinTxRate];
-		} else {
-			pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
-		}
-	}
-
-	pHtPhy->word = (pMaxHtPhy->word);
-	if (bLinkUp && (pAd->OpMode == OPMODE_STA)) {
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word = pHtPhy->word;
-		pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word =
-		    pMaxHtPhy->word;
-		pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word =
-		    pMinHtPhy->word;
-	} else {
-		switch (pAd->CommonCfg.PhyMode) {
-		case PHY_11BG_MIXED:
-		case PHY_11B:
-		case PHY_11BGN_MIXED:
-			pAd->CommonCfg.MlmeRate = RATE_1;
-			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
-			pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
-
-/*#ifdef        WIFI_TEST */
-			pAd->CommonCfg.RtsRate = RATE_11;
-/*#else */
-/*                              pAd->CommonCfg.RtsRate = RATE_1; */
-/*#endif */
-			break;
-		case PHY_11G:
-		case PHY_11A:
-		case PHY_11AGN_MIXED:
-		case PHY_11GN_MIXED:
-		case PHY_11N_2_4G:
-		case PHY_11AN_MIXED:
-		case PHY_11N_5G:
-			pAd->CommonCfg.MlmeRate = RATE_6;
-			pAd->CommonCfg.RtsRate = RATE_6;
-			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-			pAd->CommonCfg.MlmeTransmit.field.MCS =
-			    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-			break;
-		case PHY_11ABG_MIXED:
-		case PHY_11ABGN_MIXED:
-			if (pAd->CommonCfg.Channel <= 14) {
-				pAd->CommonCfg.MlmeRate = RATE_1;
-				pAd->CommonCfg.RtsRate = RATE_1;
-				pAd->CommonCfg.MlmeTransmit.field.MODE =
-				    MODE_CCK;
-				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
-			} else {
-				pAd->CommonCfg.MlmeRate = RATE_6;
-				pAd->CommonCfg.RtsRate = RATE_6;
-				pAd->CommonCfg.MlmeTransmit.field.MODE =
-				    MODE_OFDM;
-				pAd->CommonCfg.MlmeTransmit.field.MCS =
-				    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-			}
-			break;
-		default:	/* error */
-			pAd->CommonCfg.MlmeRate = RATE_6;
-			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-			pAd->CommonCfg.MlmeTransmit.field.MCS =
-			    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-			pAd->CommonCfg.RtsRate = RATE_1;
-			break;
-		}
-		/* */
-		/* Keep Basic Mlme Rate. */
-		/* */
-		pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word =
-		    pAd->CommonCfg.MlmeTransmit.word;
-		if (pAd->CommonCfg.MlmeTransmit.field.MODE == MODE_OFDM)
-			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS =
-			    OfdmRateToRxwiMCS[RATE_24];
-		else
-			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS =
-			    RATE_1;
-		pAd->CommonCfg.BasicMlmeRate = pAd->CommonCfg.MlmeRate;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 (" MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, MinRate=%d, Rate Switching =%d)\n",
-		  RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport],
-		  RateIdToMbps[pAd->CommonCfg.MaxTxRate],
-		  RateIdToMbps[pAd->CommonCfg.MinTxRate],
-		  /*OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) */
-		  *auto_rate_cur_p));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 (" MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04lx)\n",
-		  RateIdToMbps[pAd->CommonCfg.TxRate],
-		  RateIdToMbps[pAd->CommonCfg.RtsRate], BasicRateBitmap));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("MlmeUpdateTxRates (MlmeTransmit=0x%x, MinHTPhyMode=%x, MaxHTPhyMode=0x%x, HTPhyMode=0x%x)\n",
-		  pAd->CommonCfg.MlmeTransmit.word,
-		  pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word,
-		  pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word,
-		  pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word));
-}
-
-/*
-	==========================================================================
-	Description:
-		This function update HT Rate setting.
-		Input Wcid value is valid for 2 case :
-		1. it's used for Station in infra mode that copy AP rate to Mactable.
-		2. OR Station	in adhoc mode to copy peer's HT rate to Mactable.
-
- IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void MlmeUpdateHtTxRates(struct rt_rtmp_adapter *pAd, u8 apidx)
-{
-	u8 StbcMcs;		/*j, StbcMcs, bitmask; */
-	char i;			/* 3*3 */
-	struct rt_ht_capability *pRtHtCap = NULL;
-	struct rt_ht_phy_info *pActiveHtPhy = NULL;
-	unsigned long BasicMCS;
-	u8 j, bitmask;
-	struct rt_ht_phy_info *pDesireHtPhy = NULL;
-	PHTTRANSMIT_SETTING pHtPhy = NULL;
-	PHTTRANSMIT_SETTING pMaxHtPhy = NULL;
-	PHTTRANSMIT_SETTING pMinHtPhy = NULL;
-	BOOLEAN *auto_rate_cur_p;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("MlmeUpdateHtTxRates===> \n"));
-
-	auto_rate_cur_p = NULL;
-
-	{
-		pDesireHtPhy = &pAd->StaCfg.DesiredHtPhyInfo;
-		pActiveHtPhy = &pAd->StaCfg.DesiredHtPhyInfo;
-		pHtPhy = &pAd->StaCfg.HTPhyMode;
-		pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
-		pMinHtPhy = &pAd->StaCfg.MinHTPhyMode;
-
-		auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
-	}
-
-	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) {
-		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
-			return;
-
-		pRtHtCap = &pAd->StaActive.SupportedHtPhy;
-		pActiveHtPhy = &pAd->StaActive.SupportedPhyInfo;
-		StbcMcs = (u8)pAd->MlmeAux.AddHtInfo.AddHtInfo3.StbcMcs;
-		BasicMCS =
-		    pAd->MlmeAux.AddHtInfo.MCSSet[0] +
-		    (pAd->MlmeAux.AddHtInfo.MCSSet[1] << 8) + (StbcMcs << 16);
-		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC)
-		    && (pAd->Antenna.field.TxPath == 2))
-			pMaxHtPhy->field.STBC = STBC_USE;
-		else
-			pMaxHtPhy->field.STBC = STBC_NONE;
-	} else {
-		if (pDesireHtPhy->bHtEnable == FALSE)
-			return;
-
-		pRtHtCap = &pAd->CommonCfg.DesiredHtPhy;
-		StbcMcs = (u8)pAd->CommonCfg.AddHTInfo.AddHtInfo3.StbcMcs;
-		BasicMCS =
-		    pAd->CommonCfg.AddHTInfo.MCSSet[0] +
-		    (pAd->CommonCfg.AddHTInfo.MCSSet[1] << 8) + (StbcMcs << 16);
-		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC)
-		    && (pAd->Antenna.field.TxPath == 2))
-			pMaxHtPhy->field.STBC = STBC_USE;
-		else
-			pMaxHtPhy->field.STBC = STBC_NONE;
-	}
-
-	/* Decide MAX ht rate. */
-	if ((pRtHtCap->GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
-		pMaxHtPhy->field.MODE = MODE_HTGREENFIELD;
-	else
-		pMaxHtPhy->field.MODE = MODE_HTMIX;
-
-	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth)
-	    && (pRtHtCap->ChannelWidth))
-		pMaxHtPhy->field.BW = BW_40;
-	else
-		pMaxHtPhy->field.BW = BW_20;
-
-	if (pMaxHtPhy->field.BW == BW_20)
-		pMaxHtPhy->field.ShortGI =
-		    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 & pRtHtCap->
-		     ShortGIfor20);
-	else
-		pMaxHtPhy->field.ShortGI =
-		    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 & pRtHtCap->
-		     ShortGIfor40);
-
-	if (pDesireHtPhy->MCSSet[4] != 0) {
-		pMaxHtPhy->field.MCS = 32;
-	}
-
-	for (i = 23; i >= 0; i--)	/* 3*3 */
-	{
-		j = i / 8;
-		bitmask = (1 << (i - (j * 8)));
-
-		if ((pActiveHtPhy->MCSSet[j] & bitmask)
-		    && (pDesireHtPhy->MCSSet[j] & bitmask)) {
-			pMaxHtPhy->field.MCS = i;
-			break;
-		}
-
-		if (i == 0)
-			break;
-	}
-
-	/* Copy MIN ht rate.  rt2860??? */
-	pMinHtPhy->field.BW = BW_20;
-	pMinHtPhy->field.MCS = 0;
-	pMinHtPhy->field.STBC = 0;
-	pMinHtPhy->field.ShortGI = 0;
-	/*If STA assigns fixed rate. update to fixed here. */
-	if ((pAd->OpMode == OPMODE_STA) && (pDesireHtPhy->MCSSet[0] != 0xff)) {
-		if (pDesireHtPhy->MCSSet[4] != 0) {
-			pMaxHtPhy->field.MCS = 32;
-			pMinHtPhy->field.MCS = 32;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MlmeUpdateHtTxRates<=== Use Fixed MCS = %d\n",
-				  pMinHtPhy->field.MCS));
-		}
-
-		for (i = 23; (char)i >= 0; i--)	/* 3*3 */
-		{
-			j = i / 8;
-			bitmask = (1 << (i - (j * 8)));
-			if ((pDesireHtPhy->MCSSet[j] & bitmask)
-			    && (pActiveHtPhy->MCSSet[j] & bitmask)) {
-				pMaxHtPhy->field.MCS = i;
-				pMinHtPhy->field.MCS = i;
-				break;
-			}
-			if (i == 0)
-				break;
-		}
-	}
-
-	/* Decide ht rate */
-	pHtPhy->field.STBC = pMaxHtPhy->field.STBC;
-	pHtPhy->field.BW = pMaxHtPhy->field.BW;
-	pHtPhy->field.MODE = pMaxHtPhy->field.MODE;
-	pHtPhy->field.MCS = pMaxHtPhy->field.MCS;
-	pHtPhy->field.ShortGI = pMaxHtPhy->field.ShortGI;
-
-	/* use default now. rt2860 */
-	if (pDesireHtPhy->MCSSet[0] != 0xff)
-		*auto_rate_cur_p = FALSE;
-	else
-		*auto_rate_cur_p = TRUE;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 (" MlmeUpdateHtTxRates<---.AMsduSize = %d  \n",
-		  pAd->CommonCfg.DesiredHtPhy.AmsduSize));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("TX: MCS[0] = %x (choose %d), BW = %d, ShortGI = %d, MODE = %d,  \n",
-		  pActiveHtPhy->MCSSet[0], pHtPhy->field.MCS, pHtPhy->field.BW,
-		  pHtPhy->field.ShortGI, pHtPhy->field.MODE));
-	DBGPRINT(RT_DEBUG_TRACE, ("MlmeUpdateHtTxRates<=== \n"));
-}
-
-void BATableInit(struct rt_rtmp_adapter *pAd, struct rt_ba_table *Tab)
-{
-	int i;
-
-	Tab->numAsOriginator = 0;
-	Tab->numAsRecipient = 0;
-	Tab->numDoneOriginator = 0;
-	NdisAllocateSpinLock(&pAd->BATabLock);
-	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
-		Tab->BARecEntry[i].REC_BA_Status = Recipient_NONE;
-		NdisAllocateSpinLock(&(Tab->BARecEntry[i].RxReRingLock));
-	}
-	for (i = 0; i < MAX_LEN_OF_BA_ORI_TABLE; i++) {
-		Tab->BAOriEntry[i].ORI_BA_Status = Originator_NONE;
-	}
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeRadioOff(struct rt_rtmp_adapter *pAd)
-{
-	RTMP_MLME_RADIO_OFF(pAd);
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeRadioOn(struct rt_rtmp_adapter *pAd)
-{
-	RTMP_MLME_RADIO_ON(pAd);
-}
-
-/* =========================================================================================== */
-/* bss_table.c */
-/* =========================================================================================== */
-
-/*! \brief initialize BSS table
- *	\param p_tab pointer to the table
- *	\return none
- *	\pre
- *	\post
-
- IRQL = PASSIVE_LEVEL
- IRQL = DISPATCH_LEVEL
-
- */
-void BssTableInit(struct rt_bss_table *Tab)
-{
-	int i;
-
-	Tab->BssNr = 0;
-	Tab->BssOverlapNr = 0;
-	for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++) {
-		NdisZeroMemory(&Tab->BssEntry[i], sizeof(struct rt_bss_entry));
-		Tab->BssEntry[i].Rssi = -127;	/* initial the rssi as a minimum value */
-	}
-}
-
-/*! \brief search the BSS table by SSID
- *	\param p_tab pointer to the bss table
- *	\param ssid SSID string
- *	\return index of the table, BSS_NOT_FOUND if not in the table
- *	\pre
- *	\post
- *	\note search by sequential search
-
- IRQL = DISPATCH_LEVEL
-
- */
-unsigned long BssTableSearch(struct rt_bss_table *Tab, u8 *pBssid, u8 Channel)
-{
-	u8 i;
-
-	for (i = 0; i < Tab->BssNr; i++) {
-		/* */
-		/* Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G. */
-		/* We should distinguish this case. */
-		/* */
-		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid)) {
-			return i;
-		}
-	}
-	return (unsigned long)BSS_NOT_FOUND;
-}
-
-unsigned long BssSsidTableSearch(struct rt_bss_table *Tab,
-			 u8 *pBssid,
-			 u8 *pSsid, u8 SsidLen, u8 Channel)
-{
-	u8 i;
-
-	for (i = 0; i < Tab->BssNr; i++) {
-		/* */
-		/* Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G. */
-		/* We should distinguish this case. */
-		/* */
-		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid) &&
-		    SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid,
-			       Tab->BssEntry[i].SsidLen)) {
-			return i;
-		}
-	}
-	return (unsigned long)BSS_NOT_FOUND;
-}
-
-unsigned long BssTableSearchWithSSID(struct rt_bss_table *Tab,
-			     u8 *Bssid,
-			     u8 *pSsid,
-			     u8 SsidLen, u8 Channel)
-{
-	u8 i;
-
-	for (i = 0; i < Tab->BssNr; i++) {
-		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-		    MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid) &&
-		    (SSID_EQUAL
-		     (pSsid, SsidLen, Tab->BssEntry[i].Ssid,
-		      Tab->BssEntry[i].SsidLen)
-		     || (NdisEqualMemory(pSsid, ZeroSsid, SsidLen))
-		     ||
-		     (NdisEqualMemory
-		      (Tab->BssEntry[i].Ssid, ZeroSsid,
-		       Tab->BssEntry[i].SsidLen)))) {
-			return i;
-		}
-	}
-	return (unsigned long)BSS_NOT_FOUND;
-}
-
-unsigned long BssSsidTableSearchBySSID(struct rt_bss_table *Tab,
-			       u8 *pSsid, u8 SsidLen)
-{
-	u8 i;
-
-	for (i = 0; i < Tab->BssNr; i++) {
-		if (SSID_EQUAL
-		    (pSsid, SsidLen, Tab->BssEntry[i].Ssid,
-		     Tab->BssEntry[i].SsidLen)) {
-			return i;
-		}
-	}
-	return (unsigned long)BSS_NOT_FOUND;
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void BssTableDeleteEntry(struct rt_bss_table *Tab,
-			 u8 *pBssid, u8 Channel)
-{
-	u8 i, j;
-
-	for (i = 0; i < Tab->BssNr; i++) {
-		if ((Tab->BssEntry[i].Channel == Channel) &&
-		    (MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid))) {
-			for (j = i; j < Tab->BssNr - 1; j++) {
-				NdisMoveMemory(&(Tab->BssEntry[j]),
-					       &(Tab->BssEntry[j + 1]),
-					       sizeof(struct rt_bss_entry));
-			}
-			NdisZeroMemory(&(Tab->BssEntry[Tab->BssNr - 1]),
-				       sizeof(struct rt_bss_entry));
-			Tab->BssNr -= 1;
-			return;
-		}
-	}
-}
-
-/*
-	========================================================================
-	Routine Description:
-		Delete the Originator Entry in BAtable. Or decrease numAs Originator by 1 if needed.
-
-	Arguments:
-	// IRQL = DISPATCH_LEVEL
-	========================================================================
-*/
-void BATableDeleteORIEntry(struct rt_rtmp_adapter *pAd,
-			   struct rt_ba_ori_entry *pBAORIEntry)
-{
-
-	if (pBAORIEntry->ORI_BA_Status != Originator_NONE) {
-		NdisAcquireSpinLock(&pAd->BATabLock);
-		if (pBAORIEntry->ORI_BA_Status == Originator_Done) {
-			pAd->BATable.numAsOriginator -= 1;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BATableDeleteORIEntry numAsOriginator= %ld\n",
-				  pAd->BATable.numAsRecipient));
-			/* Erase Bitmap flag. */
-		}
-		pAd->MacTab.Content[pBAORIEntry->Wcid].TXBAbitmap &= (~(1 << (pBAORIEntry->TID)));	/* If STA mode,  erase flag here */
-		pAd->MacTab.Content[pBAORIEntry->Wcid].BAOriWcidArray[pBAORIEntry->TID] = 0;	/* If STA mode,  erase flag here */
-		pBAORIEntry->ORI_BA_Status = Originator_NONE;
-		pBAORIEntry->Token = 1;
-		/* Not clear Sequence here. */
-		NdisReleaseSpinLock(&pAd->BATabLock);
-	}
-}
-
-/*! \brief
- *	\param
- *	\return
- *	\pre
- *	\post
-
- IRQL = DISPATCH_LEVEL
-
- */
-void BssEntrySet(struct rt_rtmp_adapter *pAd, struct rt_bss_entry *pBss, u8 *pBssid, char Ssid[], u8 SsidLen, u8 BssType, u16 BeaconPeriod, struct rt_cf_parm * pCfParm, u16 AtimWin, u16 CapabilityInfo, u8 SupRate[], u8 SupRateLen, u8 ExtRate[], u8 ExtRateLen, struct rt_ht_capability_ie * pHtCapability, struct rt_add_ht_info_ie * pAddHtInfo,	/* AP might use this additional ht info IE */
-		 u8 HtCapabilityLen,
-		 u8 AddHtInfoLen,
-		 u8 NewExtChanOffset,
-		 u8 Channel,
-		 char Rssi,
-		 IN LARGE_INTEGER TimeStamp,
-		 u8 CkipFlag,
-		 struct rt_edca_parm *pEdcaParm,
-		 struct rt_qos_capability_parm *pQosCapability,
-		 struct rt_qbss_load_parm *pQbssLoad,
-		 u16 LengthVIE, struct rt_ndis_802_11_variable_ies *pVIE)
-{
-	COPY_MAC_ADDR(pBss->Bssid, pBssid);
-	/* Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID */
-	pBss->Hidden = 1;
-	if (SsidLen > 0) {
-		/* For hidden SSID AP, it might send beacon with SSID len equal to 0 */
-		/* Or send beacon /probe response with SSID len matching real SSID length, */
-		/* but SSID is all zero. such as "00-00-00-00" with length 4. */
-		/* We have to prevent this case overwrite correct table */
-		if (NdisEqualMemory(Ssid, ZeroSsid, SsidLen) == 0) {
-			NdisZeroMemory(pBss->Ssid, MAX_LEN_OF_SSID);
-			NdisMoveMemory(pBss->Ssid, Ssid, SsidLen);
-			pBss->SsidLen = SsidLen;
-			pBss->Hidden = 0;
-		}
-	} else
-		pBss->SsidLen = 0;
-	pBss->BssType = BssType;
-	pBss->BeaconPeriod = BeaconPeriod;
-	if (BssType == BSS_INFRA) {
-		if (pCfParm->bValid) {
-			pBss->CfpCount = pCfParm->CfpCount;
-			pBss->CfpPeriod = pCfParm->CfpPeriod;
-			pBss->CfpMaxDuration = pCfParm->CfpMaxDuration;
-			pBss->CfpDurRemaining = pCfParm->CfpDurRemaining;
-		}
-	} else {
-		pBss->AtimWin = AtimWin;
-	}
-
-	pBss->CapabilityInfo = CapabilityInfo;
-	/* The privacy bit indicate security is ON, it maight be WEP, TKIP or AES */
-	/* Combine with AuthMode, they will decide the connection methods. */
-	pBss->Privacy = CAP_IS_PRIVACY_ON(pBss->CapabilityInfo);
-	ASSERT(SupRateLen <= MAX_LEN_OF_SUPPORTED_RATES);
-	if (SupRateLen <= MAX_LEN_OF_SUPPORTED_RATES)
-		NdisMoveMemory(pBss->SupRate, SupRate, SupRateLen);
-	else
-		NdisMoveMemory(pBss->SupRate, SupRate,
-			       MAX_LEN_OF_SUPPORTED_RATES);
-	pBss->SupRateLen = SupRateLen;
-	ASSERT(ExtRateLen <= MAX_LEN_OF_SUPPORTED_RATES);
-	NdisMoveMemory(pBss->ExtRate, ExtRate, ExtRateLen);
-	pBss->NewExtChanOffset = NewExtChanOffset;
-	pBss->ExtRateLen = ExtRateLen;
-	pBss->Channel = Channel;
-	pBss->CentralChannel = Channel;
-	pBss->Rssi = Rssi;
-	/* Update CkipFlag. if not exists, the value is 0x0 */
-	pBss->CkipFlag = CkipFlag;
-
-	/* New for microsoft Fixed IEs */
-	NdisMoveMemory(pBss->FixIEs.Timestamp, &TimeStamp, 8);
-	pBss->FixIEs.BeaconInterval = BeaconPeriod;
-	pBss->FixIEs.Capabilities = CapabilityInfo;
-
-	/* New for microsoft Variable IEs */
-	if (LengthVIE != 0) {
-		pBss->VarIELen = LengthVIE;
-		NdisMoveMemory(pBss->VarIEs, pVIE, pBss->VarIELen);
-	} else {
-		pBss->VarIELen = 0;
-	}
-
-	pBss->AddHtInfoLen = 0;
-	pBss->HtCapabilityLen = 0;
-	if (HtCapabilityLen > 0) {
-		pBss->HtCapabilityLen = HtCapabilityLen;
-		NdisMoveMemory(&pBss->HtCapability, pHtCapability,
-			       HtCapabilityLen);
-		if (AddHtInfoLen > 0) {
-			pBss->AddHtInfoLen = AddHtInfoLen;
-			NdisMoveMemory(&pBss->AddHtInfo, pAddHtInfo,
-				       AddHtInfoLen);
-
-			if ((pAddHtInfo->ControlChan > 2)
-			    && (pAddHtInfo->AddHtInfo.ExtChanOffset ==
-				EXTCHA_BELOW)
-			    && (pHtCapability->HtCapInfo.ChannelWidth ==
-				BW_40)) {
-				pBss->CentralChannel =
-				    pAddHtInfo->ControlChan - 2;
-			} else
-			    if ((pAddHtInfo->AddHtInfo.ExtChanOffset ==
-				 EXTCHA_ABOVE)
-				&& (pHtCapability->HtCapInfo.ChannelWidth ==
-				    BW_40)) {
-				pBss->CentralChannel =
-				    pAddHtInfo->ControlChan + 2;
-			}
-		}
-	}
-
-	BssCipherParse(pBss);
-
-	/* new for QOS */
-	if (pEdcaParm)
-		NdisMoveMemory(&pBss->EdcaParm, pEdcaParm, sizeof(struct rt_edca_parm));
-	else
-		pBss->EdcaParm.bValid = FALSE;
-	if (pQosCapability)
-		NdisMoveMemory(&pBss->QosCapability, pQosCapability,
-			       sizeof(struct rt_qos_capability_parm));
-	else
-		pBss->QosCapability.bValid = FALSE;
-	if (pQbssLoad)
-		NdisMoveMemory(&pBss->QbssLoad, pQbssLoad,
-			       sizeof(struct rt_qbss_load_parm));
-	else
-		pBss->QbssLoad.bValid = FALSE;
-
-	{
-		struct rt_eid * pEid;
-		u16 Length = 0;
-
-		NdisZeroMemory(&pBss->WpaIE.IE[0], MAX_CUSTOM_LEN);
-		NdisZeroMemory(&pBss->RsnIE.IE[0], MAX_CUSTOM_LEN);
-		pEid = (struct rt_eid *) pVIE;
-		while ((Length + 2 + (u16)pEid->Len) <= LengthVIE) {
-			switch (pEid->Eid) {
-			case IE_WPA:
-				if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)) {
-					if ((pEid->Len + 2) > MAX_CUSTOM_LEN) {
-						pBss->WpaIE.IELen = 0;
-						break;
-					}
-					pBss->WpaIE.IELen = pEid->Len + 2;
-					NdisMoveMemory(pBss->WpaIE.IE, pEid,
-						       pBss->WpaIE.IELen);
-				}
-				break;
-			case IE_RSN:
-				if (NdisEqualMemory
-				    (pEid->Octet + 2, RSN_OUI, 3)) {
-					if ((pEid->Len + 2) > MAX_CUSTOM_LEN) {
-						pBss->RsnIE.IELen = 0;
-						break;
-					}
-					pBss->RsnIE.IELen = pEid->Len + 2;
-					NdisMoveMemory(pBss->RsnIE.IE, pEid,
-						       pBss->RsnIE.IELen);
-				}
-				break;
-			}
-			Length = Length + 2 + (u16)pEid->Len;	/* Eid[1] + Len[1]+ content[Len] */
-			pEid = (struct rt_eid *) ((u8 *) pEid + 2 + pEid->Len);
-		}
-	}
-}
-
-/*!
- *	\brief insert an entry into the bss table
- *	\param p_tab The BSS table
- *	\param Bssid BSSID
- *	\param ssid SSID
- *	\param ssid_len Length of SSID
- *	\param bss_type
- *	\param beacon_period
- *	\param timestamp
- *	\param p_cf
- *	\param atim_win
- *	\param cap
- *	\param rates
- *	\param rates_len
- *	\param channel_idx
- *	\return none
- *	\pre
- *	\post
- *	\note If SSID is identical, the old entry will be replaced by the new one
-
- IRQL = DISPATCH_LEVEL
-
- */
-unsigned long BssTableSetEntry(struct rt_rtmp_adapter *pAd, struct rt_bss_table *Tab, u8 *pBssid, char Ssid[], u8 SsidLen, u8 BssType, u16 BeaconPeriod, struct rt_cf_parm * CfParm, u16 AtimWin, u16 CapabilityInfo, u8 SupRate[], u8 SupRateLen, u8 ExtRate[], u8 ExtRateLen, struct rt_ht_capability_ie * pHtCapability, struct rt_add_ht_info_ie * pAddHtInfo,	/* AP might use this additional ht info IE */
-		       u8 HtCapabilityLen,
-		       u8 AddHtInfoLen,
-		       u8 NewExtChanOffset,
-		       u8 ChannelNo,
-		       char Rssi,
-		       IN LARGE_INTEGER TimeStamp,
-		       u8 CkipFlag,
-		       struct rt_edca_parm *pEdcaParm,
-		       struct rt_qos_capability_parm *pQosCapability,
-		       struct rt_qbss_load_parm *pQbssLoad,
-		       u16 LengthVIE, struct rt_ndis_802_11_variable_ies *pVIE)
-{
-	unsigned long Idx;
-
-	Idx =
-	    BssTableSearchWithSSID(Tab, pBssid, (u8 *) Ssid, SsidLen,
-				   ChannelNo);
-	if (Idx == BSS_NOT_FOUND) {
-		if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE) {
-			/* */
-			/* It may happen when BSS Table was full. */
-			/* The desired AP will not be added into BSS Table */
-			/* In this case, if we found the desired AP then overwrite BSS Table. */
-			/* */
-			if (!OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, pBssid)
-				    || SSID_EQUAL(pAd->MlmeAux.Ssid,
-						  pAd->MlmeAux.SsidLen, Ssid,
-						  SsidLen)) {
-					Idx = Tab->BssOverlapNr;
-					BssEntrySet(pAd, &Tab->BssEntry[Idx],
-						    pBssid, Ssid, SsidLen,
-						    BssType, BeaconPeriod,
-						    CfParm, AtimWin,
-						    CapabilityInfo, SupRate,
-						    SupRateLen, ExtRate,
-						    ExtRateLen, pHtCapability,
-						    pAddHtInfo, HtCapabilityLen,
-						    AddHtInfoLen,
-						    NewExtChanOffset, ChannelNo,
-						    Rssi, TimeStamp, CkipFlag,
-						    pEdcaParm, pQosCapability,
-						    pQbssLoad, LengthVIE, pVIE);
-					Tab->BssOverlapNr =
-					    (Tab->BssOverlapNr++) %
-					    MAX_LEN_OF_BSS_TABLE;
-				}
-				return Idx;
-			} else {
-				return BSS_NOT_FOUND;
-			}
-		}
-		Idx = Tab->BssNr;
-		BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen,
-			    BssType, BeaconPeriod, CfParm, AtimWin,
-			    CapabilityInfo, SupRate, SupRateLen, ExtRate,
-			    ExtRateLen, pHtCapability, pAddHtInfo,
-			    HtCapabilityLen, AddHtInfoLen, NewExtChanOffset,
-			    ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm,
-			    pQosCapability, pQbssLoad, LengthVIE, pVIE);
-		Tab->BssNr++;
-	} else {
-		/* avoid  Hidden SSID form beacon to overwirite correct SSID from probe response */
-		if ((SSID_EQUAL
-		     (Ssid, SsidLen, Tab->BssEntry[Idx].Ssid,
-		      Tab->BssEntry[Idx].SsidLen))
-		    ||
-		    (NdisEqualMemory
-		     (Tab->BssEntry[Idx].Ssid, ZeroSsid,
-		      Tab->BssEntry[Idx].SsidLen))) {
-			BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid,
-				    SsidLen, BssType, BeaconPeriod, CfParm,
-				    AtimWin, CapabilityInfo, SupRate,
-				    SupRateLen, ExtRate, ExtRateLen,
-				    pHtCapability, pAddHtInfo, HtCapabilityLen,
-				    AddHtInfoLen, NewExtChanOffset, ChannelNo,
-				    Rssi, TimeStamp, CkipFlag, pEdcaParm,
-				    pQosCapability, pQbssLoad, LengthVIE, pVIE);
-		}
-	}
-
-	return Idx;
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void BssTableSsidSort(struct rt_rtmp_adapter *pAd,
-		      struct rt_bss_table *OutTab, char Ssid[], u8 SsidLen)
-{
-	int i;
-	BssTableInit(OutTab);
-
-	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
-		struct rt_bss_entry *pInBss = &pAd->ScanTab.BssEntry[i];
-		BOOLEAN bIsHiddenApIncluded = FALSE;
-
-		if (((pAd->CommonCfg.bIEEE80211H == 1) &&
-		     (pAd->MlmeAux.Channel > 14) &&
-		     RadarChannelCheck(pAd, pInBss->Channel))
-		    ) {
-			if (pInBss->Hidden)
-				bIsHiddenApIncluded = TRUE;
-		}
-
-		if ((pInBss->BssType == pAd->StaCfg.BssType) &&
-		    (SSID_EQUAL(Ssid, SsidLen, pInBss->Ssid, pInBss->SsidLen)
-		     || bIsHiddenApIncluded)) {
-			struct rt_bss_entry *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
-
-			/* 2.4G/5G N only mode */
-			if ((pInBss->HtCapabilityLen == 0) &&
-			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
-			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
-				continue;
-			}
-			/* New for WPA2 */
-			/* Check the Authmode first */
-			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-				/* Check AuthMode and AuthModeAux for matching, in case AP support dual-mode */
-				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
-				    && (pAd->StaCfg.AuthMode !=
-					pInBss->AuthModeAux))
-					/* None matched */
-					continue;
-
-				/* Check cipher suite, AP must have more secured cipher than station setting */
-				if ((pAd->StaCfg.AuthMode ==
-				     Ndis802_11AuthModeWPA)
-				    || (pAd->StaCfg.AuthMode ==
-					Ndis802_11AuthModeWPAPSK)) {
-					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
-					if (pInBss->WPA.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus !=
-						    pInBss->WPA.GroupCipher)
-							continue;
-
-					/* check group cipher */
-					if ((pAd->StaCfg.WepStatus <
-					     pInBss->WPA.GroupCipher)
-					    && (pInBss->WPA.GroupCipher !=
-						Ndis802_11GroupWEP40Enabled)
-					    && (pInBss->WPA.GroupCipher !=
-						Ndis802_11GroupWEP104Enabled))
-						continue;
-
-					/* check pairwise cipher, skip if none matched */
-					/* If profile set to AES, let it pass without question. */
-					/* If profile set to TKIP, we must find one mateched */
-					if ((pAd->StaCfg.WepStatus ==
-					     Ndis802_11Encryption2Enabled)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA.PairCipher)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA.PairCipherAux))
-						continue;
-				} else
-				    if ((pAd->StaCfg.AuthMode ==
-					 Ndis802_11AuthModeWPA2)
-					|| (pAd->StaCfg.AuthMode ==
-					    Ndis802_11AuthModeWPA2PSK)) {
-					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
-					if (pInBss->WPA2.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus !=
-						    pInBss->WPA2.GroupCipher)
-							continue;
-
-					/* check group cipher */
-					if ((pAd->StaCfg.WepStatus <
-					     pInBss->WPA.GroupCipher)
-					    && (pInBss->WPA2.GroupCipher !=
-						Ndis802_11GroupWEP40Enabled)
-					    && (pInBss->WPA2.GroupCipher !=
-						Ndis802_11GroupWEP104Enabled))
-						continue;
-
-					/* check pairwise cipher, skip if none matched */
-					/* If profile set to AES, let it pass without question. */
-					/* If profile set to TKIP, we must find one mateched */
-					if ((pAd->StaCfg.WepStatus ==
-					     Ndis802_11Encryption2Enabled)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA2.PairCipher)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA2.PairCipherAux))
-						continue;
-				}
-			}
-			/* Bss Type matched, SSID matched. */
-			/* We will check wepstatus for qualification Bss */
-			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("StaCfg.WepStatus=%d, while pInBss->WepStatus=%d\n",
-					  pAd->StaCfg.WepStatus,
-					  pInBss->WepStatus));
-				/* */
-				/* For the SESv2 case, we will not qualify WepStatus. */
-				/* */
-				if (!pInBss->bSES)
-					continue;
-			}
-			/* Since the AP is using hidden SSID, and we are trying to connect to ANY */
-			/* It definitely will fail. So, skip it. */
-			/* CCX also require not even try to connect it! */
-			if (SsidLen == 0)
-				continue;
-
-			/* If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region */
-			/* If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead, */
-			if ((pInBss->CentralChannel != pInBss->Channel) &&
-			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
-			     BW_40)) {
-				if (RTMPCheckChannel
-				    (pAd, pInBss->CentralChannel,
-				     pInBss->Channel) == FALSE) {
-					pAd->CommonCfg.RegTransmitSetting.field.
-					    BW = BW_20;
-					SetCommonHT(pAd);
-					pAd->CommonCfg.RegTransmitSetting.field.
-					    BW = BW_40;
-				} else {
-					if (pAd->CommonCfg.DesiredHtPhy.
-					    ChannelWidth == BAND_WIDTH_20) {
-						SetCommonHT(pAd);
-					}
-				}
-			}
-			/* copy matching BSS from InTab to OutTab */
-			NdisMoveMemory(pOutBss, pInBss, sizeof(struct rt_bss_entry));
-
-			OutTab->BssNr++;
-		} else if ((pInBss->BssType == pAd->StaCfg.BssType)
-			   && (SsidLen == 0)) {
-			struct rt_bss_entry *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
-
-			/* 2.4G/5G N only mode */
-			if ((pInBss->HtCapabilityLen == 0) &&
-			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
-			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
-				continue;
-			}
-			/* New for WPA2 */
-			/* Check the Authmode first */
-			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-				/* Check AuthMode and AuthModeAux for matching, in case AP support dual-mode */
-				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
-				    && (pAd->StaCfg.AuthMode !=
-					pInBss->AuthModeAux))
-					/* None matched */
-					continue;
-
-				/* Check cipher suite, AP must have more secured cipher than station setting */
-				if ((pAd->StaCfg.AuthMode ==
-				     Ndis802_11AuthModeWPA)
-				    || (pAd->StaCfg.AuthMode ==
-					Ndis802_11AuthModeWPAPSK)) {
-					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
-					if (pInBss->WPA.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus !=
-						    pInBss->WPA.GroupCipher)
-							continue;
-
-					/* check group cipher */
-					if (pAd->StaCfg.WepStatus <
-					    pInBss->WPA.GroupCipher)
-						continue;
-
-					/* check pairwise cipher, skip if none matched */
-					/* If profile set to AES, let it pass without question. */
-					/* If profile set to TKIP, we must find one mateched */
-					if ((pAd->StaCfg.WepStatus ==
-					     Ndis802_11Encryption2Enabled)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA.PairCipher)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA.PairCipherAux))
-						continue;
-				} else
-				    if ((pAd->StaCfg.AuthMode ==
-					 Ndis802_11AuthModeWPA2)
-					|| (pAd->StaCfg.AuthMode ==
-					    Ndis802_11AuthModeWPA2PSK)) {
-					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
-					if (pInBss->WPA2.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus !=
-						    pInBss->WPA2.GroupCipher)
-							continue;
-
-					/* check group cipher */
-					if (pAd->StaCfg.WepStatus <
-					    pInBss->WPA2.GroupCipher)
-						continue;
-
-					/* check pairwise cipher, skip if none matched */
-					/* If profile set to AES, let it pass without question. */
-					/* If profile set to TKIP, we must find one mateched */
-					if ((pAd->StaCfg.WepStatus ==
-					     Ndis802_11Encryption2Enabled)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA2.PairCipher)
-					    && (pAd->StaCfg.WepStatus !=
-						pInBss->WPA2.PairCipherAux))
-						continue;
-				}
-			}
-			/* Bss Type matched, SSID matched. */
-			/* We will check wepstatus for qualification Bss */
-			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
-				continue;
-
-			/* If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region */
-			/* If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead, */
-			if ((pInBss->CentralChannel != pInBss->Channel) &&
-			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
-			     BW_40)) {
-				if (RTMPCheckChannel
-				    (pAd, pInBss->CentralChannel,
-				     pInBss->Channel) == FALSE) {
-					pAd->CommonCfg.RegTransmitSetting.field.
-					    BW = BW_20;
-					SetCommonHT(pAd);
-					pAd->CommonCfg.RegTransmitSetting.field.
-					    BW = BW_40;
-				}
-			}
-			/* copy matching BSS from InTab to OutTab */
-			NdisMoveMemory(pOutBss, pInBss, sizeof(struct rt_bss_entry));
-
-			OutTab->BssNr++;
-		}
-
-		if (OutTab->BssNr >= MAX_LEN_OF_BSS_TABLE)
-			break;
-	}
-
-	BssTableSortByRssi(OutTab);
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void BssTableSortByRssi(struct rt_bss_table *OutTab)
-{
-	int i, j;
-	struct rt_bss_entry TmpBss;
-
-	for (i = 0; i < OutTab->BssNr - 1; i++) {
-		for (j = i + 1; j < OutTab->BssNr; j++) {
-			if (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi) {
-				NdisMoveMemory(&TmpBss, &OutTab->BssEntry[j],
-					       sizeof(struct rt_bss_entry));
-				NdisMoveMemory(&OutTab->BssEntry[j],
-					       &OutTab->BssEntry[i],
-					       sizeof(struct rt_bss_entry));
-				NdisMoveMemory(&OutTab->BssEntry[i], &TmpBss,
-					       sizeof(struct rt_bss_entry));
-			}
-		}
-	}
-}
-
-void BssCipherParse(struct rt_bss_entry *pBss)
-{
-	struct rt_eid * pEid;
-	u8 *pTmp;
-	struct rt_rsn_ie_header * pRsnHeader;
-	struct rt_cipher_suite_struct * pCipher;
-	struct rt_akm_suite * pAKM;
-	u16 Count;
-	int Length;
-	NDIS_802_11_ENCRYPTION_STATUS TmpCipher;
-
-	/* */
-	/* WepStatus will be reset later, if AP announce TKIP or AES on the beacon frame. */
-	/* */
-	if (pBss->Privacy) {
-		pBss->WepStatus = Ndis802_11WEPEnabled;
-	} else {
-		pBss->WepStatus = Ndis802_11WEPDisabled;
-	}
-	/* Set default to disable & open authentication before parsing variable IE */
-	pBss->AuthMode = Ndis802_11AuthModeOpen;
-	pBss->AuthModeAux = Ndis802_11AuthModeOpen;
-
-	/* Init WPA setting */
-	pBss->WPA.PairCipher = Ndis802_11WEPDisabled;
-	pBss->WPA.PairCipherAux = Ndis802_11WEPDisabled;
-	pBss->WPA.GroupCipher = Ndis802_11WEPDisabled;
-	pBss->WPA.RsnCapability = 0;
-	pBss->WPA.bMixMode = FALSE;
-
-	/* Init WPA2 setting */
-	pBss->WPA2.PairCipher = Ndis802_11WEPDisabled;
-	pBss->WPA2.PairCipherAux = Ndis802_11WEPDisabled;
-	pBss->WPA2.GroupCipher = Ndis802_11WEPDisabled;
-	pBss->WPA2.RsnCapability = 0;
-	pBss->WPA2.bMixMode = FALSE;
-
-	Length = (int)pBss->VarIELen;
-
-	while (Length > 0) {
-		/* Parse cipher suite base on WPA1 & WPA2, they should be parsed differently */
-		pTmp = ((u8 *)pBss->VarIEs) + pBss->VarIELen - Length;
-		pEid = (struct rt_eid *) pTmp;
-		switch (pEid->Eid) {
-		case IE_WPA:
-			if (NdisEqualMemory(pEid->Octet, SES_OUI, 3)
-			    && (pEid->Len == 7)) {
-				pBss->bSES = TRUE;
-				break;
-			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4) !=
-				   1) {
-				/* if unsupported vendor specific IE */
-				break;
-			}
-			/* Skip OUI, version, and multicast suite */
-			/* This part should be improved in the future when AP supported multiple cipher suite. */
-			/* For now, it's OK since almost all APs have fixed cipher suite supported. */
-			/* pTmp = (u8 *)pEid->Octet; */
-			pTmp += 11;
-
-			/* Cipher Suite Selectors from Spec P802.11i/D3.2 P26. */
-			/*      Value      Meaning */
-			/*      0                       None */
-			/*      1                       WEP-40 */
-			/*      2                       Tkip */
-			/*      3                       WRAP */
-			/*      4                       AES */
-			/*      5                       WEP-104 */
-			/* Parse group cipher */
-			switch (*pTmp) {
-			case 1:
-				pBss->WPA.GroupCipher =
-				    Ndis802_11GroupWEP40Enabled;
-				break;
-			case 5:
-				pBss->WPA.GroupCipher =
-				    Ndis802_11GroupWEP104Enabled;
-				break;
-			case 2:
-				pBss->WPA.GroupCipher =
-				    Ndis802_11Encryption2Enabled;
-				break;
-			case 4:
-				pBss->WPA.GroupCipher =
-				    Ndis802_11Encryption3Enabled;
-				break;
-			default:
-				break;
-			}
-			/* number of unicast suite */
-			pTmp += 1;
-
-			/* skip all unicast cipher suites */
-			/*Count = *(u16 *)pTmp; */
-			Count = (pTmp[1] << 8) + pTmp[0];
-			pTmp += sizeof(u16);
-
-			/* Parsing all unicast cipher suite */
-			while (Count > 0) {
-				/* Skip OUI */
-				pTmp += 3;
-				TmpCipher = Ndis802_11WEPDisabled;
-				switch (*pTmp) {
-				case 1:
-				case 5:	/* Although WEP is not allowed in WPA related auth mode, we parse it anyway */
-					TmpCipher =
-					    Ndis802_11Encryption1Enabled;
-					break;
-				case 2:
-					TmpCipher =
-					    Ndis802_11Encryption2Enabled;
-					break;
-				case 4:
-					TmpCipher =
-					    Ndis802_11Encryption3Enabled;
-					break;
-				default:
-					break;
-				}
-				if (TmpCipher > pBss->WPA.PairCipher) {
-					/* Move the lower cipher suite to PairCipherAux */
-					pBss->WPA.PairCipherAux =
-					    pBss->WPA.PairCipher;
-					pBss->WPA.PairCipher = TmpCipher;
-				} else {
-					pBss->WPA.PairCipherAux = TmpCipher;
-				}
-				pTmp++;
-				Count--;
-			}
-
-			/* 4. get AKM suite counts */
-			/*Count = *(u16 *)pTmp; */
-			Count = (pTmp[1] << 8) + pTmp[0];
-			pTmp += sizeof(u16);
-			pTmp += 3;
-
-			switch (*pTmp) {
-			case 1:
-				/* Set AP support WPA-enterprise mode */
-				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-					pBss->AuthMode = Ndis802_11AuthModeWPA;
-				else
-					pBss->AuthModeAux =
-					    Ndis802_11AuthModeWPA;
-				break;
-			case 2:
-				/* Set AP support WPA-PSK mode */
-				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-					pBss->AuthMode =
-					    Ndis802_11AuthModeWPAPSK;
-				else
-					pBss->AuthModeAux =
-					    Ndis802_11AuthModeWPAPSK;
-				break;
-			default:
-				break;
-			}
-			pTmp += 1;
-
-			/* Fixed for WPA-None */
-			if (pBss->BssType == BSS_ADHOC) {
-				pBss->AuthMode = Ndis802_11AuthModeWPANone;
-				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
-				pBss->WepStatus = pBss->WPA.GroupCipher;
-				/* Patched bugs for old driver */
-				if (pBss->WPA.PairCipherAux ==
-				    Ndis802_11WEPDisabled)
-					pBss->WPA.PairCipherAux =
-					    pBss->WPA.GroupCipher;
-			} else
-				pBss->WepStatus = pBss->WPA.PairCipher;
-
-			/* Check the Pair & Group, if different, turn on mixed mode flag */
-			if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
-				pBss->WPA.bMixMode = TRUE;
-
-			break;
-
-		case IE_RSN:
-			pRsnHeader = (struct rt_rsn_ie_header *) pTmp;
-
-			/* 0. Version must be 1 */
-			if (le2cpu16(pRsnHeader->Version) != 1)
-				break;
-			pTmp += sizeof(struct rt_rsn_ie_header);
-
-			/* 1. Check group cipher */
-			pCipher = (struct rt_cipher_suite_struct *) pTmp;
-			if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
-				break;
-
-			/* Parse group cipher */
-			switch (pCipher->Type) {
-			case 1:
-				pBss->WPA2.GroupCipher =
-				    Ndis802_11GroupWEP40Enabled;
-				break;
-			case 5:
-				pBss->WPA2.GroupCipher =
-				    Ndis802_11GroupWEP104Enabled;
-				break;
-			case 2:
-				pBss->WPA2.GroupCipher =
-				    Ndis802_11Encryption2Enabled;
-				break;
-			case 4:
-				pBss->WPA2.GroupCipher =
-				    Ndis802_11Encryption3Enabled;
-				break;
-			default:
-				break;
-			}
-			/* set to correct offset for next parsing */
-			pTmp += sizeof(struct rt_cipher_suite_struct);
-
-			/* 2. Get pairwise cipher counts */
-			/*Count = *(u16 *)pTmp; */
-			Count = (pTmp[1] << 8) + pTmp[0];
-			pTmp += sizeof(u16);
-
-			/* 3. Get pairwise cipher */
-			/* Parsing all unicast cipher suite */
-			while (Count > 0) {
-				/* Skip OUI */
-				pCipher = (struct rt_cipher_suite_struct *) pTmp;
-				TmpCipher = Ndis802_11WEPDisabled;
-				switch (pCipher->Type) {
-				case 1:
-				case 5:	/* Although WEP is not allowed in WPA related auth mode, we parse it anyway */
-					TmpCipher =
-					    Ndis802_11Encryption1Enabled;
-					break;
-				case 2:
-					TmpCipher =
-					    Ndis802_11Encryption2Enabled;
-					break;
-				case 4:
-					TmpCipher =
-					    Ndis802_11Encryption3Enabled;
-					break;
-				default:
-					break;
-				}
-				if (TmpCipher > pBss->WPA2.PairCipher) {
-					/* Move the lower cipher suite to PairCipherAux */
-					pBss->WPA2.PairCipherAux =
-					    pBss->WPA2.PairCipher;
-					pBss->WPA2.PairCipher = TmpCipher;
-				} else {
-					pBss->WPA2.PairCipherAux = TmpCipher;
-				}
-				pTmp += sizeof(struct rt_cipher_suite_struct);
-				Count--;
-			}
-
-			/* 4. get AKM suite counts */
-			/*Count = *(u16 *)pTmp; */
-			Count = (pTmp[1] << 8) + pTmp[0];
-			pTmp += sizeof(u16);
-
-			/* 5. Get AKM ciphers */
-			/* Parsing all AKM ciphers */
-			while (Count > 0) {
-				pAKM = (struct rt_akm_suite *) pTmp;
-				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
-					break;
-
-				switch (pAKM->Type) {
-				case 1:
-					/* Set AP support WPA-enterprise mode */
-					if (pBss->AuthMode ==
-					    Ndis802_11AuthModeOpen)
-						pBss->AuthMode =
-						    Ndis802_11AuthModeWPA2;
-					else
-						pBss->AuthModeAux =
-						    Ndis802_11AuthModeWPA2;
-					break;
-				case 2:
-					/* Set AP support WPA-PSK mode */
-					if (pBss->AuthMode ==
-					    Ndis802_11AuthModeOpen)
-						pBss->AuthMode =
-						    Ndis802_11AuthModeWPA2PSK;
-					else
-						pBss->AuthModeAux =
-						    Ndis802_11AuthModeWPA2PSK;
-					break;
-				default:
-					if (pBss->AuthMode ==
-					    Ndis802_11AuthModeOpen)
-						pBss->AuthMode =
-						    Ndis802_11AuthModeMax;
-					else
-						pBss->AuthModeAux =
-						    Ndis802_11AuthModeMax;
-					break;
-				}
-				pTmp += (Count * sizeof(struct rt_akm_suite));
-				Count--;
-			}
-
-			/* Fixed for WPA-None */
-			if (pBss->BssType == BSS_ADHOC) {
-				pBss->AuthMode = Ndis802_11AuthModeWPANone;
-				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
-				pBss->WPA.PairCipherAux =
-				    pBss->WPA2.PairCipherAux;
-				pBss->WPA.GroupCipher = pBss->WPA2.GroupCipher;
-				pBss->WepStatus = pBss->WPA.GroupCipher;
-				/* Patched bugs for old driver */
-				if (pBss->WPA.PairCipherAux ==
-				    Ndis802_11WEPDisabled)
-					pBss->WPA.PairCipherAux =
-					    pBss->WPA.GroupCipher;
-			}
-			pBss->WepStatus = pBss->WPA2.PairCipher;
-
-			/* 6. Get RSN capability */
-			/*pBss->WPA2.RsnCapability = *(u16 *)pTmp; */
-			pBss->WPA2.RsnCapability = (pTmp[1] << 8) + pTmp[0];
-			pTmp += sizeof(u16);
-
-			/* Check the Pair & Group, if different, turn on mixed mode flag */
-			if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
-				pBss->WPA2.bMixMode = TRUE;
-
-			break;
-		default:
-			break;
-		}
-		Length -= (pEid->Len + 2);
-	}
-}
-
-/* =========================================================================================== */
-/* mac_table.c */
-/* =========================================================================================== */
-
-/*! \brief generates a random mac address value for IBSS BSSID
- *	\param Addr the bssid location
- *	\return none
- *	\pre
- *	\post
- */
-void MacAddrRandomBssid(struct rt_rtmp_adapter *pAd, u8 *pAddr)
-{
-	int i;
-
-	for (i = 0; i < MAC_ADDR_LEN; i++) {
-		pAddr[i] = RandomByte(pAd);
-	}
-
-	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;	/* the first 2 bits must be 01xxxxxxxx */
-}
-
-/*! \brief init the management mac frame header
- *	\param p_hdr mac header
- *	\param subtype subtype of the frame
- *	\param p_ds destination address, don't care if it is a broadcast address
- *	\return none
- *	\pre the station has the following information in the pAd->StaCfg
- *	 - bssid
- *	 - station address
- *	\post
- *	\note this function initializes the following field
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
- */
-void MgtMacHeaderInit(struct rt_rtmp_adapter *pAd,
-		      struct rt_header_802_11 * pHdr80211,
-		      u8 SubType,
-		      u8 ToDs, u8 *pDA, u8 *pBssid)
-{
-	NdisZeroMemory(pHdr80211, sizeof(struct rt_header_802_11));
-
-	pHdr80211->FC.Type = BTYPE_MGMT;
-	pHdr80211->FC.SubType = SubType;
-/*      if (SubType == SUBTYPE_ACK)     // sample, no use, it will conflict with ACTION frame sub type */
-/*              pHdr80211->FC.Type = BTYPE_CNTL; */
-	pHdr80211->FC.ToDs = ToDs;
-	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
-	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
-	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
-}
-
-/* =========================================================================================== */
-/* mem_mgmt.c */
-/* =========================================================================================== */
-
-/*!***************************************************************************
- * This routine build an outgoing frame, and fill all information specified
- * in argument list to the frame body. The actual frame size is the summation
- * of all arguments.
- * input params:
- *		Buffer - pointer to a pre-allocated memory segment
- *		args - a list of <int arg_size, arg> pairs.
- *		NOTE NOTE NOTE! the last argument must be NULL, otherwise this
- *						   function will FAIL!
- * return:
- *		Size of the buffer
- * usage:
- *		MakeOutgoingFrame(Buffer, output_length, 2, &fc, 2, &dur, 6, p_addr1, 6,p_addr2, END_OF_ARGS);
-
- IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
- ****************************************************************************/
-unsigned long MakeOutgoingFrame(u8 * Buffer, unsigned long * FrameLen, ...)
-{
-	u8 *p;
-	int leng;
-	unsigned long TotLeng;
-	va_list Args;
-
-	/* calculates the total length */
-	TotLeng = 0;
-	va_start(Args, FrameLen);
-	do {
-		leng = va_arg(Args, int);
-		if (leng == END_OF_ARGS) {
-			break;
-		}
-		p = va_arg(Args, void *);
-		NdisMoveMemory(&Buffer[TotLeng], p, leng);
-		TotLeng = TotLeng + leng;
-	} while (TRUE);
-
-	va_end(Args);		/* clean up */
-	*FrameLen = TotLeng;
-	return TotLeng;
-}
-
-/* =========================================================================================== */
-/* mlme_queue.c */
-/* =========================================================================================== */
-
-/*! \brief	Initialize The MLME Queue, used by MLME Functions
- *	\param	*Queue	   The MLME Queue
- *	\return Always	   Return NDIS_STATE_SUCCESS in this implementation
- *	\pre
- *	\post
- *	\note	Because this is done only once (at the init stage), no need to be locked
-
- IRQL = PASSIVE_LEVEL
-
- */
-int MlmeQueueInit(struct rt_mlme_queue *Queue)
-{
-	int i;
-
-	NdisAllocateSpinLock(&Queue->Lock);
-
-	Queue->Num = 0;
-	Queue->Head = 0;
-	Queue->Tail = 0;
-
-	for (i = 0; i < MAX_LEN_OF_MLME_QUEUE; i++) {
-		Queue->Entry[i].Occupied = FALSE;
-		Queue->Entry[i].MsgLen = 0;
-		NdisZeroMemory(Queue->Entry[i].Msg, MGMT_DMA_BUFFER_SIZE);
-	}
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*! \brief	 Enqueue a message for other threads, if they want to send messages to MLME thread
- *	\param	*Queue	  The MLME Queue
- *	\param	 Machine  The State Machine Id
- *	\param	 MsgType  The Message Type
- *	\param	 MsgLen   The Message length
- *	\param	*Msg	  The message pointer
- *	\return  TRUE if enqueue is successful, FALSE if the queue is full
- *	\pre
- *	\post
- *	\note	 The message has to be initialized
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MlmeEnqueue(struct rt_rtmp_adapter *pAd,
-		    unsigned long Machine,
-		    unsigned long MsgType, unsigned long MsgLen, void * Msg)
-{
-	int Tail;
-	struct rt_mlme_queue *Queue = (struct rt_mlme_queue *)& pAd->Mlme.Queue;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return FALSE;
-
-	/* First check the size, it MUST not exceed the mlme queue size */
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
-		DBGPRINT_ERR("MlmeEnqueue: msg too large, size = %ld \n", MsgLen);
-		return FALSE;
-	}
-
-	if (MlmeQueueFull(Queue)) {
-		return FALSE;
-	}
-
-	NdisAcquireSpinLock(&(Queue->Lock));
-	Tail = Queue->Tail;
-	Queue->Tail++;
-	Queue->Num++;
-	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) {
-		Queue->Tail = 0;
-	}
-
-	Queue->Entry[Tail].Wcid = RESERVED_WCID;
-	Queue->Entry[Tail].Occupied = TRUE;
-	Queue->Entry[Tail].Machine = Machine;
-	Queue->Entry[Tail].MsgType = MsgType;
-	Queue->Entry[Tail].MsgLen = MsgLen;
-
-	if (Msg != NULL) {
-		NdisMoveMemory(Queue->Entry[Tail].Msg, Msg, MsgLen);
-	}
-
-	NdisReleaseSpinLock(&(Queue->Lock));
-	return TRUE;
-}
-
-/*! \brief	 This function is used when Recv gets a MLME message
- *	\param	*Queue			 The MLME Queue
- *	\param	 TimeStampHigh	 The upper 32 bit of timestamp
- *	\param	 TimeStampLow	 The lower 32 bit of timestamp
- *	\param	 Rssi			 The receiving RSSI strength
- *	\param	 MsgLen			 The length of the message
- *	\param	*Msg			 The message pointer
- *	\return  TRUE if everything ok, FALSE otherwise (like Queue Full)
- *	\pre
- *	\post
-
- IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MlmeEnqueueForRecv(struct rt_rtmp_adapter *pAd,
-			   unsigned long Wcid,
-			   unsigned long TimeStampHigh,
-			   unsigned long TimeStampLow,
-			   u8 Rssi0,
-			   u8 Rssi1,
-			   u8 Rssi2,
-			   unsigned long MsgLen, void * Msg, u8 Signal)
-{
-	int Tail, Machine;
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) Msg;
-	int MsgType;
-	struct rt_mlme_queue *Queue = (struct rt_mlme_queue *)& pAd->Mlme.Queue;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd,
-	     fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		DBGPRINT_ERR("MlmeEnqueueForRecv: fRTMP_ADAPTER_HALT_IN_PROGRESS\n");
-		return FALSE;
-	}
-	/* First check the size, it MUST not exceed the mlme queue size */
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
-		DBGPRINT_ERR("MlmeEnqueueForRecv: frame too large, size = %ld \n", MsgLen);
-		return FALSE;
-	}
-
-	if (MlmeQueueFull(Queue)) {
-		return FALSE;
-	}
-
-	{
-		if (!MsgTypeSubst(pAd, pFrame, &Machine, &MsgType)) {
-			DBGPRINT_ERR("MlmeEnqueueForRecv: un-recongnized mgmt->subtype=%d\n", pFrame->Hdr.FC.SubType);
-			return FALSE;
-		}
-	}
-
-	/* OK, we got all the informations, it is time to put things into queue */
-	NdisAcquireSpinLock(&(Queue->Lock));
-	Tail = Queue->Tail;
-	Queue->Tail++;
-	Queue->Num++;
-	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) {
-		Queue->Tail = 0;
-	}
-	Queue->Entry[Tail].Occupied = TRUE;
-	Queue->Entry[Tail].Machine = Machine;
-	Queue->Entry[Tail].MsgType = MsgType;
-	Queue->Entry[Tail].MsgLen = MsgLen;
-	Queue->Entry[Tail].TimeStamp.u.LowPart = TimeStampLow;
-	Queue->Entry[Tail].TimeStamp.u.HighPart = TimeStampHigh;
-	Queue->Entry[Tail].Rssi0 = Rssi0;
-	Queue->Entry[Tail].Rssi1 = Rssi1;
-	Queue->Entry[Tail].Rssi2 = Rssi2;
-	Queue->Entry[Tail].Signal = Signal;
-	Queue->Entry[Tail].Wcid = (u8)Wcid;
-
-	Queue->Entry[Tail].Channel = pAd->LatchRfRegs.Channel;
-
-	if (Msg != NULL) {
-		NdisMoveMemory(Queue->Entry[Tail].Msg, Msg, MsgLen);
-	}
-
-	NdisReleaseSpinLock(&(Queue->Lock));
-
-	RTMP_MLME_HANDLER(pAd);
-
-	return TRUE;
-}
-
-/*! \brief	 Dequeue a message from the MLME Queue
- *	\param	*Queue	  The MLME Queue
- *	\param	*Elem	  The message dequeued from MLME Queue
- *	\return  TRUE if the Elem contains something, FALSE otherwise
- *	\pre
- *	\post
-
- IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MlmeDequeue(struct rt_mlme_queue *Queue, struct rt_mlme_queue_elem ** Elem)
-{
-	NdisAcquireSpinLock(&(Queue->Lock));
-	*Elem = &(Queue->Entry[Queue->Head]);
-	Queue->Num--;
-	Queue->Head++;
-	if (Queue->Head == MAX_LEN_OF_MLME_QUEUE) {
-		Queue->Head = 0;
-	}
-	NdisReleaseSpinLock(&(Queue->Lock));
-	return TRUE;
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void MlmeRestartStateMachine(struct rt_rtmp_adapter *pAd)
-{
-#ifdef RTMP_MAC_PCI
-	struct rt_mlme_queue_elem *Elem = NULL;
-#endif /* RTMP_MAC_PCI // */
-	BOOLEAN Cancelled;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("MlmeRestartStateMachine \n"));
-
-#ifdef RTMP_MAC_PCI
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	if (pAd->Mlme.bRunning) {
-		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-		return;
-	} else {
-		pAd->Mlme.bRunning = TRUE;
-	}
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-
-	/* Remove all Mlme queues elements */
-	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) {
-		/*From message type, determine which state machine I should drive */
-		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
-			/* free MLME element */
-			Elem->Occupied = FALSE;
-			Elem->MsgLen = 0;
-
-		} else {
-			DBGPRINT_ERR("MlmeRestartStateMachine: MlmeQueue empty\n");
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	{
-		/* Cancel all timer events */
-		/* Be careful to cancel new added timer */
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
-
-	}
-
-	/* Change back to original channel in case of doing scan */
-	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-
-	/* Resume MSDU which is turned off durning scan */
-	RTMPResumeMsduTransmission(pAd);
-
-	{
-		/* Set all state machines back IDLE */
-		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
-		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-		pAd->Mlme.ActMachine.CurrState = ACT_IDLE;
-	}
-
-#ifdef RTMP_MAC_PCI
-	/* Remove running state */
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	pAd->Mlme.bRunning = FALSE;
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-#endif /* RTMP_MAC_PCI // */
-}
-
-/*! \brief	test if the MLME Queue is empty
- *	\param	*Queue	  The MLME Queue
- *	\return TRUE if the Queue is empty, FALSE otherwise
- *	\pre
- *	\post
-
- IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MlmeQueueEmpty(struct rt_mlme_queue *Queue)
-{
-	BOOLEAN Ans;
-
-	NdisAcquireSpinLock(&(Queue->Lock));
-	Ans = (Queue->Num == 0);
-	NdisReleaseSpinLock(&(Queue->Lock));
-
-	return Ans;
-}
-
-/*! \brief	 test if the MLME Queue is full
- *	\param	 *Queue		 The MLME Queue
- *	\return  TRUE if the Queue is empty, FALSE otherwise
- *	\pre
- *	\post
-
- IRQL = PASSIVE_LEVEL
- IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MlmeQueueFull(struct rt_mlme_queue *Queue)
-{
-	BOOLEAN Ans;
-
-	NdisAcquireSpinLock(&(Queue->Lock));
-	Ans = (Queue->Num == MAX_LEN_OF_MLME_QUEUE
-	       || Queue->Entry[Queue->Tail].Occupied);
-	NdisReleaseSpinLock(&(Queue->Lock));
-
-	return Ans;
-}
-
-/*! \brief	 The destructor of MLME Queue
- *	\param
- *	\return
- *	\pre
- *	\post
- *	\note	Clear Mlme Queue, Set Queue->Num to Zero.
-
- IRQL = PASSIVE_LEVEL
-
- */
-void MlmeQueueDestroy(struct rt_mlme_queue *pQueue)
-{
-	NdisAcquireSpinLock(&(pQueue->Lock));
-	pQueue->Num = 0;
-	pQueue->Head = 0;
-	pQueue->Tail = 0;
-	NdisReleaseSpinLock(&(pQueue->Lock));
-	NdisFreeSpinLock(&(pQueue->Lock));
-}
-
-/*! \brief	 To substitute the message type if the message is coming from external
- *	\param	pFrame		   The frame received
- *	\param	*Machine	   The state machine
- *	\param	*MsgType	   the message type for the state machine
- *	\return TRUE if the substitution is successful, FALSE otherwise
- *	\pre
- *	\post
-
- IRQL = DISPATCH_LEVEL
-
- */
-BOOLEAN MsgTypeSubst(struct rt_rtmp_adapter *pAd,
-		     struct rt_frame_802_11 * pFrame,
-		     int * Machine, int * MsgType)
-{
-	u16 Seq, Alg;
-	u8 EAPType;
-	u8 *pData;
-
-	/* Pointer to start of data frames including SNAP header */
-	pData = (u8 *)pFrame + LENGTH_802_11;
-
-	/* The only data type will pass to this function is EAPOL frame */
-	if (pFrame->Hdr.FC.Type == BTYPE_DATA) {
-		{
-			*Machine = WPA_STATE_MACHINE;
-			EAPType =
-			    *((u8 *) pFrame + LENGTH_802_11 +
-			      LENGTH_802_1_H + 1);
-			return (WpaMsgTypeSubst(EAPType, (int *) MsgType));
-		}
-	}
-
-	switch (pFrame->Hdr.FC.SubType) {
-	case SUBTYPE_ASSOC_REQ:
-		*Machine = ASSOC_STATE_MACHINE;
-		*MsgType = MT2_PEER_ASSOC_REQ;
-		break;
-	case SUBTYPE_ASSOC_RSP:
-		*Machine = ASSOC_STATE_MACHINE;
-		*MsgType = MT2_PEER_ASSOC_RSP;
-		break;
-	case SUBTYPE_REASSOC_REQ:
-		*Machine = ASSOC_STATE_MACHINE;
-		*MsgType = MT2_PEER_REASSOC_REQ;
-		break;
-	case SUBTYPE_REASSOC_RSP:
-		*Machine = ASSOC_STATE_MACHINE;
-		*MsgType = MT2_PEER_REASSOC_RSP;
-		break;
-	case SUBTYPE_PROBE_REQ:
-		*Machine = SYNC_STATE_MACHINE;
-		*MsgType = MT2_PEER_PROBE_REQ;
-		break;
-	case SUBTYPE_PROBE_RSP:
-		*Machine = SYNC_STATE_MACHINE;
-		*MsgType = MT2_PEER_PROBE_RSP;
-		break;
-	case SUBTYPE_BEACON:
-		*Machine = SYNC_STATE_MACHINE;
-		*MsgType = MT2_PEER_BEACON;
-		break;
-	case SUBTYPE_ATIM:
-		*Machine = SYNC_STATE_MACHINE;
-		*MsgType = MT2_PEER_ATIM;
-		break;
-	case SUBTYPE_DISASSOC:
-		*Machine = ASSOC_STATE_MACHINE;
-		*MsgType = MT2_PEER_DISASSOC_REQ;
-		break;
-	case SUBTYPE_AUTH:
-		/* get the sequence number from payload 24 Mac Header + 2 bytes algorithm */
-		NdisMoveMemory(&Seq, &pFrame->Octet[2], sizeof(u16));
-		NdisMoveMemory(&Alg, &pFrame->Octet[0], sizeof(u16));
-		if (Seq == 1 || Seq == 3) {
-			*Machine = AUTH_RSP_STATE_MACHINE;
-			*MsgType = MT2_PEER_AUTH_ODD;
-		} else if (Seq == 2 || Seq == 4) {
-			if (Alg == AUTH_MODE_OPEN || Alg == AUTH_MODE_KEY) {
-				*Machine = AUTH_STATE_MACHINE;
-				*MsgType = MT2_PEER_AUTH_EVEN;
-			}
-		} else {
-			return FALSE;
-		}
-		break;
-	case SUBTYPE_DEAUTH:
-		*Machine = AUTH_RSP_STATE_MACHINE;
-		*MsgType = MT2_PEER_DEAUTH;
-		break;
-	case SUBTYPE_ACTION:
-		*Machine = ACTION_STATE_MACHINE;
-		/*  Sometimes Sta will return with category bytes with MSB = 1, if they receive catogory out of their support */
-		if ((pFrame->Octet[0] & 0x7F) > MAX_PEER_CATE_MSG) {
-			*MsgType = MT2_ACT_INVALID;
-		} else {
-			*MsgType = (pFrame->Octet[0] & 0x7F);
-		}
-		break;
-	default:
-		return FALSE;
-		break;
-	}
-
-	return TRUE;
-}
-
-/* =========================================================================================== */
-/* state_machine.c */
-/* =========================================================================================== */
-
-/*! \brief Initialize the state machine.
- *	\param *S			pointer to the state machine
- *	\param	Trans		State machine transition function
- *	\param	StNr		number of states
- *	\param	MsgNr		number of messages
- *	\param	DefFunc		default function, when there is invalid state/message combination
- *	\param	InitState	initial state of the state machine
- *	\param	Base		StateMachine base, internal use only
- *	\pre p_sm should be a legal pointer
- *	\post
-
- IRQL = PASSIVE_LEVEL
-
- */
-void StateMachineInit(struct rt_state_machine *S,
-		      IN STATE_MACHINE_FUNC Trans[],
-		      unsigned long StNr,
-		      unsigned long MsgNr,
-		      IN STATE_MACHINE_FUNC DefFunc,
-		      unsigned long InitState, unsigned long Base)
-{
-	unsigned long i, j;
-
-	/* set number of states and messages */
-	S->NrState = StNr;
-	S->NrMsg = MsgNr;
-	S->Base = Base;
-
-	S->TransFunc = Trans;
-
-	/* init all state transition to default function */
-	for (i = 0; i < StNr; i++) {
-		for (j = 0; j < MsgNr; j++) {
-			S->TransFunc[i * MsgNr + j] = DefFunc;
-		}
-	}
-
-	/* set the starting state */
-	S->CurrState = InitState;
-}
-
-/*! \brief This function fills in the function pointer into the cell in the state machine
- *	\param *S	pointer to the state machine
- *	\param St	state
- *	\param Msg	incoming message
- *	\param f	the function to be executed when (state, message) combination occurs at the state machine
- *	\pre *S should be a legal pointer to the state machine, st, msg, should be all within the range, Base should be set in the initial state
- *	\post
-
- IRQL = PASSIVE_LEVEL
-
- */
-void StateMachineSetAction(struct rt_state_machine *S,
-			   unsigned long St,
-			   unsigned long Msg, IN STATE_MACHINE_FUNC Func)
-{
-	unsigned long MsgIdx;
-
-	MsgIdx = Msg - S->Base;
-
-	if (St < S->NrState && MsgIdx < S->NrMsg) {
-		/* boundary checking before setting the action */
-		S->TransFunc[St * S->NrMsg + MsgIdx] = Func;
-	}
-}
-
-/*! \brief	 This function does the state transition
- *	\param	 *Adapter the NIC adapter pointer
- *	\param	 *S	  the state machine
- *	\param	 *Elem	  the message to be executed
- *	\return   None
-
- IRQL = DISPATCH_LEVEL
-
- */
-void StateMachinePerformAction(struct rt_rtmp_adapter *pAd,
-			       struct rt_state_machine *S, struct rt_mlme_queue_elem *Elem)
-{
-	(*(S->TransFunc[S->CurrState * S->NrMsg + Elem->MsgType - S->Base]))
-	    (pAd, Elem);
-}
-
-/*
-	==========================================================================
-	Description:
-		The drop function, when machine executes this, the message is simply
-		ignored. This function does nothing, the message is freed in
-		StateMachinePerformAction()
-	==========================================================================
- */
-void Drop(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-}
-
-/* =========================================================================================== */
-/* lfsr.c */
-/* =========================================================================================== */
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
- */
-void LfsrInit(struct rt_rtmp_adapter *pAd, unsigned long Seed)
-{
-	if (Seed == 0)
-		pAd->Mlme.ShiftReg = 1;
-	else
-		pAd->Mlme.ShiftReg = Seed;
-}
-
-/*
-	==========================================================================
-	Description:
-	==========================================================================
- */
-u8 RandomByte(struct rt_rtmp_adapter *pAd)
-{
-	unsigned long i;
-	u8 R, Result;
-
-	R = 0;
-
-	if (pAd->Mlme.ShiftReg == 0)
-		NdisGetSystemUpTime((unsigned long *) & pAd->Mlme.ShiftReg);
-
-	for (i = 0; i < 8; i++) {
-		if (pAd->Mlme.ShiftReg & 0x00000001) {
-			pAd->Mlme.ShiftReg =
-			    ((pAd->Mlme.
-			      ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
-			Result = 1;
-		} else {
-			pAd->Mlme.ShiftReg = pAd->Mlme.ShiftReg >> 1;
-			Result = 0;
-		}
-		R = (R << 1) | Result;
-	}
-
-	return R;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Verify the support rate for different PHY type
-
-	Arguments:
-		pAd 				Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-void RTMPCheckRates(struct rt_rtmp_adapter *pAd,
-		    IN u8 SupRate[], IN u8 * SupRateLen)
-{
-	u8 RateIdx, i, j;
-	u8 NewRate[12], NewRateLen;
-
-	NewRateLen = 0;
-
-	if (pAd->CommonCfg.PhyMode == PHY_11B)
-		RateIdx = 4;
-	else
-		RateIdx = 12;
-
-	/* Check for support rates exclude basic rate bit */
-	for (i = 0; i < *SupRateLen; i++)
-		for (j = 0; j < RateIdx; j++)
-			if ((SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
-				NewRate[NewRateLen++] = SupRate[i];
-
-	*SupRateLen = NewRateLen;
-	NdisMoveMemory(SupRate, NewRate, NewRateLen);
-}
-
-BOOLEAN RTMPCheckChannel(struct rt_rtmp_adapter *pAd,
-			 u8 CentralChannel, u8 Channel)
-{
-	u8 k;
-	u8 UpperChannel = 0, LowerChannel = 0;
-	u8 NoEffectChannelinList = 0;
-
-	/* Find upper and lower channel according to 40MHz current operation. */
-	if (CentralChannel < Channel) {
-		UpperChannel = Channel;
-		if (CentralChannel > 2)
-			LowerChannel = CentralChannel - 2;
-		else
-			return FALSE;
-	} else if (CentralChannel > Channel) {
-		UpperChannel = CentralChannel + 2;
-		LowerChannel = Channel;
-	}
-
-	for (k = 0; k < pAd->ChannelListNum; k++) {
-		if (pAd->ChannelList[k].Channel == UpperChannel) {
-			NoEffectChannelinList++;
-		}
-		if (pAd->ChannelList[k].Channel == LowerChannel) {
-			NoEffectChannelinList++;
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Total Channel in Channel List = [%d]\n",
-		  NoEffectChannelinList));
-	if (NoEffectChannelinList == 2)
-		return TRUE;
-	else
-		return FALSE;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Verify the support rate for HT phy type
-
-	Arguments:
-		pAd 				Pointer to our adapter
-
-	Return Value:
-		FALSE if pAd->CommonCfg.SupportedHtPhy doesn't accept the pHtCapability.  (AP Mode)
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-BOOLEAN RTMPCheckHt(struct rt_rtmp_adapter *pAd,
-		    u8 Wcid,
-		    struct rt_ht_capability_ie * pHtCapability,
-		    struct rt_add_ht_info_ie * pAddHtInfo)
-{
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
-		return FALSE;
-
-	/* If use AMSDU, set flag. */
-	if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_AMSDU_INUSED);
-	/* Save Peer Capability */
-	if (pHtCapability->HtCapInfo.ShortGIfor20)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_SGI20_CAPABLE);
-	if (pHtCapability->HtCapInfo.ShortGIfor40)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_SGI40_CAPABLE);
-	if (pHtCapability->HtCapInfo.TxSTBC)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_TxSTBC_CAPABLE);
-	if (pHtCapability->HtCapInfo.RxSTBC)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_RxSTBC_CAPABLE);
-	if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport) {
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
-				       fCLIENT_STATUS_RDG_CAPABLE);
-	}
-
-	if (Wcid < MAX_LEN_OF_MAC_TABLE) {
-		pAd->MacTab.Content[Wcid].MpduDensity =
-		    pHtCapability->HtCapParm.MpduDensity;
-	}
-	/* Will check ChannelWidth for MCSSet[4] below */
-	pAd->MlmeAux.HtCapability.MCSSet[4] = 0x1;
-	switch (pAd->CommonCfg.RxStream) {
-	case 1:
-		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[1] = 0x00;
-		pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
-		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-		break;
-	case 2:
-		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
-		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-		break;
-	case 3:
-		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[2] = 0xff;
-		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-		break;
-	}
-
-	pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth =
-	    pAddHtInfo->AddHtInfo.RecomWidth & pAd->CommonCfg.DesiredHtPhy.
-	    ChannelWidth;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPCheckHt:: HtCapInfo.ChannelWidth=%d, RecomWidth=%d, DesiredHtPhy.ChannelWidth=%d, BW40MAvailForA/G=%d/%d, PhyMode=%d \n",
-		  pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth,
-		  pAddHtInfo->AddHtInfo.RecomWidth,
-		  pAd->CommonCfg.DesiredHtPhy.ChannelWidth,
-		  pAd->NicConfig2.field.BW40MAvailForA,
-		  pAd->NicConfig2.field.BW40MAvailForG,
-		  pAd->CommonCfg.PhyMode));
-
-	pAd->MlmeAux.HtCapability.HtCapInfo.GF =
-	    pHtCapability->HtCapInfo.GF & pAd->CommonCfg.DesiredHtPhy.GF;
-
-	/* Send Assoc Req with my HT capability. */
-	pAd->MlmeAux.HtCapability.HtCapInfo.AMsduSize =
-	    pAd->CommonCfg.DesiredHtPhy.AmsduSize;
-	pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs =
-	    pAd->CommonCfg.DesiredHtPhy.MimoPs;
-	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20 =
-	    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (pHtCapability->
-							  HtCapInfo.
-							  ShortGIfor20);
-	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40 =
-	    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (pHtCapability->
-							  HtCapInfo.
-							  ShortGIfor40);
-	pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC =
-	    (pAd->CommonCfg.DesiredHtPhy.TxSTBC) & (pHtCapability->HtCapInfo.
-						    RxSTBC);
-	pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC =
-	    (pAd->CommonCfg.DesiredHtPhy.RxSTBC) & (pHtCapability->HtCapInfo.
-						    TxSTBC);
-	pAd->MlmeAux.HtCapability.HtCapParm.MaxRAmpduFactor =
-	    pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor;
-	pAd->MlmeAux.HtCapability.HtCapParm.MpduDensity =
-	    pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity;
-	pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC =
-	    pHtCapability->ExtHtCapInfo.PlusHTC;
-	pAd->MacTab.Content[Wcid].HTCapability.ExtHtCapInfo.PlusHTC =
-	    pHtCapability->ExtHtCapInfo.PlusHTC;
-	if (pAd->CommonCfg.bRdg) {
-		pAd->MlmeAux.HtCapability.ExtHtCapInfo.RDGSupport =
-		    pHtCapability->ExtHtCapInfo.RDGSupport;
-		pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = 1;
-	}
-
-	if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_20)
-		pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;	/* BW20 can't transmit MCS32 */
-
-	COPY_AP_HTSETTINGS_FROM_BEACON(pAd, pHtCapability);
-	return TRUE;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Verify the support rate for different PHY type
-
-	Arguments:
-		pAd 				Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-void RTMPUpdateMlmeRate(struct rt_rtmp_adapter *pAd)
-{
-	u8 MinimumRate;
-	u8 ProperMlmeRate;	/*= RATE_54; */
-	u8 i, j, RateIdx = 12;	/*1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54 */
-	BOOLEAN bMatch = FALSE;
-
-	switch (pAd->CommonCfg.PhyMode) {
-	case PHY_11B:
-		ProperMlmeRate = RATE_11;
-		MinimumRate = RATE_1;
-		break;
-	case PHY_11BG_MIXED:
-	case PHY_11ABGN_MIXED:
-	case PHY_11BGN_MIXED:
-		if ((pAd->MlmeAux.SupRateLen == 4) &&
-		    (pAd->MlmeAux.ExtRateLen == 0))
-			/* B only AP */
-			ProperMlmeRate = RATE_11;
-		else
-			ProperMlmeRate = RATE_24;
-
-		if (pAd->MlmeAux.Channel <= 14)
-			MinimumRate = RATE_1;
-		else
-			MinimumRate = RATE_6;
-		break;
-	case PHY_11A:
-	case PHY_11N_2_4G:	/* rt2860 need to check mlmerate for 802.11n */
-	case PHY_11GN_MIXED:
-	case PHY_11AGN_MIXED:
-	case PHY_11AN_MIXED:
-	case PHY_11N_5G:
-		ProperMlmeRate = RATE_24;
-		MinimumRate = RATE_6;
-		break;
-	case PHY_11ABG_MIXED:
-		ProperMlmeRate = RATE_24;
-		if (pAd->MlmeAux.Channel <= 14)
-			MinimumRate = RATE_1;
-		else
-			MinimumRate = RATE_6;
-		break;
-	default:		/* error */
-		ProperMlmeRate = RATE_1;
-		MinimumRate = RATE_1;
-		break;
-	}
-
-	for (i = 0; i < pAd->MlmeAux.SupRateLen; i++) {
-		for (j = 0; j < RateIdx; j++) {
-			if ((pAd->MlmeAux.SupRate[i] & 0x7f) ==
-			    RateIdTo500Kbps[j]) {
-				if (j == ProperMlmeRate) {
-					bMatch = TRUE;
-					break;
-				}
-			}
-		}
-
-		if (bMatch)
-			break;
-	}
-
-	if (bMatch == FALSE) {
-		for (i = 0; i < pAd->MlmeAux.ExtRateLen; i++) {
-			for (j = 0; j < RateIdx; j++) {
-				if ((pAd->MlmeAux.ExtRate[i] & 0x7f) ==
-				    RateIdTo500Kbps[j]) {
-					if (j == ProperMlmeRate) {
-						bMatch = TRUE;
-						break;
-					}
-				}
-			}
-
-			if (bMatch)
-				break;
-		}
-	}
-
-	if (bMatch == FALSE) {
-		ProperMlmeRate = MinimumRate;
-	}
-
-	pAd->CommonCfg.MlmeRate = MinimumRate;
-	pAd->CommonCfg.RtsRate = ProperMlmeRate;
-	if (pAd->CommonCfg.MlmeRate >= RATE_6) {
-		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-		pAd->CommonCfg.MlmeTransmit.field.MCS =
-		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
-		    MODE_OFDM;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
-		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-	} else {
-		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
-		pAd->CommonCfg.MlmeTransmit.field.MCS = pAd->CommonCfg.MlmeRate;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
-		    MODE_CCK;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
-		    pAd->CommonCfg.MlmeRate;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPUpdateMlmeRate ==>   MlmeTransmit = 0x%x  \n",
-		  pAd->CommonCfg.MlmeTransmit.word));
-}
-
-char RTMPMaxRssi(struct rt_rtmp_adapter *pAd,
-		 char Rssi0, char Rssi1, char Rssi2)
-{
-	char larger = -127;
-
-	if ((pAd->Antenna.field.RxPath == 1) && (Rssi0 != 0)) {
-		larger = Rssi0;
-	}
-
-	if ((pAd->Antenna.field.RxPath >= 2) && (Rssi1 != 0)) {
-		larger = max(Rssi0, Rssi1);
-	}
-
-	if ((pAd->Antenna.field.RxPath == 3) && (Rssi2 != 0)) {
-		larger = max(larger, Rssi2);
-	}
-
-	if (larger == -127)
-		larger = 0;
-
-	return larger;
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        Periodic evaluate antenna link status
-
-    Arguments:
-        pAd         - Adapter pointer
-
-    Return Value:
-        None
-
-    ========================================================================
-*/
-void AsicEvaluateRxAnt(struct rt_rtmp_adapter *pAd)
-{
-	u8 BBPR3 = 0;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS |
-			   fRTMP_ADAPTER_HALT_IN_PROGRESS |
-			   fRTMP_ADAPTER_RADIO_OFF |
-			   fRTMP_ADAPTER_NIC_NOT_EXIST |
-			   fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
-	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
-#ifdef RT30xx
-	    || (pAd->EepromAccess)
-#endif /* RT30xx // */
-#ifdef RT3090
-	    || (pAd->bPCIclkOff == TRUE)
-#endif /* RT3090 // */
-	    )
-		return;
-
-	{
-		/*if (pAd->StaCfg.Psm == PWR_SAVE) */
-		/*      return; */
-
-		{
-
-			if (pAd->StaCfg.Psm == PWR_SAVE)
-				return;
-
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
-			BBPR3 &= (~0x18);
-			if (pAd->Antenna.field.RxPath == 3) {
-				BBPR3 |= (0x10);
-			} else if (pAd->Antenna.field.RxPath == 2) {
-				BBPR3 |= (0x8);
-			} else if (pAd->Antenna.field.RxPath == 1) {
-				BBPR3 |= (0x0);
-			}
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
-#ifdef RTMP_MAC_PCI
-			pAd->StaCfg.BBPR3 = BBPR3;
-#endif /* RTMP_MAC_PCI // */
-			if (OPSTATUS_TEST_FLAG
-			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-			    ) {
-				unsigned long TxTotalCnt =
-				    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-				    pAd->RalinkCounters.OneSecTxRetryOkCount +
-				    pAd->RalinkCounters.OneSecTxFailCount;
-
-				/* dynamic adjust antenna evaluation period according to the traffic */
-				if (TxTotalCnt > 50) {
-					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer,
-						     20);
-					pAd->Mlme.bLowThroughput = FALSE;
-				} else {
-					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer,
-						     300);
-					pAd->Mlme.bLowThroughput = TRUE;
-				}
-			}
-		}
-
-	}
-
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        After evaluation, check antenna link status
-
-    Arguments:
-        pAd         - Adapter pointer
-
-    Return Value:
-        None
-
-    ========================================================================
-*/
-void AsicRxAntEvalTimeout(void *SystemSpecific1,
-			  void *FunctionContext,
-			  void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	u8 BBPR3 = 0;
-	char larger = -127, rssi0, rssi1, rssi2;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS |
-			   fRTMP_ADAPTER_HALT_IN_PROGRESS |
-			   fRTMP_ADAPTER_RADIO_OFF |
-			   fRTMP_ADAPTER_NIC_NOT_EXIST) ||
-	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
-#ifdef RT30xx
-	    || (pAd->EepromAccess)
-#endif /* RT30xx // */
-#ifdef RT3090
-	    || (pAd->bPCIclkOff == TRUE)
-#endif /* RT3090 // */
-	    )
-		return;
-
-	{
-		/*if (pAd->StaCfg.Psm == PWR_SAVE) */
-		/*      return; */
-		{
-			if (pAd->StaCfg.Psm == PWR_SAVE)
-				return;
-
-			/* if the traffic is low, use average rssi as the criteria */
-			if (pAd->Mlme.bLowThroughput == TRUE) {
-				rssi0 = pAd->StaCfg.RssiSample.LastRssi0;
-				rssi1 = pAd->StaCfg.RssiSample.LastRssi1;
-				rssi2 = pAd->StaCfg.RssiSample.LastRssi2;
-			} else {
-				rssi0 = pAd->StaCfg.RssiSample.AvgRssi0;
-				rssi1 = pAd->StaCfg.RssiSample.AvgRssi1;
-				rssi2 = pAd->StaCfg.RssiSample.AvgRssi2;
-			}
-
-			if (pAd->Antenna.field.RxPath == 3) {
-				larger = max(rssi0, rssi1);
-
-				if (larger > (rssi2 + 20))
-					pAd->Mlme.RealRxPath = 2;
-				else
-					pAd->Mlme.RealRxPath = 3;
-			} else if (pAd->Antenna.field.RxPath == 2) {
-				if (rssi0 > (rssi1 + 20))
-					pAd->Mlme.RealRxPath = 1;
-				else
-					pAd->Mlme.RealRxPath = 2;
-			}
-
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
-			BBPR3 &= (~0x18);
-			if (pAd->Mlme.RealRxPath == 3) {
-				BBPR3 |= (0x10);
-			} else if (pAd->Mlme.RealRxPath == 2) {
-				BBPR3 |= (0x8);
-			} else if (pAd->Mlme.RealRxPath == 1) {
-				BBPR3 |= (0x0);
-			}
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
-#ifdef RTMP_MAC_PCI
-			pAd->StaCfg.BBPR3 = BBPR3;
-#endif /* RTMP_MAC_PCI // */
-		}
-	}
-
-}
-
-void APSDPeriodicExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-		return;
-
-	pAd->CommonCfg.TriggerTimerCount++;
-
-/* Driver should not send trigger frame, it should be send by application layer */
-/*
-	if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable
-		&& (pAd->CommonCfg.bNeedSendTriggerFrame ||
-		(((pAd->CommonCfg.TriggerTimerCount%20) == 19) && (!pAd->CommonCfg.bAPSDAC_BE || !pAd->CommonCfg.bAPSDAC_BK || !pAd->CommonCfg.bAPSDAC_VI || !pAd->CommonCfg.bAPSDAC_VO))))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("Sending trigger frame and enter service period when support APSD\n"));
-		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-		pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
-		pAd->CommonCfg.TriggerTimerCount = 0;
-		pAd->CommonCfg.bInServicePeriod = TRUE;
-	}*/
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        Set/reset MAC registers according to bPiggyBack parameter
-
-    Arguments:
-        pAd         - Adapter pointer
-        bPiggyBack  - Enable / Disable Piggy-Back
-
-    Return Value:
-        None
-
-    ========================================================================
-*/
-void RTMPSetPiggyBack(struct rt_rtmp_adapter *pAd, IN BOOLEAN bPiggyBack)
-{
-	TX_LINK_CFG_STRUC TxLinkCfg;
-
-	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
-
-	TxLinkCfg.field.TxCFAckEn = bPiggyBack;
-	RTMP_IO_WRITE32(pAd, TX_LINK_CFG, TxLinkCfg.word);
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        check if this entry need to switch rate automatically
-
-    Arguments:
-        pAd
-        pEntry
-
-    Return Value:
-        TURE
-        FALSE
-
-    ========================================================================
-*/
-BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(struct rt_rtmp_adapter *pAd,
-					   struct rt_mac_table_entry *pEntry)
-{
-	BOOLEAN result = TRUE;
-
-	{
-		/* only associated STA counts */
-		if (pEntry && (pEntry->ValidAsCLI)
-		    && (pEntry->Sst == SST_ASSOC)) {
-			result = pAd->StaCfg.bAutoTxRateSwitch;
-		} else
-			result = FALSE;
-	}
-
-	return result;
-}
-
-BOOLEAN RTMPAutoRateSwitchCheck(struct rt_rtmp_adapter *pAd)
-{
-	{
-		if (pAd->StaCfg.bAutoTxRateSwitch)
-			return TRUE;
-	}
-	return FALSE;
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        check if this entry need to fix tx legacy rate
-
-    Arguments:
-        pAd
-        pEntry
-
-    Return Value:
-        TURE
-        FALSE
-
-    ========================================================================
-*/
-u8 RTMPStaFixedTxMode(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry)
-{
-	u8 tx_mode = FIXED_TXMODE_HT;
-
-	{
-		tx_mode =
-		    (u8)pAd->StaCfg.DesiredTransmitSetting.field.
-		    FixedTxMode;
-	}
-
-	return tx_mode;
-}
-
-/*
-    ========================================================================
-    Routine Description:
-        Overwrite HT Tx Mode by Fixed Legency Tx Mode, if specified.
-
-    Arguments:
-        pAd
-        pEntry
-
-    Return Value:
-        TURE
-        FALSE
-
-    ========================================================================
-*/
-void RTMPUpdateLegacyTxSetting(u8 fixed_tx_mode, struct rt_mac_table_entry *pEntry)
-{
-	HTTRANSMIT_SETTING TransmitSetting;
-
-	if (fixed_tx_mode == FIXED_TXMODE_HT)
-		return;
-
-	TransmitSetting.word = 0;
-
-	TransmitSetting.field.MODE = pEntry->HTPhyMode.field.MODE;
-	TransmitSetting.field.MCS = pEntry->HTPhyMode.field.MCS;
-
-	if (fixed_tx_mode == FIXED_TXMODE_CCK) {
-		TransmitSetting.field.MODE = MODE_CCK;
-		/* CCK mode allow MCS 0~3 */
-		if (TransmitSetting.field.MCS > MCS_3)
-			TransmitSetting.field.MCS = MCS_3;
-	} else {
-		TransmitSetting.field.MODE = MODE_OFDM;
-		/* OFDM mode allow MCS 0~7 */
-		if (TransmitSetting.field.MCS > MCS_7)
-			TransmitSetting.field.MCS = MCS_7;
-	}
-
-	if (pEntry->HTPhyMode.field.MODE >= TransmitSetting.field.MODE) {
-		pEntry->HTPhyMode.word = TransmitSetting.word;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTMPUpdateLegacyTxSetting : wcid-%d, MODE=%s, MCS=%d \n",
-			  pEntry->Aid, GetPhyMode(pEntry->HTPhyMode.field.MODE),
-			  pEntry->HTPhyMode.field.MCS));
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		dynamic tune BBP R66 to find a balance between sensibility and
-		noise isolation
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AsicStaBbpTuning(struct rt_rtmp_adapter *pAd)
-{
-	u8 OrigR66Value = 0, R66;	/*, R66UpperBound = 0x30, R66LowerBound = 0x30; */
-	char Rssi;
-
-	/* 2860C did not support Fase CCA, therefore can't tune */
-	if (pAd->MACVersion == 0x28600100)
-		return;
-
-	/* */
-	/* work as a STA */
-	/* */
-	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)	/* no R66 tuning when SCANNING */
-		return;
-
-	if ((pAd->OpMode == OPMODE_STA)
-	    && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-	    )
-	    && !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-#ifdef RTMP_MAC_PCI
-	    && (pAd->bPCIclkOff == FALSE)
-#endif /* RTMP_MAC_PCI // */
-	    ) {
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &OrigR66Value);
-		R66 = OrigR66Value;
-
-		if (pAd->Antenna.field.RxPath > 1)
-			Rssi =
-			    (pAd->StaCfg.RssiSample.AvgRssi0 +
-			     pAd->StaCfg.RssiSample.AvgRssi1) >> 1;
-		else
-			Rssi = pAd->StaCfg.RssiSample.AvgRssi0;
-
-		if (pAd->LatchRfRegs.Channel <= 14) {	/*BG band */
-#ifdef RT30xx
-			/* RT3070 is a no LNA solution, it should have different control regarding to AGC gain control */
-			/* Otherwise, it will have some throughput side effect when low RSSI */
-
-			if (IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3572(pAd)
-			    || IS_RT3390(pAd)) {
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
-					R66 =
-					    0x1C + 2 * GET_LNA_GAIN(pAd) + 0x20;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				} else {
-					R66 = 0x1C + 2 * GET_LNA_GAIN(pAd);
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				}
-			} else
-#endif /* RT30xx // */
-			{
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
-					R66 = (0x2E + GET_LNA_GAIN(pAd)) + 0x10;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				} else {
-					R66 = 0x2E + GET_LNA_GAIN(pAd);
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				}
-			}
-		} else {	/*A band */
-			if (pAd->CommonCfg.BBPCurrentBW == BW_20) {
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
-					R66 =
-					    0x32 + (GET_LNA_GAIN(pAd) * 5) / 3 +
-					    0x10;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				} else {
-					R66 =
-					    0x32 + (GET_LNA_GAIN(pAd) * 5) / 3;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				}
-			} else {
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
-					R66 =
-					    0x3A + (GET_LNA_GAIN(pAd) * 5) / 3 +
-					    0x10;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				} else {
-					R66 =
-					    0x3A + (GET_LNA_GAIN(pAd) * 5) / 3;
-					if (OrigR66Value != R66) {
-						RTMP_BBP_IO_WRITE8_BY_REG_ID
-						    (pAd, BBP_R66, R66);
-					}
-				}
-			}
-		}
-
-	}
-}
-
-void RTMPSetAGCInitValue(struct rt_rtmp_adapter *pAd, u8 BandWidth)
-{
-	u8 R66 = 0x30;
-
-	if (pAd->LatchRfRegs.Channel <= 14) {	/* BG band */
-#ifdef RT30xx
-		/* Gary was verified Amazon AP and find that RT307x has BBP_R66 invalid default value */
-
-		if (IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3572(pAd)
-		    || IS_RT3390(pAd)) {
-			R66 = 0x1C + 2 * GET_LNA_GAIN(pAd);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-		} else
-#endif /* RT30xx // */
-		{
-			R66 = 0x2E + GET_LNA_GAIN(pAd);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-		}
-	} else {		/*A band */
-		{
-			if (BandWidth == BW_20) {
-				R66 =
-				    (u8)(0x32 +
-					     (GET_LNA_GAIN(pAd) * 5) / 3);
-				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-			} else {
-				R66 =
-				    (u8)(0x3A +
-					     (GET_LNA_GAIN(pAd) * 5) / 3);
-				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-			}
-		}
-	}
-
-}
diff --git a/drivers/staging/rt2860/common/rt_channel.c b/drivers/staging/rt2860/common/rt_channel.c
deleted file mode 100644
index 5387989..0000000
--- a/drivers/staging/rt2860/common/rt_channel.c
+++ /dev/null
@@ -1,1705 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-#include "../rt_config.h"
-
-struct rt_ch_freq_map CH_HZ_ID_MAP[] = {
-	{1, 2412}
-	,
-	{2, 2417}
-	,
-	{3, 2422}
-	,
-	{4, 2427}
-	,
-	{5, 2432}
-	,
-	{6, 2437}
-	,
-	{7, 2442}
-	,
-	{8, 2447}
-	,
-	{9, 2452}
-	,
-	{10, 2457}
-	,
-	{11, 2462}
-	,
-	{12, 2467}
-	,
-	{13, 2472}
-	,
-	{14, 2484}
-	,
-
-	/*  UNII */
-	{36, 5180}
-	,
-	{40, 5200}
-	,
-	{44, 5220}
-	,
-	{48, 5240}
-	,
-	{52, 5260}
-	,
-	{56, 5280}
-	,
-	{60, 5300}
-	,
-	{64, 5320}
-	,
-	{149, 5745}
-	,
-	{153, 5765}
-	,
-	{157, 5785}
-	,
-	{161, 5805}
-	,
-	{165, 5825}
-	,
-	{167, 5835}
-	,
-	{169, 5845}
-	,
-	{171, 5855}
-	,
-	{173, 5865}
-	,
-
-	/* HiperLAN2 */
-	{100, 5500}
-	,
-	{104, 5520}
-	,
-	{108, 5540}
-	,
-	{112, 5560}
-	,
-	{116, 5580}
-	,
-	{120, 5600}
-	,
-	{124, 5620}
-	,
-	{128, 5640}
-	,
-	{132, 5660}
-	,
-	{136, 5680}
-	,
-	{140, 5700}
-	,
-
-	/* Japan MMAC */
-	{34, 5170}
-	,
-	{38, 5190}
-	,
-	{42, 5210}
-	,
-	{46, 5230}
-	,
-
-	/*  Japan */
-	{184, 4920}
-	,
-	{188, 4940}
-	,
-	{192, 4960}
-	,
-	{196, 4980}
-	,
-
-	{208, 5040}
-	,			/* Japan, means J08 */
-	{212, 5060}
-	,			/* Japan, means J12 */
-	{216, 5080}
-	,			/* Japan, means J16 */
-};
-
-int CH_HZ_ID_MAP_NUM = (sizeof(CH_HZ_ID_MAP) / sizeof(struct rt_ch_freq_map));
-
-struct rt_ch_region ChRegion[] = {
-	{			/* Antigua and Berbuda */
-	 "AG",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Argentina */
-	 "AR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Aruba */
-	 "AW",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Australia */
-	 "AU",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Austria */
-	 "AT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Bahamas */
-	 "BS",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Barbados */
-	 "BB",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Bermuda */
-	 "BM",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Brazil */
-	 "BR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Belgium */
-	 "BE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 18, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 18, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Bulgaria */
-	 "BG",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, ODOR, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Canada */
-	 "CA",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Cayman IsLands */
-	 "KY",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Chile */
-	 "CL",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* China */
-	 "CN",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Colombia */
-	 "CO",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 17, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Costa Rica */
-	 "CR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 17, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Cyprus */
-	 "CY",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Czech_Republic */
-	 "CZ",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Denmark */
-	 "DK",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Dominican Republic */
-	 "DO",
-	 CE,
-	 {
-	  {1, 0, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 0 */
-	  {149, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Equador */
-	 "EC",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {100, 11, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* El Salvador */
-	 "SV",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 36, BOTH, TRUE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Finland */
-	 "FI",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* France */
-	 "FR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Germany */
-	 "DE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Greece */
-	 "GR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, ODOR, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Guam */
-	 "GU",
-	 CE,
-	 {
-	  {1, 11, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {36, 4, 17, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Guatemala */
-	 "GT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 17, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Haiti */
-	 "HT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 17, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Honduras */
-	 "HN",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Hong Kong */
-	 "HK",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Hungary */
-	 "HU",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Iceland */
-	 "IS",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* India */
-	 "IN",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 24, IDOR, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Indonesia */
-	 "ID",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Ireland */
-	 "IE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, ODOR, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Israel */
-	 "IL",
-	 CE,
-	 {
-	  {1, 3, 20, IDOR, FALSE}
-	  ,			/* 2.4 G, ch 1~3 */
-	  {4, 6, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 4~9 */
-	  {10, 4, 20, IDOR, FALSE}
-	  ,			/* 2.4 G, ch 10~13 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Italy */
-	 "IT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, ODOR, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Japan */
-	 "JP",
-	 JAP,
-	 {
-	  {1, 14, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~14 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Jordan */
-	 "JO",
-	 CE,
-	 {
-	  {1, 13, 20, IDOR, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {149, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Latvia */
-	 "LV",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Liechtenstein */
-	 "LI",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Lithuania */
-	 "LT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Luxemburg */
-	 "LU",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Malaysia */
-	 "MY",
-	 CE,
-	 {
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Malta */
-	 "MT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Marocco */
-	 "MA",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 24, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Mexico */
-	 "MX",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 5, 30, IDOR, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Netherlands */
-	 "NL",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* New Zealand */
-	 "NZ",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Norway */
-	 "NO",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 24, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 24, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Peru */
-	 "PE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Portugal */
-	 "PT",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Poland */
-	 "PL",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Romania */
-	 "RO",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Russia */
-	 "RU",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {149, 4, 20, IDOR, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Saudi Arabia */
-	 "SA",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Serbia_and_Montenegro */
-	 "CS",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Singapore */
-	 "SG",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {149, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Slovakia */
-	 "SK",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Slovenia */
-	 "SI",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* South Africa */
-	 "ZA",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 4, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* South Korea */
-	 "KR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 8, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 100~128 */
-	  {149, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Spain */
-	 "ES",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 17, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Sweden */
-	 "SE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Switzerland */
-	 "CH",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~13 */
-	  {36, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Taiwan */
-	 "TW",
-	 CE,
-	 {
-	  {1, 11, 30, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {52, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Turkey */
-	 "TR",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {36, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 36~48 */
-	  {52, 4, 23, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* UK */
-	 "GB",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {36, 4, 23, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {52, 4, 23, IDOR, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Ukraine */
-	 "UA",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* United_Arab_Emirates */
-	 "AE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* United_States */
-	 "US",
-	 CE,
-	 {
-	  {1, 11, 30, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {36, 4, 17, IDOR, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {52, 4, 24, BOTH, TRUE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 30, BOTH, TRUE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 5, 30, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Venezuela */
-	 "VE",
-	 CE,
-	 {
-	  {1, 13, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {149, 4, 27, BOTH, FALSE}
-	  ,			/* 5G, ch 149~161 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-
-	{			/* Default */
-	 "",
-	 CE,
-	 {
-	  {1, 11, 20, BOTH, FALSE}
-	  ,			/* 2.4 G, ch 1~11 */
-	  {36, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {52, 4, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 52~64 */
-	  {100, 11, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 100~140 */
-	  {149, 5, 20, BOTH, FALSE}
-	  ,			/* 5G, ch 149~165 */
-	  {0}
-	  ,			/* end */
-	  }
-	 }
-	,
-};
-
-static struct rt_ch_region *GetChRegion(u8 *CntryCode)
-{
-	int loop = 0;
-	struct rt_ch_region *pChRegion = NULL;
-
-	while (strcmp((char *)ChRegion[loop].CountReg, "") != 0) {
-		if (strncmp
-		    ((char *)ChRegion[loop].CountReg, (char *)CntryCode,
-		     2) == 0) {
-			pChRegion = &ChRegion[loop];
-			break;
-		}
-		loop++;
-	}
-
-	if (pChRegion == NULL)
-		pChRegion = &ChRegion[loop];
-	return pChRegion;
-}
-
-static void ChBandCheck(u8 PhyMode, u8 *pChType)
-{
-	switch (PhyMode) {
-	case PHY_11A:
-	case PHY_11AN_MIXED:
-		*pChType = BAND_5G;
-		break;
-	case PHY_11ABG_MIXED:
-	case PHY_11AGN_MIXED:
-	case PHY_11ABGN_MIXED:
-		*pChType = BAND_BOTH;
-		break;
-
-	default:
-		*pChType = BAND_24G;
-		break;
-	}
-}
-
-static u8 FillChList(struct rt_rtmp_adapter *pAd,
-			struct rt_ch_desp *pChDesp,
-			u8 Offset, u8 increment)
-{
-	int i, j, l;
-	u8 channel;
-
-	j = Offset;
-	for (i = 0; i < pChDesp->NumOfCh; i++) {
-		channel = pChDesp->FirstChannel + i * increment;
-		for (l = 0; l < MAX_NUM_OF_CHANNELS; l++) {
-			if (channel == pAd->TxPower[l].Channel) {
-				pAd->ChannelList[j].Power =
-				    pAd->TxPower[l].Power;
-				pAd->ChannelList[j].Power2 =
-				    pAd->TxPower[l].Power2;
-				break;
-			}
-		}
-		if (l == MAX_NUM_OF_CHANNELS)
-			continue;
-
-		pAd->ChannelList[j].Channel =
-		    pChDesp->FirstChannel + i * increment;
-		pAd->ChannelList[j].MaxTxPwr = pChDesp->MaxTxPwr;
-		pAd->ChannelList[j].DfsReq = pChDesp->DfsReq;
-		j++;
-	}
-	pAd->ChannelListNum = j;
-
-	return j;
-}
-
-static inline void CreateChList(struct rt_rtmp_adapter *pAd,
-				struct rt_ch_region *pChRegion, u8 Geography)
-{
-	int i;
-	u8 offset = 0;
-	struct rt_ch_desp *pChDesp;
-	u8 ChType;
-	u8 increment;
-
-	if (pChRegion == NULL)
-		return;
-
-	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
-
-	for (i = 0; i < 10; i++) {
-		pChDesp = &pChRegion->ChDesp[i];
-		if (pChDesp->FirstChannel == 0)
-			break;
-
-		if (ChType == BAND_5G) {
-			if (pChDesp->FirstChannel <= 14)
-				continue;
-		} else if (ChType == BAND_24G) {
-			if (pChDesp->FirstChannel > 14)
-				continue;
-		}
-
-		if ((pChDesp->Geography == BOTH)
-		    || (pChDesp->Geography == Geography)) {
-			if (pChDesp->FirstChannel > 14)
-				increment = 4;
-			else
-				increment = 1;
-			offset = FillChList(pAd, pChDesp, offset, increment);
-		}
-	}
-}
-
-void BuildChannelListEx(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_ch_region *pChReg;
-
-	pChReg = GetChRegion(pAd->CommonCfg.CountryCode);
-	CreateChList(pAd, pChReg, pAd->CommonCfg.Geography);
-}
-
-void BuildBeaconChList(struct rt_rtmp_adapter *pAd,
-		       u8 *pBuf, unsigned long *pBufLen)
-{
-	int i;
-	unsigned long TmpLen;
-	struct rt_ch_region *pChRegion;
-	struct rt_ch_desp *pChDesp;
-	u8 ChType;
-
-	pChRegion = GetChRegion(pAd->CommonCfg.CountryCode);
-
-	if (pChRegion == NULL)
-		return;
-
-	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
-	*pBufLen = 0;
-
-	for (i = 0; i < 10; i++) {
-		pChDesp = &pChRegion->ChDesp[i];
-		if (pChDesp->FirstChannel == 0)
-			break;
-
-		if (ChType == BAND_5G) {
-			if (pChDesp->FirstChannel <= 14)
-				continue;
-		} else if (ChType == BAND_24G) {
-			if (pChDesp->FirstChannel > 14)
-				continue;
-		}
-
-		if ((pChDesp->Geography == BOTH)
-		    || (pChDesp->Geography == pAd->CommonCfg.Geography)) {
-			MakeOutgoingFrame(pBuf + *pBufLen, &TmpLen,
-					  1, &pChDesp->FirstChannel,
-					  1, &pChDesp->NumOfCh,
-					  1, &pChDesp->MaxTxPwr, END_OF_ARGS);
-			*pBufLen += TmpLen;
-		}
-	}
-}
-
-static BOOLEAN IsValidChannel(struct rt_rtmp_adapter *pAd, u8 channel)
-{
-	int i;
-
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		if (pAd->ChannelList[i].Channel == channel)
-			break;
-	}
-
-	if (i == pAd->ChannelListNum)
-		return FALSE;
-	else
-		return TRUE;
-}
-
-static u8 GetExtCh(u8 Channel, u8 Direction)
-{
-	char ExtCh;
-
-	if (Direction == EXTCHA_ABOVE)
-		ExtCh = Channel + 4;
-	else
-		ExtCh = (Channel - 4) > 0 ? (Channel - 4) : 0;
-
-	return ExtCh;
-}
-
-void N_ChannelCheck(struct rt_rtmp_adapter *pAd)
-{
-	/*u8 ChannelNum = pAd->ChannelListNum; */
-	u8 Channel = pAd->CommonCfg.Channel;
-
-	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-	    && (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)) {
-		if (Channel > 14) {
-			if ((Channel == 36) || (Channel == 44)
-			    || (Channel == 52) || (Channel == 60)
-			    || (Channel == 100) || (Channel == 108)
-			    || (Channel == 116) || (Channel == 124)
-			    || (Channel == 132) || (Channel == 149)
-			    || (Channel == 157)) {
-				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA =
-				    EXTCHA_ABOVE;
-			} else if ((Channel == 40) || (Channel == 48)
-				   || (Channel == 56) || (Channel == 64)
-				   || (Channel == 104) || (Channel == 112)
-				   || (Channel == 120) || (Channel == 128)
-				   || (Channel == 136) || (Channel == 153)
-				   || (Channel == 161)) {
-				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA =
-				    EXTCHA_BELOW;
-			} else {
-				pAd->CommonCfg.RegTransmitSetting.field.BW =
-				    BW_20;
-			}
-		} else {
-			do {
-				u8 ExtCh;
-				u8 Dir =
-				    pAd->CommonCfg.RegTransmitSetting.field.
-				    EXTCHA;
-				ExtCh = GetExtCh(Channel, Dir);
-				if (IsValidChannel(pAd, ExtCh))
-					break;
-
-				Dir =
-				    (Dir ==
-				     EXTCHA_ABOVE) ? EXTCHA_BELOW :
-				    EXTCHA_ABOVE;
-				ExtCh = GetExtCh(Channel, Dir);
-				if (IsValidChannel(pAd, ExtCh)) {
-					pAd->CommonCfg.RegTransmitSetting.field.
-					    EXTCHA = Dir;
-					break;
-				}
-				pAd->CommonCfg.RegTransmitSetting.field.BW =
-				    BW_20;
-			} while (FALSE);
-
-			if (Channel == 14) {
-				pAd->CommonCfg.RegTransmitSetting.field.BW =
-				    BW_20;
-				/*pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE; // We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT() */
-			}
-		}
-	}
-
-}
-
-void N_SetCenCh(struct rt_rtmp_adapter *pAd)
-{
-	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40) {
-		if (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA ==
-		    EXTCHA_ABOVE) {
-			pAd->CommonCfg.CentralChannel =
-			    pAd->CommonCfg.Channel + 2;
-		} else {
-			if (pAd->CommonCfg.Channel == 14)
-				pAd->CommonCfg.CentralChannel =
-				    pAd->CommonCfg.Channel - 1;
-			else
-				pAd->CommonCfg.CentralChannel =
-				    pAd->CommonCfg.Channel - 2;
-		}
-	} else {
-		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
-	}
-}
-
-u8 GetCuntryMaxTxPwr(struct rt_rtmp_adapter *pAd, u8 channel)
-{
-	int i;
-	for (i = 0; i < pAd->ChannelListNum; i++) {
-		if (pAd->ChannelList[i].Channel == channel)
-			break;
-	}
-
-	if (i == pAd->ChannelListNum)
-		return 0xff;
-	else
-		return pAd->ChannelList[i].MaxTxPwr;
-}
diff --git a/drivers/staging/rt2860/common/rt_rf.c b/drivers/staging/rt2860/common/rt_rf.c
deleted file mode 100644
index 2895447..0000000
--- a/drivers/staging/rt2860/common/rt_rf.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rt_rf.c
-
-	Abstract:
-	Ralink Wireless driver RF related functions
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#include "../rt_config.h"
-
-#ifdef RTMP_RF_RW_SUPPORT
-/*
-	========================================================================
-
-	Routine Description: Write RT30xx RF register through MAC
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RT30xxWriteRFRegister(struct rt_rtmp_adapter *pAd,
-				  u8 regID, u8 value)
-{
-	RF_CSR_CFG_STRUC rfcsr;
-	u32 i = 0;
-
-	do {
-		RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
-
-		if (!rfcsr.field.RF_CSR_KICK)
-			break;
-		i++;
-	}
-	while ((i < RETRY_LIMIT)
-	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
-
-	if ((i == RETRY_LIMIT)
-	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("Retry count exhausted or device removed!\n"));
-		return STATUS_UNSUCCESSFUL;
-	}
-
-	rfcsr.field.RF_CSR_WR = 1;
-	rfcsr.field.RF_CSR_KICK = 1;
-	rfcsr.field.TESTCSR_RFACC_REGNUM = regID;
-	rfcsr.field.RF_CSR_DATA = value;
-
-	RTMP_IO_WRITE32(pAd, RF_CSR_CFG, rfcsr.word);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Read RT30xx RF register through MAC
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RT30xxReadRFRegister(struct rt_rtmp_adapter *pAd,
-				 u8 regID, u8 *pValue)
-{
-	RF_CSR_CFG_STRUC rfcsr;
-	u32 i = 0, k = 0;
-
-	for (i = 0; i < MAX_BUSY_COUNT; i++) {
-		RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
-
-		if (rfcsr.field.RF_CSR_KICK == BUSY) {
-			continue;
-		}
-		rfcsr.word = 0;
-		rfcsr.field.RF_CSR_WR = 0;
-		rfcsr.field.RF_CSR_KICK = 1;
-		rfcsr.field.TESTCSR_RFACC_REGNUM = regID;
-		RTMP_IO_WRITE32(pAd, RF_CSR_CFG, rfcsr.word);
-		for (k = 0; k < MAX_BUSY_COUNT; k++) {
-			RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
-
-			if (rfcsr.field.RF_CSR_KICK == IDLE)
-				break;
-		}
-		if ((rfcsr.field.RF_CSR_KICK == IDLE) &&
-		    (rfcsr.field.TESTCSR_RFACC_REGNUM == regID)) {
-			*pValue = (u8)rfcsr.field.RF_CSR_DATA;
-			break;
-		}
-	}
-	if (rfcsr.field.RF_CSR_KICK == BUSY) {
-		DBGPRINT_ERR("RF read R%d=0x%x fail, i[%d], k[%d]\n", regID, rfcsr.word, i, k);
-		return STATUS_UNSUCCESSFUL;
-	}
-
-	return STATUS_SUCCESS;
-}
-
-void NICInitRFRegisters(struct rt_rtmp_adapter *pAd)
-{
-	if (pAd->chipOps.AsicRfInit)
-		pAd->chipOps.AsicRfInit(pAd);
-}
-
-void RtmpChipOpsRFHook(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-
-	pChipOps->pRFRegTable = NULL;
-	pChipOps->AsicRfInit = NULL;
-	pChipOps->AsicRfTurnOn = NULL;
-	pChipOps->AsicRfTurnOff = NULL;
-	pChipOps->AsicReverseRfFromSleepMode = NULL;
-	pChipOps->AsicHaltAction = NULL;
-	/* We depends on RfICType and MACVersion to assign the corresponding operation callbacks. */
-
-#ifdef RT30xx
-	if (IS_RT30xx(pAd)) {
-		pChipOps->pRFRegTable = RT30xx_RFRegTable;
-		pChipOps->AsicHaltAction = RT30xxHaltAction;
-#ifdef RT3070
-		if ((IS_RT3070(pAd) || IS_RT3071(pAd))
-		    && (pAd->infType == RTMP_DEV_INF_USB)) {
-			pChipOps->AsicRfInit = NICInitRT3070RFRegisters;
-			if (IS_RT3071(pAd)) {
-				pChipOps->AsicRfTurnOff =
-				    RT30xxLoadRFSleepModeSetup;
-				pChipOps->AsicReverseRfFromSleepMode =
-				    RT30xxReverseRFSleepModeSetup;
-			}
-		}
-#endif /* RT3070 // */
-#ifdef RT3090
-		if (IS_RT3090(pAd) && (pAd->infType == RTMP_DEV_INF_PCI)) {
-			pChipOps->AsicRfTurnOff = RT30xxLoadRFSleepModeSetup;
-			pChipOps->AsicRfInit = NICInitRT3090RFRegisters;
-			pChipOps->AsicReverseRfFromSleepMode =
-			    RT30xxReverseRFSleepModeSetup;
-		}
-#endif /* RT3090 // */
-	}
-#endif /* RT30xx // */
-}
-
-#endif /* RTMP_RF_RW_SUPPORT // */
diff --git a/drivers/staging/rt2860/common/rtmp_init.c b/drivers/staging/rt2860/common/rtmp_init.c
deleted file mode 100644
index 5fa193e..0000000
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ /dev/null
@@ -1,3536 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_init.c
-
-	Abstract:
-	Miniport generic portion header file
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-#include "../rt_config.h"
-
-u8 BIT8[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
-char *CipherName[] =
-    { "none", "wep64", "wep128", "TKIP", "AES", "CKIP64", "CKIP128" };
-
-/* */
-/* BBP register initialization set */
-/* */
-struct rt_reg_pair BBPRegTable[] = {
-	{BBP_R65, 0x2C},	/* fix rssi issue */
-	{BBP_R66, 0x38},	/* Also set this default value to pAd->BbpTuning.R66CurrentValue at initial */
-	{BBP_R69, 0x12},
-	{BBP_R70, 0xa},		/* BBP_R70 will change to 0x8 in ApStartUp and LinkUp for rt2860C, otherwise value is 0xa */
-	{BBP_R73, 0x10},
-	{BBP_R81, 0x37},
-	{BBP_R82, 0x62},
-	{BBP_R83, 0x6A},
-	{BBP_R84, 0x99},	/* 0x19 is for rt2860E and after. This is for extension channel overlapping IOT. 0x99 is for rt2860D and before */
-	{BBP_R86, 0x00},	/* middle range issue, Rory @2008-01-28 */
-	{BBP_R91, 0x04},	/* middle range issue, Rory @2008-01-28 */
-	{BBP_R92, 0x00},	/* middle range issue, Rory @2008-01-28 */
-	{BBP_R103, 0x00},	/* near range high-power issue, requested from Gary @2008-0528 */
-	{BBP_R105, 0x05},	/* 0x05 is for rt2860E to turn on FEQ control. It is safe for rt2860D and before, because Bit 7:2 are reserved in rt2860D and before. */
-	{BBP_R106, 0x35},	/* for ShortGI throughput */
-};
-
-#define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(struct rt_reg_pair))
-
-/* */
-/* ASIC register initialization sets */
-/* */
-
-struct rt_rtmp_reg_pair MACRegTable[] = {
-#if defined(HW_BEACON_OFFSET) && (HW_BEACON_OFFSET == 0x200)
-	{BCN_OFFSET0, 0xf8f0e8e0},	/* 0x3800(e0), 0x3A00(e8), 0x3C00(f0), 0x3E00(f8), 512B for each beacon */
-	{BCN_OFFSET1, 0x6f77d0c8},	/* 0x3200(c8), 0x3400(d0), 0x1DC0(77), 0x1BC0(6f), 512B for each beacon */
-#elif defined(HW_BEACON_OFFSET) && (HW_BEACON_OFFSET == 0x100)
-	{BCN_OFFSET0, 0xece8e4e0},	/* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
-	{BCN_OFFSET1, 0xfcf8f4f0},	/* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
-#else
-#error You must re-calculate new value for BCN_OFFSET0 & BCN_OFFSET1 in MACRegTable[]!
-#endif /* HW_BEACON_OFFSET // */
-
-	{LEGACY_BASIC_RATE, 0x0000013f},	/*  Basic rate set bitmap */
-	{HT_BASIC_RATE, 0x00008003},	/* Basic HT rate set , 20M, MCS=3, MM. Format is the same as in TXWI. */
-	{MAC_SYS_CTRL, 0x00},	/* 0x1004, , default Disable RX */
-	{RX_FILTR_CFG, 0x17f97},	/*0x1400  , RX filter control, */
-	{BKOFF_SLOT_CFG, 0x209},	/* default set short slot time, CC_DELAY_TIME should be 2 */
-	/*{TX_SW_CFG0,          0x40a06}, // Gary,2006-08-23 */
-	{TX_SW_CFG0, 0x0},	/* Gary,2008-05-21 for CWC test */
-	{TX_SW_CFG1, 0x80606},	/* Gary,2006-08-23 */
-	{TX_LINK_CFG, 0x1020},	/* Gary,2006-08-23 */
-	/*{TX_TIMEOUT_CFG,      0x00182090},    // CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT */
-	{TX_TIMEOUT_CFG, 0x000a2090},	/* CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01 */
-	{MAX_LEN_CFG, MAX_AGGREGATION_SIZE | 0x00001000},	/* 0x3018, MAX frame length. Max PSDU = 16kbytes. */
-	{LED_CFG, 0x7f031e46},	/* Gary, 2006-08-23 */
-
-	{PBF_MAX_PCNT, 0x1F3FBF9F},	/*0x1F3f7f9f},          //Jan, 2006/04/20 */
-
-	{TX_RTY_CFG, 0x47d01f0f},	/* Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03 */
-
-	{AUTO_RSP_CFG, 0x00000013},	/* Initial Auto_Responder, because QA will turn off Auto-Responder */
-	{CCK_PROT_CFG, 0x05740003 /*0x01740003 */ },	/* Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled. */
-	{OFDM_PROT_CFG, 0x05740003 /*0x01740003 */ },	/* Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled. */
-#ifdef RTMP_MAC_USB
-	{PBF_CFG, 0xf40006},	/* Only enable Queue 2 */
-	{MM40_PROT_CFG, 0x3F44084},	/* Initial Auto_Responder, because QA will turn off Auto-Responder */
-	{WPDMA_GLO_CFG, 0x00000030},
-#endif /* RTMP_MAC_USB // */
-	{GF20_PROT_CFG, 0x01744004},	/* set 19:18 --> Short NAV for MIMO PS */
-	{GF40_PROT_CFG, 0x03F44084},
-	{MM20_PROT_CFG, 0x01744004},
-#ifdef RTMP_MAC_PCI
-	{MM40_PROT_CFG, 0x03F54084},
-#endif /* RTMP_MAC_PCI // */
-	{TXOP_CTRL_CFG, 0x0000583f, /*0x0000243f *//*0x000024bf */ },	/*Extension channel backoff. */
-	{TX_RTS_CFG, 0x00092b20},
-	{EXP_ACK_TIME, 0x002400ca},	/* default value */
-
-	{TXOP_HLDR_ET, 0x00000002},
-
-	/* Jerry comments 2008/01/16: we use SIFS = 10us in CCK defaultly, but it seems that 10us
-	   is too small for INTEL 2200bg card, so in MBSS mode, the delta time between beacon0
-	   and beacon1 is SIFS (10us), so if INTEL 2200bg card connects to BSS0, the ping
-	   will always lost. So we change the SIFS of CCK from 10us to 16us. */
-	{XIFS_TIME_CFG, 0x33a41010},
-	{PWR_PIN_CFG, 0x00000003},	/* patch for 2880-E */
-};
-
-struct rt_rtmp_reg_pair STAMACRegTable[] = {
-	{WMM_AIFSN_CFG, 0x00002273},
-	{WMM_CWMIN_CFG, 0x00002344},
-	{WMM_CWMAX_CFG, 0x000034aa},
-};
-
-#define	NUM_MAC_REG_PARMS		(sizeof(MACRegTable) / sizeof(struct rt_rtmp_reg_pair))
-#define	NUM_STA_MAC_REG_PARMS	(sizeof(STAMACRegTable) / sizeof(struct rt_rtmp_reg_pair))
-
-/*
-	========================================================================
-
-	Routine Description:
-		Allocate struct rt_rtmp_adapter data block and do some initialization
-
-	Arguments:
-		Adapter		Pointer to our adapter
-
-	Return Value:
-		NDIS_STATUS_SUCCESS
-		NDIS_STATUS_FAILURE
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int RTMPAllocAdapterBlock(void *handle,
-				  struct rt_rtmp_adapter * * ppAdapter)
-{
-	struct rt_rtmp_adapter *pAd;
-	int Status;
-	int index;
-	u8 *pBeaconBuf = NULL;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocAdapterBlock\n"));
-
-	*ppAdapter = NULL;
-
-	do {
-		/* Allocate struct rt_rtmp_adapter memory block */
-		pBeaconBuf = kmalloc(MAX_BEACON_SIZE, MEM_ALLOC_FLAG);
-		if (pBeaconBuf == NULL) {
-			Status = NDIS_STATUS_FAILURE;
-			DBGPRINT_ERR("Failed to allocate memory - BeaconBuf!\n");
-			break;
-		}
-		NdisZeroMemory(pBeaconBuf, MAX_BEACON_SIZE);
-
-		Status = AdapterBlockAllocateMemory(handle, (void **) & pAd);
-		if (Status != NDIS_STATUS_SUCCESS) {
-			DBGPRINT_ERR("Failed to allocate memory - ADAPTER\n");
-			break;
-		}
-		pAd->BeaconBuf = pBeaconBuf;
-		DBGPRINT(RT_DEBUG_OFF,
-			 ("=== pAd = %p, size = %d ===\n", pAd,
-			  (u32)sizeof(struct rt_rtmp_adapter)));
-
-		/* Init spin locks */
-		NdisAllocateSpinLock(&pAd->MgmtRingLock);
-#ifdef RTMP_MAC_PCI
-		NdisAllocateSpinLock(&pAd->RxRingLock);
-#ifdef RT3090
-		NdisAllocateSpinLock(&pAd->McuCmdLock);
-#endif /* RT3090 // */
-#endif /* RTMP_MAC_PCI // */
-
-		for (index = 0; index < NUM_OF_TX_RING; index++) {
-			NdisAllocateSpinLock(&pAd->TxSwQueueLock[index]);
-			NdisAllocateSpinLock(&pAd->DeQueueLock[index]);
-			pAd->DeQueueRunning[index] = FALSE;
-		}
-
-		NdisAllocateSpinLock(&pAd->irq_lock);
-
-	} while (FALSE);
-
-	if ((Status != NDIS_STATUS_SUCCESS) && (pBeaconBuf))
-		kfree(pBeaconBuf);
-
-	*ppAdapter = pAd;
-
-	DBGPRINT_S(Status, ("<-- RTMPAllocAdapterBlock, Status=%x\n", Status));
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Read initial Tx power per MCS and BW from EEPROM
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPReadTxPwrPerRate(struct rt_rtmp_adapter *pAd)
-{
-	unsigned long data, Adata, Gdata;
-	u16 i, value, value2;
-	int Apwrdelta, Gpwrdelta;
-	u8 t1, t2, t3, t4;
-	BOOLEAN bApwrdeltaMinus = TRUE, bGpwrdeltaMinus = TRUE;
-
-	/* */
-	/* Get power delta for 20MHz and 40MHz. */
-	/* */
-	DBGPRINT(RT_DEBUG_TRACE, ("Txpower per Rate\n"));
-	RT28xx_EEPROM_READ16(pAd, EEPROM_TXPOWER_DELTA, value2);
-	Apwrdelta = 0;
-	Gpwrdelta = 0;
-
-	if ((value2 & 0xff) != 0xff) {
-		if ((value2 & 0x80))
-			Gpwrdelta = (value2 & 0xf);
-
-		if ((value2 & 0x40))
-			bGpwrdeltaMinus = FALSE;
-		else
-			bGpwrdeltaMinus = TRUE;
-	}
-	if ((value2 & 0xff00) != 0xff00) {
-		if ((value2 & 0x8000))
-			Apwrdelta = ((value2 & 0xf00) >> 8);
-
-		if ((value2 & 0x4000))
-			bApwrdeltaMinus = FALSE;
-		else
-			bApwrdeltaMinus = TRUE;
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Gpwrdelta = %x, Apwrdelta = %x .\n", Gpwrdelta, Apwrdelta));
-
-	/* */
-	/* Get Txpower per MCS for 20MHz in 2.4G. */
-	/* */
-	for (i = 0; i < 5; i++) {
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i * 4,
-				     value);
-		data = value;
-		if (bApwrdeltaMinus == FALSE) {
-			t1 = (value & 0xf) + (Apwrdelta);
-			if (t1 > 0xf)
-				t1 = 0xf;
-			t2 = ((value & 0xf0) >> 4) + (Apwrdelta);
-			if (t2 > 0xf)
-				t2 = 0xf;
-			t3 = ((value & 0xf00) >> 8) + (Apwrdelta);
-			if (t3 > 0xf)
-				t3 = 0xf;
-			t4 = ((value & 0xf000) >> 12) + (Apwrdelta);
-			if (t4 > 0xf)
-				t4 = 0xf;
-		} else {
-			if ((value & 0xf) > Apwrdelta)
-				t1 = (value & 0xf) - (Apwrdelta);
-			else
-				t1 = 0;
-			if (((value & 0xf0) >> 4) > Apwrdelta)
-				t2 = ((value & 0xf0) >> 4) - (Apwrdelta);
-			else
-				t2 = 0;
-			if (((value & 0xf00) >> 8) > Apwrdelta)
-				t3 = ((value & 0xf00) >> 8) - (Apwrdelta);
-			else
-				t3 = 0;
-			if (((value & 0xf000) >> 12) > Apwrdelta)
-				t4 = ((value & 0xf000) >> 12) - (Apwrdelta);
-			else
-				t4 = 0;
-		}
-		Adata = t1 + (t2 << 4) + (t3 << 8) + (t4 << 12);
-		if (bGpwrdeltaMinus == FALSE) {
-			t1 = (value & 0xf) + (Gpwrdelta);
-			if (t1 > 0xf)
-				t1 = 0xf;
-			t2 = ((value & 0xf0) >> 4) + (Gpwrdelta);
-			if (t2 > 0xf)
-				t2 = 0xf;
-			t3 = ((value & 0xf00) >> 8) + (Gpwrdelta);
-			if (t3 > 0xf)
-				t3 = 0xf;
-			t4 = ((value & 0xf000) >> 12) + (Gpwrdelta);
-			if (t4 > 0xf)
-				t4 = 0xf;
-		} else {
-			if ((value & 0xf) > Gpwrdelta)
-				t1 = (value & 0xf) - (Gpwrdelta);
-			else
-				t1 = 0;
-			if (((value & 0xf0) >> 4) > Gpwrdelta)
-				t2 = ((value & 0xf0) >> 4) - (Gpwrdelta);
-			else
-				t2 = 0;
-			if (((value & 0xf00) >> 8) > Gpwrdelta)
-				t3 = ((value & 0xf00) >> 8) - (Gpwrdelta);
-			else
-				t3 = 0;
-			if (((value & 0xf000) >> 12) > Gpwrdelta)
-				t4 = ((value & 0xf000) >> 12) - (Gpwrdelta);
-			else
-				t4 = 0;
-		}
-		Gdata = t1 + (t2 << 4) + (t3 << 8) + (t4 << 12);
-
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i * 4 +
-				     2, value);
-		if (bApwrdeltaMinus == FALSE) {
-			t1 = (value & 0xf) + (Apwrdelta);
-			if (t1 > 0xf)
-				t1 = 0xf;
-			t2 = ((value & 0xf0) >> 4) + (Apwrdelta);
-			if (t2 > 0xf)
-				t2 = 0xf;
-			t3 = ((value & 0xf00) >> 8) + (Apwrdelta);
-			if (t3 > 0xf)
-				t3 = 0xf;
-			t4 = ((value & 0xf000) >> 12) + (Apwrdelta);
-			if (t4 > 0xf)
-				t4 = 0xf;
-		} else {
-			if ((value & 0xf) > Apwrdelta)
-				t1 = (value & 0xf) - (Apwrdelta);
-			else
-				t1 = 0;
-			if (((value & 0xf0) >> 4) > Apwrdelta)
-				t2 = ((value & 0xf0) >> 4) - (Apwrdelta);
-			else
-				t2 = 0;
-			if (((value & 0xf00) >> 8) > Apwrdelta)
-				t3 = ((value & 0xf00) >> 8) - (Apwrdelta);
-			else
-				t3 = 0;
-			if (((value & 0xf000) >> 12) > Apwrdelta)
-				t4 = ((value & 0xf000) >> 12) - (Apwrdelta);
-			else
-				t4 = 0;
-		}
-		Adata |= ((t1 << 16) + (t2 << 20) + (t3 << 24) + (t4 << 28));
-		if (bGpwrdeltaMinus == FALSE) {
-			t1 = (value & 0xf) + (Gpwrdelta);
-			if (t1 > 0xf)
-				t1 = 0xf;
-			t2 = ((value & 0xf0) >> 4) + (Gpwrdelta);
-			if (t2 > 0xf)
-				t2 = 0xf;
-			t3 = ((value & 0xf00) >> 8) + (Gpwrdelta);
-			if (t3 > 0xf)
-				t3 = 0xf;
-			t4 = ((value & 0xf000) >> 12) + (Gpwrdelta);
-			if (t4 > 0xf)
-				t4 = 0xf;
-		} else {
-			if ((value & 0xf) > Gpwrdelta)
-				t1 = (value & 0xf) - (Gpwrdelta);
-			else
-				t1 = 0;
-			if (((value & 0xf0) >> 4) > Gpwrdelta)
-				t2 = ((value & 0xf0) >> 4) - (Gpwrdelta);
-			else
-				t2 = 0;
-			if (((value & 0xf00) >> 8) > Gpwrdelta)
-				t3 = ((value & 0xf00) >> 8) - (Gpwrdelta);
-			else
-				t3 = 0;
-			if (((value & 0xf000) >> 12) > Gpwrdelta)
-				t4 = ((value & 0xf000) >> 12) - (Gpwrdelta);
-			else
-				t4 = 0;
-		}
-		Gdata |= ((t1 << 16) + (t2 << 20) + (t3 << 24) + (t4 << 28));
-		data |= (value << 16);
-
-		/* For 20M/40M Power Delta issue */
-		pAd->Tx20MPwrCfgABand[i] = data;
-		pAd->Tx20MPwrCfgGBand[i] = data;
-		pAd->Tx40MPwrCfgABand[i] = Adata;
-		pAd->Tx40MPwrCfgGBand[i] = Gdata;
-
-		if (data != 0xffffffff)
-			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i * 4, data);
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			     ("20MHz BW, 2.4G band-%lx,  Adata = %lx,  Gdata = %lx \n",
-			      data, Adata, Gdata));
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Read initial channel power parameters from EEPROM
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPReadChannelPwr(struct rt_rtmp_adapter *pAd)
-{
-	u8 i, choffset;
-	EEPROM_TX_PWR_STRUC Power;
-	EEPROM_TX_PWR_STRUC Power2;
-
-	/* Read Tx power value for all channels */
-	/* Value from 1 - 0x7f. Default value is 24. */
-	/* Power value : 2.4G 0x00 (0) ~ 0x1F (31) */
-	/*             : 5.5G 0xF9 (-7) ~ 0x0F (15) */
-
-	/* 0. 11b/g, ch1 - ch 14 */
-	for (i = 0; i < 7; i++) {
-		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2,
-				     Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2,
-				     Power2.word);
-		pAd->TxPower[i * 2].Channel = i * 2 + 1;
-		pAd->TxPower[i * 2 + 1].Channel = i * 2 + 2;
-
-		if ((Power.field.Byte0 > 31) || (Power.field.Byte0 < 0))
-			pAd->TxPower[i * 2].Power = DEFAULT_RF_TX_POWER;
-		else
-			pAd->TxPower[i * 2].Power = Power.field.Byte0;
-
-		if ((Power.field.Byte1 > 31) || (Power.field.Byte1 < 0))
-			pAd->TxPower[i * 2 + 1].Power = DEFAULT_RF_TX_POWER;
-		else
-			pAd->TxPower[i * 2 + 1].Power = Power.field.Byte1;
-
-		if ((Power2.field.Byte0 > 31) || (Power2.field.Byte0 < 0))
-			pAd->TxPower[i * 2].Power2 = DEFAULT_RF_TX_POWER;
-		else
-			pAd->TxPower[i * 2].Power2 = Power2.field.Byte0;
-
-		if ((Power2.field.Byte1 > 31) || (Power2.field.Byte1 < 0))
-			pAd->TxPower[i * 2 + 1].Power2 = DEFAULT_RF_TX_POWER;
-		else
-			pAd->TxPower[i * 2 + 1].Power2 = Power2.field.Byte1;
-	}
-
-	/* 1. U-NII lower/middle band: 36, 38, 40; 44, 46, 48; 52, 54, 56; 60, 62, 64 (including central frequency in BW 40MHz) */
-	/* 1.1 Fill up channel */
-	choffset = 14;
-	for (i = 0; i < 4; i++) {
-		pAd->TxPower[3 * i + choffset + 0].Channel = 36 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel = 36 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel = 36 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
-	}
-
-	/* 1.2 Fill up power */
-	for (i = 0; i < 6; i++) {
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2,
-				     Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2,
-				     Power2.word);
-
-		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power =
-			    Power.field.Byte0;
-
-		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power =
-			    Power.field.Byte1;
-
-		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 =
-			    Power2.field.Byte0;
-
-		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 =
-			    Power2.field.Byte1;
-	}
-
-	/* 2. HipperLAN 2 100, 102 ,104; 108, 110, 112; 116, 118, 120; 124, 126, 128; 132, 134, 136; 140 (including central frequency in BW 40MHz) */
-	/* 2.1 Fill up channel */
-	choffset = 14 + 12;
-	for (i = 0; i < 5; i++) {
-		pAd->TxPower[3 * i + choffset + 0].Channel = 100 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel = 100 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel = 100 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
-	}
-	pAd->TxPower[3 * 5 + choffset + 0].Channel = 140;
-	pAd->TxPower[3 * 5 + choffset + 0].Power = DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 5 + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
-
-	/* 2.2 Fill up power */
-	for (i = 0; i < 8; i++) {
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_A_TX_PWR_OFFSET + (choffset - 14) +
-				     i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) +
-				     i * 2, Power2.word);
-
-		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power =
-			    Power.field.Byte0;
-
-		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power =
-			    Power.field.Byte1;
-
-		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 =
-			    Power2.field.Byte0;
-
-		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 =
-			    Power2.field.Byte1;
-	}
-
-	/* 3. U-NII upper band: 149, 151, 153; 157, 159, 161; 165, 167, 169; 171, 173 (including central frequency in BW 40MHz) */
-	/* 3.1 Fill up channel */
-	choffset = 14 + 12 + 16;
-	/*for (i = 0; i < 2; i++) */
-	for (i = 0; i < 3; i++) {
-		pAd->TxPower[3 * i + choffset + 0].Channel = 149 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel = 149 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel = 149 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
-	}
-	pAd->TxPower[3 * 3 + choffset + 0].Channel = 171;
-	pAd->TxPower[3 * 3 + choffset + 0].Power = DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 3 + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
-
-	pAd->TxPower[3 * 3 + choffset + 1].Channel = 173;
-	pAd->TxPower[3 * 3 + choffset + 1].Power = DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 3 + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
-
-	/* 3.2 Fill up power */
-	/*for (i = 0; i < 4; i++) */
-	for (i = 0; i < 6; i++) {
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_A_TX_PWR_OFFSET + (choffset - 14) +
-				     i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd,
-				     EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) +
-				     i * 2, Power2.word);
-
-		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power =
-			    Power.field.Byte0;
-
-		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power =
-			    Power.field.Byte1;
-
-		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 =
-			    Power2.field.Byte0;
-
-		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 =
-			    Power2.field.Byte1;
-	}
-
-	/* 4. Print and Debug */
-	/*choffset = 14 + 12 + 16 + 7; */
-	choffset = 14 + 12 + 16 + 11;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Read the following from the registry
-		1. All the parameters
-		2. NetworkAddres
-
-	Arguments:
-		Adapter						Pointer to our adapter
-		WrapperConfigurationContext	For use by NdisOpenConfiguration
-
-	Return Value:
-		NDIS_STATUS_SUCCESS
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_RESOURCES
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int NICReadRegParameters(struct rt_rtmp_adapter *pAd,
-				 void *WrapperConfigurationContext)
-{
-	int Status = NDIS_STATUS_SUCCESS;
-	DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Read initial parameters from EEPROM
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void NICReadEEPROMParameters(struct rt_rtmp_adapter *pAd, u8 *mac_addr)
-{
-	u32 data = 0;
-	u16 i, value, value2;
-	u8 TmpPhy;
-	EEPROM_TX_PWR_STRUC Power;
-	EEPROM_VERSION_STRUC Version;
-	EEPROM_ANTENNA_STRUC Antenna;
-	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICReadEEPROMParameters\n"));
-
-	if (pAd->chipOps.eeinit)
-		pAd->chipOps.eeinit(pAd);
-
-	/* Init EEPROM Address Number, before access EEPROM; if 93c46, EEPROMAddressNum=6, else if 93c66, EEPROMAddressNum=8 */
-	RTMP_IO_READ32(pAd, E2PROM_CSR, &data);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> E2PROM_CSR = 0x%x\n", data));
-
-	if ((data & 0x30) == 0)
-		pAd->EEPROMAddressNum = 6;	/* 93C46 */
-	else if ((data & 0x30) == 0x10)
-		pAd->EEPROMAddressNum = 8;	/* 93C66 */
-	else
-		pAd->EEPROMAddressNum = 8;	/* 93C86 */
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("--> EEPROMAddressNum = %d\n", pAd->EEPROMAddressNum));
-
-	/* RT2860 MAC no longer auto load MAC address from E2PROM. Driver has to initialize */
-	/* MAC address registers according to E2PROM setting */
-	if (mac_addr == NULL ||
-	    strlen((char *)mac_addr) != 17 ||
-	    mac_addr[2] != ':' || mac_addr[5] != ':' || mac_addr[8] != ':' ||
-	    mac_addr[11] != ':' || mac_addr[14] != ':') {
-		u16 Addr01, Addr23, Addr45;
-
-		RT28xx_EEPROM_READ16(pAd, 0x04, Addr01);
-		RT28xx_EEPROM_READ16(pAd, 0x06, Addr23);
-		RT28xx_EEPROM_READ16(pAd, 0x08, Addr45);
-
-		pAd->PermanentAddress[0] = (u8)(Addr01 & 0xff);
-		pAd->PermanentAddress[1] = (u8)(Addr01 >> 8);
-		pAd->PermanentAddress[2] = (u8)(Addr23 & 0xff);
-		pAd->PermanentAddress[3] = (u8)(Addr23 >> 8);
-		pAd->PermanentAddress[4] = (u8)(Addr45 & 0xff);
-		pAd->PermanentAddress[5] = (u8)(Addr45 >> 8);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Initialize MAC Address from E2PROM \n"));
-	} else {
-		int j;
-		char *macptr;
-
-		macptr = (char *)mac_addr;
-
-		for (j = 0; j < MAC_ADDR_LEN; j++) {
-			AtoH(macptr, &pAd->PermanentAddress[j], 1);
-			macptr = macptr + 3;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Initialize MAC Address from module parameter \n"));
-	}
-
-	{
-		/*more conveninet to test mbssid, so ap's bssid &0xf1 */
-		if (pAd->PermanentAddress[0] == 0xff)
-			pAd->PermanentAddress[0] = RandomByte(pAd) & 0xf8;
-
-		/*if (pAd->PermanentAddress[5] == 0xff) */
-		/*      pAd->PermanentAddress[5] = RandomByte(pAd)&0xf8; */
-
-		DBGPRINT_RAW(RT_DEBUG_TRACE,
-			("E2PROM MAC: =%pM\n", pAd->PermanentAddress));
-		if (pAd->bLocalAdminMAC == FALSE) {
-			MAC_DW0_STRUC csr2;
-			MAC_DW1_STRUC csr3;
-			COPY_MAC_ADDR(pAd->CurrentAddress,
-				      pAd->PermanentAddress);
-			csr2.field.Byte0 = pAd->CurrentAddress[0];
-			csr2.field.Byte1 = pAd->CurrentAddress[1];
-			csr2.field.Byte2 = pAd->CurrentAddress[2];
-			csr2.field.Byte3 = pAd->CurrentAddress[3];
-			RTMP_IO_WRITE32(pAd, MAC_ADDR_DW0, csr2.word);
-			csr3.word = 0;
-			csr3.field.Byte4 = pAd->CurrentAddress[4];
-			csr3.field.Byte5 = pAd->CurrentAddress[5];
-			csr3.field.U2MeMask = 0xff;
-			RTMP_IO_WRITE32(pAd, MAC_ADDR_DW1, csr3.word);
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				("E2PROM MAC: =%pM\n",
-					pAd->PermanentAddress));
-		}
-	}
-
-	/* if not return early. cause fail at emulation. */
-	/* Init the channel number for TX channel power */
-	RTMPReadChannelPwr(pAd);
-
-	/* if E2PROM version mismatch with driver's expectation, then skip */
-	/* all subsequent E2RPOM retieval and set a system error bit to notify GUI */
-	RT28xx_EEPROM_READ16(pAd, EEPROM_VERSION_OFFSET, Version.word);
-	pAd->EepromVersion =
-	    Version.field.Version + Version.field.FaeReleaseNumber * 256;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("E2PROM: Version = %d, FAE release #%d\n",
-		  Version.field.Version, Version.field.FaeReleaseNumber));
-
-	if (Version.field.Version > VALID_EEPROM_VERSION) {
-		DBGPRINT_ERR("E2PROM: WRONG VERSION 0x%x, should be %d\n", Version.field.Version, VALID_EEPROM_VERSION);
-		/*pAd->SystemErrorBitmap |= 0x00000001;
-
-		   // hard-code default value when no proper E2PROM installed
-		   pAd->bAutoTxAgcA = FALSE;
-		   pAd->bAutoTxAgcG = FALSE;
-
-		   // Default the channel power
-		   for (i = 0; i < MAX_NUM_OF_CHANNELS; i++)
-		   pAd->TxPower[i].Power = DEFAULT_RF_TX_POWER;
-
-		   // Default the channel power
-		   for (i = 0; i < MAX_NUM_OF_11JCHANNELS; i++)
-		   pAd->TxPower11J[i].Power = DEFAULT_RF_TX_POWER;
-
-		   for(i = 0; i < NUM_EEPROM_BBP_PARMS; i++)
-		   pAd->EEPROMDefaultValue[i] = 0xffff;
-		   return;  */
-	}
-	/* Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd */
-	RT28xx_EEPROM_READ16(pAd, EEPROM_NIC1_OFFSET, value);
-	pAd->EEPROMDefaultValue[0] = value;
-
-	RT28xx_EEPROM_READ16(pAd, EEPROM_NIC2_OFFSET, value);
-	pAd->EEPROMDefaultValue[1] = value;
-
-	RT28xx_EEPROM_READ16(pAd, 0x38, value);	/* Country Region */
-	pAd->EEPROMDefaultValue[2] = value;
-
-	for (i = 0; i < 8; i++) {
-		RT28xx_EEPROM_READ16(pAd, EEPROM_BBP_BASE_OFFSET + i * 2,
-				     value);
-		pAd->EEPROMDefaultValue[i + 3] = value;
-	}
-
-	/* We have to parse NIC configuration 0 at here. */
-	/* If TSSI did not have preloaded value, it should reset the TxAutoAgc to false */
-	/* Therefore, we have to read TxAutoAgc control beforehand. */
-	/* Read Tx AGC control bit */
-	Antenna.word = pAd->EEPROMDefaultValue[0];
-	if (Antenna.word == 0xFFFF) {
-#ifdef RT30xx
-		if (IS_RT3090(pAd) || IS_RT3390(pAd)) {
-			Antenna.word = 0;
-			Antenna.field.RfIcType = RFIC_3020;
-			Antenna.field.TxPath = 1;
-			Antenna.field.RxPath = 1;
-		} else
-#endif /* RT30xx // */
-		{
-
-			Antenna.word = 0;
-			Antenna.field.RfIcType = RFIC_2820;
-			Antenna.field.TxPath = 1;
-			Antenna.field.RxPath = 2;
-			DBGPRINT(RT_DEBUG_WARN,
-				 ("E2PROM error, hard code as 0x%04x\n",
-				  Antenna.word));
-		}
-	}
-	/* Choose the desired Tx&Rx stream. */
-	if ((pAd->CommonCfg.TxStream == 0)
-	    || (pAd->CommonCfg.TxStream > Antenna.field.TxPath))
-		pAd->CommonCfg.TxStream = Antenna.field.TxPath;
-
-	if ((pAd->CommonCfg.RxStream == 0)
-	    || (pAd->CommonCfg.RxStream > Antenna.field.RxPath)) {
-		pAd->CommonCfg.RxStream = Antenna.field.RxPath;
-
-		if ((pAd->MACVersion < RALINK_2883_VERSION) &&
-		    (pAd->CommonCfg.RxStream > 2)) {
-			/* only 2 Rx streams for RT2860 series */
-			pAd->CommonCfg.RxStream = 2;
-		}
-	}
-	/* 3*3 */
-	/* read value from EEPROM and set them to CSR174 ~ 177 in chain0 ~ chain2 */
-	/* yet implement */
-	for (i = 0; i < 3; i++) {
-	}
-
-	NicConfig2.word = pAd->EEPROMDefaultValue[1];
-
-	{
-		if ((NicConfig2.word & 0x00ff) == 0xff) {
-			NicConfig2.word &= 0xff00;
-		}
-
-		if ((NicConfig2.word >> 8) == 0xff) {
-			NicConfig2.word &= 0x00ff;
-		}
-	}
-
-	if (NicConfig2.field.DynamicTxAgcControl == 1)
-		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
-	else
-		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
-
-	DBGPRINT_RAW(RT_DEBUG_TRACE,
-		     ("NICReadEEPROMParameters: RxPath = %d, TxPath = %d\n",
-		      Antenna.field.RxPath, Antenna.field.TxPath));
-
-	/* Save the antenna for future use */
-	pAd->Antenna.word = Antenna.word;
-
-	/* Set the RfICType here, then we can initialize RFIC related operation callbacks */
-	pAd->Mlme.RealRxPath = (u8)Antenna.field.RxPath;
-	pAd->RfIcType = (u8)Antenna.field.RfIcType;
-
-#ifdef RTMP_RF_RW_SUPPORT
-	RtmpChipOpsRFHook(pAd);
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-#ifdef RTMP_MAC_PCI
-	sprintf((char *)pAd->nickname, "RT2860STA");
-#endif /* RTMP_MAC_PCI // */
-
-	/* */
-	/* Reset PhyMode if we don't support 802.11a */
-	/* Only RFIC_2850 & RFIC_2750 support 802.11a */
-	/* */
-	if ((Antenna.field.RfIcType != RFIC_2850)
-	    && (Antenna.field.RfIcType != RFIC_2750)
-	    && (Antenna.field.RfIcType != RFIC_3052)) {
-		if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED) ||
-		    (pAd->CommonCfg.PhyMode == PHY_11A))
-			pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;
-		else if ((pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) ||
-			 (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED) ||
-			 (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) ||
-			 (pAd->CommonCfg.PhyMode == PHY_11N_5G))
-			pAd->CommonCfg.PhyMode = PHY_11BGN_MIXED;
-	}
-	/* Read TSSI reference and TSSI boundary for temperature compensation. This is ugly */
-	/* 0. 11b/g */
-	{
-		/* these are tempature reference value (0x00 ~ 0xFE)
-		   ex: 0x00 0x15 0x25 0x45 0x88 0xA0 0xB5 0xD0 0xF0
-		   TssiPlusBoundaryG [4] [3] [2] [1] [0] (smaller) +
-		   TssiMinusBoundaryG[0] [1] [2] [3] [4] (larger) */
-		RT28xx_EEPROM_READ16(pAd, 0x6E, Power.word);
-		pAd->TssiMinusBoundaryG[4] = Power.field.Byte0;
-		pAd->TssiMinusBoundaryG[3] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0x70, Power.word);
-		pAd->TssiMinusBoundaryG[2] = Power.field.Byte0;
-		pAd->TssiMinusBoundaryG[1] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0x72, Power.word);
-		pAd->TssiRefG = Power.field.Byte0;	/* reference value [0] */
-		pAd->TssiPlusBoundaryG[1] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0x74, Power.word);
-		pAd->TssiPlusBoundaryG[2] = Power.field.Byte0;
-		pAd->TssiPlusBoundaryG[3] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0x76, Power.word);
-		pAd->TssiPlusBoundaryG[4] = Power.field.Byte0;
-		pAd->TxAgcStepG = Power.field.Byte1;
-		pAd->TxAgcCompensateG = 0;
-		pAd->TssiMinusBoundaryG[0] = pAd->TssiRefG;
-		pAd->TssiPlusBoundaryG[0] = pAd->TssiRefG;
-
-		/* Disable TxAgc if the based value is not right */
-		if (pAd->TssiRefG == 0xff)
-			pAd->bAutoTxAgcG = FALSE;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("E2PROM: G Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
-			  pAd->TssiMinusBoundaryG[4],
-			  pAd->TssiMinusBoundaryG[3],
-			  pAd->TssiMinusBoundaryG[2],
-			  pAd->TssiMinusBoundaryG[1], pAd->TssiRefG,
-			  pAd->TssiPlusBoundaryG[1], pAd->TssiPlusBoundaryG[2],
-			  pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
-			  pAd->TxAgcStepG, pAd->bAutoTxAgcG));
-	}
-	/* 1. 11a */
-	{
-		RT28xx_EEPROM_READ16(pAd, 0xD4, Power.word);
-		pAd->TssiMinusBoundaryA[4] = Power.field.Byte0;
-		pAd->TssiMinusBoundaryA[3] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0xD6, Power.word);
-		pAd->TssiMinusBoundaryA[2] = Power.field.Byte0;
-		pAd->TssiMinusBoundaryA[1] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0xD8, Power.word);
-		pAd->TssiRefA = Power.field.Byte0;
-		pAd->TssiPlusBoundaryA[1] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0xDA, Power.word);
-		pAd->TssiPlusBoundaryA[2] = Power.field.Byte0;
-		pAd->TssiPlusBoundaryA[3] = Power.field.Byte1;
-		RT28xx_EEPROM_READ16(pAd, 0xDC, Power.word);
-		pAd->TssiPlusBoundaryA[4] = Power.field.Byte0;
-		pAd->TxAgcStepA = Power.field.Byte1;
-		pAd->TxAgcCompensateA = 0;
-		pAd->TssiMinusBoundaryA[0] = pAd->TssiRefA;
-		pAd->TssiPlusBoundaryA[0] = pAd->TssiRefA;
-
-		/* Disable TxAgc if the based value is not right */
-		if (pAd->TssiRefA == 0xff)
-			pAd->bAutoTxAgcA = FALSE;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("E2PROM: A Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
-			  pAd->TssiMinusBoundaryA[4],
-			  pAd->TssiMinusBoundaryA[3],
-			  pAd->TssiMinusBoundaryA[2],
-			  pAd->TssiMinusBoundaryA[1], pAd->TssiRefA,
-			  pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2],
-			  pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
-			  pAd->TxAgcStepA, pAd->bAutoTxAgcA));
-	}
-	pAd->BbpRssiToDbmDelta = 0x0;
-
-	/* Read frequency offset setting for RF */
-	RT28xx_EEPROM_READ16(pAd, EEPROM_FREQ_OFFSET, value);
-	if ((value & 0x00FF) != 0x00FF)
-		pAd->RfFreqOffset = (unsigned long)(value & 0x00FF);
-	else
-		pAd->RfFreqOffset = 0;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("E2PROM: RF FreqOffset=0x%lx \n", pAd->RfFreqOffset));
-
-	/*CountryRegion byte offset (38h) */
-	value = pAd->EEPROMDefaultValue[2] >> 8;	/* 2.4G band */
-	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;	/* 5G band */
-
-	if ((value <= REGION_MAXIMUM_BG_BAND)
-	    && (value2 <= REGION_MAXIMUM_A_BAND)) {
-		pAd->CommonCfg.CountryRegion = ((u8)value) | 0x80;
-		pAd->CommonCfg.CountryRegionForABand = ((u8)value2) | 0x80;
-		TmpPhy = pAd->CommonCfg.PhyMode;
-		pAd->CommonCfg.PhyMode = 0xff;
-		RTMPSetPhyMode(pAd, TmpPhy);
-		SetCommonHT(pAd);
-	}
-	/* */
-	/* Get RSSI Offset on EEPROM 0x9Ah & 0x9Ch. */
-	/* The valid value are (-10 ~ 10) */
-	/* */
-	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET, value);
-	pAd->BGRssiOffset0 = value & 0x00ff;
-	pAd->BGRssiOffset1 = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET + 2, value);
-	pAd->BGRssiOffset2 = value & 0x00ff;
-	pAd->ALNAGain1 = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, EEPROM_LNA_OFFSET, value);
-	pAd->BLNAGain = value & 0x00ff;
-	pAd->ALNAGain0 = (value >> 8);
-
-	/* Validate 11b/g RSSI_0 offset. */
-	if ((pAd->BGRssiOffset0 < -10) || (pAd->BGRssiOffset0 > 10))
-		pAd->BGRssiOffset0 = 0;
-
-	/* Validate 11b/g RSSI_1 offset. */
-	if ((pAd->BGRssiOffset1 < -10) || (pAd->BGRssiOffset1 > 10))
-		pAd->BGRssiOffset1 = 0;
-
-	/* Validate 11b/g RSSI_2 offset. */
-	if ((pAd->BGRssiOffset2 < -10) || (pAd->BGRssiOffset2 > 10))
-		pAd->BGRssiOffset2 = 0;
-
-	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_A_OFFSET, value);
-	pAd->ARssiOffset0 = value & 0x00ff;
-	pAd->ARssiOffset1 = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, (EEPROM_RSSI_A_OFFSET + 2), value);
-	pAd->ARssiOffset2 = value & 0x00ff;
-	pAd->ALNAGain2 = (value >> 8);
-
-	if (((u8)pAd->ALNAGain1 == 0xFF) || (pAd->ALNAGain1 == 0x00))
-		pAd->ALNAGain1 = pAd->ALNAGain0;
-	if (((u8)pAd->ALNAGain2 == 0xFF) || (pAd->ALNAGain2 == 0x00))
-		pAd->ALNAGain2 = pAd->ALNAGain0;
-
-	/* Validate 11a RSSI_0 offset. */
-	if ((pAd->ARssiOffset0 < -10) || (pAd->ARssiOffset0 > 10))
-		pAd->ARssiOffset0 = 0;
-
-	/* Validate 11a RSSI_1 offset. */
-	if ((pAd->ARssiOffset1 < -10) || (pAd->ARssiOffset1 > 10))
-		pAd->ARssiOffset1 = 0;
-
-	/*Validate 11a RSSI_2 offset. */
-	if ((pAd->ARssiOffset2 < -10) || (pAd->ARssiOffset2 > 10))
-		pAd->ARssiOffset2 = 0;
-
-#ifdef RT30xx
-	/* */
-	/* Get TX mixer gain setting */
-	/* 0xff are invalid value */
-	/* Note: RT30xX default value is 0x00 and will program to RF_R17 only when this value is not zero. */
-	/*       RT359X default value is 0x02 */
-	/* */
-	if (IS_RT30xx(pAd) || IS_RT3572(pAd)) {
-		RT28xx_EEPROM_READ16(pAd, EEPROM_TXMIXER_GAIN_2_4G, value);
-		pAd->TxMixerGain24G = 0;
-		value &= 0x00ff;
-		if (value != 0xff) {
-			value &= 0x07;
-			pAd->TxMixerGain24G = (u8)value;
-		}
-	}
-#endif /* RT30xx // */
-
-	/* */
-	/* Get LED Setting. */
-	/* */
-	RT28xx_EEPROM_READ16(pAd, 0x3a, value);
-	pAd->LedCntl.word = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, EEPROM_LED1_OFFSET, value);
-	pAd->Led1 = value;
-	RT28xx_EEPROM_READ16(pAd, EEPROM_LED2_OFFSET, value);
-	pAd->Led2 = value;
-	RT28xx_EEPROM_READ16(pAd, EEPROM_LED3_OFFSET, value);
-	pAd->Led3 = value;
-
-	RTMPReadTxPwrPerRate(pAd);
-
-#ifdef RT30xx
-#ifdef RTMP_EFUSE_SUPPORT
-	RtmpEfuseSupportCheck(pAd);
-#endif /* RTMP_EFUSE_SUPPORT // */
-#endif /* RT30xx // */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICReadEEPROMParameters\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Set default value from EEPROM
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void NICInitAsicFromEEPROM(struct rt_rtmp_adapter *pAd)
-{
-	u32 data = 0;
-	u8 BBPR1 = 0;
-	u16 i;
-/*      EEPROM_ANTENNA_STRUC    Antenna; */
-	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
-	u8 BBPR3 = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitAsicFromEEPROM\n"));
-	for (i = 3; i < NUM_EEPROM_BBP_PARMS; i++) {
-		u8 BbpRegIdx, BbpValue;
-
-		if ((pAd->EEPROMDefaultValue[i] != 0xFFFF)
-		    && (pAd->EEPROMDefaultValue[i] != 0)) {
-			BbpRegIdx = (u8)(pAd->EEPROMDefaultValue[i] >> 8);
-			BbpValue = (u8)(pAd->EEPROMDefaultValue[i] & 0xff);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BbpRegIdx, BbpValue);
-		}
-	}
-
-	NicConfig2.word = pAd->EEPROMDefaultValue[1];
-
-	{
-		if ((NicConfig2.word & 0x00ff) == 0xff) {
-			NicConfig2.word &= 0xff00;
-		}
-
-		if ((NicConfig2.word >> 8) == 0xff) {
-			NicConfig2.word &= 0x00ff;
-		}
-	}
-
-	/* Save the antenna for future use */
-	pAd->NicConfig2.word = NicConfig2.word;
-
-#ifdef RT30xx
-	/* set default antenna as main */
-	if (pAd->RfIcType == RFIC_3020)
-		AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt);
-#endif /* RT30xx // */
-
-	/* */
-	/* Send LED Setting to MCU. */
-	/* */
-	if (pAd->LedCntl.word == 0xFF) {
-		pAd->LedCntl.word = 0x01;
-		pAd->Led1 = 0x5555;
-		pAd->Led2 = 0x2221;
-
-#ifdef RTMP_MAC_PCI
-		pAd->Led3 = 0xA9F8;
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		pAd->Led3 = 0x5627;
-#endif /* RTMP_MAC_USB // */
-	}
-
-	AsicSendCommandToMcu(pAd, 0x52, 0xff, (u8)pAd->Led1,
-			     (u8)(pAd->Led1 >> 8));
-	AsicSendCommandToMcu(pAd, 0x53, 0xff, (u8)pAd->Led2,
-			     (u8)(pAd->Led2 >> 8));
-	AsicSendCommandToMcu(pAd, 0x54, 0xff, (u8)pAd->Led3,
-			     (u8)(pAd->Led3 >> 8));
-	AsicSendCommandToMcu(pAd, 0x51, 0xff, 0, pAd->LedCntl.field.Polarity);
-
-	pAd->LedIndicatorStrength = 0xFF;
-	RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, before link up */
-
-	{
-		/* Read Hardware controlled Radio state enable bit */
-		if (NicConfig2.field.HardwareRadioControl == 1) {
-			pAd->StaCfg.bHardwareRadio = TRUE;
-
-			/* Read GPIO pin2 as Hardware controlled radio state */
-			RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &data);
-			if ((data & 0x04) == 0) {
-				pAd->StaCfg.bHwRadio = FALSE;
-				pAd->StaCfg.bRadio = FALSE;
-/*                              RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818); */
-				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-			}
-		} else
-			pAd->StaCfg.bHardwareRadio = FALSE;
-
-		if (pAd->StaCfg.bRadio == FALSE) {
-			RTMPSetLED(pAd, LED_RADIO_OFF);
-		} else {
-			RTMPSetLED(pAd, LED_RADIO_ON);
-#ifdef RTMP_MAC_PCI
-#ifdef RT3090
-			AsicSendCommandToMcu(pAd, 0x30, PowerRadioOffCID, 0xff,
-					     0x02);
-			AsicCheckCommanOk(pAd, PowerRadioOffCID);
-#endif /* RT3090 // */
-#ifndef RT3090
-			AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
-#endif /* RT3090 // */
-			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00,
-					     0x00);
-			/* 2-1. wait command ok. */
-			AsicCheckCommanOk(pAd, PowerWakeCID);
-#endif /* RTMP_MAC_PCI // */
-		}
-	}
-
-#ifdef RTMP_MAC_PCI
-#ifdef RT30xx
-	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
-		struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-		if (pChipOps->AsicReverseRfFromSleepMode)
-			pChipOps->AsicReverseRfFromSleepMode(pAd);
-	}
-	/* 3090 MCU Wakeup command needs more time to be stable. */
-	/* Before stable, don't issue other MCU command to prevent from firmware error. */
-
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	    && IS_VERSION_AFTER_F(pAd)
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("%s, release Mcu Lock\n", __func__));
-		RTMP_SEM_LOCK(&pAd->McuCmdLock);
-		pAd->brt30xxBanMcuCmd = FALSE;
-		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-	}
-#endif /* RT30xx // */
-#endif /* RTMP_MAC_PCI // */
-
-	/* Turn off patching for cardbus controller */
-	if (NicConfig2.field.CardbusAcceleration == 1) {
-/*              pAd->bTest1 = TRUE; */
-	}
-
-	if (NicConfig2.field.DynamicTxAgcControl == 1)
-		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
-	else
-		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
-	/* */
-	/* Since BBP has been progamed, to make sure BBP setting will be */
-	/* upate inside of AsicAntennaSelect, so reset to UNKNOWN_BAND! */
-	/* */
-	pAd->CommonCfg.BandState = UNKNOWN_BAND;
-
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
-	BBPR3 &= (~0x18);
-	if (pAd->Antenna.field.RxPath == 3) {
-		BBPR3 |= (0x10);
-	} else if (pAd->Antenna.field.RxPath == 2) {
-		BBPR3 |= (0x8);
-	} else if (pAd->Antenna.field.RxPath == 1) {
-		BBPR3 |= (0x0);
-	}
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
-
-	{
-		/* Handle the difference when 1T */
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BBPR1);
-		if (pAd->Antenna.field.TxPath == 1) {
-			BBPR1 &= (~0x18);
-		}
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, BBPR1);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Use Hw Radio Control Pin=%d; if used Pin=%d;\n",
-			  pAd->CommonCfg.bHardwareRadio,
-			  pAd->CommonCfg.bHardwareRadio));
-	}
-
-#ifdef RTMP_MAC_USB
-#ifdef RT30xx
-	/* update registers from EEPROM for RT3071 or later(3572/3592). */
-
-	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
-		u8 RegIdx, RegValue;
-		u16 value;
-
-		/* after RT3071, write BBP from EEPROM 0xF0 to 0x102 */
-		for (i = 0xF0; i <= 0x102; i = i + 2) {
-			value = 0xFFFF;
-			RT28xx_EEPROM_READ16(pAd, i, value);
-			if ((value != 0xFFFF) && (value != 0)) {
-				RegIdx = (u8)(value >> 8);
-				RegValue = (u8)(value & 0xff);
-				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, RegIdx,
-							     RegValue);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Update BBP Registers from EEPROM(0x%0x), BBP(0x%x) = 0x%x\n",
-					  i, RegIdx, RegValue));
-			}
-		}
-
-		/* after RT3071, write RF from EEPROM 0x104 to 0x116 */
-		for (i = 0x104; i <= 0x116; i = i + 2) {
-			value = 0xFFFF;
-			RT28xx_EEPROM_READ16(pAd, i, value);
-			if ((value != 0xFFFF) && (value != 0)) {
-				RegIdx = (u8)(value >> 8);
-				RegValue = (u8)(value & 0xff);
-				RT30xxWriteRFRegister(pAd, RegIdx, RegValue);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Update RF Registers from EEPROM0x%x), BBP(0x%x) = 0x%x\n",
-					  i, RegIdx, RegValue));
-			}
-		}
-	}
-#endif /* RT30xx // */
-#endif /* RTMP_MAC_USB // */
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("TxPath = %d, RxPath = %d, RFIC=%d, Polar+LED mode=%x\n",
-		  pAd->Antenna.field.TxPath, pAd->Antenna.field.RxPath,
-		  pAd->RfIcType, pAd->LedCntl.word));
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitAsicFromEEPROM\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Initialize NIC hardware
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int NICInitializeAdapter(struct rt_rtmp_adapter *pAd, IN BOOLEAN bHardReset)
-{
-	int Status = NDIS_STATUS_SUCCESS;
-	WPDMA_GLO_CFG_STRUC GloCfg;
-#ifdef RTMP_MAC_PCI
-	u32 Value;
-	DELAY_INT_CFG_STRUC IntCfg;
-#endif /* RTMP_MAC_PCI // */
-/*      INT_MASK_CSR_STRUC              IntMask; */
-	unsigned long i = 0, j = 0;
-	AC_TXOP_CSR0_STRUC csr0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAdapter\n"));
-
-	/* 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits: */
-retry:
-	i = 0;
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)
-		    && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		RTMPusecDelay(1000);
-		i++;
-	} while (i < 100);
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("<== DMA offset 0x208 = 0x%x\n", GloCfg.word));
-	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE = 1;
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-	/* Record HW Beacon offset */
-	pAd->BeaconOffset[0] = HW_BEACON_BASE0;
-	pAd->BeaconOffset[1] = HW_BEACON_BASE1;
-	pAd->BeaconOffset[2] = HW_BEACON_BASE2;
-	pAd->BeaconOffset[3] = HW_BEACON_BASE3;
-	pAd->BeaconOffset[4] = HW_BEACON_BASE4;
-	pAd->BeaconOffset[5] = HW_BEACON_BASE5;
-	pAd->BeaconOffset[6] = HW_BEACON_BASE6;
-	pAd->BeaconOffset[7] = HW_BEACON_BASE7;
-
-	/* */
-	/* write all shared Ring's base address into ASIC */
-	/* */
-
-	/* asic simulation sequence put this ahead before loading firmware. */
-	/* pbf hardware reset */
-#ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE32(pAd, WPDMA_RST_IDX, 0x1003f);	/* 0x10000 for reset rx, 0x3f resets all 6 tx rings. */
-	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe1f);
-	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe00);
-#endif /* RTMP_MAC_PCI // */
-
-	/* Initialze ASIC for TX & Rx operation */
-	if (NICInitializeAsic(pAd, bHardReset) != NDIS_STATUS_SUCCESS) {
-		if (j++ == 0) {
-			NICLoadFirmware(pAd);
-			goto retry;
-		}
-		return NDIS_STATUS_FAILURE;
-	}
-
-#ifdef RTMP_MAC_PCI
-	/* Write AC_BK base address register */
-	Value =
-	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BK].Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, TX_BASE_PTR1, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR1 : 0x%x\n", Value));
-
-	/* Write AC_BE base address register */
-	Value =
-	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BE].Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, TX_BASE_PTR0, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR0 : 0x%x\n", Value));
-
-	/* Write AC_VI base address register */
-	Value =
-	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VI].Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, TX_BASE_PTR2, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR2 : 0x%x\n", Value));
-
-	/* Write AC_VO base address register */
-	Value =
-	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VO].Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, TX_BASE_PTR3, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR3 : 0x%x\n", Value));
-
-	/* Write MGMT_BASE_CSR register */
-	Value = RTMP_GetPhysicalAddressLow(pAd->MgmtRing.Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, TX_BASE_PTR5, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR5 : 0x%x\n", Value));
-
-	/* Write RX_BASE_CSR register */
-	Value = RTMP_GetPhysicalAddressLow(pAd->RxRing.Cell[0].AllocPa);
-	RTMP_IO_WRITE32(pAd, RX_BASE_PTR, Value);
-	DBGPRINT(RT_DEBUG_TRACE, ("--> RX_BASE_PTR : 0x%x\n", Value));
-
-	/* Init RX Ring index pointer */
-	pAd->RxRing.RxSwReadIdx = 0;
-	pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
-	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
-
-	/* Init TX rings index pointer */
-	{
-		for (i = 0; i < NUM_OF_TX_RING; i++) {
-			pAd->TxRing[i].TxSwFreeIdx = 0;
-			pAd->TxRing[i].TxCpuIdx = 0;
-			RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10),
-					pAd->TxRing[i].TxCpuIdx);
-		}
-	}
-
-	/* init MGMT ring index pointer */
-	pAd->MgmtRing.TxSwFreeIdx = 0;
-	pAd->MgmtRing.TxCpuIdx = 0;
-	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
-
-	/* */
-	/* set each Ring's SIZE  into ASIC. Descriptor Size is fixed by design. */
-	/* */
-
-	/* Write TX_RING_CSR0 register */
-	Value = TX_RING_SIZE;
-	RTMP_IO_WRITE32(pAd, TX_MAX_CNT0, Value);
-	RTMP_IO_WRITE32(pAd, TX_MAX_CNT1, Value);
-	RTMP_IO_WRITE32(pAd, TX_MAX_CNT2, Value);
-	RTMP_IO_WRITE32(pAd, TX_MAX_CNT3, Value);
-	RTMP_IO_WRITE32(pAd, TX_MAX_CNT4, Value);
-	Value = MGMT_RING_SIZE;
-	RTMP_IO_WRITE32(pAd, TX_MGMTMAX_CNT, Value);
-
-	/* Write RX_RING_CSR register */
-	Value = RX_RING_SIZE;
-	RTMP_IO_WRITE32(pAd, RX_MAX_CNT, Value);
-#endif /* RTMP_MAC_PCI // */
-
-	/* WMM parameter */
-	csr0.word = 0;
-	RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
-	if (pAd->CommonCfg.PhyMode == PHY_11B) {
-		csr0.field.Ac0Txop = 192;	/* AC_VI: 192*32us ~= 6ms */
-		csr0.field.Ac1Txop = 96;	/* AC_VO: 96*32us  ~= 3ms */
-	} else {
-		csr0.field.Ac0Txop = 96;	/* AC_VI: 96*32us ~= 3ms */
-		csr0.field.Ac1Txop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
-	}
-	RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr0.word);
-
-#ifdef RTMP_MAC_PCI
-	/* 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits: */
-	i = 0;
-	do {
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)
-		    && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		RTMPusecDelay(1000);
-		i++;
-	} while (i < 100);
-
-	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE = 1;
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-	IntCfg.word = 0;
-	RTMP_IO_WRITE32(pAd, DELAY_INT_CFG, IntCfg.word);
-#endif /* RTMP_MAC_PCI // */
-
-	/* reset action */
-	/* Load firmware */
-	/*  Status = NICLoadFirmware(pAd); */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitializeAdapter\n"));
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Initialize ASIC
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int NICInitializeAsic(struct rt_rtmp_adapter *pAd, IN BOOLEAN bHardReset)
-{
-	unsigned long Index = 0;
-	u8 R0 = 0xff;
-	u32 MacCsr12 = 0, Counter = 0;
-#ifdef RTMP_MAC_USB
-	u32 MacCsr0 = 0;
-	int Status;
-	u8 Value = 0xff;
-#endif /* RTMP_MAC_USB // */
-#ifdef RT30xx
-	u8 bbpreg = 0;
-	u8 RFValue = 0;
-#endif /* RT30xx // */
-	u16 KeyIdx;
-	int i, apidx;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAsic\n"));
-
-#ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x3);	/* To fix driver disable/enable hang issue when radio off */
-	if (bHardReset == TRUE) {
-		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x3);
-	} else
-		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
-	/* Initialize MAC register to default value */
-	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
-		RTMP_IO_WRITE32(pAd, MACRegTable[Index].Register,
-				MACRegTable[Index].Value);
-	}
-
-	{
-		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++) {
-			RTMP_IO_WRITE32(pAd, STAMACRegTable[Index].Register,
-					STAMACRegTable[Index].Value);
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	/* */
-	/* Make sure MAC gets ready after NICLoadFirmware(). */
-	/* */
-	Index = 0;
-
-	/*To avoid hang-on issue when interface up in kernel 2.4, */
-	/*we use a local variable "MacCsr0" instead of using "pAd->MACVersion" directly. */
-	do {
-		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
-
-		if ((MacCsr0 != 0x00) && (MacCsr0 != 0xFFFFFFFF))
-			break;
-
-		RTMPusecDelay(10);
-	} while (Index++ < 100);
-
-	pAd->MACVersion = MacCsr0;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
-	/* turn on bit13 (set to zero) after rt2860D. This is to solve high-current issue. */
-	RTMP_IO_READ32(pAd, PBF_SYS_CTRL, &MacCsr12);
-	MacCsr12 &= (~0x2000);
-	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, MacCsr12);
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x3);
-	RTMP_IO_WRITE32(pAd, USB_DMA_CFG, 0x0);
-	Status = RTUSBVenderReset(pAd);
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
-
-	/* Initialize MAC register to default value */
-	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
-#ifdef RT30xx
-		if ((MACRegTable[Index].Register == TX_SW_CFG0)
-		    && (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd)
-			|| IS_RT3090(pAd) || IS_RT3390(pAd))) {
-			MACRegTable[Index].Value = 0x00000400;
-		}
-#endif /* RT30xx // */
-		RTMP_IO_WRITE32(pAd, (u16)MACRegTable[Index].Register,
-				MACRegTable[Index].Value);
-	}
-
-	{
-		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++) {
-			RTMP_IO_WRITE32(pAd,
-					(u16)STAMACRegTable[Index].Register,
-					STAMACRegTable[Index].Value);
-		}
-	}
-#endif /* RTMP_MAC_USB // */
-
-#ifdef RT30xx
-	/* Initialize RT3070 serial MAC registers which is different from RT2870 serial */
-	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
-		RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
-
-		/* RT3071 version E has fixed this issue */
-		if ((pAd->MACVersion & 0xffff) < 0x0211) {
-			if (pAd->NicConfig2.field.DACTestBit == 1) {
-				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	/* To fix throughput drop drastically */
-			} else {
-				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0F);	/* To fix throughput drop drastically */
-			}
-		} else {
-			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0);
-		}
-	} else if (IS_RT3070(pAd)) {
-		if (((pAd->MACVersion & 0xffff) < 0x0201)) {
-			RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
-			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	/* To fix throughput drop drastically */
-		} else {
-			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0);
-		}
-	}
-#endif /* RT30xx // */
-
-	/* */
-	/* Before program BBP, we need to wait BBP/RF get wake up. */
-	/* */
-	Index = 0;
-	do {
-		RTMP_IO_READ32(pAd, MAC_STATUS_CFG, &MacCsr12);
-
-		if ((MacCsr12 & 0x03) == 0)	/* if BB.RF is stable */
-			break;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Check MAC_STATUS_CFG  = Busy = %x\n", MacCsr12));
-		RTMPusecDelay(1000);
-	} while (Index++ < 100);
-
-	/* The commands to firmware should be after these commands, these commands will init firmware */
-	/* PCI and USB are not the same because PCI driver needs to wait for PCI bus ready */
-	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, 0);	/* initialize BBP R/W access agent */
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, 0);
-#ifdef RT3090
-	/*2008/11/28:KH add to fix the dead rf frequency offset bug<-- */
-	AsicSendCommandToMcu(pAd, 0x72, 0, 0, 0);
-	/*2008/11/28:KH add to fix the dead rf frequency offset bug--> */
-#endif /* RT3090 // */
-	RTMPusecDelay(1000);
-
-	/* Read BBP register, make sure BBP is up and running before write new data */
-	Index = 0;
-	do {
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R0, &R0);
-		DBGPRINT(RT_DEBUG_TRACE, ("BBP version = %x\n", R0));
-	} while ((++Index < 20) && ((R0 == 0xff) || (R0 == 0x00)));
-	/*ASSERT(Index < 20); //this will cause BSOD on Check-build driver */
-
-	if ((R0 == 0xff) || (R0 == 0x00))
-		return NDIS_STATUS_FAILURE;
-
-	/* Initialize BBP register to default value */
-	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++) {
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBPRegTable[Index].Register,
-					     BBPRegTable[Index].Value);
-	}
-
-#ifdef RTMP_MAC_PCI
-	/* TODO: shiang, check MACVersion, currently, rbus-based chip use this. */
-	if (pAd->MACVersion == 0x28720200) {
-		/*u8 value; */
-		unsigned long value2;
-
-		/*disable MLD by Bruce 20080704 */
-		/*BBP_IO_READ8_BY_REG_ID(pAd, BBP_R105, &value); */
-		/*BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R105, value | 4); */
-
-		/*Maximum PSDU length from 16K to 32K bytes */
-		RTMP_IO_READ32(pAd, MAX_LEN_CFG, &value2);
-		value2 &= ~(0x3 << 12);
-		value2 |= (0x2 << 12);
-		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, value2);
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	/* for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT. */
-	/* RT3090 should not program BBP R84 to 0x19, otherwise TX will block. */
-	/*3070/71/72,3090,3090A( are included in RT30xx),3572,3390 */
-	if (((pAd->MACVersion & 0xffff) != 0x0101)
-	    && !(IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R84, 0x19);
-
-#ifdef RT30xx
-/* add by johnli, RF power sequence setup */
-	if (IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {	/*update for RT3070/71/72/90/91/92,3572,3390. */
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R79, 0x13);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R80, 0x05);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R81, 0x33);
-	}
-
-	if (IS_RT3090(pAd) || IS_RT3390(pAd))	/* RT309x, RT3071/72 */
-	{
-		/* enable DC filter */
-		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
-		}
-		/* improve power consumption */
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R138, &bbpreg);
-		if (pAd->Antenna.field.TxPath == 1) {
-			/* turn off tx DAC_1 */
-			bbpreg = (bbpreg | 0x20);
-		}
-
-		if (pAd->Antenna.field.RxPath == 1) {
-			/* turn off tx ADC_1 */
-			bbpreg &= (~0x2);
-		}
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R138, bbpreg);
-
-		/* improve power consumption in RT3071 Ver.E */
-		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R31, &bbpreg);
-			bbpreg &= (~0x3);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R31, bbpreg);
-		}
-	} else if (IS_RT3070(pAd)) {
-		if ((pAd->MACVersion & 0xffff) >= 0x0201) {
-			/* enable DC filter */
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
-
-			/* improve power consumption in RT3070 Ver.F */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R31, &bbpreg);
-			bbpreg &= (~0x3);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R31, bbpreg);
-		}
-		/* TX_LO1_en, RF R17 register Bit 3 to 0 */
-		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
-		RFValue &= (~0x08);
-		/* to fix rx long range issue */
-		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
-			RFValue |= 0x20;
-		}
-		/* set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h */
-		if (pAd->TxMixerGain24G >= 1) {
-			RFValue &= (~0x7);	/* clean bit [2:0] */
-			RFValue |= pAd->TxMixerGain24G;
-		}
-		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
-	}
-/* end johnli */
-#endif /* RT30xx // */
-
-	if (pAd->MACVersion == 0x28600100) {
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x12);
-	}
-
-	if (pAd->MACVersion >= RALINK_2880E_VERSION && pAd->MACVersion < RALINK_3070_VERSION)	/* 3*3 */
-	{
-		/* enlarge MAX_LEN_CFG */
-		u32 csr;
-		RTMP_IO_READ32(pAd, MAX_LEN_CFG, &csr);
-		csr &= 0xFFF;
-		csr |= 0x2000;
-		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, csr);
-	}
-#ifdef RTMP_MAC_USB
-	{
-		u8 MAC_Value[] =
-		    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0 };
-
-		/*Initialize WCID table */
-		Value = 0xff;
-		for (Index = 0; Index < 254; Index++) {
-			RTUSBMultiWrite(pAd,
-					(u16)(MAC_WCID_BASE + Index * 8),
-					MAC_Value, 8);
-		}
-	}
-#endif /* RTMP_MAC_USB // */
-
-	/* Add radio off control */
-	{
-		if (pAd->StaCfg.bRadio == FALSE) {
-/*                      RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818); */
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-			DBGPRINT(RT_DEBUG_TRACE, ("Set Radio Off\n"));
-		}
-	}
-
-	/* Clear raw counters */
-	RTMP_IO_READ32(pAd, RX_STA_CNT0, &Counter);
-	RTMP_IO_READ32(pAd, RX_STA_CNT1, &Counter);
-	RTMP_IO_READ32(pAd, RX_STA_CNT2, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT0, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT1, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT2, &Counter);
-
-	/* ASIC will keep garbage value after boot */
-	/* Clear all shared key table when initial */
-	/* This routine can be ignored in radio-ON/OFF operation. */
-	if (bHardReset) {
-		for (KeyIdx = 0; KeyIdx < 4; KeyIdx++) {
-			RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * KeyIdx,
-					0);
-		}
-
-		/* Clear all pairwise key table when initial */
-		for (KeyIdx = 0; KeyIdx < 256; KeyIdx++) {
-			RTMP_IO_WRITE32(pAd,
-					MAC_WCID_ATTRIBUTE_BASE +
-					(KeyIdx * HW_WCID_ATTRI_SIZE), 1);
-		}
-	}
-	/* assert HOST ready bit */
-/*  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark */
-/*  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4); */
-
-	/* It isn't necessary to clear this space when not hard reset. */
-	if (bHardReset == TRUE) {
-		/* clear all on-chip BEACON frame space */
-		for (apidx = 0; apidx < HW_BEACON_MAX_COUNT; apidx++) {
-			for (i = 0; i < HW_BEACON_OFFSET >> 2; i += 4)
-				RTMP_IO_WRITE32(pAd,
-						pAd->BeaconOffset[apidx] + i,
-						0x00);
-		}
-	}
-#ifdef RTMP_MAC_USB
-	AsicDisableSync(pAd);
-	/* Clear raw counters */
-	RTMP_IO_READ32(pAd, RX_STA_CNT0, &Counter);
-	RTMP_IO_READ32(pAd, RX_STA_CNT1, &Counter);
-	RTMP_IO_READ32(pAd, RX_STA_CNT2, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT0, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT1, &Counter);
-	RTMP_IO_READ32(pAd, TX_STA_CNT2, &Counter);
-	/* Default PCI clock cycle per ms is different as default setting, which is based on PCI. */
-	RTMP_IO_READ32(pAd, USB_CYC_CFG, &Counter);
-	Counter &= 0xffffff00;
-	Counter |= 0x000001e;
-	RTMP_IO_WRITE32(pAd, USB_CYC_CFG, Counter);
-#endif /* RTMP_MAC_USB // */
-
-	{
-		/* for rt2860E and after, init TXOP_CTRL_CFG with 0x583f. This is for extension channel overlapping IOT. */
-		if ((pAd->MACVersion & 0xffff) != 0x0101)
-			RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x583f);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitializeAsic\n"));
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Reset NIC Asics
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-		Reset NIC to initial state AS IS system boot up time.
-
-	========================================================================
-*/
-void NICIssueReset(struct rt_rtmp_adapter *pAd)
-{
-	u32 Value = 0;
-	DBGPRINT(RT_DEBUG_TRACE, ("--> NICIssueReset\n"));
-
-	/* Abort Tx, prevent ASIC from writing to Host memory */
-	/*RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x001f0000); */
-
-	/* Disable Rx, register value supposed will remain after reset */
-	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
-	Value &= (0xfffffff3);
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-
-	/* Issue reset and clear from reset state */
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x03);	/* 2004-09-17 change from 0x01 */
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x00);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICIssueReset\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Check ASIC registers and find any reason the system might hang
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-BOOLEAN NICCheckForHang(struct rt_rtmp_adapter *pAd)
-{
-	return (FALSE);
-}
-
-void NICUpdateFifoStaCounters(struct rt_rtmp_adapter *pAd)
-{
-	TX_STA_FIFO_STRUC StaFifo;
-	struct rt_mac_table_entry *pEntry;
-	u8 i = 0;
-	u8 pid = 0, wcid = 0;
-	char reTry;
-	u8 succMCS;
-
-	do {
-		RTMP_IO_READ32(pAd, TX_STA_FIFO, &StaFifo.word);
-
-		if (StaFifo.field.bValid == 0)
-			break;
-
-		wcid = (u8)StaFifo.field.wcid;
-
-		/* ignore NoACK and MGMT frame use 0xFF as WCID */
-		if ((StaFifo.field.TxAckRequired == 0)
-		    || (wcid >= MAX_LEN_OF_MAC_TABLE)) {
-			i++;
-			continue;
-		}
-
-		/* PID store Tx MCS Rate */
-		pid = (u8)StaFifo.field.PidType;
-
-		pEntry = &pAd->MacTab.Content[wcid];
-
-		pEntry->DebugFIFOCount++;
-
-		if (StaFifo.field.TxBF)	/* 3*3 */
-			pEntry->TxBFCount++;
-
-		if (!StaFifo.field.TxSuccess) {
-			pEntry->FIFOCount++;
-			pEntry->OneSecTxFailCount++;
-
-			if (pEntry->FIFOCount >= 1) {
-				DBGPRINT(RT_DEBUG_TRACE, ("#"));
-				pEntry->NoBADataCountDown = 64;
-
-				if (pEntry->PsMode == PWR_ACTIVE) {
-					int tid;
-					for (tid = 0; tid < NUM_OF_TID; tid++) {
-						BAOriSessionTearDown(pAd,
-								     pEntry->
-								     Aid, tid,
-								     FALSE,
-								     FALSE);
-					}
-
-					/* Update the continuous transmission counter except PS mode */
-					pEntry->ContinueTxFailCnt++;
-				} else {
-					/* Clear the FIFOCount when sta in Power Save mode. Basically we assume */
-					/*     this tx error happened due to sta just go to sleep. */
-					pEntry->FIFOCount = 0;
-					pEntry->ContinueTxFailCnt = 0;
-				}
-				/*pEntry->FIFOCount = 0; */
-			}
-			/*pEntry->bSendBAR = TRUE; */
-		} else {
-			if ((pEntry->PsMode != PWR_SAVE)
-			    && (pEntry->NoBADataCountDown > 0)) {
-				pEntry->NoBADataCountDown--;
-				if (pEntry->NoBADataCountDown == 0) {
-					DBGPRINT(RT_DEBUG_TRACE, ("@\n"));
-				}
-			}
-
-			pEntry->FIFOCount = 0;
-			pEntry->OneSecTxNoRetryOkCount++;
-			/* update NoDataIdleCount when successful send packet to STA. */
-			pEntry->NoDataIdleCount = 0;
-			pEntry->ContinueTxFailCnt = 0;
-		}
-
-		succMCS = StaFifo.field.SuccessRate & 0x7F;
-
-		reTry = pid - succMCS;
-
-		if (StaFifo.field.TxSuccess) {
-			pEntry->TXMCSExpected[pid]++;
-			if (pid == succMCS) {
-				pEntry->TXMCSSuccessful[pid]++;
-			} else {
-				pEntry->TXMCSAutoFallBack[pid][succMCS]++;
-			}
-		} else {
-			pEntry->TXMCSFailed[pid]++;
-		}
-
-		if (reTry > 0) {
-			if ((pid >= 12) && succMCS <= 7) {
-				reTry -= 4;
-			}
-			pEntry->OneSecTxRetryOkCount += reTry;
-		}
-
-		i++;
-		/* ASIC store 16 stack */
-	} while (i < (2 * TX_RING_SIZE));
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Read statistical counters from hardware registers and record them
-		in software variables for later on query
-
-	Arguments:
-		pAd					Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void NICUpdateRawCounters(struct rt_rtmp_adapter *pAd)
-{
-	u32 OldValue;	/*, Value2; */
-	/*unsigned long PageSum, OneSecTransmitCount; */
-	/*unsigned long TxErrorRatio, Retry, Fail; */
-	RX_STA_CNT0_STRUC RxStaCnt0;
-	RX_STA_CNT1_STRUC RxStaCnt1;
-	RX_STA_CNT2_STRUC RxStaCnt2;
-	TX_STA_CNT0_STRUC TxStaCnt0;
-	TX_STA_CNT1_STRUC StaTx1;
-	TX_STA_CNT2_STRUC StaTx2;
-	TX_AGG_CNT_STRUC TxAggCnt;
-	TX_AGG_CNT0_STRUC TxAggCnt0;
-	TX_AGG_CNT1_STRUC TxAggCnt1;
-	TX_AGG_CNT2_STRUC TxAggCnt2;
-	TX_AGG_CNT3_STRUC TxAggCnt3;
-	TX_AGG_CNT4_STRUC TxAggCnt4;
-	TX_AGG_CNT5_STRUC TxAggCnt5;
-	TX_AGG_CNT6_STRUC TxAggCnt6;
-	TX_AGG_CNT7_STRUC TxAggCnt7;
-	struct rt_counter_ralink *pRalinkCounters;
-
-	pRalinkCounters = &pAd->RalinkCounters;
-
-	RTMP_IO_READ32(pAd, RX_STA_CNT0, &RxStaCnt0.word);
-	RTMP_IO_READ32(pAd, RX_STA_CNT2, &RxStaCnt2.word);
-
-	{
-		RTMP_IO_READ32(pAd, RX_STA_CNT1, &RxStaCnt1.word);
-		/* Update RX PLCP error counter */
-		pAd->PrivateInfo.PhyRxErrCnt += RxStaCnt1.field.PlcpErr;
-		/* Update False CCA counter */
-		pAd->RalinkCounters.OneSecFalseCCACnt +=
-		    RxStaCnt1.field.FalseCca;
-	}
-
-	/* Update FCS counters */
-	OldValue = pAd->WlanCounters.FCSErrorCount.u.LowPart;
-	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr);	/* >> 7); */
-	if (pAd->WlanCounters.FCSErrorCount.u.LowPart < OldValue)
-		pAd->WlanCounters.FCSErrorCount.u.HighPart++;
-
-	/* Add FCS error count to private counters */
-	pRalinkCounters->OneSecRxFcsErrCnt += RxStaCnt0.field.CrcErr;
-	OldValue = pRalinkCounters->RealFcsErrCount.u.LowPart;
-	pRalinkCounters->RealFcsErrCount.u.LowPart += RxStaCnt0.field.CrcErr;
-	if (pRalinkCounters->RealFcsErrCount.u.LowPart < OldValue)
-		pRalinkCounters->RealFcsErrCount.u.HighPart++;
-
-	/* Update Duplicate Rcv check */
-	pRalinkCounters->DuplicateRcv += RxStaCnt2.field.RxDupliCount;
-	pAd->WlanCounters.FrameDuplicateCount.u.LowPart +=
-	    RxStaCnt2.field.RxDupliCount;
-	/* Update RX Overflow counter */
-	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
-
-	/*pAd->RalinkCounters.RxCount = 0; */
-#ifdef RTMP_MAC_USB
-	if (pRalinkCounters->RxCount != pAd->watchDogRxCnt) {
-		pAd->watchDogRxCnt = pRalinkCounters->RxCount;
-		pAd->watchDogRxOverFlowCnt = 0;
-	} else {
-		if (RxStaCnt2.field.RxFifoOverflowCount)
-			pAd->watchDogRxOverFlowCnt++;
-		else
-			pAd->watchDogRxOverFlowCnt = 0;
-	}
-#endif /* RTMP_MAC_USB // */
-
-	/*if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) || */
-	/*      (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1))) */
-	if (!pAd->bUpdateBcnCntDone) {
-		/* Update BEACON sent count */
-		RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
-		RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
-		RTMP_IO_READ32(pAd, TX_STA_CNT2, &StaTx2.word);
-		pRalinkCounters->OneSecBeaconSentCnt +=
-		    TxStaCnt0.field.TxBeaconCount;
-		pRalinkCounters->OneSecTxRetryOkCount +=
-		    StaTx1.field.TxRetransmit;
-		pRalinkCounters->OneSecTxNoRetryOkCount +=
-		    StaTx1.field.TxSuccess;
-		pRalinkCounters->OneSecTxFailCount +=
-		    TxStaCnt0.field.TxFailCount;
-		pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
-		    StaTx1.field.TxSuccess;
-		pAd->WlanCounters.RetryCount.u.LowPart +=
-		    StaTx1.field.TxRetransmit;
-		pAd->WlanCounters.FailedCount.u.LowPart +=
-		    TxStaCnt0.field.TxFailCount;
-	}
-
-	/*if (pAd->bStaFifoTest == TRUE) */
-	{
-		RTMP_IO_READ32(pAd, TX_AGG_CNT, &TxAggCnt.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT0, &TxAggCnt0.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT1, &TxAggCnt1.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT2, &TxAggCnt2.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT3, &TxAggCnt3.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT4, &TxAggCnt4.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT5, &TxAggCnt5.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT6, &TxAggCnt6.word);
-		RTMP_IO_READ32(pAd, TX_AGG_CNT7, &TxAggCnt7.word);
-		pRalinkCounters->TxAggCount += TxAggCnt.field.AggTxCount;
-		pRalinkCounters->TxNonAggCount += TxAggCnt.field.NonAggTxCount;
-		pRalinkCounters->TxAgg1MPDUCount +=
-		    TxAggCnt0.field.AggSize1Count;
-		pRalinkCounters->TxAgg2MPDUCount +=
-		    TxAggCnt0.field.AggSize2Count;
-
-		pRalinkCounters->TxAgg3MPDUCount +=
-		    TxAggCnt1.field.AggSize3Count;
-		pRalinkCounters->TxAgg4MPDUCount +=
-		    TxAggCnt1.field.AggSize4Count;
-		pRalinkCounters->TxAgg5MPDUCount +=
-		    TxAggCnt2.field.AggSize5Count;
-		pRalinkCounters->TxAgg6MPDUCount +=
-		    TxAggCnt2.field.AggSize6Count;
-
-		pRalinkCounters->TxAgg7MPDUCount +=
-		    TxAggCnt3.field.AggSize7Count;
-		pRalinkCounters->TxAgg8MPDUCount +=
-		    TxAggCnt3.field.AggSize8Count;
-		pRalinkCounters->TxAgg9MPDUCount +=
-		    TxAggCnt4.field.AggSize9Count;
-		pRalinkCounters->TxAgg10MPDUCount +=
-		    TxAggCnt4.field.AggSize10Count;
-
-		pRalinkCounters->TxAgg11MPDUCount +=
-		    TxAggCnt5.field.AggSize11Count;
-		pRalinkCounters->TxAgg12MPDUCount +=
-		    TxAggCnt5.field.AggSize12Count;
-		pRalinkCounters->TxAgg13MPDUCount +=
-		    TxAggCnt6.field.AggSize13Count;
-		pRalinkCounters->TxAgg14MPDUCount +=
-		    TxAggCnt6.field.AggSize14Count;
-
-		pRalinkCounters->TxAgg15MPDUCount +=
-		    TxAggCnt7.field.AggSize15Count;
-		pRalinkCounters->TxAgg16MPDUCount +=
-		    TxAggCnt7.field.AggSize16Count;
-
-		/* Calculate the transmitted A-MPDU count */
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    TxAggCnt0.field.AggSize1Count;
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt0.field.AggSize2Count / 2);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt1.field.AggSize3Count / 3);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt1.field.AggSize4Count / 4);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt2.field.AggSize5Count / 5);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt2.field.AggSize6Count / 6);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt3.field.AggSize7Count / 7);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt3.field.AggSize8Count / 8);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt4.field.AggSize9Count / 9);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt4.field.AggSize10Count / 10);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt5.field.AggSize11Count / 11);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt5.field.AggSize12Count / 12);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt6.field.AggSize13Count / 13);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt6.field.AggSize14Count / 14);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt7.field.AggSize15Count / 15);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
-		    (TxAggCnt7.field.AggSize16Count / 16);
-	}
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Reset NIC from error
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-		Reset NIC from error state
-
-	========================================================================
-*/
-void NICResetFromError(struct rt_rtmp_adapter *pAd)
-{
-	/* Reset BBP (according to alex, reset ASIC will force reset BBP */
-	/* Therefore, skip the reset BBP */
-	/* RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x2); */
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
-	/* Remove ASIC from reset state */
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
-
-	NICInitializeAdapter(pAd, FALSE);
-	NICInitAsicFromEEPROM(pAd);
-
-	/* Switch to current channel, since during reset process, the connection should remains on. */
-	AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-	AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-}
-
-int NICLoadFirmware(struct rt_rtmp_adapter *pAd)
-{
-	int status = NDIS_STATUS_SUCCESS;
-	if (pAd->chipOps.loadFirmware)
-		status = pAd->chipOps.loadFirmware(pAd);
-
-	return status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		erase 8051 firmware image in MAC ASIC
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-void NICEraseFirmware(struct rt_rtmp_adapter *pAd)
-{
-	if (pAd->chipOps.eraseFirmware)
-		pAd->chipOps.eraseFirmware(pAd);
-
-}				/* End of NICEraseFirmware */
-
-/*
-	========================================================================
-
-	Routine Description:
-		Load Tx rate switching parameters
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		NDIS_STATUS_SUCCESS         firmware image load ok
-		NDIS_STATUS_FAILURE         image not found
-
-	IRQL = PASSIVE_LEVEL
-
-	Rate Table Format:
-		1. (B0: Valid Item number) (B1:Initial item from zero)
-		2. Item Number(Dec)      Mode(Hex)     Current MCS(Dec)    TrainUp(Dec)    TrainDown(Dec)
-
-	========================================================================
-*/
-int NICLoadRateSwitchingParams(struct rt_rtmp_adapter *pAd)
-{
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Compare two memory block
-
-	Arguments:
-		pSrc1		Pointer to first memory address
-		pSrc2		Pointer to second memory address
-
-	Return Value:
-		0:			memory is equal
-		1:			pSrc1 memory is larger
-		2:			pSrc2 memory is larger
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-unsigned long RTMPCompareMemory(void *pSrc1, void *pSrc2, unsigned long Length)
-{
-	u8 *pMem1;
-	u8 *pMem2;
-	unsigned long Index = 0;
-
-	pMem1 = (u8 *)pSrc1;
-	pMem2 = (u8 *)pSrc2;
-
-	for (Index = 0; Index < Length; Index++) {
-		if (pMem1[Index] > pMem2[Index])
-			return (1);
-		else if (pMem1[Index] < pMem2[Index])
-			return (2);
-	}
-
-	/* Equal */
-	return (0);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Zero out memory block
-
-	Arguments:
-		pSrc1		Pointer to memory address
-		Length		Size
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPZeroMemory(void *pSrc, unsigned long Length)
-{
-	u8 *pMem;
-	unsigned long Index = 0;
-
-	pMem = (u8 *)pSrc;
-
-	for (Index = 0; Index < Length; Index++) {
-		pMem[Index] = 0x00;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Copy data from memory block 1 to memory block 2
-
-	Arguments:
-		pDest		Pointer to destination memory address
-		pSrc		Pointer to source memory address
-		Length		Copy size
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPMoveMemory(void *pDest, void *pSrc, unsigned long Length)
-{
-	u8 *pMem1;
-	u8 *pMem2;
-	u32 Index;
-
-	ASSERT((Length == 0) || (pDest && pSrc));
-
-	pMem1 = (u8 *)pDest;
-	pMem2 = (u8 *)pSrc;
-
-	for (Index = 0; Index < Length; Index++) {
-		pMem1[Index] = pMem2[Index];
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Initialize port configuration structure
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void UserCfgInit(struct rt_rtmp_adapter *pAd)
-{
-	u32 key_index, bss_index;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit\n"));
-
-	/* */
-	/*  part I. initialize common configuration */
-	/* */
-#ifdef RTMP_MAC_USB
-	pAd->BulkOutReq = 0;
-
-	pAd->BulkOutComplete = 0;
-	pAd->BulkOutCompleteOther = 0;
-	pAd->BulkOutCompleteCancel = 0;
-	pAd->BulkInReq = 0;
-	pAd->BulkInComplete = 0;
-	pAd->BulkInCompleteFail = 0;
-
-	/*pAd->QuickTimerP = 100; */
-	/*pAd->TurnAggrBulkInCount = 0; */
-	pAd->bUsbTxBulkAggre = 0;
-
-	/* init as unused value to ensure driver will set to MCU once. */
-	pAd->LedIndicatorStrength = 0xFF;
-
-	pAd->CommonCfg.MaxPktOneTxBulk = 2;
-	pAd->CommonCfg.TxBulkFactor = 1;
-	pAd->CommonCfg.RxBulkFactor = 1;
-
-	pAd->CommonCfg.TxPower = 100;	/*mW */
-
-	NdisZeroMemory(&pAd->CommonCfg.IOTestParm,
-		       sizeof(pAd->CommonCfg.IOTestParm));
-#endif /* RTMP_MAC_USB // */
-
-	for (key_index = 0; key_index < SHARE_KEY_NUM; key_index++) {
-		for (bss_index = 0; bss_index < MAX_MBSSID_NUM; bss_index++) {
-			pAd->SharedKey[bss_index][key_index].KeyLen = 0;
-			pAd->SharedKey[bss_index][key_index].CipherAlg =
-			    CIPHER_NONE;
-		}
-	}
-
-	pAd->EepromAccess = FALSE;
-
-	pAd->Antenna.word = 0;
-	pAd->CommonCfg.BBPCurrentBW = BW_20;
-
-	pAd->LedCntl.word = 0;
-#ifdef RTMP_MAC_PCI
-	pAd->LedIndicatorStrength = 0;
-	pAd->RLnkCtrlOffset = 0;
-	pAd->HostLnkCtrlOffset = 0;
-	pAd->StaCfg.PSControl.field.EnableNewPS = TRUE;
-	pAd->CheckDmaBusyCount = 0;
-#endif /* RTMP_MAC_PCI // */
-
-	pAd->bAutoTxAgcA = FALSE;	/* Default is OFF */
-	pAd->bAutoTxAgcG = FALSE;	/* Default is OFF */
-	pAd->RfIcType = RFIC_2820;
-
-	/* Init timer for reset complete event */
-	pAd->CommonCfg.CentralChannel = 1;
-	pAd->bForcePrintTX = FALSE;
-	pAd->bForcePrintRX = FALSE;
-	pAd->bStaFifoTest = FALSE;
-	pAd->bProtectionTest = FALSE;
-	pAd->CommonCfg.Dsifs = 10;	/* in units of usec */
-	pAd->CommonCfg.TxPower = 100;	/*mW */
-	pAd->CommonCfg.TxPowerPercentage = 0xffffffff;	/* AUTO */
-	pAd->CommonCfg.TxPowerDefault = 0xffffffff;	/* AUTO */
-	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto;	/* use Long preamble on TX by defaut */
-	pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
-	pAd->CommonCfg.RtsThreshold = 2347;
-	pAd->CommonCfg.FragmentThreshold = 2346;
-	pAd->CommonCfg.UseBGProtection = 0;	/* 0: AUTO */
-	pAd->CommonCfg.bEnableTxBurst = TRUE;	/*0; */
-	pAd->CommonCfg.PhyMode = 0xff;	/* unknown */
-	pAd->CommonCfg.BandState = UNKNOWN_BAND;
-	pAd->CommonCfg.RadarDetect.CSPeriod = 10;
-	pAd->CommonCfg.RadarDetect.CSCount = 0;
-	pAd->CommonCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
-
-	pAd->CommonCfg.RadarDetect.ChMovingTime = 65;
-	pAd->CommonCfg.RadarDetect.LongPulseRadarTh = 3;
-	pAd->CommonCfg.bAPSDCapable = FALSE;
-	pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
-	pAd->CommonCfg.TriggerTimerCount = 0;
-	pAd->CommonCfg.bAPSDForcePowerSave = FALSE;
-	pAd->CommonCfg.bCountryFlag = FALSE;
-	pAd->CommonCfg.TxStream = 0;
-	pAd->CommonCfg.RxStream = 0;
-
-	NdisZeroMemory(&pAd->BeaconTxWI, sizeof(pAd->BeaconTxWI));
-
-	NdisZeroMemory(&pAd->CommonCfg.HtCapability,
-		       sizeof(pAd->CommonCfg.HtCapability));
-	pAd->HTCEnable = FALSE;
-	pAd->bBroadComHT = FALSE;
-	pAd->CommonCfg.bRdg = FALSE;
-
-	NdisZeroMemory(&pAd->CommonCfg.AddHTInfo,
-		       sizeof(pAd->CommonCfg.AddHTInfo));
-	pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
-	pAd->CommonCfg.BACapability.field.MpduDensity = 0;
-	pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
-	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;	/*32; */
-	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64;	/*32; */
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("--> UserCfgInit. BACapability = 0x%x\n",
-		  pAd->CommonCfg.BACapability.word));
-
-	pAd->CommonCfg.BACapability.field.AutoBA = FALSE;
-	BATableInit(pAd, &pAd->BATable);
-
-	pAd->CommonCfg.bExtChannelSwitchAnnouncement = 1;
-	pAd->CommonCfg.bHTProtect = 1;
-	pAd->CommonCfg.bMIMOPSEnable = TRUE;
-	/*2008/11/05:KH add to support Antenna power-saving of AP<-- */
-	pAd->CommonCfg.bGreenAPEnable = FALSE;
-	/*2008/11/05:KH add to support Antenna power-saving of AP--> */
-	pAd->CommonCfg.bBADecline = FALSE;
-	pAd->CommonCfg.bDisableReordering = FALSE;
-
-	if (pAd->MACVersion == 0x28720200) {
-		pAd->CommonCfg.TxBASize = 13;	/*by Jerry recommend */
-	} else {
-		pAd->CommonCfg.TxBASize = 7;
-	}
-
-	pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
-
-	/*pAd->CommonCfg.HTPhyMode.field.BW = BW_20; */
-	/*pAd->CommonCfg.HTPhyMode.field.MCS = MCS_AUTO; */
-	/*pAd->CommonCfg.HTPhyMode.field.ShortGI = GI_800; */
-	/*pAd->CommonCfg.HTPhyMode.field.STBC = STBC_NONE; */
-	pAd->CommonCfg.TxRate = RATE_6;
-
-	pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_RATE_6;
-	pAd->CommonCfg.MlmeTransmit.field.BW = BW_20;
-	pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-
-	pAd->CommonCfg.BeaconPeriod = 100;	/* in mSec */
-
-	/* */
-	/* part II. initialize STA specific configuration */
-	/* */
-	{
-		RX_FILTER_SET_FLAG(pAd, fRX_FILTER_ACCEPT_DIRECT);
-		RX_FILTER_CLEAR_FLAG(pAd, fRX_FILTER_ACCEPT_MULTICAST);
-		RX_FILTER_SET_FLAG(pAd, fRX_FILTER_ACCEPT_BROADCAST);
-		RX_FILTER_SET_FLAG(pAd, fRX_FILTER_ACCEPT_ALL_MULTICAST);
-
-		pAd->StaCfg.Psm = PWR_ACTIVE;
-
-		pAd->StaCfg.OrigWepStatus = Ndis802_11EncryptionDisabled;
-		pAd->StaCfg.PairCipher = Ndis802_11EncryptionDisabled;
-		pAd->StaCfg.GroupCipher = Ndis802_11EncryptionDisabled;
-		pAd->StaCfg.bMixCipher = FALSE;
-		pAd->StaCfg.DefaultKeyId = 0;
-
-		/* 802.1x port control */
-		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
-		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-		pAd->StaCfg.LastMicErrorTime = 0;
-		pAd->StaCfg.MicErrCnt = 0;
-		pAd->StaCfg.bBlockAssoc = FALSE;
-		pAd->StaCfg.WpaState = SS_NOTUSE;
-
-		pAd->CommonCfg.NdisRadioStateOff = FALSE;	/* New to support microsoft disable radio with OID command */
-
-		pAd->StaCfg.RssiTrigger = 0;
-		NdisZeroMemory(&pAd->StaCfg.RssiSample, sizeof(struct rt_rssi_sample));
-		pAd->StaCfg.RssiTriggerMode =
-		    RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
-		pAd->StaCfg.AtimWin = 0;
-		pAd->StaCfg.DefaultListenCount = 3;	/*default listen count; */
-		pAd->StaCfg.BssType = BSS_INFRA;	/* BSS_INFRA or BSS_ADHOC or BSS_MONITOR */
-		pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
-
-		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
-		pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-	}
-
-#ifdef PCIE_PS_SUPPORT
-	pAd->brt30xxBanMcuCmd = FALSE;
-	pAd->b3090ESpecialChip = FALSE;
-/*KH Debug:the following must be removed */
-	pAd->StaCfg.PSControl.field.rt30xxPowerMode = 3;
-	pAd->StaCfg.PSControl.field.rt30xxForceASPMTest = 0;
-	pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM = 1;
-#endif /* PCIE_PS_SUPPORT // */
-
-	/* global variables mXXXX used in MAC protocol state machines */
-	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
-
-	/* PHY specification */
-	pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;	/* default PHY mode */
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);	/* CCK use long preamble */
-
-	{
-		/* user desired power mode */
-		pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
-		pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
-		pAd->StaCfg.bWindowsACCAMEnable = FALSE;
-
-		RTMPInitTimer(pAd, &pAd->StaCfg.StaQuickResponeForRateUpTimer,
-			      GET_TIMER_FUNCTION(StaQuickResponeForRateUpExec),
-			      pAd, FALSE);
-		pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
-
-		/* Patch for Ndtest */
-		pAd->StaCfg.ScanCnt = 0;
-
-		pAd->StaCfg.bHwRadio = TRUE;	/* Default Hardware Radio status is On */
-		pAd->StaCfg.bSwRadio = TRUE;	/* Default Software Radio status is On */
-		pAd->StaCfg.bRadio = TRUE;	/* bHwRadio && bSwRadio */
-		pAd->StaCfg.bHardwareRadio = FALSE;	/* Default is OFF */
-		pAd->StaCfg.bShowHiddenSSID = FALSE;	/* Default no show */
-
-		/* Nitro mode control */
-		pAd->StaCfg.bAutoReconnect = TRUE;
-
-		/* Save the init time as last scan time, the system should do scan after 2 seconds. */
-		/* This patch is for driver wake up from standby mode, system will do scan right away. */
-		NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
-		if (pAd->StaCfg.LastScanTime > 10 * OS_HZ)
-			pAd->StaCfg.LastScanTime -= (10 * OS_HZ);
-
-		NdisZeroMemory(pAd->nickname, IW_ESSID_MAX_SIZE + 1);
-#ifdef RTMP_MAC_PCI
-		sprintf((char *)pAd->nickname, "RT2860STA");
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		sprintf((char *)pAd->nickname, "RT2870STA");
-#endif /* RTMP_MAC_USB // */
-		RTMPInitTimer(pAd, &pAd->StaCfg.WpaDisassocAndBlockAssocTimer,
-			      GET_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc),
-			      pAd, FALSE);
-		pAd->StaCfg.IEEE8021X = FALSE;
-		pAd->StaCfg.IEEE8021x_required_keys = FALSE;
-		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_DISABLE;
-		pAd->StaCfg.bRSN_IE_FromWpaSupplicant = FALSE;
-		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE;
-
-		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
-
-		pAd->StaCfg.bAutoConnectByBssid = FALSE;
-		pAd->StaCfg.BeaconLostTime = BEACON_LOST_TIME;
-		NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
-		pAd->StaCfg.WpaPassPhraseLen = 0;
-		pAd->StaCfg.bAutoRoaming = FALSE;
-		pAd->StaCfg.bForceTxBurst = FALSE;
-	}
-
-	/* Default for extra information is not valid */
-	pAd->ExtraInfo = EXTRA_INFO_CLEAR;
-
-	/* Default Config change flag */
-	pAd->bConfigChanged = FALSE;
-
-	/* */
-	/* part III. AP configurations */
-	/* */
-
-	/* */
-	/* part IV. others */
-	/* */
-	/* dynamic BBP R66:sensibity tuning to overcome background noise */
-	pAd->BbpTuning.bEnable = TRUE;
-	pAd->BbpTuning.FalseCcaLowerThreshold = 100;
-	pAd->BbpTuning.FalseCcaUpperThreshold = 512;
-	pAd->BbpTuning.R66Delta = 4;
-	pAd->Mlme.bEnableAutoAntennaCheck = TRUE;
-
-	/* */
-	/* Also initial R66CurrentValue, RTUSBResumeMsduTransmission might use this value. */
-	/* if not initial this value, the default value will be 0. */
-	/* */
-	pAd->BbpTuning.R66CurrentValue = 0x38;
-
-	pAd->Bbp94 = BBPR94_DEFAULT;
-	pAd->BbpForCCK = FALSE;
-
-	/* Default is FALSE for test bit 1 */
-	/*pAd->bTest1 = FALSE; */
-
-	/* initialize MAC table and allocate spin lock */
-	NdisZeroMemory(&pAd->MacTab, sizeof(struct rt_mac_table));
-	InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
-	NdisAllocateSpinLock(&pAd->MacTabLock);
-
-	/*RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE); */
-	/*RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV); */
-
-	pAd->CommonCfg.bWiFiTest = FALSE;
-#ifdef RTMP_MAC_PCI
-	pAd->bPCIclkOff = FALSE;
-#endif /* RTMP_MAC_PCI // */
-
-	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-	DBGPRINT(RT_DEBUG_TRACE, ("<-- UserCfgInit\n"));
-}
-
-/* IRQL = PASSIVE_LEVEL */
-/* */
-/*  FUNCTION: AtoH(char *, u8 *, int) */
-/* */
-/*  PURPOSE:  Converts ascii string to network order hex */
-/* */
-/*  PARAMETERS: */
-/*    src    - pointer to input ascii string */
-/*    dest   - pointer to output hex */
-/*    destlen - size of dest */
-/* */
-/*  COMMENTS: */
-/* */
-/*    2 ascii bytes make a hex byte so must put 1st ascii byte of pair */
-/*    into upper nibble and 2nd ascii byte of pair into lower nibble. */
-/* */
-/* IRQL = PASSIVE_LEVEL */
-
-void AtoH(char *src, u8 *dest, int destlen)
-{
-	char *srcptr;
-	u8 *destTemp;
-
-	srcptr = src;
-	destTemp = (u8 *)dest;
-
-	while (destlen--) {
-		*destTemp = hex_to_bin(*srcptr++) << 4;	/* Put 1st ascii byte in upper nibble. */
-		*destTemp += hex_to_bin(*srcptr++);	/* Add 2nd ascii byte to above. */
-		destTemp++;
-	}
-}
-
-/*+++Mark by shiang, not use now, need to remove after confirm */
-/*---Mark by shiang, not use now, need to remove after confirm */
-
-/*
-	========================================================================
-
-	Routine Description:
-		Init timer objects
-
-	Arguments:
-		pAd			Pointer to our adapter
-		pTimer				Timer structure
-		pTimerFunc			Function to execute when timer expired
-		Repeat				Ture for period timer
-
-	Return Value:
-		None
-
-	Note:
-
-	========================================================================
-*/
-void RTMPInitTimer(struct rt_rtmp_adapter *pAd,
-		   struct rt_ralink_timer *pTimer,
-		   void *pTimerFunc, void *pData, IN BOOLEAN Repeat)
-{
-	/* */
-	/* Set Valid to TRUE for later used. */
-	/* It will crash if we cancel a timer or set a timer */
-	/* that we haven't initialize before. */
-	/* */
-	pTimer->Valid = TRUE;
-
-	pTimer->PeriodicType = Repeat;
-	pTimer->State = FALSE;
-	pTimer->cookie = (unsigned long)pData;
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-	pTimer->pAd = pAd;
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
-
-	RTMP_OS_Init_Timer(pAd, &pTimer->TimerObj, pTimerFunc, (void *)pTimer);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Init timer objects
-
-	Arguments:
-		pTimer				Timer structure
-		Value				Timer value in milliseconds
-
-	Return Value:
-		None
-
-	Note:
-		To use this routine, must call RTMPInitTimer before.
-
-	========================================================================
-*/
-void RTMPSetTimer(struct rt_ralink_timer *pTimer, unsigned long Value)
-{
-	if (pTimer->Valid) {
-		pTimer->TimerValue = Value;
-		pTimer->State = FALSE;
-		if (pTimer->PeriodicType == TRUE) {
-			pTimer->Repeat = TRUE;
-			RTMP_SetPeriodicTimer(&pTimer->TimerObj, Value);
-		} else {
-			pTimer->Repeat = FALSE;
-			RTMP_OS_Add_Timer(&pTimer->TimerObj, Value);
-		}
-	} else {
-		DBGPRINT_ERR("RTMPSetTimer failed, Timer hasn't been initialize!\n");
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Init timer objects
-
-	Arguments:
-		pTimer				Timer structure
-		Value				Timer value in milliseconds
-
-	Return Value:
-		None
-
-	Note:
-		To use this routine, must call RTMPInitTimer before.
-
-	========================================================================
-*/
-void RTMPModTimer(struct rt_ralink_timer *pTimer, unsigned long Value)
-{
-	BOOLEAN Cancel;
-
-	if (pTimer->Valid) {
-		pTimer->TimerValue = Value;
-		pTimer->State = FALSE;
-		if (pTimer->PeriodicType == TRUE) {
-			RTMPCancelTimer(pTimer, &Cancel);
-			RTMPSetTimer(pTimer, Value);
-		} else {
-			RTMP_OS_Mod_Timer(&pTimer->TimerObj, Value);
-		}
-	} else {
-		DBGPRINT_ERR("RTMPModTimer failed, Timer hasn't been initialize!\n");
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Cancel timer objects
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		1.) To use this routine, must call RTMPInitTimer before.
-		2.) Reset NIC to initial state AS IS system boot up time.
-
-	========================================================================
-*/
-void RTMPCancelTimer(struct rt_ralink_timer *pTimer, OUT BOOLEAN * pCancelled)
-{
-	if (pTimer->Valid) {
-		if (pTimer->State == FALSE)
-			pTimer->Repeat = FALSE;
-
-		RTMP_OS_Del_Timer(&pTimer->TimerObj, pCancelled);
-
-		if (*pCancelled == TRUE)
-			pTimer->State = TRUE;
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-		/* We need to go-through the TimerQ to findout this timer handler and remove it if */
-		/*              it's still waiting for execution. */
-		RtmpTimerQRemove(pTimer->pAd, pTimer);
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
-	} else {
-		DBGPRINT_ERR("RTMPCancelTimer failed, Timer hasn't been initialize!\n");
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Set LED Status
-
-	Arguments:
-		pAd						Pointer to our adapter
-		Status					LED Status
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPSetLED(struct rt_rtmp_adapter *pAd, u8 Status)
-{
-	/*unsigned long                 data; */
-	u8 HighByte = 0;
-	u8 LowByte;
-
-	LowByte = pAd->LedCntl.field.LedMode & 0x7f;
-	switch (Status) {
-	case LED_LINK_DOWN:
-		HighByte = 0x20;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		pAd->LedIndicatorStrength = 0;
-		break;
-	case LED_LINK_UP:
-		if (pAd->CommonCfg.Channel > 14)
-			HighByte = 0xa0;
-		else
-			HighByte = 0x60;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	case LED_RADIO_ON:
-		HighByte = 0x20;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	case LED_HALT:
-		LowByte = 0;	/* Driver sets MAC register and MAC controls LED */
-	case LED_RADIO_OFF:
-		HighByte = 0;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	case LED_WPS:
-		HighByte = 0x10;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	case LED_ON_SITE_SURVEY:
-		HighByte = 0x08;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	case LED_POWER_UP:
-		HighByte = 0x04;
-		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-		break;
-	default:
-		DBGPRINT(RT_DEBUG_WARN,
-			 ("RTMPSetLED::Unknown Status %d\n", Status));
-		break;
-	}
-
-	/* */
-	/* Keep LED status for LED SiteSurvey mode. */
-	/* After SiteSurvey, we will set the LED mode to previous status. */
-	/* */
-	if ((Status != LED_ON_SITE_SURVEY) && (Status != LED_POWER_UP))
-		pAd->LedStatus = Status;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPSetLED::Mode=%d,HighByte=0x%02x,LowByte=0x%02x\n",
-		  pAd->LedCntl.field.LedMode, HighByte, LowByte));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Set LED Signal Strength
-
-	Arguments:
-		pAd						Pointer to our adapter
-		Dbm						Signal Strength
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-
-	Note:
-		Can be run on any IRQL level.
-
-		According to Microsoft Zero Config Wireless Signal Strength definition as belows.
-		<= -90  No Signal
-		<= -81  Very Low
-		<= -71  Low
-		<= -67  Good
-		<= -57  Very Good
-		 > -57  Excellent
-	========================================================================
-*/
-void RTMPSetSignalLED(struct rt_rtmp_adapter *pAd, IN NDIS_802_11_RSSI Dbm)
-{
-	u8 nLed = 0;
-
-	if (pAd->LedCntl.field.LedMode == LED_MODE_SIGNAL_STREGTH) {
-		if (Dbm <= -90)
-			nLed = 0;
-		else if (Dbm <= -81)
-			nLed = 1;
-		else if (Dbm <= -71)
-			nLed = 3;
-		else if (Dbm <= -67)
-			nLed = 7;
-		else if (Dbm <= -57)
-			nLed = 15;
-		else
-			nLed = 31;
-
-		/* */
-		/* Update Signal Strength to firmware if changed. */
-		/* */
-		if (pAd->LedIndicatorStrength != nLed) {
-			AsicSendCommandToMcu(pAd, 0x51, 0xff, nLed,
-					     pAd->LedCntl.field.Polarity);
-			pAd->LedIndicatorStrength = nLed;
-		}
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Enable RX
-
-	Arguments:
-		pAd						Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL <= DISPATCH_LEVEL
-
-	Note:
-		Before Enable RX, make sure you have enabled Interrupt.
-	========================================================================
-*/
-void RTMPEnableRxTx(struct rt_rtmp_adapter *pAd)
-{
-/*      WPDMA_GLO_CFG_STRUC     GloCfg; */
-/*      unsigned long   i = 0; */
-	u32 rx_filter_flag;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPEnableRxTx\n"));
-
-	/* Enable Rx DMA. */
-	RT28XXDMAEnable(pAd);
-
-	/* enable RX of MAC block */
-	if (pAd->OpMode == OPMODE_AP) {
-		rx_filter_flag = APNORMAL;
-
-		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);	/* enable RX of DMA block */
-	} else {
-		if (pAd->CommonCfg.PSPXlink)
-			rx_filter_flag = PSPXLINK;
-		else
-			rx_filter_flag = STANORMAL;	/* Station not drop control frame will fail WiFi Certification. */
-		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);
-	}
-
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0xc);
-	DBGPRINT(RT_DEBUG_TRACE, ("<== RTMPEnableRxTx\n"));
-}
-
-/*+++Add by shiang, move from os/linux/rt_main_dev.c */
-void CfgInitHook(struct rt_rtmp_adapter *pAd)
-{
-	pAd->bBroadComHT = TRUE;
-}
-
-int rt28xx_init(struct rt_rtmp_adapter *pAd,
-		char *pDefaultMac, char *pHostName)
-{
-	u32 index;
-	u8 TmpPhy;
-	int Status;
-	u32 MacCsr0 = 0;
-
-#ifdef RTMP_MAC_PCI
-	{
-		/* If dirver doesn't wake up firmware here, */
-		/* NICLoadFirmware will hang forever when interface is up again. */
-		/* RT2860 PCI */
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) &&
-		    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-			AUTO_WAKEUP_STRUC AutoWakeupCfg;
-			AsicForceWakeup(pAd, TRUE);
-			AutoWakeupCfg.word = 0;
-			RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG,
-					AutoWakeupCfg.word);
-			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	/* reset Adapter flags */
-	RTMP_CLEAR_FLAGS(pAd);
-
-	/* Init BssTab & ChannelInfo tabbles for auto channel select. */
-
-	/* Allocate BA Reordering memory */
-	ba_reordering_resource_init(pAd, MAX_REORDERING_MPDU_NUM);
-
-	/* Make sure MAC gets ready. */
-	index = 0;
-	do {
-		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
-		pAd->MACVersion = MacCsr0;
-
-		if ((pAd->MACVersion != 0x00)
-		    && (pAd->MACVersion != 0xFFFFFFFF))
-			break;
-
-		RTMPusecDelay(10);
-	} while (index++ < 100);
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
-
-#ifdef RTMP_MAC_PCI
-#ifdef PCIE_PS_SUPPORT
-	/*Iverson patch PCIE L1 issue to make sure that driver can be read,write ,BBP and RF register  at pcie L.1 level */
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-		RTMP_IO_READ32(pAd, AUX_CTRL, &MacCsr0);
-		MacCsr0 |= 0x402;
-		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacCsr0);
-		DBGPRINT(RT_DEBUG_TRACE, ("AUX_CTRL = 0x%x\n", MacCsr0));
-	}
-#endif /* PCIE_PS_SUPPORT // */
-
-	/* To fix driver disable/enable hang issue when radio off */
-	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x2);
-#endif /* RTMP_MAC_PCI // */
-
-	/* Disable DMA */
-	RT28XXDMADisable(pAd);
-
-	/* Load 8051 firmware */
-	Status = NICLoadFirmware(pAd);
-	if (Status != NDIS_STATUS_SUCCESS) {
-		DBGPRINT_ERR("NICLoadFirmware failed, Status[=0x%08x]\n", Status);
-		goto err1;
-	}
-
-	NICLoadRateSwitchingParams(pAd);
-
-	/* Disable interrupts here which is as soon as possible */
-	/* This statement should never be true. We might consider to remove it later */
-#ifdef RTMP_MAC_PCI
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
-		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	Status = RTMPAllocTxRxRingMemory(pAd);
-	if (Status != NDIS_STATUS_SUCCESS) {
-		DBGPRINT_ERR("RTMPAllocDMAMemory failed, Status[=0x%08x]\n", Status);
-		goto err1;
-	}
-
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
-
-	/* initialize MLME */
-	/* */
-
-	Status = RtmpMgmtTaskInit(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-		goto err2;
-
-	Status = MlmeInit(pAd);
-	if (Status != NDIS_STATUS_SUCCESS) {
-		DBGPRINT_ERR("MlmeInit failed, Status[=0x%08x]\n", Status);
-		goto err2;
-	}
-	/* Initialize pAd->StaCfg, pAd->ApCfg, pAd->CommonCfg to manufacture default */
-	/* */
-	UserCfgInit(pAd);
-	Status = RtmpNetTaskInit(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-		goto err3;
-
-/*      COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr); */
-/*      pAd->bForcePrintTX = TRUE; */
-
-	CfgInitHook(pAd);
-
-	NdisAllocateSpinLock(&pAd->MacTabLock);
-
-	MeasureReqTabInit(pAd);
-	TpcReqTabInit(pAd);
-
-	/* */
-	/* Init the hardware, we need to init asic before read registry, otherwise mac register will be reset */
-	/* */
-	Status = NICInitializeAdapter(pAd, TRUE);
-	if (Status != NDIS_STATUS_SUCCESS) {
-		DBGPRINT_ERR("NICInitializeAdapter failed, Status[=0x%08x]\n", Status);
-		if (Status != NDIS_STATUS_SUCCESS)
-			goto err3;
-	}
-
-	DBGPRINT(RT_DEBUG_OFF, ("1. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
-
-#ifdef RTMP_MAC_USB
-	pAd->CommonCfg.bMultipleIRP = FALSE;
-
-	if (pAd->CommonCfg.bMultipleIRP)
-		pAd->CommonCfg.NumOfBulkInIRP = RX_RING_SIZE;
-	else
-		pAd->CommonCfg.NumOfBulkInIRP = 1;
-#endif /* RTMP_MAC_USB // */
-
-	/*Init Ba Capability parameters. */
-/*      RT28XX_BA_INIT(pAd); */
-	pAd->CommonCfg.DesiredHtPhy.MpduDensity =
-	    (u8)pAd->CommonCfg.BACapability.field.MpduDensity;
-	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
-	    (u16)pAd->CommonCfg.BACapability.field.AmsduEnable;
-	pAd->CommonCfg.DesiredHtPhy.AmsduSize =
-	    (u16)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.DesiredHtPhy.MimoPs =
-	    (u16)pAd->CommonCfg.BACapability.field.MMPSmode;
-	/* UPdata to HT IE */
-	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs =
-	    (u16)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize =
-	    (u16)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity =
-	    (u8)pAd->CommonCfg.BACapability.field.MpduDensity;
-
-	/* after reading Registry, we now know if in AP mode or STA mode */
-
-	/* Load 8051 firmware; crash when FW image not existent */
-	/* Status = NICLoadFirmware(pAd); */
-	/* if (Status != NDIS_STATUS_SUCCESS) */
-	/*    break; */
-
-	DBGPRINT(RT_DEBUG_OFF, ("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
-
-	/* We should read EEPROM for all cases.  rt2860b */
-	NICReadEEPROMParameters(pAd, (u8 *)pDefaultMac);
-
-	DBGPRINT(RT_DEBUG_OFF, ("3. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
-
-	NICInitAsicFromEEPROM(pAd);	/*rt2860b */
-
-	/* Set PHY to appropriate mode */
-	TmpPhy = pAd->CommonCfg.PhyMode;
-	pAd->CommonCfg.PhyMode = 0xff;
-	RTMPSetPhyMode(pAd, TmpPhy);
-	SetCommonHT(pAd);
-
-	/* No valid channels. */
-	if (pAd->ChannelListNum == 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Wrong configuration. No valid channel found. Check \"ContryCode\" and \"ChannelGeography\" setting.\n"));
-		goto err4;
-	}
-
-	DBGPRINT(RT_DEBUG_OFF,
-		 ("MCS Set = %02x %02x %02x %02x %02x\n",
-		  pAd->CommonCfg.HtCapability.MCSSet[0],
-		  pAd->CommonCfg.HtCapability.MCSSet[1],
-		  pAd->CommonCfg.HtCapability.MCSSet[2],
-		  pAd->CommonCfg.HtCapability.MCSSet[3],
-		  pAd->CommonCfg.HtCapability.MCSSet[4]));
-
-#ifdef RTMP_RF_RW_SUPPORT
-	/*Init RT30xx RFRegisters after read RFIC type from EEPROM */
-	NICInitRFRegisters(pAd);
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-/*              APInitialize(pAd); */
-
-	/* */
-	/* Initialize RF register to default value */
-	/* */
-	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-
-	/* 8051 firmware require the signal during booting time. */
-	/*2008/11/28:KH marked the following codes to patch Frequency offset bug */
-	/*AsicSendCommandToMcu(pAd, 0x72, 0xFF, 0x00, 0x00); */
-
-	if (pAd && (Status != NDIS_STATUS_SUCCESS)) {
-		/* */
-		/* Undo everything if it failed */
-		/* */
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-/*                      NdisMDeregisterInterrupt(&pAd->Interrupt); */
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
-		}
-/*              RTMPFreeAdapter(pAd); // we will free it in disconnect() */
-	} else if (pAd) {
-		/* Microsoft HCT require driver send a disconnect event after driver initialization. */
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-/*              pAd->IndicateMediaState = NdisMediaStateDisconnected; */
-		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("NDIS_STATUS_MEDIA_DISCONNECT Event B!\n"));
-
-#ifdef RTMP_MAC_USB
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
-
-		/* */
-		/* Support multiple BulkIn IRP, */
-		/* the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1. */
-		/* */
-		for (index = 0; index < pAd->CommonCfg.NumOfBulkInIRP; index++) {
-			RTUSBBulkReceive(pAd);
-			DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBulkReceive!\n"));
-		}
-#endif /* RTMP_MAC_USB // */
-	}			/* end of else */
-
-	/* Set up the Mac address */
-	RtmpOSNetDevAddrSet(pAd->net_dev, &pAd->CurrentAddress[0]);
-
-	DBGPRINT_S(Status, ("<==== rt28xx_init, Status=%x\n", Status));
-
-	return TRUE;
-
-err4:
-err3:
-	MlmeHalt(pAd);
-err2:
-	RTMPFreeTxRxRingMemory(pAd);
-err1:
-
-	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);	/* free BA pool */
-
-	/* shall not set priv to NULL here because the priv didn't been free yet. */
-	/*net_dev->ml_priv = 0; */
-#ifdef ST
-err0:
-#endif /* ST // */
-
-	DBGPRINT(RT_DEBUG_ERROR, ("rt28xx Initialized fail!\n"));
-	return FALSE;
-}
-
-/*---Add by shiang, move from os/linux/rt_main_dev.c */
-
-static int RtmpChipOpsRegister(struct rt_rtmp_adapter *pAd, int infType)
-{
-	struct rt_rtmp_chip_op *pChipOps = &pAd->chipOps;
-	int status;
-
-	memset(pChipOps, 0, sizeof(struct rt_rtmp_chip_op));
-
-	/* set eeprom related hook functions */
-	status = RtmpChipOpsEepromHook(pAd, infType);
-
-	/* set mcu related hook functions */
-	switch (infType) {
-#ifdef RTMP_PCI_SUPPORT
-	case RTMP_DEV_INF_PCI:
-		pChipOps->loadFirmware = RtmpAsicLoadFirmware;
-		pChipOps->eraseFirmware = RtmpAsicEraseFirmware;
-		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
-		break;
-#endif /* RTMP_PCI_SUPPORT // */
-#ifdef RTMP_USB_SUPPORT
-	case RTMP_DEV_INF_USB:
-		pChipOps->loadFirmware = RtmpAsicLoadFirmware;
-		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
-		break;
-#endif /* RTMP_USB_SUPPORT // */
-	default:
-		break;
-	}
-
-	return status;
-}
-
-int RtmpRaDevCtrlInit(struct rt_rtmp_adapter *pAd, IN RTMP_INF_TYPE infType)
-{
-	/*void  *handle; */
-
-	/* Assign the interface type. We need use it when do register/EEPROM access. */
-	pAd->infType = infType;
-
-	pAd->OpMode = OPMODE_STA;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("STA Driver version-%s\n", STA_DRIVER_VERSION));
-
-#ifdef RTMP_MAC_USB
-	sema_init(&(pAd->UsbVendorReq_semaphore), 1);
-	os_alloc_mem(pAd, (u8 **) & pAd->UsbVendorReqBuf,
-		     MAX_PARAM_BUFFER_SIZE - 1);
-	if (pAd->UsbVendorReqBuf == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Allocate vendor request temp buffer failed!\n"));
-		return FALSE;
-	}
-#endif /* RTMP_MAC_USB // */
-
-	RtmpChipOpsRegister(pAd, infType);
-
-	return 0;
-}
-
-BOOLEAN RtmpRaDevCtrlExit(struct rt_rtmp_adapter *pAd)
-{
-
-	RTMPFreeAdapter(pAd);
-
-	return TRUE;
-}
-
-/* not yet support MBSS */
-struct net_device *get_netdev_from_bssid(struct rt_rtmp_adapter *pAd, u8 FromWhichBSSID)
-{
-	struct net_device *dev_p = NULL;
-
-	{
-		dev_p = pAd->net_dev;
-	}
-
-	ASSERT(dev_p);
-	return dev_p;		/* return one of MBSS */
-}
diff --git a/drivers/staging/rt2860/common/rtmp_mcu.c b/drivers/staging/rt2860/common/rtmp_mcu.c
deleted file mode 100644
index 80fa416..0000000
--- a/drivers/staging/rt2860/common/rtmp_mcu.c
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_mcu.c
-
-	Abstract:
-	Miniport generic portion header file
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#include	"../rt_config.h"
-
-#include <linux/crc-ccitt.h>
-#include <linux/firmware.h>
-
-#ifdef RTMP_MAC_USB
-
-#define FIRMWAREIMAGE_LENGTH		0x1000
-
-#define FIRMWARE_2870_MIN_VERSION	12
-#define FIRMWARE_2870_FILENAME		"rt2870.bin"
-MODULE_FIRMWARE(FIRMWARE_2870_FILENAME);
-
-#define FIRMWARE_3070_MIN_VERSION	17
-#define FIRMWARE_3070_FILENAME		"rt3070.bin"
-MODULE_FIRMWARE(FIRMWARE_3070_FILENAME);
-
-#define FIRMWARE_3071_MIN_VERSION	17
-#define FIRMWARE_3071_FILENAME		"rt3071.bin"	/* for RT3071/RT3072 */
-MODULE_FIRMWARE(FIRMWARE_3071_FILENAME);
-
-#else /* RTMP_MAC_PCI */
-
-#define FIRMWAREIMAGE_LENGTH		0x2000
-
-#define FIRMWARE_2860_MIN_VERSION	11
-#define FIRMWARE_2860_FILENAME		"rt2860.bin"
-MODULE_FIRMWARE(FIRMWARE_2860_FILENAME);
-
-#define FIRMWARE_3090_MIN_VERSION	19
-#define FIRMWARE_3090_FILENAME		"rt3090.bin"	/* for RT3090/RT3390 */
-MODULE_FIRMWARE(FIRMWARE_3090_FILENAME);
-
-#endif
-
-/*
-	========================================================================
-
-	Routine Description:
-		erase 8051 firmware image in MAC ASIC
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-int RtmpAsicEraseFirmware(struct rt_rtmp_adapter *pAd)
-{
-	unsigned long i;
-
-	for (i = 0; i < MAX_FIRMWARE_IMAGE_SIZE; i += 4)
-		RTMP_IO_WRITE32(pAd, FIRMWARE_IMAGE_BASE + i, 0);
-
-	return 0;
-}
-
-static const struct firmware *rtmp_get_firmware(struct rt_rtmp_adapter *adapter)
-{
-	const char *name;
-	const struct firmware *fw = NULL;
-	u8 min_version;
-	struct device *dev;
-	int err;
-
-	if (adapter->firmware)
-		return adapter->firmware;
-
-#ifdef RTMP_MAC_USB
-	if (IS_RT3071(adapter)) {
-		name = FIRMWARE_3071_FILENAME;
-		min_version = FIRMWARE_3071_MIN_VERSION;
-	} else if (IS_RT3070(adapter)) {
-		name = FIRMWARE_3070_FILENAME;
-		min_version = FIRMWARE_3070_MIN_VERSION;
-	} else {
-		name = FIRMWARE_2870_FILENAME;
-		min_version = FIRMWARE_2870_MIN_VERSION;
-	}
-	dev = &((struct os_cookie *)adapter->OS_Cookie)->pUsb_Dev->dev;
-#else /* RTMP_MAC_PCI */
-	if (IS_RT3090(adapter) || IS_RT3390(adapter)) {
-		name = FIRMWARE_3090_FILENAME;
-		min_version = FIRMWARE_3090_MIN_VERSION;
-	} else {
-		name = FIRMWARE_2860_FILENAME;
-		min_version = FIRMWARE_2860_MIN_VERSION;
-	}
-	dev = &((struct os_cookie *)adapter->OS_Cookie)->pci_dev->dev;
-#endif
-
-	err = request_firmware(&fw, name, dev);
-	if (err) {
-		dev_err(dev, "firmware file %s request failed (%d)\n",
-			name, err);
-		return NULL;
-	}
-
-	if (fw->size < FIRMWAREIMAGE_LENGTH) {
-		dev_err(dev, "firmware file %s size is invalid\n", name);
-		goto invalid;
-	}
-
-	/* is it new enough? */
-	adapter->FirmwareVersion = fw->data[FIRMWAREIMAGE_LENGTH - 3];
-	if (adapter->FirmwareVersion < min_version) {
-		dev_err(dev,
-			"firmware file %s is too old;"
-			" driver requires v%d or later\n",
-			name, min_version);
-		goto invalid;
-	}
-
-	/* is the internal CRC correct? */
-	if (crc_ccitt(0xffff, fw->data, FIRMWAREIMAGE_LENGTH - 2) !=
-	    (fw->data[FIRMWAREIMAGE_LENGTH - 2] |
-	     (fw->data[FIRMWAREIMAGE_LENGTH - 1] << 8))) {
-		dev_err(dev, "firmware file %s failed internal CRC\n", name);
-		goto invalid;
-	}
-
-	adapter->firmware = fw;
-	return fw;
-
-invalid:
-	release_firmware(fw);
-	return NULL;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Load 8051 firmware file into MAC ASIC
-
-	Arguments:
-		Adapter						Pointer to our adapter
-
-	Return Value:
-		NDIS_STATUS_SUCCESS         firmware image load ok
-		NDIS_STATUS_FAILURE         image not found
-
-	IRQL = PASSIVE_LEVEL
-
-	========================================================================
-*/
-int RtmpAsicLoadFirmware(struct rt_rtmp_adapter *pAd)
-{
-	const struct firmware *fw;
-	int Status = NDIS_STATUS_SUCCESS;
-	unsigned long Index;
-	u32 MacReg = 0;
-
-	fw = rtmp_get_firmware(pAd);
-	if (!fw)
-		return NDIS_STATUS_FAILURE;
-
-	RTMP_WRITE_FIRMWARE(pAd, fw->data, FIRMWAREIMAGE_LENGTH);
-
-	/* check if MCU is ready */
-	Index = 0;
-	do {
-		RTMP_IO_READ32(pAd, PBF_SYS_CTRL, &MacReg);
-
-		if (MacReg & 0x80)
-			break;
-
-		RTMPusecDelay(1000);
-	} while (Index++ < 1000);
-
-	if (Index > 1000) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("NICLoadFirmware: MCU is not ready\n"));
-		Status = NDIS_STATUS_FAILURE;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== %s (status=%d)\n", __func__, Status));
-
-	return Status;
-}
-
-int RtmpAsicSendCommandToMcu(struct rt_rtmp_adapter *pAd,
-			     u8 Command,
-			     u8 Token, u8 Arg0, u8 Arg1)
-{
-	HOST_CMD_CSR_STRUC H2MCmd;
-	H2M_MAILBOX_STRUC H2MMailbox;
-	unsigned long i = 0;
-
-#ifdef PCIE_PS_SUPPORT
-	/* 3090F power solution 3 has hw limitation that needs to ban all mcu command */
-	/* when firmware is in radio state.  For other chip doesn't have this limitation. */
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
-		RTMP_SEM_LOCK(&pAd->McuCmdLock);
-		if ((pAd->brt30xxBanMcuCmd == TRUE)
-		    && (Command != WAKE_MCU_CMD) && (Command != RFOFF_MCU_CMD)) {
-			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 (" Ban Mcu Cmd %x in sleep mode\n", Command));
-			return FALSE;
-		} else if ((Command == SLEEP_MCU_CMD)
-			   || (Command == RFOFF_MCU_CMD)) {
-			pAd->brt30xxBanMcuCmd = TRUE;
-		} else if (Command != WAKE_MCU_CMD) {
-			pAd->brt30xxBanMcuCmd = FALSE;
-		}
-
-		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-
-	}
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	    && (Command == WAKE_MCU_CMD)) {
-
-		do {
-			RTMP_IO_FORCE_READ32(pAd, H2M_MAILBOX_CSR,
-					     &H2MMailbox.word);
-			if (H2MMailbox.field.Owner == 0)
-				break;
-
-			RTMPusecDelay(2);
-			DBGPRINT(RT_DEBUG_INFO,
-				 ("AsicSendCommanToMcu::Mail box is busy\n"));
-		} while (i++ < 100);
-
-		if (i > 100) {
-			DBGPRINT_ERR("H2M_MAILBOX still hold by MCU. command fail\n");
-			return FALSE;
-		}
-
-		H2MMailbox.field.Owner = 1;	/* pass ownership to MCU */
-		H2MMailbox.field.CmdToken = Token;
-		H2MMailbox.field.HighByte = Arg1;
-		H2MMailbox.field.LowByte = Arg0;
-		RTMP_IO_FORCE_WRITE32(pAd, H2M_MAILBOX_CSR, H2MMailbox.word);
-
-		H2MCmd.word = 0;
-		H2MCmd.field.HostCommand = Command;
-		RTMP_IO_FORCE_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
-
-	} else
-#endif /* PCIE_PS_SUPPORT // */
-	{
-		do {
-			RTMP_IO_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
-			if (H2MMailbox.field.Owner == 0)
-				break;
-
-			RTMPusecDelay(2);
-		} while (i++ < 100);
-
-		if (i > 100) {
-#ifdef RTMP_MAC_PCI
-#endif /* RTMP_MAC_PCI // */
-			{
-				DBGPRINT_ERR("H2M_MAILBOX still hold by MCU. command fail\n");
-			}
-			return FALSE;
-		}
-#ifdef RTMP_MAC_PCI
-#endif /* RTMP_MAC_PCI // */
-
-		H2MMailbox.field.Owner = 1;	/* pass ownership to MCU */
-		H2MMailbox.field.CmdToken = Token;
-		H2MMailbox.field.HighByte = Arg1;
-		H2MMailbox.field.LowByte = Arg0;
-		RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, H2MMailbox.word);
-
-		H2MCmd.word = 0;
-		H2MCmd.field.HostCommand = Command;
-		RTMP_IO_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
-
-		if (Command != 0x80) {
-		}
-	}
-#ifdef PCIE_PS_SUPPORT
-	/* 3090 MCU Wakeup command needs more time to be stable. */
-	/* Before stable, don't issue other MCU command to prevent from firmware error. */
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	    && (Command == WAKE_MCU_CMD)) {
-		RTMPusecDelay(2000);
-		/*Put this is after RF programming. */
-		/*NdisAcquireSpinLock(&pAd->McuCmdLock); */
-		/*pAd->brt30xxBanMcuCmd = FALSE; */
-		/*NdisReleaseSpinLock(&pAd->McuCmdLock); */
-	}
-#endif /* PCIE_PS_SUPPORT // */
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/common/rtmp_timer.c b/drivers/staging/rt2860/common/rtmp_timer.c
deleted file mode 100644
index ab52090..0000000
--- a/drivers/staging/rt2860/common/rtmp_timer.c
+++ /dev/null
@@ -1,302 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rtmp_timer.c
-
-    Abstract:
-    task for timer handling
-
-    Revision History:
-    Who         When            What
-    --------    ----------      ----------------------------------------------
-    Name          Date            Modification logs
-    Shiang Tu	08-28-2008   init version
-
-*/
-
-#include "../rt_config.h"
-
-BUILD_TIMER_FUNCTION(MlmePeriodicExec);
-/*BUILD_TIMER_FUNCTION(MlmeRssiReportExec); */
-BUILD_TIMER_FUNCTION(AsicRxAntEvalTimeout);
-BUILD_TIMER_FUNCTION(APSDPeriodicExec);
-BUILD_TIMER_FUNCTION(AsicRfTuningExec);
-#ifdef RTMP_MAC_USB
-BUILD_TIMER_FUNCTION(BeaconUpdateExec);
-#endif /* RTMP_MAC_USB // */
-
-BUILD_TIMER_FUNCTION(BeaconTimeout);
-BUILD_TIMER_FUNCTION(ScanTimeout);
-BUILD_TIMER_FUNCTION(AuthTimeout);
-BUILD_TIMER_FUNCTION(AssocTimeout);
-BUILD_TIMER_FUNCTION(ReassocTimeout);
-BUILD_TIMER_FUNCTION(DisassocTimeout);
-BUILD_TIMER_FUNCTION(LinkDownExec);
-BUILD_TIMER_FUNCTION(StaQuickResponeForRateUpExec);
-BUILD_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
-#ifdef RTMP_MAC_PCI
-BUILD_TIMER_FUNCTION(PsPollWakeExec);
-BUILD_TIMER_FUNCTION(RadioOnExec);
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-BUILD_TIMER_FUNCTION(RtmpUsbStaAsicForceWakeupTimeout);
-#endif /* RTMP_MAC_USB // */
-
-#if defined(AP_LED) || defined(STA_LED)
-extern void LedCtrlMain(void *SystemSpecific1,
-			void *FunctionContext,
-			void *SystemSpecific2, void *SystemSpecific3);
-BUILD_TIMER_FUNCTION(LedCtrlMain);
-#endif
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-static void RtmpTimerQHandle(struct rt_rtmp_adapter *pAd)
-{
-#ifndef KTHREAD_SUPPORT
-	int status;
-#endif
-	struct rt_ralink_timer *pTimer;
-	struct rt_rtmp_timer_task_entry *pEntry;
-	unsigned long irqFlag;
-	struct rt_rtmp_os_task *pTask;
-
-	pTask = &pAd->timerTask;
-	while (!pTask->task_killed) {
-		pTimer = NULL;
-
-#ifdef KTHREAD_SUPPORT
-		RTMP_WAIT_EVENT_INTERRUPTIBLE(pAd, pTask);
-#else
-		RTMP_SEM_EVENT_WAIT(&(pTask->taskSema), status);
-#endif
-
-		if (pAd->TimerQ.status == RTMP_TASK_STAT_STOPED)
-			break;
-
-		/* event happened. */
-		while (pAd->TimerQ.pQHead) {
-			RTMP_INT_LOCK(&pAd->TimerQLock, irqFlag);
-			pEntry = pAd->TimerQ.pQHead;
-			if (pEntry) {
-				pTimer = pEntry->pRaTimer;
-
-				/* update pQHead */
-				pAd->TimerQ.pQHead = pEntry->pNext;
-				if (pEntry == pAd->TimerQ.pQTail)
-					pAd->TimerQ.pQTail = NULL;
-
-				/* return this queue entry to timerQFreeList. */
-				pEntry->pNext = pAd->TimerQ.pQPollFreeList;
-				pAd->TimerQ.pQPollFreeList = pEntry;
-			}
-			RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlag);
-
-			if (pTimer) {
-				if ((pTimer->handle != NULL)
-				    && (!pAd->PM_FlgSuspend))
-					pTimer->handle(NULL,
-						       (void *)pTimer->cookie,
-						       NULL, pTimer);
-				if ((pTimer->Repeat)
-				    && (pTimer->State == FALSE))
-					RTMP_OS_Add_Timer(&pTimer->TimerObj,
-							  pTimer->TimerValue);
-			}
-		}
-
-#ifndef KTHREAD_SUPPORT
-		if (status != 0) {
-			pAd->TimerQ.status = RTMP_TASK_STAT_STOPED;
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-			break;
-		}
-#endif
-	}
-}
-
-int RtmpTimerQThread(IN void *Context)
-{
-	struct rt_rtmp_os_task *pTask;
-	struct rt_rtmp_adapter *pAd;
-
-	pTask = Context;
-	pAd = pTask->priv;
-
-	RtmpOSTaskCustomize(pTask);
-
-	RtmpTimerQHandle(pAd);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<---%s\n", __func__));
-#ifndef KTHREAD_SUPPORT
-	pTask->taskPID = THREAD_PID_INIT_VALUE;
-#endif
-	/* notify the exit routine that we're actually exiting now
-	 *
-	 * complete()/wait_for_completion() is similar to up()/down(),
-	 * except that complete() is safe in the case where the structure
-	 * is getting deleted in a parallel mode of execution (i.e. just
-	 * after the down() -- that's necessary for the thread-shutdown
-	 * case.
-	 *
-	 * complete_and_exit() goes even further than this -- it is safe in
-	 * the case that the thread of the caller is going away (not just
-	 * the structure) -- this is necessary for the module-remove case.
-	 * This is important in preemption kernels, which transfer the flow
-	 * of execution immediately upon a complete().
-	 */
-	RtmpOSTaskNotifyToExit(pTask);
-
-	return 0;
-
-}
-
-struct rt_rtmp_timer_task_entry *RtmpTimerQInsert(struct rt_rtmp_adapter *pAd,
-					struct rt_ralink_timer *pTimer)
-{
-	struct rt_rtmp_timer_task_entry *pQNode = NULL, *pQTail;
-	unsigned long irqFlags;
-	struct rt_rtmp_os_task *pTask = &pAd->timerTask;
-
-	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	if (pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT) {
-		if (pAd->TimerQ.pQPollFreeList) {
-			pQNode = pAd->TimerQ.pQPollFreeList;
-			pAd->TimerQ.pQPollFreeList = pQNode->pNext;
-
-			pQNode->pRaTimer = pTimer;
-			pQNode->pNext = NULL;
-
-			pQTail = pAd->TimerQ.pQTail;
-			if (pAd->TimerQ.pQTail != NULL)
-				pQTail->pNext = pQNode;
-			pAd->TimerQ.pQTail = pQNode;
-			if (pAd->TimerQ.pQHead == NULL)
-				pAd->TimerQ.pQHead = pQNode;
-		}
-	}
-	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
-
-	if (pQNode) {
-#ifdef KTHREAD_SUPPORT
-		WAKE_UP(pTask);
-#else
-		RTMP_SEM_EVENT_UP(&pTask->taskSema);
-#endif
-	}
-
-	return pQNode;
-}
-
-BOOLEAN RtmpTimerQRemove(struct rt_rtmp_adapter *pAd, struct rt_ralink_timer *pTimer)
-{
-	struct rt_rtmp_timer_task_entry *pNode, *pPrev = NULL;
-	unsigned long irqFlags;
-
-	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	if (pAd->TimerQ.status >= RTMP_TASK_STAT_INITED) {
-		pNode = pAd->TimerQ.pQHead;
-		while (pNode) {
-			if (pNode->pRaTimer == pTimer)
-				break;
-			pPrev = pNode;
-			pNode = pNode->pNext;
-		}
-
-		/* Now move it to freeList queue. */
-		if (pNode) {
-			if (pNode == pAd->TimerQ.pQHead)
-				pAd->TimerQ.pQHead = pNode->pNext;
-			if (pNode == pAd->TimerQ.pQTail)
-				pAd->TimerQ.pQTail = pPrev;
-			if (pPrev != NULL)
-				pPrev->pNext = pNode->pNext;
-
-			/* return this queue entry to timerQFreeList. */
-			pNode->pNext = pAd->TimerQ.pQPollFreeList;
-			pAd->TimerQ.pQPollFreeList = pNode;
-		}
-	}
-	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
-
-	return TRUE;
-}
-
-void RtmpTimerQExit(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rtmp_timer_task_entry *pTimerQ;
-	unsigned long irqFlags;
-
-	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	while (pAd->TimerQ.pQHead) {
-		pTimerQ = pAd->TimerQ.pQHead;
-		pAd->TimerQ.pQHead = pTimerQ->pNext;
-		/* remove the timeQ */
-	}
-	pAd->TimerQ.pQPollFreeList = NULL;
-	os_free_mem(pAd, pAd->TimerQ.pTimerQPoll);
-	pAd->TimerQ.pQTail = NULL;
-	pAd->TimerQ.pQHead = NULL;
-#ifndef KTHREAD_SUPPORT
-	pAd->TimerQ.status = RTMP_TASK_STAT_STOPED;
-#endif
-	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
-
-}
-
-void RtmpTimerQInit(struct rt_rtmp_adapter *pAd)
-{
-	int i;
-	struct rt_rtmp_timer_task_entry *pQNode, *pEntry;
-	unsigned long irqFlags;
-
-	NdisAllocateSpinLock(&pAd->TimerQLock);
-
-	NdisZeroMemory(&pAd->TimerQ, sizeof(pAd->TimerQ));
-
-	os_alloc_mem(pAd, &pAd->TimerQ.pTimerQPoll,
-		     sizeof(struct rt_rtmp_timer_task_entry) * TIMER_QUEUE_SIZE_MAX);
-	if (pAd->TimerQ.pTimerQPoll) {
-		pEntry = NULL;
-		pQNode = (struct rt_rtmp_timer_task_entry *)pAd->TimerQ.pTimerQPoll;
-		NdisZeroMemory(pAd->TimerQ.pTimerQPoll,
-			       sizeof(struct rt_rtmp_timer_task_entry) *
-			       TIMER_QUEUE_SIZE_MAX);
-
-		RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-		for (i = 0; i < TIMER_QUEUE_SIZE_MAX; i++) {
-			pQNode->pNext = pEntry;
-			pEntry = pQNode;
-			pQNode++;
-		}
-		pAd->TimerQ.pQPollFreeList = pEntry;
-		pAd->TimerQ.pQHead = NULL;
-		pAd->TimerQ.pQTail = NULL;
-		pAd->TimerQ.status = RTMP_TASK_STAT_INITED;
-		RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
-	}
-}
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
diff --git a/drivers/staging/rt2860/common/spectrum.c b/drivers/staging/rt2860/common/spectrum.c
deleted file mode 100644
index ceb622d..0000000
--- a/drivers/staging/rt2860/common/spectrum.c
+++ /dev/null
@@ -1,2205 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	action.c
-
-    Abstract:
-    Handle association related requests either from WSTA or from local MLME
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
-	Fonchi Wu    2008	  	   created for 802.11h
- */
-
-#include "../rt_config.h"
-#include "action.h"
-
-/* The regulatory information in the USA (US) */
-struct rt_dot11_regulatory_information USARegulatoryInfo[] = {
-/*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-	{0, {0, 0, {0}
-	     }
-	 }
-	,			/* Invlid entry */
-	{1, {4, 16, {36, 40, 44, 48}
-	     }
-	 }
-	,
-	{2, {4, 23, {52, 56, 60, 64}
-	     }
-	 }
-	,
-	{3, {4, 29, {149, 153, 157, 161}
-	     }
-	 }
-	,
-	{4, {11, 23, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}
-	     }
-	 }
-	,
-	{5, {5, 30, {149, 153, 157, 161, 165}
-	     }
-	 }
-	,
-	{6, {10, 14, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
-	     }
-	 }
-	,
-	{7, {10, 27, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
-	     }
-	 }
-	,
-	{8, {5, 17, {11, 13, 15, 17, 19}
-	     }
-	 }
-	,
-	{9, {5, 30, {11, 13, 15, 17, 19}
-	     }
-	 }
-	,
-	{10, {2, 20, {21, 25}
-	      }
-	 }
-	,
-	{11, {2, 33, {21, 25}
-	      }
-	 }
-	,
-	{12, {11, 30, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
-	      }
-	 }
-};
-
-#define USA_REGULATORY_INFO_SIZE (sizeof(USARegulatoryInfo) / sizeof(struct rt_dot11_regulatory_information))
-
-/* The regulatory information in Europe */
-struct rt_dot11_regulatory_information EuropeRegulatoryInfo[] = {
-/*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-	{0, {0, 0, {0}
-	     }
-	 }
-	,			/* Invalid entry */
-	{1, {4, 20, {36, 40, 44, 48}
-	     }
-	 }
-	,
-	{2, {4, 20, {52, 56, 60, 64}
-	     }
-	 }
-	,
-	{3, {11, 30, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}
-	     }
-	 }
-	,
-	{4, {13, 20, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
-	     }
-	 }
-};
-
-#define EU_REGULATORY_INFO_SIZE (sizeof(EuropeRegulatoryInfo) / sizeof(struct rt_dot11_regulatory_information))
-
-/* The regulatory information in Japan */
-struct rt_dot11_regulatory_information JapanRegulatoryInfo[] = {
-/*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-	{0, {0, 0, {0}
-	     }
-	 }
-	,			/* Invalid entry */
-	{1, {4, 22, {34, 38, 42, 46}
-	     }
-	 }
-	,
-	{2, {3, 24, {8, 12, 16}
-	     }
-	 }
-	,
-	{3, {3, 24, {8, 12, 16}
-	     }
-	 }
-	,
-	{4, {3, 24, {8, 12, 16}
-	     }
-	 }
-	,
-	{5, {3, 24, {8, 12, 16}
-	     }
-	 }
-	,
-	{6, {3, 22, {8, 12, 16}
-	     }
-	 }
-	,
-	{7, {4, 24, {184, 188, 192, 196}
-	     }
-	 }
-	,
-	{8, {4, 24, {184, 188, 192, 196}
-	     }
-	 }
-	,
-	{9, {4, 24, {184, 188, 192, 196}
-	     }
-	 }
-	,
-	{10, {4, 24, {184, 188, 192, 196}
-	      }
-	 }
-	,
-	{11, {4, 22, {184, 188, 192, 196}
-	      }
-	 }
-	,
-	{12, {4, 24, {7, 8, 9, 11}
-	      }
-	 }
-	,
-	{13, {4, 24, {7, 8, 9, 11}
-	      }
-	 }
-	,
-	{14, {4, 24, {7, 8, 9, 11}
-	      }
-	 }
-	,
-	{15, {4, 24, {7, 8, 9, 11}
-	      }
-	 }
-	,
-	{16, {6, 24, {183, 184, 185, 187, 188, 189}
-	      }
-	 }
-	,
-	{17, {6, 24, {183, 184, 185, 187, 188, 189}
-	      }
-	 }
-	,
-	{18, {6, 24, {183, 184, 185, 187, 188, 189}
-	      }
-	 }
-	,
-	{19, {6, 24, {183, 184, 185, 187, 188, 189}
-	      }
-	 }
-	,
-	{20, {6, 17, {183, 184, 185, 187, 188, 189}
-	      }
-	 }
-	,
-	{21, {6, 24, {6, 7, 8, 9, 10, 11}
-	      }
-	 }
-	,
-	{22, {6, 24, {6, 7, 8, 9, 10, 11}
-	      }
-	 }
-	,
-	{23, {6, 24, {6, 7, 8, 9, 10, 11}
-	      }
-	 }
-	,
-	{24, {6, 24, {6, 7, 8, 9, 10, 11}
-	      }
-	 }
-	,
-	{25, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
-	      }
-	 }
-	,
-	{26, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
-	      }
-	 }
-	,
-	{27, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
-	      }
-	 }
-	,
-	{28, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
-	      }
-	 }
-	,
-	{29, {8, 17, {182, 183, 184, 185, 186, 187, 188, 189}
-	      }
-	 }
-	,
-	{30, {13, 23, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
-	      }
-	 }
-	,
-	{31, {1, 23, {14}
-	      }
-	 }
-	,
-	{32, {4, 22, {52, 56, 60, 64}
-	      }
-	 }
-};
-
-#define JP_REGULATORY_INFO_SIZE (sizeof(JapanRegulatoryInfo) / sizeof(struct rt_dot11_regulatory_information))
-
-char RTMP_GetTxPwr(struct rt_rtmp_adapter *pAd, IN HTTRANSMIT_SETTING HTTxMode)
-{
-	struct tx_pwr_cfg {
-		u8 Mode;
-		u8 MCS;
-		u16 req;
-		u8 shift;
-		u32 BitMask;
-	};
-
-	u32 Value;
-	int Idx;
-	u8 PhyMode;
-	char CurTxPwr;
-	u8 TxPwrRef = 0;
-	char DaltaPwr;
-	unsigned long TxPwr[5];
-
-	struct tx_pwr_cfg TxPwrCfg[] = {
-		{MODE_CCK, 0, 0, 4, 0x000000f0},
-		{MODE_CCK, 1, 0, 0, 0x0000000f},
-		{MODE_CCK, 2, 0, 12, 0x0000f000},
-		{MODE_CCK, 3, 0, 8, 0x00000f00},
-
-		{MODE_OFDM, 0, 0, 20, 0x00f00000},
-		{MODE_OFDM, 1, 0, 16, 0x000f0000},
-		{MODE_OFDM, 2, 0, 28, 0xf0000000},
-		{MODE_OFDM, 3, 0, 24, 0x0f000000},
-		{MODE_OFDM, 4, 1, 4, 0x000000f0},
-		{MODE_OFDM, 5, 1, 0, 0x0000000f},
-		{MODE_OFDM, 6, 1, 12, 0x0000f000},
-		{MODE_OFDM, 7, 1, 8, 0x00000f00}
-		, {MODE_HTMIX, 0, 1, 20, 0x00f00000},
-		{MODE_HTMIX, 1, 1, 16, 0x000f0000},
-		{MODE_HTMIX, 2, 1, 28, 0xf0000000},
-		{MODE_HTMIX, 3, 1, 24, 0x0f000000},
-		{MODE_HTMIX, 4, 2, 4, 0x000000f0},
-		{MODE_HTMIX, 5, 2, 0, 0x0000000f},
-		{MODE_HTMIX, 6, 2, 12, 0x0000f000},
-		{MODE_HTMIX, 7, 2, 8, 0x00000f00},
-		{MODE_HTMIX, 8, 2, 20, 0x00f00000},
-		{MODE_HTMIX, 9, 2, 16, 0x000f0000},
-		{MODE_HTMIX, 10, 2, 28, 0xf0000000},
-		{MODE_HTMIX, 11, 2, 24, 0x0f000000},
-		{MODE_HTMIX, 12, 3, 4, 0x000000f0},
-		{MODE_HTMIX, 13, 3, 0, 0x0000000f},
-		{MODE_HTMIX, 14, 3, 12, 0x0000f000},
-		{MODE_HTMIX, 15, 3, 8, 0x00000f00}
-	};
-#define MAX_TXPWR_TAB_SIZE (sizeof(TxPwrCfg) / sizeof(struct tx_pwr_cfg))
-
-	CurTxPwr = 19;
-
-	/* check Tx Power setting from UI. */
-	if (pAd->CommonCfg.TxPowerPercentage > 90) ;
-	else if (pAd->CommonCfg.TxPowerPercentage > 60)	/* reduce Pwr for 1 dB. */
-		CurTxPwr -= 1;
-	else if (pAd->CommonCfg.TxPowerPercentage > 30)	/* reduce Pwr for 3 dB. */
-		CurTxPwr -= 3;
-	else if (pAd->CommonCfg.TxPowerPercentage > 15)	/* reduce Pwr for 6 dB. */
-		CurTxPwr -= 6;
-	else if (pAd->CommonCfg.TxPowerPercentage > 9)	/* reduce Pwr for 9 dB. */
-		CurTxPwr -= 9;
-	else			/* reduce Pwr for 12 dB. */
-		CurTxPwr -= 12;
-
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
-		if (pAd->CommonCfg.CentralChannel > 14) {
-			TxPwr[0] = pAd->Tx40MPwrCfgABand[0];
-			TxPwr[1] = pAd->Tx40MPwrCfgABand[1];
-			TxPwr[2] = pAd->Tx40MPwrCfgABand[2];
-			TxPwr[3] = pAd->Tx40MPwrCfgABand[3];
-			TxPwr[4] = pAd->Tx40MPwrCfgABand[4];
-		} else {
-			TxPwr[0] = pAd->Tx40MPwrCfgGBand[0];
-			TxPwr[1] = pAd->Tx40MPwrCfgGBand[1];
-			TxPwr[2] = pAd->Tx40MPwrCfgGBand[2];
-			TxPwr[3] = pAd->Tx40MPwrCfgGBand[3];
-			TxPwr[4] = pAd->Tx40MPwrCfgGBand[4];
-		}
-	} else {
-		if (pAd->CommonCfg.Channel > 14) {
-			TxPwr[0] = pAd->Tx20MPwrCfgABand[0];
-			TxPwr[1] = pAd->Tx20MPwrCfgABand[1];
-			TxPwr[2] = pAd->Tx20MPwrCfgABand[2];
-			TxPwr[3] = pAd->Tx20MPwrCfgABand[3];
-			TxPwr[4] = pAd->Tx20MPwrCfgABand[4];
-		} else {
-			TxPwr[0] = pAd->Tx20MPwrCfgGBand[0];
-			TxPwr[1] = pAd->Tx20MPwrCfgGBand[1];
-			TxPwr[2] = pAd->Tx20MPwrCfgGBand[2];
-			TxPwr[3] = pAd->Tx20MPwrCfgGBand[3];
-			TxPwr[4] = pAd->Tx20MPwrCfgGBand[4];
-		}
-	}
-
-	switch (HTTxMode.field.MODE) {
-	case MODE_CCK:
-	case MODE_OFDM:
-		Value = TxPwr[1];
-		TxPwrRef = (Value & 0x00000f00) >> 8;
-
-		break;
-
-	case MODE_HTMIX:
-	case MODE_HTGREENFIELD:
-		if (pAd->CommonCfg.TxStream == 1) {
-			Value = TxPwr[2];
-			TxPwrRef = (Value & 0x00000f00) >> 8;
-		} else if (pAd->CommonCfg.TxStream == 2) {
-			Value = TxPwr[3];
-			TxPwrRef = (Value & 0x00000f00) >> 8;
-		}
-		break;
-	}
-
-	PhyMode = (HTTxMode.field.MODE == MODE_HTGREENFIELD)
-	    ? MODE_HTMIX : HTTxMode.field.MODE;
-
-	for (Idx = 0; Idx < MAX_TXPWR_TAB_SIZE; Idx++) {
-		if ((TxPwrCfg[Idx].Mode == PhyMode)
-		    && (TxPwrCfg[Idx].MCS == HTTxMode.field.MCS)) {
-			Value = TxPwr[TxPwrCfg[Idx].req];
-			DaltaPwr =
-			    TxPwrRef - (char)((Value & TxPwrCfg[Idx].BitMask)
-					       >> TxPwrCfg[Idx].shift);
-			CurTxPwr -= DaltaPwr;
-			break;
-		}
-	}
-
-	return CurTxPwr;
-}
-
-void MeasureReqTabInit(struct rt_rtmp_adapter *pAd)
-{
-	NdisAllocateSpinLock(&pAd->CommonCfg.MeasureReqTabLock);
-
-	pAd->CommonCfg.pMeasureReqTab =
-	    kmalloc(sizeof(struct rt_measure_req_tab), GFP_ATOMIC);
-	if (pAd->CommonCfg.pMeasureReqTab)
-		NdisZeroMemory(pAd->CommonCfg.pMeasureReqTab,
-			       sizeof(struct rt_measure_req_tab));
-	else
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s Fail to alloc memory for pAd->CommonCfg.pMeasureReqTab.\n",
-			  __func__));
-
-	return;
-}
-
-void MeasureReqTabExit(struct rt_rtmp_adapter *pAd)
-{
-	NdisFreeSpinLock(&pAd->CommonCfg.MeasureReqTabLock);
-
-	kfree(pAd->CommonCfg.pMeasureReqTab);
-	pAd->CommonCfg.pMeasureReqTab = NULL;
-
-	return;
-}
-
-struct rt_measure_req_entry *MeasureReqLookUp(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	u32 HashIdx;
-	struct rt_measure_req_tab *pTab = pAd->CommonCfg.pMeasureReqTab;
-	struct rt_measure_req_entry *pEntry = NULL;
-	struct rt_measure_req_entry *pPrevEntry = NULL;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
-		return NULL;
-	}
-
-	RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
-
-	HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(DialogToken);
-	pEntry = pTab->Hash[HashIdx];
-
-	while (pEntry) {
-		if (pEntry->DialogToken == DialogToken)
-			break;
-		else {
-			pPrevEntry = pEntry;
-			pEntry = pEntry->pNext;
-		}
-	}
-
-	RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
-
-	return pEntry;
-}
-
-struct rt_measure_req_entry *MeasureReqInsert(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	int i;
-	unsigned long HashIdx;
-	struct rt_measure_req_tab *pTab = pAd->CommonCfg.pMeasureReqTab;
-	struct rt_measure_req_entry *pEntry = NULL, *pCurrEntry;
-	unsigned long Now;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
-		return NULL;
-	}
-
-	pEntry = MeasureReqLookUp(pAd, DialogToken);
-	if (pEntry == NULL) {
-		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
-		for (i = 0; i < MAX_MEASURE_REQ_TAB_SIZE; i++) {
-			NdisGetSystemUpTime(&Now);
-			pEntry = &pTab->Content[i];
-
-			if ((pEntry->Valid == TRUE)
-			    && RTMP_TIME_AFTER((unsigned long)Now,
-					       (unsigned long)(pEntry->
-							       lastTime +
-							       MQ_REQ_AGE_OUT)))
-			{
-				struct rt_measure_req_entry *pPrevEntry = NULL;
-				unsigned long HashIdx =
-				    MQ_DIALOGTOKEN_HASH_INDEX(pEntry->
-							      DialogToken);
-				struct rt_measure_req_entry *pProbeEntry =
-				    pTab->Hash[HashIdx];
-
-				/* update Hash list */
-				do {
-					if (pProbeEntry == pEntry) {
-						if (pPrevEntry == NULL) {
-							pTab->Hash[HashIdx] =
-							    pEntry->pNext;
-						} else {
-							pPrevEntry->pNext =
-							    pEntry->pNext;
-						}
-						break;
-					}
-
-					pPrevEntry = pProbeEntry;
-					pProbeEntry = pProbeEntry->pNext;
-				} while (pProbeEntry);
-
-				NdisZeroMemory(pEntry,
-					       sizeof(struct rt_measure_req_entry));
-				pTab->Size--;
-
-				break;
-			}
-
-			if (pEntry->Valid == FALSE)
-				break;
-		}
-
-		if (i < MAX_MEASURE_REQ_TAB_SIZE) {
-			NdisGetSystemUpTime(&Now);
-			pEntry->lastTime = Now;
-			pEntry->Valid = TRUE;
-			pEntry->DialogToken = DialogToken;
-			pTab->Size++;
-		} else {
-			pEntry = NULL;
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s: pMeasureReqTab tab full.\n", __func__));
-		}
-
-		/* add this Neighbor entry into HASH table */
-		if (pEntry) {
-			HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(DialogToken);
-			if (pTab->Hash[HashIdx] == NULL) {
-				pTab->Hash[HashIdx] = pEntry;
-			} else {
-				pCurrEntry = pTab->Hash[HashIdx];
-				while (pCurrEntry->pNext != NULL)
-					pCurrEntry = pCurrEntry->pNext;
-				pCurrEntry->pNext = pEntry;
-			}
-		}
-
-		RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
-	}
-
-	return pEntry;
-}
-
-void MeasureReqDelete(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	struct rt_measure_req_tab *pTab = pAd->CommonCfg.pMeasureReqTab;
-	struct rt_measure_req_entry *pEntry = NULL;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
-		return;
-	}
-	/* if empty, return */
-	if (pTab->Size == 0) {
-		DBGPRINT(RT_DEBUG_ERROR, ("pMeasureReqTab empty.\n"));
-		return;
-	}
-
-	pEntry = MeasureReqLookUp(pAd, DialogToken);
-	if (pEntry != NULL) {
-		struct rt_measure_req_entry *pPrevEntry = NULL;
-		unsigned long HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
-		struct rt_measure_req_entry *pProbeEntry = pTab->Hash[HashIdx];
-
-		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
-		/* update Hash list */
-		do {
-			if (pProbeEntry == pEntry) {
-				if (pPrevEntry == NULL) {
-					pTab->Hash[HashIdx] = pEntry->pNext;
-				} else {
-					pPrevEntry->pNext = pEntry->pNext;
-				}
-				break;
-			}
-
-			pPrevEntry = pProbeEntry;
-			pProbeEntry = pProbeEntry->pNext;
-		} while (pProbeEntry);
-
-		NdisZeroMemory(pEntry, sizeof(struct rt_measure_req_entry));
-		pTab->Size--;
-
-		RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
-	}
-
-	return;
-}
-
-void TpcReqTabInit(struct rt_rtmp_adapter *pAd)
-{
-	NdisAllocateSpinLock(&pAd->CommonCfg.TpcReqTabLock);
-
-	pAd->CommonCfg.pTpcReqTab = kmalloc(sizeof(struct rt_tpc_req_tab), GFP_ATOMIC);
-	if (pAd->CommonCfg.pTpcReqTab)
-		NdisZeroMemory(pAd->CommonCfg.pTpcReqTab, sizeof(struct rt_tpc_req_tab));
-	else
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s Fail to alloc memory for pAd->CommonCfg.pTpcReqTab.\n",
-			  __func__));
-
-	return;
-}
-
-void TpcReqTabExit(struct rt_rtmp_adapter *pAd)
-{
-	NdisFreeSpinLock(&pAd->CommonCfg.TpcReqTabLock);
-
-	kfree(pAd->CommonCfg.pTpcReqTab);
-	pAd->CommonCfg.pTpcReqTab = NULL;
-
-	return;
-}
-
-static struct rt_tpc_req_entry *TpcReqLookUp(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	u32 HashIdx;
-	struct rt_tpc_req_tab *pTab = pAd->CommonCfg.pTpcReqTab;
-	struct rt_tpc_req_entry *pEntry = NULL;
-	struct rt_tpc_req_entry *pPrevEntry = NULL;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
-		return NULL;
-	}
-
-	RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
-
-	HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(DialogToken);
-	pEntry = pTab->Hash[HashIdx];
-
-	while (pEntry) {
-		if (pEntry->DialogToken == DialogToken)
-			break;
-		else {
-			pPrevEntry = pEntry;
-			pEntry = pEntry->pNext;
-		}
-	}
-
-	RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
-
-	return pEntry;
-}
-
-static struct rt_tpc_req_entry *TpcReqInsert(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	int i;
-	unsigned long HashIdx;
-	struct rt_tpc_req_tab *pTab = pAd->CommonCfg.pTpcReqTab;
-	struct rt_tpc_req_entry *pEntry = NULL, *pCurrEntry;
-	unsigned long Now;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
-		return NULL;
-	}
-
-	pEntry = TpcReqLookUp(pAd, DialogToken);
-	if (pEntry == NULL) {
-		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
-		for (i = 0; i < MAX_TPC_REQ_TAB_SIZE; i++) {
-			NdisGetSystemUpTime(&Now);
-			pEntry = &pTab->Content[i];
-
-			if ((pEntry->Valid == TRUE)
-			    && RTMP_TIME_AFTER((unsigned long)Now,
-					       (unsigned long)(pEntry->
-							       lastTime +
-							       TPC_REQ_AGE_OUT)))
-			{
-				struct rt_tpc_req_entry *pPrevEntry = NULL;
-				unsigned long HashIdx =
-				    TPC_DIALOGTOKEN_HASH_INDEX(pEntry->
-							       DialogToken);
-				struct rt_tpc_req_entry *pProbeEntry =
-				    pTab->Hash[HashIdx];
-
-				/* update Hash list */
-				do {
-					if (pProbeEntry == pEntry) {
-						if (pPrevEntry == NULL) {
-							pTab->Hash[HashIdx] =
-							    pEntry->pNext;
-						} else {
-							pPrevEntry->pNext =
-							    pEntry->pNext;
-						}
-						break;
-					}
-
-					pPrevEntry = pProbeEntry;
-					pProbeEntry = pProbeEntry->pNext;
-				} while (pProbeEntry);
-
-				NdisZeroMemory(pEntry, sizeof(struct rt_tpc_req_entry));
-				pTab->Size--;
-
-				break;
-			}
-
-			if (pEntry->Valid == FALSE)
-				break;
-		}
-
-		if (i < MAX_TPC_REQ_TAB_SIZE) {
-			NdisGetSystemUpTime(&Now);
-			pEntry->lastTime = Now;
-			pEntry->Valid = TRUE;
-			pEntry->DialogToken = DialogToken;
-			pTab->Size++;
-		} else {
-			pEntry = NULL;
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s: pTpcReqTab tab full.\n", __func__));
-		}
-
-		/* add this Neighbor entry into HASH table */
-		if (pEntry) {
-			HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(DialogToken);
-			if (pTab->Hash[HashIdx] == NULL) {
-				pTab->Hash[HashIdx] = pEntry;
-			} else {
-				pCurrEntry = pTab->Hash[HashIdx];
-				while (pCurrEntry->pNext != NULL)
-					pCurrEntry = pCurrEntry->pNext;
-				pCurrEntry->pNext = pEntry;
-			}
-		}
-
-		RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
-	}
-
-	return pEntry;
-}
-
-static void TpcReqDelete(struct rt_rtmp_adapter *pAd, u8 DialogToken)
-{
-	struct rt_tpc_req_tab *pTab = pAd->CommonCfg.pTpcReqTab;
-	struct rt_tpc_req_entry *pEntry = NULL;
-
-	if (pTab == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
-		return;
-	}
-	/* if empty, return */
-	if (pTab->Size == 0) {
-		DBGPRINT(RT_DEBUG_ERROR, ("pTpcReqTab empty.\n"));
-		return;
-	}
-
-	pEntry = TpcReqLookUp(pAd, DialogToken);
-	if (pEntry != NULL) {
-		struct rt_tpc_req_entry *pPrevEntry = NULL;
-		unsigned long HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
-		struct rt_tpc_req_entry *pProbeEntry = pTab->Hash[HashIdx];
-
-		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
-		/* update Hash list */
-		do {
-			if (pProbeEntry == pEntry) {
-				if (pPrevEntry == NULL) {
-					pTab->Hash[HashIdx] = pEntry->pNext;
-				} else {
-					pPrevEntry->pNext = pEntry->pNext;
-				}
-				break;
-			}
-
-			pPrevEntry = pProbeEntry;
-			pProbeEntry = pProbeEntry->pNext;
-		} while (pProbeEntry);
-
-		NdisZeroMemory(pEntry, sizeof(struct rt_tpc_req_entry));
-		pTab->Size--;
-
-		RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Get Current TimeS tamp.
-
-	Parametrs:
-
-	Return	: Current Time Stamp.
-	==========================================================================
- */
-static u64 GetCurrentTimeStamp(struct rt_rtmp_adapter *pAd)
-{
-	/* get current time stamp. */
-	return 0;
-}
-
-/*
-	==========================================================================
-	Description:
-		Get Current Transmit Power.
-
-	Parametrs:
-
-	Return	: Current Time Stamp.
-	==========================================================================
- */
-static u8 GetCurTxPwr(struct rt_rtmp_adapter *pAd, u8 Wcid)
-{
-	return 16;		/* 16 dBm */
-}
-
-/*
-	==========================================================================
-	Description:
-		Get Current Transmit Power.
-
-	Parametrs:
-
-	Return	: Current Time Stamp.
-	==========================================================================
- */
-void InsertChannelRepIE(struct rt_rtmp_adapter *pAd,
-			u8 *pFrameBuf,
-			unsigned long *pFrameLen,
-			char *pCountry, u8 RegulatoryClass)
-{
-	unsigned long TempLen;
-	u8 Len;
-	u8 IEId = IE_AP_CHANNEL_REPORT;
-	u8 *pChListPtr = NULL;
-
-	Len = 1;
-	if (strncmp(pCountry, "US", 2) == 0) {
-		if (RegulatoryClass >= USA_REGULATORY_INFO_SIZE) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s: USA Unknow Requlatory class (%d)\n",
-				  __func__, RegulatoryClass));
-			return;
-		}
-
-		Len +=
-		    USARegulatoryInfo[RegulatoryClass].ChannelSet.
-		    NumberOfChannels;
-		pChListPtr =
-		    USARegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
-	} else if (strncmp(pCountry, "JP", 2) == 0) {
-		if (RegulatoryClass >= JP_REGULATORY_INFO_SIZE) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s: JP Unknow Requlatory class (%d)\n",
-				  __func__, RegulatoryClass));
-			return;
-		}
-
-		Len +=
-		    JapanRegulatoryInfo[RegulatoryClass].ChannelSet.
-		    NumberOfChannels;
-		pChListPtr =
-		    JapanRegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: Unknow Country (%s)\n",
-					  __func__, pCountry));
-		return;
-	}
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &IEId,
-			  1, &Len,
-			  1, &RegulatoryClass,
-			  Len - 1, pChListPtr, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert Dialog Token into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. Dialog token.
-
-	Return	: None.
-	==========================================================================
- */
-void InsertDialogToken(struct rt_rtmp_adapter *pAd,
-		       u8 *pFrameBuf,
-		       unsigned long *pFrameLen, u8 DialogToken)
-{
-	unsigned long TempLen;
-	MakeOutgoingFrame(pFrameBuf, &TempLen, 1, &DialogToken, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert TPC Request IE into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-
-	Return	: None.
-	==========================================================================
- */
-static void InsertTpcReqIE(struct rt_rtmp_adapter *pAd,
-			   u8 *pFrameBuf, unsigned long *pFrameLen)
-{
-	unsigned long TempLen;
-	unsigned long Len = 0;
-	u8 ElementID = IE_TPC_REQUEST;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &ElementID, 1, &Len, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert TPC Report IE into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. Transmit Power.
-		4. Link Margin.
-
-	Return	: None.
-	==========================================================================
- */
-void InsertTpcReportIE(struct rt_rtmp_adapter *pAd,
-		       u8 *pFrameBuf,
-		       unsigned long *pFrameLen,
-		       u8 TxPwr, u8 LinkMargin)
-{
-	unsigned long TempLen;
-	unsigned long Len = sizeof(struct rt_tpc_report_info);
-	u8 ElementID = IE_TPC_REPORT;
-	struct rt_tpc_report_info TpcReportIE;
-
-	TpcReportIE.TxPwr = TxPwr;
-	TpcReportIE.LinkMargin = LinkMargin;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &ElementID,
-			  1, &Len, Len, &TpcReportIE, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert Channel Switch Announcement IE into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. channel switch announcement mode.
-		4. new selected channel.
-		5. channel switch announcement count.
-
-	Return	: None.
-	==========================================================================
- */
-static void InsertChSwAnnIE(struct rt_rtmp_adapter *pAd,
-			    u8 *pFrameBuf,
-			    unsigned long *pFrameLen,
-			    u8 ChSwMode,
-			    u8 NewChannel, u8 ChSwCnt)
-{
-	unsigned long TempLen;
-	unsigned long Len = sizeof(struct rt_ch_sw_ann_info);
-	u8 ElementID = IE_CHANNEL_SWITCH_ANNOUNCEMENT;
-	struct rt_ch_sw_ann_info ChSwAnnIE;
-
-	ChSwAnnIE.ChSwMode = ChSwMode;
-	ChSwAnnIE.Channel = NewChannel;
-	ChSwAnnIE.ChSwCnt = ChSwCnt;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &ElementID, 1, &Len, Len, &ChSwAnnIE, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert Measure Request IE into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. Measure Token.
-		4. Measure Request Mode.
-		5. Measure Request Type.
-		6. Measure Channel.
-		7. Measure Start time.
-		8. Measure Duration.
-
-	Return	: None.
-	==========================================================================
- */
-static void InsertMeasureReqIE(struct rt_rtmp_adapter *pAd,
-			       u8 *pFrameBuf,
-			       unsigned long *pFrameLen,
-			       u8 Len, struct rt_measure_req_info * pMeasureReqIE)
-{
-	unsigned long TempLen;
-	u8 ElementID = IE_MEASUREMENT_REQUEST;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &ElementID,
-			  1, &Len,
-			  sizeof(struct rt_measure_req_info), pMeasureReqIE, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Insert Measure Report IE into frame.
-
-	Parametrs:
-		1. frame buffer pointer.
-		2. frame length.
-		3. Measure Token.
-		4. Measure Request Mode.
-		5. Measure Request Type.
-		6. Length of Report Information
-		7. Pointer of Report Information Buffer.
-
-	Return	: None.
-	==========================================================================
- */
-static void InsertMeasureReportIE(struct rt_rtmp_adapter *pAd,
-				  u8 *pFrameBuf,
-				  unsigned long *pFrameLen,
-				  struct rt_measure_report_info * pMeasureReportIE,
-				  u8 ReportLnfoLen, u8 *pReportInfo)
-{
-	unsigned long TempLen;
-	unsigned long Len;
-	u8 ElementID = IE_MEASUREMENT_REPORT;
-
-	Len = sizeof(struct rt_measure_report_info) + ReportLnfoLen;
-
-	MakeOutgoingFrame(pFrameBuf, &TempLen,
-			  1, &ElementID,
-			  1, &Len, Len, pMeasureReportIE, END_OF_ARGS);
-
-	*pFrameLen = *pFrameLen + TempLen;
-
-	if ((ReportLnfoLen > 0) && (pReportInfo != NULL)) {
-		MakeOutgoingFrame(pFrameBuf + *pFrameLen, &TempLen,
-				  ReportLnfoLen, pReportInfo, END_OF_ARGS);
-
-		*pFrameLen = *pFrameLen + TempLen;
-	}
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Prepare Measurement request action frame and enqueue it into
-		management queue waiting for transmition.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void MakeMeasurementReqFrame(struct rt_rtmp_adapter *pAd,
-			     u8 *pOutBuffer,
-			     unsigned long *pFrameLen,
-			     u8 TotalLen,
-			     u8 Category,
-			     u8 Action,
-			     u8 MeasureToken,
-			     u8 MeasureReqMode,
-			     u8 MeasureReqType, u8 NumOfRepetitions)
-{
-	unsigned long TempLen;
-	struct rt_measure_req_info MeasureReqIE;
-
-	InsertActField(pAd, (pOutBuffer + *pFrameLen), pFrameLen, Category,
-		       Action);
-
-	/* fill Dialog Token */
-	InsertDialogToken(pAd, (pOutBuffer + *pFrameLen), pFrameLen,
-			  MeasureToken);
-
-	/* fill Number of repetitions. */
-	if (Category == CATEGORY_RM) {
-		MakeOutgoingFrame((pOutBuffer + *pFrameLen), &TempLen,
-				  2, &NumOfRepetitions, END_OF_ARGS);
-
-		*pFrameLen += TempLen;
-	}
-	/* prepare Measurement IE. */
-	NdisZeroMemory(&MeasureReqIE, sizeof(struct rt_measure_req_info));
-	MeasureReqIE.Token = MeasureToken;
-	MeasureReqIE.ReqMode.word = MeasureReqMode;
-	MeasureReqIE.ReqType = MeasureReqType;
-	InsertMeasureReqIE(pAd, (pOutBuffer + *pFrameLen), pFrameLen,
-			   TotalLen, &MeasureReqIE);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Prepare Measurement report action frame and enqueue it into
-		management queue waiting for transmition.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueMeasurementRep(struct rt_rtmp_adapter *pAd,
-			   u8 *pDA,
-			   u8 DialogToken,
-			   u8 MeasureToken,
-			   u8 MeasureReqMode,
-			   u8 MeasureReqType,
-			   u8 ReportInfoLen, u8 *pReportInfo)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-	struct rt_header_802_11 ActHdr;
-	struct rt_measure_report_info MeasureRepIE;
-
-	/* build action frame header. */
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-			 pAd->CurrentAddress);
-
-	NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s() allocate memory failed \n", __func__));
-		return;
-	}
-	NdisMoveMemory(pOutBuffer, (char *)& ActHdr, sizeof(struct rt_header_802_11));
-	FrameLen = sizeof(struct rt_header_802_11);
-
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
-		       CATEGORY_SPECTRUM, SPEC_MRP);
-
-	/* fill Dialog Token */
-	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
-
-	/* prepare Measurement IE. */
-	NdisZeroMemory(&MeasureRepIE, sizeof(struct rt_measure_report_info));
-	MeasureRepIE.Token = MeasureToken;
-	MeasureRepIE.ReportMode = MeasureReqMode;
-	MeasureRepIE.ReportType = MeasureReqType;
-	InsertMeasureReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen,
-			      &MeasureRepIE, ReportInfoLen, pReportInfo);
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Prepare TPC Request action frame and enqueue it into
-		management queue waiting for transmition.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueTPCReq(struct rt_rtmp_adapter *pAd, u8 *pDA, u8 DialogToken)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-
-	struct rt_header_802_11 ActHdr;
-
-	/* build action frame header. */
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-			 pAd->CurrentAddress);
-
-	NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s() allocate memory failed \n", __func__));
-		return;
-	}
-	NdisMoveMemory(pOutBuffer, (char *)& ActHdr, sizeof(struct rt_header_802_11));
-	FrameLen = sizeof(struct rt_header_802_11);
-
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
-		       CATEGORY_SPECTRUM, SPEC_TPCRQ);
-
-	/* fill Dialog Token */
-	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
-
-	/* Insert TPC Request IE. */
-	InsertTpcReqIE(pAd, (pOutBuffer + FrameLen), &FrameLen);
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Prepare TPC Report action frame and enqueue it into
-		management queue waiting for transmition.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueTPCRep(struct rt_rtmp_adapter *pAd,
-		   u8 *pDA,
-		   u8 DialogToken, u8 TxPwr, u8 LinkMargin)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-
-	struct rt_header_802_11 ActHdr;
-
-	/* build action frame header. */
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-			 pAd->CurrentAddress);
-
-	NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s() allocate memory failed \n", __func__));
-		return;
-	}
-	NdisMoveMemory(pOutBuffer, (char *)& ActHdr, sizeof(struct rt_header_802_11));
-	FrameLen = sizeof(struct rt_header_802_11);
-
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
-		       CATEGORY_SPECTRUM, SPEC_TPCRP);
-
-	/* fill Dialog Token */
-	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
-
-	/* Insert TPC Request IE. */
-	InsertTpcReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen, TxPwr,
-			  LinkMargin);
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Prepare Channel Switch Announcement action frame and enqueue it into
-		management queue waiting for transmition.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-		2. Channel switch announcement mode.
-		2. a New selected channel.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueChSwAnn(struct rt_rtmp_adapter *pAd,
-		    u8 *pDA, u8 ChSwMode, u8 NewCh)
-{
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-
-	struct rt_header_802_11 ActHdr;
-
-	/* build action frame header. */
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-			 pAd->CurrentAddress);
-
-	NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s() allocate memory failed \n", __func__));
-		return;
-	}
-	NdisMoveMemory(pOutBuffer, (char *)& ActHdr, sizeof(struct rt_header_802_11));
-	FrameLen = sizeof(struct rt_header_802_11);
-
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
-		       CATEGORY_SPECTRUM, SPEC_CHANNEL_SWITCH);
-
-	InsertChSwAnnIE(pAd, (pOutBuffer + FrameLen), &FrameLen, ChSwMode,
-			NewCh, 0);
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	return;
-}
-
-static BOOLEAN DfsRequirementCheck(struct rt_rtmp_adapter *pAd, u8 Channel)
-{
-	BOOLEAN Result = FALSE;
-	int i;
-
-	do {
-		/* check DFS procedure is running. */
-		/* make sure DFS procedure won't start twice. */
-		if (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE) {
-			Result = FALSE;
-			break;
-		}
-		/* check the new channel carried from Channel Switch Announcemnet is valid. */
-		for (i = 0; i < pAd->ChannelListNum; i++) {
-			if ((Channel == pAd->ChannelList[i].Channel)
-			    && (pAd->ChannelList[i].RemainingTimeForUse == 0)) {
-				/* found radar signal in the channel. the channel can't use at least for 30 minutes. */
-				pAd->ChannelList[i].RemainingTimeForUse = 1800;	/*30 min = 1800 sec */
-				Result = TRUE;
-				break;
-			}
-		}
-	} while (FALSE);
-
-	return Result;
-}
-
-void NotifyChSwAnnToPeerAPs(struct rt_rtmp_adapter *pAd,
-			    u8 *pRA,
-			    u8 *pTA, u8 ChSwMode, u8 Channel)
-{
-}
-
-static void StartDFSProcedure(struct rt_rtmp_adapter *pAd,
-			      u8 Channel, u8 ChSwMode)
-{
-	/* start DFS procedure */
-	pAd->CommonCfg.Channel = Channel;
-
-	N_ChannelCheck(pAd);
-
-	pAd->CommonCfg.RadarDetect.RDMode = RD_SWITCHING_MODE;
-	pAd->CommonCfg.RadarDetect.CSCount = 0;
-}
-
-/*
-	==========================================================================
-	Description:
-		Channel Switch Announcement action frame sanity check.
-
-	Parametrs:
-		1. MLME message containing the received frame
-		2. message length.
-		3. Channel switch announcement information buffer.
-
-	Return	: None.
-	==========================================================================
- */
-
-/*
-  Channel Switch Announcement IE.
-  +----+-----+-----------+------------+-----------+
-  | ID | Len |Ch Sw Mode | New Ch Num | Ch Sw Cnt |
-  +----+-----+-----------+------------+-----------+
-    1    1        1           1            1
-*/
-static BOOLEAN PeerChSwAnnSanity(struct rt_rtmp_adapter *pAd,
-				 void * pMsg,
-				 unsigned long MsgLen,
-				 struct rt_ch_sw_ann_info * pChSwAnnInfo)
-{
-	struct rt_frame_802_11 * Fr = (struct rt_frame_802_11 *) pMsg;
-	u8 *pFramePtr = Fr->Octet;
-	BOOLEAN result = FALSE;
-	struct rt_eid * eid_ptr;
-
-	/* skip 802.11 header. */
-	MsgLen -= sizeof(struct rt_header_802_11);
-
-	/* skip category and action code. */
-	pFramePtr += 2;
-	MsgLen -= 2;
-
-	if (pChSwAnnInfo == NULL)
-		return result;
-
-	eid_ptr = (struct rt_eid *) pFramePtr;
-	while (((u8 *) eid_ptr + eid_ptr->Len + 1) <
-	       ((u8 *)pFramePtr + MsgLen)) {
-		switch (eid_ptr->Eid) {
-		case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
-			NdisMoveMemory(&pChSwAnnInfo->ChSwMode, eid_ptr->Octet,
-				       1);
-			NdisMoveMemory(&pChSwAnnInfo->Channel,
-				       eid_ptr->Octet + 1, 1);
-			NdisMoveMemory(&pChSwAnnInfo->ChSwCnt,
-				       eid_ptr->Octet + 2, 1);
-
-			result = TRUE;
-			break;
-
-		default:
-			break;
-		}
-		eid_ptr = (struct rt_eid *) ((u8 *) eid_ptr + 2 + eid_ptr->Len);
-	}
-
-	return result;
-}
-
-/*
-	==========================================================================
-	Description:
-		Measurement request action frame sanity check.
-
-	Parametrs:
-		1. MLME message containing the received frame
-		2. message length.
-		3. Measurement request information buffer.
-
-	Return	: None.
-	==========================================================================
- */
-static BOOLEAN PeerMeasureReqSanity(struct rt_rtmp_adapter *pAd,
-				    void * pMsg,
-				    unsigned long MsgLen,
-				    u8 *pDialogToken,
-				    struct rt_measure_req_info * pMeasureReqInfo,
-				    struct rt_measure_req * pMeasureReq)
-{
-	struct rt_frame_802_11 * Fr = (struct rt_frame_802_11 *) pMsg;
-	u8 *pFramePtr = Fr->Octet;
-	BOOLEAN result = FALSE;
-	struct rt_eid * eid_ptr;
-	u8 *ptr;
-	u64 MeasureStartTime;
-	u16 MeasureDuration;
-
-	/* skip 802.11 header. */
-	MsgLen -= sizeof(struct rt_header_802_11);
-
-	/* skip category and action code. */
-	pFramePtr += 2;
-	MsgLen -= 2;
-
-	if (pMeasureReqInfo == NULL)
-		return result;
-
-	NdisMoveMemory(pDialogToken, pFramePtr, 1);
-	pFramePtr += 1;
-	MsgLen -= 1;
-
-	eid_ptr = (struct rt_eid *) pFramePtr;
-	while (((u8 *) eid_ptr + eid_ptr->Len + 1) <
-	       ((u8 *)pFramePtr + MsgLen)) {
-		switch (eid_ptr->Eid) {
-		case IE_MEASUREMENT_REQUEST:
-			NdisMoveMemory(&pMeasureReqInfo->Token, eid_ptr->Octet,
-				       1);
-			NdisMoveMemory(&pMeasureReqInfo->ReqMode.word,
-				       eid_ptr->Octet + 1, 1);
-			NdisMoveMemory(&pMeasureReqInfo->ReqType,
-				       eid_ptr->Octet + 2, 1);
-			ptr = (u8 *)(eid_ptr->Octet + 3);
-			NdisMoveMemory(&pMeasureReq->ChNum, ptr, 1);
-			NdisMoveMemory(&MeasureStartTime, ptr + 1, 8);
-			pMeasureReq->MeasureStartTime =
-			    SWAP64(MeasureStartTime);
-			NdisMoveMemory(&MeasureDuration, ptr + 9, 2);
-			pMeasureReq->MeasureDuration = SWAP16(MeasureDuration);
-
-			result = TRUE;
-			break;
-
-		default:
-			break;
-		}
-		eid_ptr = (struct rt_eid *) ((u8 *) eid_ptr + 2 + eid_ptr->Len);
-	}
-
-	return result;
-}
-
-/*
-	==========================================================================
-	Description:
-		Measurement report action frame sanity check.
-
-	Parametrs:
-		1. MLME message containing the received frame
-		2. message length.
-		3. Measurement report information buffer.
-		4. basic report information buffer.
-
-	Return	: None.
-	==========================================================================
- */
-
-/*
-  Measurement Report IE.
-  +----+-----+-------+-------------+--------------+----------------+
-  | ID | Len | Token | Report Mode | Measure Type | Measure Report |
-  +----+-----+-------+-------------+--------------+----------------+
-    1     1      1          1             1            variable
-
-  Basic Report.
-  +--------+------------+----------+-----+
-  | Ch Num | Start Time | Duration | Map |
-  +--------+------------+----------+-----+
-      1          8           2        1
-
-  Map Field Bit Format.
-  +-----+---------------+---------------------+-------+------------+----------+
-  | Bss | OFDM Preamble | Unidentified signal | Radar | Unmeasured | Reserved |
-  +-----+---------------+---------------------+-------+------------+----------+
-     0          1                  2              3         4          5-7
-*/
-static BOOLEAN PeerMeasureReportSanity(struct rt_rtmp_adapter *pAd,
-				       void * pMsg,
-				       unsigned long MsgLen,
-				       u8 *pDialogToken,
-				       struct rt_measure_report_info *
-				       pMeasureReportInfo,
-				       u8 *pReportBuf)
-{
-	struct rt_frame_802_11 * Fr = (struct rt_frame_802_11 *) pMsg;
-	u8 *pFramePtr = Fr->Octet;
-	BOOLEAN result = FALSE;
-	struct rt_eid * eid_ptr;
-	u8 *ptr;
-
-	/* skip 802.11 header. */
-	MsgLen -= sizeof(struct rt_header_802_11);
-
-	/* skip category and action code. */
-	pFramePtr += 2;
-	MsgLen -= 2;
-
-	if (pMeasureReportInfo == NULL)
-		return result;
-
-	NdisMoveMemory(pDialogToken, pFramePtr, 1);
-	pFramePtr += 1;
-	MsgLen -= 1;
-
-	eid_ptr = (struct rt_eid *) pFramePtr;
-	while (((u8 *) eid_ptr + eid_ptr->Len + 1) <
-	       ((u8 *)pFramePtr + MsgLen)) {
-		switch (eid_ptr->Eid) {
-		case IE_MEASUREMENT_REPORT:
-			NdisMoveMemory(&pMeasureReportInfo->Token,
-				       eid_ptr->Octet, 1);
-			NdisMoveMemory(&pMeasureReportInfo->ReportMode,
-				       eid_ptr->Octet + 1, 1);
-			NdisMoveMemory(&pMeasureReportInfo->ReportType,
-				       eid_ptr->Octet + 2, 1);
-			if (pMeasureReportInfo->ReportType == RM_BASIC) {
-				struct rt_measure_basic_report * pReport =
-				    (struct rt_measure_basic_report *) pReportBuf;
-				ptr = (u8 *)(eid_ptr->Octet + 3);
-				NdisMoveMemory(&pReport->ChNum, ptr, 1);
-				NdisMoveMemory(&pReport->MeasureStartTime,
-					       ptr + 1, 8);
-				NdisMoveMemory(&pReport->MeasureDuration,
-					       ptr + 9, 2);
-				NdisMoveMemory(&pReport->Map, ptr + 11, 1);
-
-			} else if (pMeasureReportInfo->ReportType == RM_CCA) {
-				struct rt_measure_cca_report * pReport =
-				    (struct rt_measure_cca_report *) pReportBuf;
-				ptr = (u8 *)(eid_ptr->Octet + 3);
-				NdisMoveMemory(&pReport->ChNum, ptr, 1);
-				NdisMoveMemory(&pReport->MeasureStartTime,
-					       ptr + 1, 8);
-				NdisMoveMemory(&pReport->MeasureDuration,
-					       ptr + 9, 2);
-				NdisMoveMemory(&pReport->CCA_Busy_Fraction,
-					       ptr + 11, 1);
-
-			} else if (pMeasureReportInfo->ReportType ==
-				   RM_RPI_HISTOGRAM) {
-				struct rt_measure_rpi_report * pReport =
-				    (struct rt_measure_rpi_report *) pReportBuf;
-				ptr = (u8 *)(eid_ptr->Octet + 3);
-				NdisMoveMemory(&pReport->ChNum, ptr, 1);
-				NdisMoveMemory(&pReport->MeasureStartTime,
-					       ptr + 1, 8);
-				NdisMoveMemory(&pReport->MeasureDuration,
-					       ptr + 9, 2);
-				NdisMoveMemory(&pReport->RPI_Density, ptr + 11,
-					       8);
-			}
-			result = TRUE;
-			break;
-
-		default:
-			break;
-		}
-		eid_ptr = (struct rt_eid *) ((u8 *) eid_ptr + 2 + eid_ptr->Len);
-	}
-
-	return result;
-}
-
-/*
-	==========================================================================
-	Description:
-		TPC Request action frame sanity check.
-
-	Parametrs:
-		1. MLME message containing the received frame
-		2. message length.
-		3. Dialog Token.
-
-	Return	: None.
-	==========================================================================
- */
-static BOOLEAN PeerTpcReqSanity(struct rt_rtmp_adapter *pAd,
-				void * pMsg,
-				unsigned long MsgLen, u8 *pDialogToken)
-{
-	struct rt_frame_802_11 * Fr = (struct rt_frame_802_11 *) pMsg;
-	u8 *pFramePtr = Fr->Octet;
-	BOOLEAN result = FALSE;
-	struct rt_eid * eid_ptr;
-
-	MsgLen -= sizeof(struct rt_header_802_11);
-
-	/* skip category and action code. */
-	pFramePtr += 2;
-	MsgLen -= 2;
-
-	if (pDialogToken == NULL)
-		return result;
-
-	NdisMoveMemory(pDialogToken, pFramePtr, 1);
-	pFramePtr += 1;
-	MsgLen -= 1;
-
-	eid_ptr = (struct rt_eid *) pFramePtr;
-	while (((u8 *) eid_ptr + eid_ptr->Len + 1) <
-	       ((u8 *)pFramePtr + MsgLen)) {
-		switch (eid_ptr->Eid) {
-		case IE_TPC_REQUEST:
-			result = TRUE;
-			break;
-
-		default:
-			break;
-		}
-		eid_ptr = (struct rt_eid *) ((u8 *) eid_ptr + 2 + eid_ptr->Len);
-	}
-
-	return result;
-}
-
-/*
-	==========================================================================
-	Description:
-		TPC Report action frame sanity check.
-
-	Parametrs:
-		1. MLME message containing the received frame
-		2. message length.
-		3. Dialog Token.
-		4. TPC Report IE.
-
-	Return	: None.
-	==========================================================================
- */
-static BOOLEAN PeerTpcRepSanity(struct rt_rtmp_adapter *pAd,
-				void * pMsg,
-				unsigned long MsgLen,
-				u8 *pDialogToken,
-				struct rt_tpc_report_info * pTpcRepInfo)
-{
-	struct rt_frame_802_11 * Fr = (struct rt_frame_802_11 *) pMsg;
-	u8 *pFramePtr = Fr->Octet;
-	BOOLEAN result = FALSE;
-	struct rt_eid * eid_ptr;
-
-	MsgLen -= sizeof(struct rt_header_802_11);
-
-	/* skip category and action code. */
-	pFramePtr += 2;
-	MsgLen -= 2;
-
-	if (pDialogToken == NULL)
-		return result;
-
-	NdisMoveMemory(pDialogToken, pFramePtr, 1);
-	pFramePtr += 1;
-	MsgLen -= 1;
-
-	eid_ptr = (struct rt_eid *) pFramePtr;
-	while (((u8 *) eid_ptr + eid_ptr->Len + 1) <
-	       ((u8 *)pFramePtr + MsgLen)) {
-		switch (eid_ptr->Eid) {
-		case IE_TPC_REPORT:
-			NdisMoveMemory(&pTpcRepInfo->TxPwr, eid_ptr->Octet, 1);
-			NdisMoveMemory(&pTpcRepInfo->LinkMargin,
-				       eid_ptr->Octet + 1, 1);
-			result = TRUE;
-			break;
-
-		default:
-			break;
-		}
-		eid_ptr = (struct rt_eid *) ((u8 *) eid_ptr + 2 + eid_ptr->Len);
-	}
-
-	return result;
-}
-
-/*
-	==========================================================================
-	Description:
-		Channel Switch Announcement action frame handler.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-static void PeerChSwAnnAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_ch_sw_ann_info ChSwAnnInfo;
-	struct rt_frame_802_11 * pFr = (struct rt_frame_802_11 *) Elem->Msg;
-	u8 index = 0, Channel = 0, NewChannel = 0;
-	unsigned long Bssidx = 0;
-
-	NdisZeroMemory(&ChSwAnnInfo, sizeof(struct rt_ch_sw_ann_info));
-	if (!PeerChSwAnnSanity(pAd, Elem->Msg, Elem->MsgLen, &ChSwAnnInfo)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Invalid Channel Switch Action Frame.\n"));
-		return;
-	}
-
-	if (pAd->OpMode == OPMODE_STA) {
-		Bssidx =
-		    BssTableSearch(&pAd->ScanTab, pFr->Hdr.Addr3,
-				   pAd->CommonCfg.Channel);
-		if (Bssidx == BSS_NOT_FOUND) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerChSwAnnAction - Bssidx is not found\n"));
-			return;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("\n****Bssidx is %d, Channel = %d\n", index,
-			  pAd->ScanTab.BssEntry[Bssidx].Channel));
-		hex_dump("SSID", pAd->ScanTab.BssEntry[Bssidx].Bssid, 6);
-
-		Channel = pAd->CommonCfg.Channel;
-		NewChannel = ChSwAnnInfo.Channel;
-
-		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
-		    && (Channel != NewChannel)) {
-			/* Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection). */
-			/* In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results. */
-			AsicSwitchChannel(pAd, 1, FALSE);
-			AsicLockChannel(pAd, 1);
-			LinkDown(pAd, FALSE);
-			MlmeQueueInit(&pAd->Mlme.Queue);
-			BssTableInit(&pAd->ScanTab);
-			RTMPusecDelay(1000000);	/* use delay to prevent STA do reassoc */
-
-			/* channel sanity check */
-			for (index = 0; index < pAd->ChannelListNum; index++) {
-				if (pAd->ChannelList[index].Channel ==
-				    NewChannel) {
-					pAd->ScanTab.BssEntry[Bssidx].Channel =
-					    NewChannel;
-					pAd->CommonCfg.Channel = NewChannel;
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  Channel, FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.Channel);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("&&&&&&&&&&&&&&&&PeerChSwAnnAction - STA receive channel switch announcement IE (New Channel =%d)\n",
-						  NewChannel));
-					break;
-				}
-			}
-
-			if (index >= pAd->ChannelListNum) {
-				DBGPRINT_ERR("&&&&&&&&&&&&&&&&&&&&&&&&&&PeerChSwAnnAction(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum);
-			}
-		}
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Measurement Request action frame handler.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-static void PeerMeasureReqAction(struct rt_rtmp_adapter *pAd,
-				 struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_frame_802_11 * pFr = (struct rt_frame_802_11 *) Elem->Msg;
-	u8 DialogToken;
-	struct rt_measure_req_info MeasureReqInfo;
-	struct rt_measure_req MeasureReq;
-	MEASURE_REPORT_MODE ReportMode;
-
-	if (PeerMeasureReqSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReqInfo,
-	     &MeasureReq)) {
-		ReportMode.word = 0;
-		ReportMode.field.Incapable = 1;
-		EnqueueMeasurementRep(pAd, pFr->Hdr.Addr2, DialogToken,
-				      MeasureReqInfo.Token, ReportMode.word,
-				      MeasureReqInfo.ReqType, 0, NULL);
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Measurement Report action frame handler.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-static void PeerMeasureReportAction(struct rt_rtmp_adapter *pAd,
-				    struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_measure_report_info MeasureReportInfo;
-	struct rt_frame_802_11 * pFr = (struct rt_frame_802_11 *) Elem->Msg;
-	u8 DialogToken;
-	u8 *pMeasureReportInfo;
-
-/*      if (pAd->CommonCfg.bIEEE80211H != TRUE) */
-/*              return; */
-
-	pMeasureReportInfo = kmalloc(sizeof(struct rt_measure_rpi_report), GFP_ATOMIC);
-	if (pMeasureReportInfo == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s unable to alloc memory for measure report buffer (size=%zu).\n",
-			  __func__, sizeof(struct rt_measure_rpi_report)));
-		return;
-	}
-
-	NdisZeroMemory(&MeasureReportInfo, sizeof(struct rt_measure_report_info));
-	NdisZeroMemory(pMeasureReportInfo, sizeof(struct rt_measure_rpi_report));
-	if (PeerMeasureReportSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReportInfo,
-	     pMeasureReportInfo)) {
-		do {
-			struct rt_measure_req_entry *pEntry = NULL;
-
-			/* Not a autonomous measure report. */
-			/* check the dialog token field. drop it if the dialog token doesn't match. */
-			if ((DialogToken != 0)
-			    && ((pEntry = MeasureReqLookUp(pAd, DialogToken)) ==
-				NULL))
-				break;
-
-			if (pEntry != NULL)
-				MeasureReqDelete(pAd, pEntry->DialogToken);
-
-			if (MeasureReportInfo.ReportType == RM_BASIC) {
-				struct rt_measure_basic_report * pBasicReport =
-				    (struct rt_measure_basic_report *) pMeasureReportInfo;
-				if ((pBasicReport->Map.field.Radar)
-				    &&
-				    (DfsRequirementCheck
-				     (pAd, pBasicReport->ChNum) == TRUE)) {
-					NotifyChSwAnnToPeerAPs(pAd,
-							       pFr->Hdr.Addr1,
-							       pFr->Hdr.Addr2,
-							       1,
-							       pBasicReport->
-							       ChNum);
-					StartDFSProcedure(pAd,
-							  pBasicReport->ChNum,
-							  1);
-				}
-			}
-		} while (FALSE);
-	} else
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Invalid Measurement Report Frame.\n"));
-
-	kfree(pMeasureReportInfo);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		TPC Request action frame handler.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-static void PeerTpcReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_frame_802_11 * pFr = (struct rt_frame_802_11 *) Elem->Msg;
-	u8 *pFramePtr = pFr->Octet;
-	u8 DialogToken;
-	u8 TxPwr = GetCurTxPwr(pAd, Elem->Wcid);
-	u8 LinkMargin = 0;
-	char RealRssi;
-
-	/* link margin: Ratio of the received signal power to the minimum desired by the station (STA). The */
-	/*                              STA may incorporate rate information and channel conditions, including interference, into its computation */
-	/*                              of link margin. */
-
-	RealRssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
-			       ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
-			       ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
-
-	/* skip Category and action code. */
-	pFramePtr += 2;
-
-	/* Dialog token. */
-	NdisMoveMemory(&DialogToken, pFramePtr, 1);
-
-	LinkMargin = (RealRssi / MIN_RCV_PWR);
-	if (PeerTpcReqSanity(pAd, Elem->Msg, Elem->MsgLen, &DialogToken))
-		EnqueueTPCRep(pAd, pFr->Hdr.Addr2, DialogToken, TxPwr,
-			      LinkMargin);
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		TPC Report action frame handler.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-static void PeerTpcRepAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 DialogToken;
-	struct rt_tpc_report_info TpcRepInfo;
-	struct rt_tpc_req_entry *pEntry = NULL;
-
-	NdisZeroMemory(&TpcRepInfo, sizeof(struct rt_tpc_report_info));
-	if (PeerTpcRepSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &TpcRepInfo)) {
-		pEntry = TpcReqLookUp(pAd, DialogToken);
-		if (pEntry != NULL) {
-			TpcReqDelete(pAd, pEntry->DialogToken);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s: DialogToken=%x, TxPwr=%d, LinkMargin=%d\n",
-				  __func__, DialogToken, TpcRepInfo.TxPwr,
-				  TpcRepInfo.LinkMargin));
-		}
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-		Spectrun action frames Handler such as channel switch annoucement,
-		measurement report, measurement request actions frames.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-void PeerSpectrumAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-
-	u8 Action = Elem->Msg[LENGTH_802_11 + 1];
-
-	if (pAd->CommonCfg.bIEEE80211H != TRUE)
-		return;
-
-	switch (Action) {
-	case SPEC_MRQ:
-		/* current rt2860 unable do such measure specified in Measurement Request. */
-		/* reject all measurement request. */
-		PeerMeasureReqAction(pAd, Elem);
-		break;
-
-	case SPEC_MRP:
-		PeerMeasureReportAction(pAd, Elem);
-		break;
-
-	case SPEC_TPCRQ:
-		PeerTpcReqAction(pAd, Elem);
-		break;
-
-	case SPEC_TPCRP:
-		PeerTpcRepAction(pAd, Elem);
-		break;
-
-	case SPEC_CHANNEL_SWITCH:
-
-		PeerChSwAnnAction(pAd, Elem);
-		break;
-	}
-
-	return;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	Parametrs:
-
-	Return	: None.
-	==========================================================================
- */
-int Set_MeasureReq_Proc(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	u32 Aid = 1;
-	u32 ArgIdx;
-	char *thisChar;
-
-	MEASURE_REQ_MODE MeasureReqMode;
-	u8 MeasureReqToken = RandomByte(pAd);
-	u8 MeasureReqType = RM_BASIC;
-	u8 MeasureCh = 1;
-	u64 MeasureStartTime = GetCurrentTimeStamp(pAd);
-	struct rt_measure_req MeasureReq;
-	u8 TotalLen;
-
-	struct rt_header_802_11 ActHdr;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen;
-
-	NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s() allocate memory failed \n", __func__));
-		goto END_OF_MEASURE_REQ;
-	}
-
-	ArgIdx = 1;
-	while ((thisChar = strsep((char **)&arg, "-")) != NULL) {
-		switch (ArgIdx) {
-		case 1:	/* Aid. */
-			Aid = (u8)simple_strtol(thisChar, 0, 16);
-			break;
-
-		case 2:	/* Measurement Request Type. */
-			MeasureReqType = simple_strtol(thisChar, 0, 16);
-			if (MeasureReqType > 3) {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("%s: unknow MeasureReqType(%d)\n",
-					  __func__, MeasureReqType));
-				goto END_OF_MEASURE_REQ;
-			}
-			break;
-
-		case 3:	/* Measurement channel. */
-			MeasureCh = (u8)simple_strtol(thisChar, 0, 16);
-			break;
-		}
-		ArgIdx++;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s::Aid = %d, MeasureReqType=%d MeasureCh=%d\n", __func__,
-		  Aid, MeasureReqType, MeasureCh));
-	if (!VALID_WCID(Aid)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
-		goto END_OF_MEASURE_REQ;
-	}
-
-	MeasureReqMode.word = 0;
-	MeasureReqMode.field.Enable = 1;
-
-	MeasureReqInsert(pAd, MeasureReqToken);
-
-	/* build action frame header. */
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0,
-			 pAd->MacTab.Content[Aid].Addr, pAd->CurrentAddress);
-
-	NdisMoveMemory(pOutBuffer, (char *)& ActHdr, sizeof(struct rt_header_802_11));
-	FrameLen = sizeof(struct rt_header_802_11);
-
-	TotalLen = sizeof(struct rt_measure_req_info) + sizeof(struct rt_measure_req);
-
-	MakeMeasurementReqFrame(pAd, pOutBuffer, &FrameLen,
-				sizeof(struct rt_measure_req_info), CATEGORY_RM, RM_BASIC,
-				MeasureReqToken, MeasureReqMode.word,
-				MeasureReqType, 0);
-
-	MeasureReq.ChNum = MeasureCh;
-	MeasureReq.MeasureStartTime = cpu2le64(MeasureStartTime);
-	MeasureReq.MeasureDuration = cpu2le16(2000);
-
-	{
-		unsigned long TempLen;
-		MakeOutgoingFrame(pOutBuffer + FrameLen, &TempLen,
-				  sizeof(struct rt_measure_req), &MeasureReq,
-				  END_OF_ARGS);
-		FrameLen += TempLen;
-	}
-
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, (u32)FrameLen);
-
-END_OF_MEASURE_REQ:
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	return TRUE;
-}
-
-int Set_TpcReq_Proc(struct rt_rtmp_adapter *pAd, char *arg)
-{
-	u32 Aid;
-
-	u8 TpcReqToken = RandomByte(pAd);
-
-	Aid = (u32)simple_strtol(arg, 0, 16);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s::Aid = %d\n", __func__, Aid));
-	if (!VALID_WCID(Aid)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
-		return TRUE;
-	}
-
-	TpcReqInsert(pAd, TpcReqToken);
-
-	EnqueueTPCReq(pAd, pAd->MacTab.Content[Aid].Addr, TpcReqToken);
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/crypt_hmac.h b/drivers/staging/rt2860/crypt_hmac.h
deleted file mode 100644
index 7a56515..0000000
--- a/drivers/staging/rt2860/crypt_hmac.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-/****************************************************************************
-    Module Name:
-    HMAC
-
-    Abstract:
-    FIPS 198: The Keyed-Hash Message Authentication Code (HMAC)
-
-    Revision History:
-    Who         When            What
-    --------    ----------      ------------------------------------------
-    Eddy        2008/11/24      Create HMAC-SHA1, HMAC-SHA256
-***************************************************************************/
-#ifndef __CRYPT_HMAC_H__
-#define __CRYPT_HMAC_H__
-
-#ifdef CRYPT_TESTPLAN
-#include "crypt_testplan.h"
-#else
-#include "rt_config.h"
-#endif /* CRYPT_TESTPLAN */
-
-#ifdef SHA1_SUPPORT
-#define HMAC_SHA1_SUPPORT
-void HMAC_SHA1(IN const u8 Key[],
-	       u32 KeyLen,
-	       IN const u8 Message[],
-	       u32 MessageLen, u8 MAC[], u32 MACLen);
-#endif /* SHA1_SUPPORT */
-
-#ifdef MD5_SUPPORT
-#define HMAC_MD5_SUPPORT
-void HMAC_MD5(IN const u8 Key[],
-	      u32 KeyLen,
-	      IN const u8 Message[],
-	      u32 MessageLen, u8 MAC[], u32 MACLen);
-#endif /* MD5_SUPPORT */
-
-#endif /* __CRYPT_HMAC_H__ */
diff --git a/drivers/staging/rt2860/crypt_md5.h b/drivers/staging/rt2860/crypt_md5.h
deleted file mode 100644
index 26f9745..0000000
--- a/drivers/staging/rt2860/crypt_md5.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-/****************************************************************************
-    Module Name:
-    MD5
-
-    Abstract:
-    RFC1321: The MD5 Message-Digest Algorithm
-
-    Revision History:
-    Who         When            What
-    --------    ----------      ------------------------------------------
-    Eddy        2008/11/24      Create md5
-***************************************************************************/
-
-#ifndef __CRYPT_MD5_H__
-#define __CRYPT_MD5_H__
-
-#ifdef CRYPT_TESTPLAN
-#include "crypt_testplan.h"
-#else
-#include "rt_config.h"
-#endif /* CRYPT_TESTPLAN */
-
-/* Algorithm options */
-#define MD5_SUPPORT
-
-#ifdef MD5_SUPPORT
-#define MD5_BLOCK_SIZE    64	/* 512 bits = 64 bytes */
-#define MD5_DIGEST_SIZE   16	/* 128 bits = 16 bytes */
-
-struct rt_md5_ctx_struc {
-	u32 HashValue[4];
-	u64 MessageLen;
-	u8 Block[MD5_BLOCK_SIZE];
-	u32 BlockLen;
-};
-
-void MD5_Init(struct rt_md5_ctx_struc *pMD5_CTX);
-void MD5_Hash(struct rt_md5_ctx_struc *pMD5_CTX);
-void MD5_Append(struct rt_md5_ctx_struc *pMD5_CTX,
-		IN const u8 Message[], u32 MessageLen);
-void MD5_End(struct rt_md5_ctx_struc *pMD5_CTX, u8 DigestMessage[]);
-void RT_MD5(IN const u8 Message[],
-	    u32 MessageLen, u8 DigestMessage[]);
-#endif /* MD5_SUPPORT */
-
-#endif /* __CRYPT_MD5_H__ */
diff --git a/drivers/staging/rt2860/crypt_sha2.h b/drivers/staging/rt2860/crypt_sha2.h
deleted file mode 100644
index 20d11ab..0000000
--- a/drivers/staging/rt2860/crypt_sha2.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-/****************************************************************************
-    Module Name:
-    SHA2
-
-    Abstract:
-    FIPS 180-2: Secure Hash Standard (SHS)
-
-    Revision History:
-    Who         When            What
-    --------    ----------      ------------------------------------------
-    Eddy        2008/11/24      Create SHA1
-    Eddy        2008/07/23      Create SHA256
-***************************************************************************/
-
-#ifndef __CRYPT_SHA2_H__
-#define __CRYPT_SHA2_H__
-
-#ifdef CRYPT_TESTPLAN
-#include "crypt_testplan.h"
-#else
-#include "rt_config.h"
-#endif /* CRYPT_TESTPLAN */
-
-/* Algorithm options */
-#define SHA1_SUPPORT
-
-#ifdef SHA1_SUPPORT
-#define SHA1_BLOCK_SIZE    64	/* 512 bits = 64 bytes */
-#define SHA1_DIGEST_SIZE   20	/* 160 bits = 20 bytes */
-struct rt_sha1_ctx {
-	u32 HashValue[5];	/* 5 = (SHA1_DIGEST_SIZE / 32) */
-	u64 MessageLen;	/* total size */
-	u8 Block[SHA1_BLOCK_SIZE];
-	u32 BlockLen;
-};
-
-void RT_SHA1_Init(struct rt_sha1_ctx *pSHA_CTX);
-void SHA1_Hash(struct rt_sha1_ctx *pSHA_CTX);
-void SHA1_Append(struct rt_sha1_ctx *pSHA_CTX,
-		 IN const u8 Message[], u32 MessageLen);
-void SHA1_End(struct rt_sha1_ctx *pSHA_CTX, u8 DigestMessage[]);
-void RT_SHA1(IN const u8 Message[],
-	     u32 MessageLen, u8 DigestMessage[]);
-#endif /* SHA1_SUPPORT */
-
-#endif /* __CRYPT_SHA2_H__ */
diff --git a/drivers/staging/rt2860/dfs.h b/drivers/staging/rt2860/dfs.h
deleted file mode 100644
index 5fbab25..0000000
--- a/drivers/staging/rt2860/dfs.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    dfs.h
-
-    Abstract:
-    Support DFS function.
-
-    Revision History:
-    Who       When            What
-    --------  ----------      ----------------------------------------------
-    Fonchi    03-12-2007      created
-*/
-
-BOOLEAN RadarChannelCheck(struct rt_rtmp_adapter *pAd, u8 Ch);
diff --git a/drivers/staging/rt2860/eeprom.h b/drivers/staging/rt2860/eeprom.h
deleted file mode 100644
index 72c8fb9..0000000
--- a/drivers/staging/rt2860/eeprom.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	eeprom.h
-
-	Abstract:
-	Miniport header file for eeprom related information
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-#ifndef __EEPROM_H__
-#define __EEPROM_H__
-
-#ifdef RTMP_PCI_SUPPORT
-/*************************************************************************
-  *	Public function declarations for prom-based chipset
-  ************************************************************************/
-int rtmp_ee_prom_read16(struct rt_rtmp_adapter *pAd,
-			u16 Offset, u16 *pValue);
-#endif /* RTMP_PCI_SUPPORT // */
-#ifdef RTMP_USB_SUPPORT
-/*************************************************************************
-  *	Public function declarations for usb-based prom chipset
-  ************************************************************************/
-int RTUSBReadEEPROM16(struct rt_rtmp_adapter *pAd,
-			   u16 offset, u16 *pData);
-#endif /* RTMP_USB_SUPPORT // */
-
-#ifdef RT30xx
-#ifdef RTMP_EFUSE_SUPPORT
-int rtmp_ee_efuse_read16(struct rt_rtmp_adapter *pAd,
-			 u16 Offset, u16 *pValue);
-#endif /* RTMP_EFUSE_SUPPORT // */
-#endif /* RT30xx // */
-
-/*************************************************************************
-  *	Public function declarations for prom operation callback functions setting
-  ************************************************************************/
-int RtmpChipOpsEepromHook(struct rt_rtmp_adapter *pAd, int infType);
-
-#endif /* __EEPROM_H__ // */
diff --git a/drivers/staging/rt2860/iface/rtmp_pci.h b/drivers/staging/rt2860/iface/rtmp_pci.h
deleted file mode 100644
index 3d66e38..0000000
--- a/drivers/staging/rt2860/iface/rtmp_pci.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifndef __RTMP_PCI_H__
-#define __RTMP_PCI_H__
-
-#define RT28XX_HANDLE_DEV_ASSIGN(handle, dev_p)				\
-	((struct os_cookie *)handle)->pci_dev = dev_p;
-
-#ifdef LINUX
-/* set driver data */
-#define RT28XX_DRVDATA_SET(_a)			pci_set_drvdata(_a, net_dev);
-
-#define RT28XX_PUT_DEVICE(dev_p)
-
-#define SA_SHIRQ IRQF_SHARED
-
-#ifdef PCI_MSI_SUPPORT
-#define RTMP_MSI_ENABLE(_pAd) \
-	{     struct os_cookie *_pObj = (struct os_cookie *)(_pAd->OS_Cookie); \
-		(_pAd)->HaveMsi = pci_enable_msi(_pObj->pci_dev) \
-							== 0 ? TRUE : FALSE; \
-	}
-
-#define RTMP_MSI_DISABLE(_pAd) \
-	{     struct os_cookie *_pObj = (struct os_cookie *)(_pAd->OS_Cookie); \
-		if (_pAd->HaveMsi == TRUE) \
-			pci_disable_msi(_pObj->pci_dev); \
-		_pAd->HaveMsi = FALSE;  \
-	}
-#else
-#define RTMP_MSI_ENABLE(_pAd)		do {} while (0)
-#define RTMP_MSI_DISABLE(_pAd)		do {} while (0)
-#endif /* PCI_MSI_SUPPORT */
-
-#define RTMP_PCI_DEV_UNMAP()						\
-{	if (net_dev->base_addr)	{					\
-		iounmap((void *)(net_dev->base_addr));			\
-		release_mem_region(pci_resource_start(dev_p, 0),	\
-					pci_resource_len(dev_p, 0)); } \
-	if (net_dev->irq) \
-		pci_release_regions(dev_p); }
-
-#define PCI_REG_READ_WORD(pci_dev, offset, Configuration)   {\
-	if (pci_read_config_word(pci_dev, offset, &reg16) == 0)     \
-		Configuration = le2cpu16(reg16);                        \
-	else                                                        \
-		Configuration = 0; }
-
-#define PCI_REG_WIRTE_WORD(pci_dev, offset, Configuration)  {\
-	reg16 = cpu2le16(Configuration);                        \
-	pci_write_config_word(pci_dev, offset, reg16); }
-
-#endif /* LINUX */
-
-#endif /* __RTMP_PCI_H__ */
diff --git a/drivers/staging/rt2860/iface/rtmp_usb.h b/drivers/staging/rt2860/iface/rtmp_usb.h
deleted file mode 100644
index 5712896..0000000
--- a/drivers/staging/rt2860/iface/rtmp_usb.h
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifndef __RTMP_USB_H__
-#define __RTMP_USB_H__
-
-#include "../rtusb_io.h"
-
-#ifdef LINUX
-#include <linux/usb.h>
-#endif /* LINUX */
-
-extern u8 EpToQueue[6];
-
-#define RXBULKAGGRE_ZISE			12
-#define MAX_TXBULK_LIMIT		(LOCAL_TXBUF_SIZE*(BULKAGGRE_ZISE-1))
-#define MAX_TXBULK_SIZE		(LOCAL_TXBUF_SIZE*BULKAGGRE_ZISE)
-#define MAX_RXBULK_SIZE		(LOCAL_TXBUF_SIZE*RXBULKAGGRE_ZISE)
-#define MAX_MLME_HANDLER_MEMORY 20
-
-/* Flags for Bulkflags control for bulk out data */
-#define	fRTUSB_BULK_OUT_DATA_NULL				0x00000001
-#define	fRTUSB_BULK_OUT_RTS					0x00000002
-#define	fRTUSB_BULK_OUT_MLME					0x00000004
-
-#define	fRTUSB_BULK_OUT_PSPOLL				0x00000010
-#define	fRTUSB_BULK_OUT_DATA_FRAG				0x00000020
-#define	fRTUSB_BULK_OUT_DATA_FRAG_2			0x00000040
-#define	fRTUSB_BULK_OUT_DATA_FRAG_3			0x00000080
-#define	fRTUSB_BULK_OUT_DATA_FRAG_4			0x00000100
-
-#define	fRTUSB_BULK_OUT_DATA_NORMAL			0x00010000
-#define	fRTUSB_BULK_OUT_DATA_NORMAL_2			0x00020000
-#define	fRTUSB_BULK_OUT_DATA_NORMAL_3			0x00040000
-#define	fRTUSB_BULK_OUT_DATA_NORMAL_4			0x00080000
-
-/* TODO:move to ./ate/include/iface/ate_usb.h */
-
-#define FREE_HTTX_RING(_pCookie, _pipeId, _txContext)			\
-{									\
-	if ((_txContext)->ENextBulkOutPosition == \
-	(_txContext)->CurWritePosition) {\
-		(_txContext)->bRingEmpty = TRUE;			\
-	}								\
-	/*NdisInterlockedDecrement(&(_p)->TxCount); */\
-}
-
-/******************************************************************************
-
-	USB Bulk operation related definitions
-
-******************************************************************************/
-
-#ifdef LINUX
-#define BULKAGGRE_ZISE			100
-#define RT28XX_PUT_DEVICE			usb_put_dev
-#define RTUSB_ALLOC_URB(iso)		usb_alloc_urb(iso, GFP_ATOMIC)
-#define RTUSB_SUBMIT_URB(pUrb)		usb_submit_urb(pUrb, \
-								GFP_ATOMIC)
-#define RTUSB_URB_ALLOC_BUFFER(pUsb_Dev, \
-							BufSize, \
-							pDma_addr)	\
-							usb_alloc_coherent(\
-							pUsb_Dev, \
-							BufSize, \
-							GFP_ATOMIC, \
-							pDma_addr)
-#define RTUSB_URB_FREE_BUFFER(pUsb_Dev, \
-							BufSize, \
-							pTransferBuf, \
-							Dma_addr)	\
-							usb_free_coherent( \
-							pUsb_Dev, \
-							BufSize, \
-							pTransferBuf, \
-							Dma_addr)
-
-#define RTUSB_FREE_URB(pUrb)	usb_free_urb(pUrb)
-
-/* unlink urb */
-#define RTUSB_UNLINK_URB(pUrb)		usb_kill_urb(pUrb)
-
-extern void dump_urb(struct urb *purb);
-
-#define InterlockedIncrement		atomic_inc
-#define NdisInterlockedIncrement	atomic_inc
-#define InterlockedDecrement		atomic_dec
-#define NdisInterlockedDecrement	atomic_dec
-#define InterlockedExchange		atomic_set
-
-#endif /* LINUX */
-
-#define NT_SUCCESS(status)		(((status) >= 0) ? (TRUE) : (FALSE))
-
-#define USBD_TRANSFER_DIRECTION_OUT		0
-#define USBD_TRANSFER_DIRECTION_IN		0
-#define USBD_SHORT_TRANSFER_OK			0
-#define PURB			struct urb *
-
-#define PIRP		void *
-#define NDIS_OID	u32
-#ifndef USB_ST_NOERROR
-#define USB_ST_NOERROR     0
-#endif
-
-/* vendor-specific control operations */
-#define CONTROL_TIMEOUT_JIFFIES ((100 * OS_HZ) / 1000)
-#define UNLINK_TIMEOUT_MS		3
-
-void RTUSBBulkOutDataPacketComplete(struct urb *purb, struct pt_regs *pt_regs);
-void RTUSBBulkOutMLMEPacketComplete(struct urb *pUrb, struct pt_regs *pt_regs);
-void RTUSBBulkOutNullFrameComplete(struct urb *pUrb, struct pt_regs *pt_regs);
-void RTUSBBulkOutRTSFrameComplete(struct urb *pUrb, struct pt_regs *pt_regs);
-void RTUSBBulkOutPsPollComplete(struct urb *pUrb, struct pt_regs *pt_regs);
-void RTUSBBulkRxComplete(struct urb *pUrb, struct pt_regs *pt_regs);
-
-#ifdef KTHREAD_SUPPORT
-#define RTUSBMlmeUp(pAd) \
-	do {								    \
-		struct rt_rtmp_os_task *_pTask = &((pAd)->mlmeTask);\
-		if (_pTask->kthread_task) {\
-			_pTask->kthread_running = TRUE; \
-		wake_up(&_pTask->kthread_q); \
-		} \
-	} while (0)
-#else
-#define RTUSBMlmeUp(pAd)	        \
-	do {								    \
-		struct rt_rtmp_os_task *_pTask = &((pAd)->mlmeTask);\
-		CHECK_PID_LEGALITY(_pTask->taskPID)		    \
-		{ \
-			RTMP_SEM_EVENT_UP(&(_pTask->taskSema)); \
-		} \
-	} while (0)
-#endif
-
-#ifdef KTHREAD_SUPPORT
-#define RTUSBCMDUp(pAd) \
-	do {	\
-		struct rt_rtmp_os_task *_pTask = &((pAd)->cmdQTask);	\
-		{ \
-			_pTask->kthread_running = TRUE; \
-		wake_up(&_pTask->kthread_q); \
-		} \
-	} while (0)
-
-#else
-#define RTUSBCMDUp(pAd)	                \
-	do {							    \
-		struct rt_rtmp_os_task *_pTask = &((pAd)->cmdQTask);	\
-		CHECK_PID_LEGALITY(_pTask->taskPID)	    \
-		{\
-			RTMP_SEM_EVENT_UP(&(_pTask->taskSema)); \
-		} \
-	} while (0)
-#endif
-
-#define DEVICE_VENDOR_REQUEST_OUT       0x40
-#define DEVICE_VENDOR_REQUEST_IN        0xc0
-/*#define INTERFACE_VENDOR_REQUEST_OUT    0x41*/
-/*#define INTERFACE_VENDOR_REQUEST_IN     0xc1*/
-
-#define BULKOUT_MGMT_RESET_FLAG		0x80
-
-#define RTUSB_SET_BULK_FLAG(_M, _F)	((_M)->BulkFlags |= (_F))
-#define RTUSB_CLEAR_BULK_FLAG(_M, _F)	((_M)->BulkFlags &= ~(_F))
-#define RTUSB_TEST_BULK_FLAG(_M, _F)	(((_M)->BulkFlags & (_F)) != 0)
-
-#define RTMP_IRQ_REQUEST(net_dev)		do {} while (0)
-#define RTMP_IRQ_RELEASE(net_dev)		do {} while (0)
-
-#endif /* __RTMP_USB_H__ */
diff --git a/drivers/staging/rt2860/mlme.h b/drivers/staging/rt2860/mlme.h
deleted file mode 100644
index a285851..0000000
--- a/drivers/staging/rt2860/mlme.h
+++ /dev/null
@@ -1,1050 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	mlme.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		------------------------------
-	John Chang		2003-08-28		Created
-	John Chang  		2004-09-06      	modified for RT2600
-	Justin P. Mattock	11/07/2010		Fix typos in comments
-
-*/
-#ifndef __MLME_H__
-#define __MLME_H__
-
-#include "rtmp_dot11.h"
-
-/* maximum supported capability information */
-/* ESS, IBSS, Privacy, Short Preamble, Spectrum mgmt, Short Slot */
-#define SUPPORTED_CAPABILITY_INFO   0x0533
-
-#define END_OF_ARGS                 -1
-#define LFSR_MASK                   0x80000057
-#define MLME_TASK_EXEC_INTV         100/*200*/	/* */
-#define LEAD_TIME                   5
-#define MLME_TASK_EXEC_MULTIPLE       10  /*5*/	/* MLME_TASK_EXEC_MULTIPLE * MLME_TASK_EXEC_INTV = 1 sec */
-#define REORDER_EXEC_INTV		100	/* 0.1 sec */
-
-/* The definition of Radar detection duration region */
-#define CE		0
-#define FCC		1
-#define JAP		2
-#define JAP_W53	3
-#define JAP_W56	4
-#define MAX_RD_REGION 5
-
-#define BEACON_LOST_TIME            (4 * OS_HZ)	/* 2048 msec = 2 sec */
-
-#define DLS_TIMEOUT                 1200	/* unit: msec */
-#define AUTH_TIMEOUT                300	/* unit: msec */
-#define ASSOC_TIMEOUT               300	/* unit: msec */
-#define JOIN_TIMEOUT                2000	/* unit: msec */
-#define SHORT_CHANNEL_TIME          90	/* unit: msec */
-#define MIN_CHANNEL_TIME            110	/* unit: msec, for dual band scan */
-#define MAX_CHANNEL_TIME            140	/* unit: msec, for single band scan */
-#define	FAST_ACTIVE_SCAN_TIME	    30	/* Active scan waiting for probe response time */
-#define CW_MIN_IN_BITS              4	/* actual CwMin = 2^CW_MIN_IN_BITS - 1 */
-#define LINK_DOWN_TIMEOUT           20000	/* unit: msec */
-#define AUTO_WAKEUP_TIMEOUT			70	/*unit: msec */
-
-#define CW_MAX_IN_BITS              10	/* actual CwMax = 2^CW_MAX_IN_BITS - 1 */
-
-/* Note: RSSI_TO_DBM_OFFSET has been changed to variable for new RF (2004-0720). */
-/* Should not refer to this constant anymore */
-/*#define RSSI_TO_DBM_OFFSET          120 // for RT2530 RSSI-115 = dBm */
-#define RSSI_FOR_MID_TX_POWER       -55	/* -55 db is considered mid-distance */
-#define RSSI_FOR_LOW_TX_POWER       -45	/* -45 db is considered very short distance and */
-					/* eligible to use a lower TX power */
-#define RSSI_FOR_LOWEST_TX_POWER    -30
-/*#define MID_TX_POWER_DELTA          0   // 0 db from full TX power upon mid-distance to AP */
-#define LOW_TX_POWER_DELTA          6	/* -3 db from full TX power upon very short distance. 1 grade is 0.5 db */
-#define LOWEST_TX_POWER_DELTA       16	/* -8 db from full TX power upon shortest distance. 1 grade is 0.5 db */
-
-#define RSSI_TRIGGERED_UPON_BELOW_THRESHOLD     0
-#define RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD   1
-#define RSSI_THRESHOLD_FOR_ROAMING              25
-#define RSSI_DELTA                              5
-
-/* Channel Quality Indication */
-#define CQI_IS_GOOD(cqi)            ((cqi) >= 50)
-/*#define CQI_IS_FAIR(cqi)          (((cqi) >= 20) && ((cqi) < 50)) */
-#define CQI_IS_POOR(cqi)            (cqi < 50)	/*(((cqi) >= 5) && ((cqi) < 20)) */
-#define CQI_IS_BAD(cqi)             (cqi < 5)
-#define CQI_IS_DEAD(cqi)            (cqi == 0)
-
-/* weighting factor to calculate Channel quality, total should be 100% */
-#define RSSI_WEIGHTING                   50
-#define TX_WEIGHTING                     30
-#define RX_WEIGHTING                     20
-
-#define BSS_NOT_FOUND                    0xFFFFFFFF
-
-#define MAX_LEN_OF_MLME_QUEUE            40	/*10 */
-
-#define SCAN_PASSIVE                     18	/* scan with no probe request, only wait beacon and probe response */
-#define SCAN_ACTIVE                      19	/* scan with probe request, and wait beacon and probe response */
-#define	SCAN_CISCO_PASSIVE				 20	/* Single channel passive scan */
-#define	SCAN_CISCO_ACTIVE				 21	/* Single channel active scan */
-#define	SCAN_CISCO_NOISE				 22	/* Single channel passive scan for noise histogram collection */
-#define	SCAN_CISCO_CHANNEL_LOAD			 23	/* Single channel passive scan for channel load collection */
-#define FAST_SCAN_ACTIVE                 24	/* scan with probe request, and wait beacon and probe response */
-
-#define MAC_ADDR_IS_GROUP(Addr)       (((Addr[0]) & 0x01))
-#define MAC_ADDR_HASH(Addr)            (Addr[0] ^ Addr[1] ^ Addr[2] ^ Addr[3] ^ Addr[4] ^ Addr[5])
-#define MAC_ADDR_HASH_INDEX(Addr)      (MAC_ADDR_HASH(Addr) % HASH_TABLE_SIZE)
-#define TID_MAC_HASH(Addr, TID)            (TID^Addr[0] ^ Addr[1] ^ Addr[2] ^ Addr[3] ^ Addr[4] ^ Addr[5])
-#define TID_MAC_HASH_INDEX(Addr, TID)      (TID_MAC_HASH(Addr, TID) % HASH_TABLE_SIZE)
-
-/* LED Control */
-/* association ON. one LED ON. another blinking when TX, OFF when idle */
-/* no association, both LED off */
-#define ASIC_LED_ACT_ON(pAd)        RTMP_IO_WRITE32(pAd, MAC_CSR14, 0x00031e46)
-#define ASIC_LED_ACT_OFF(pAd)       RTMP_IO_WRITE32(pAd, MAC_CSR14, 0x00001e46)
-
-/* bit definition of the 2-byte pBEACON->Capability field */
-#define CAP_IS_ESS_ON(x)                 (((x) & 0x0001) != 0)
-#define CAP_IS_IBSS_ON(x)                (((x) & 0x0002) != 0)
-#define CAP_IS_CF_POLLABLE_ON(x)         (((x) & 0x0004) != 0)
-#define CAP_IS_CF_POLL_REQ_ON(x)         (((x) & 0x0008) != 0)
-#define CAP_IS_PRIVACY_ON(x)             (((x) & 0x0010) != 0)
-#define CAP_IS_SHORT_PREAMBLE_ON(x)      (((x) & 0x0020) != 0)
-#define CAP_IS_PBCC_ON(x)                (((x) & 0x0040) != 0)
-#define CAP_IS_AGILITY_ON(x)             (((x) & 0x0080) != 0)
-#define CAP_IS_SPECTRUM_MGMT(x)          (((x) & 0x0100) != 0)	/* 802.11e d9 */
-#define CAP_IS_QOS(x)                    (((x) & 0x0200) != 0)	/* 802.11e d9 */
-#define CAP_IS_SHORT_SLOT(x)             (((x) & 0x0400) != 0)
-#define CAP_IS_APSD(x)                   (((x) & 0x0800) != 0)	/* 802.11e d9 */
-#define CAP_IS_IMMED_BA(x)               (((x) & 0x1000) != 0)	/* 802.11e d9 */
-#define CAP_IS_DSSS_OFDM(x)              (((x) & 0x2000) != 0)
-#define CAP_IS_DELAY_BA(x)               (((x) & 0x4000) != 0)	/* 802.11e d9 */
-
-#define CAP_GENERATE(ess, ibss, priv, s_pre, s_slot, spectrum)  (((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((s_pre) ? 0x0020 : 0x0000) | ((s_slot) ? 0x0400 : 0x0000) | ((spectrum) ? 0x0100 : 0x0000))
-
-#define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)	/* 802.11g */
-#define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)	/* 802.11g */
-#define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)	/* 802.11g */
-
-#define DRS_TX_QUALITY_WORST_BOUND       8	/* 3  // just test by gary */
-#define DRS_PENALTY                      8
-
-#define BA_NOTUSE	2
-/*BA Policy subfiled value in ADDBA frame */
-#define IMMED_BA	1
-#define DELAY_BA	0
-
-/* BA Initiator subfield in DELBA frame */
-#define ORIGINATOR	1
-#define RECIPIENT	0
-
-/* ADDBA Status Code */
-#define ADDBA_RESULTCODE_SUCCESS					0
-#define ADDBA_RESULTCODE_REFUSED					37
-#define ADDBA_RESULTCODE_INVALID_PARAMETERS			38
-
-/* DELBA Reason Code */
-#define DELBA_REASONCODE_QSTA_LEAVING				36
-#define DELBA_REASONCODE_END_BA						37
-#define DELBA_REASONCODE_UNKNOWN_BA					38
-#define DELBA_REASONCODE_TIMEOUT					39
-
-/* reset all OneSecTx counters */
-#define RESET_ONE_SEC_TX_CNT(__pEntry) \
-if (((__pEntry)) != NULL) { \
-	(__pEntry)->OneSecTxRetryOkCount = 0; \
-	(__pEntry)->OneSecTxFailCount = 0; \
-	(__pEntry)->OneSecTxNoRetryOkCount = 0; \
-}
-
-/* */
-/* 802.11 frame formats */
-/* */
-/*  HT Capability INFO field in HT Cap IE . */
-struct PACKED rt_ht_cap_info {
-	u16 AdvCoding:1;
-	u16 ChannelWidth:1;
-	u16 MimoPs:2;	/*momi power safe */
-	u16 GF:1;		/*green field */
-	u16 ShortGIfor20:1;
-	u16 ShortGIfor40:1;	/*for40MHz */
-	u16 TxSTBC:1;
-	u16 RxSTBC:2;
-	u16 DelayedBA:1;	/*rt2860c not support */
-	u16 AMsduSize:1;	/* only support as zero */
-	u16 CCKmodein40:1;
-	u16 PSMP:1;
-	u16 Forty_Mhz_Intolerant:1;
-	u16 LSIGTxopProSup:1;
-};
-
-/*  HT Capability INFO field in HT Cap IE . */
-struct PACKED rt_ht_cap_parm {
-	u8 MaxRAmpduFactor:2;
-	u8 MpduDensity:3;
-	u8 rsv:3;		/*momi power safe */
-};
-
-/*  HT Capability INFO field in HT Cap IE . */
-struct PACKED rt_ht_mcs_set {
-	u8 MCSSet[10];
-	u8 SupRate[2];	/* unit : 1Mbps */
-	u8 TxMCSSetDefined:1;
-	u8 TxRxNotEqual:1;
-	u8 TxStream:2;
-	u8 MpduDensity:1;
-	u8 rsv:3;
-	u8 rsv3[3];
-};
-
-/*  HT Capability INFO field in HT Cap IE . */
-struct PACKED rt_ext_ht_cap_info {
-	u16 Pco:1;
-	u16 TranTime:2;
-	u16 rsv:5;		/*momi power safe */
-	u16 MCSFeedback:2;	/*0:no MCS feedback, 2:unsolicited MCS feedback, 3:Full MCS feedback,  1:rsv. */
-	u16 PlusHTC:1;	/*+HTC control field support */
-	u16 RDGSupport:1;	/*reverse Direction Grant  support */
-	u16 rsv2:4;
-};
-
-/*  HT Beamforming field in HT Cap IE . */
-struct PACKED rt_ht_bf_cap {
-	unsigned long TxBFRecCapable:1;
-	unsigned long RxSoundCapable:1;
-	unsigned long TxSoundCapable:1;
-	unsigned long RxNDPCapable:1;
-	unsigned long TxNDPCapable:1;
-	unsigned long ImpTxBFCapable:1;
-	unsigned long Calibration:2;
-	unsigned long ExpCSICapable:1;
-	unsigned long ExpNoComSteerCapable:1;
-	unsigned long ExpComSteerCapable:1;
-	unsigned long ExpCSIFbk:2;
-	unsigned long ExpNoComBF:2;
-	unsigned long ExpComBF:2;
-	unsigned long MinGrouping:2;
-	unsigned long CSIBFAntSup:2;
-	unsigned long NoComSteerBFAntSup:2;
-	unsigned long ComSteerBFAntSup:2;
-	unsigned long CSIRowBFSup:2;
-	unsigned long ChanEstimation:2;
-	unsigned long rsv:3;
-};
-
-/*  HT antenna selection field in HT Cap IE . */
-struct PACKED rt_ht_as_cap {
-	u8 AntSelect:1;
-	u8 ExpCSIFbkTxASEL:1;
-	u8 AntIndFbkTxASEL:1;
-	u8 ExpCSIFbk:1;
-	u8 AntIndFbk:1;
-	u8 RxASel:1;
-	u8 TxSoundPPDU:1;
-	u8 rsv:1;
-};
-
-/* Draft 1.0 set IE length 26, but is extensible.. */
-#define SIZE_HT_CAP_IE		26
-/* The structure for HT Capability IE. */
-struct PACKED rt_ht_capability_ie {
-	struct rt_ht_cap_info HtCapInfo;
-	struct rt_ht_cap_parm HtCapParm;
-/*      struct rt_ht_mcs_set              HtMCSSet; */
-	u8 MCSSet[16];
-	struct rt_ext_ht_cap_info ExtHtCapInfo;
-	struct rt_ht_bf_cap TxBFCap;	/* beamforming cap. rt2860c not support beamforming. */
-	struct rt_ht_as_cap ASCap;	/*antenna selection. */
-};
-
-/* 802.11n draft3 related structure definitions. */
-/* 7.3.2.60 */
-#define dot11OBSSScanPassiveDwell							20	/* in TU. min amount of time that the STA continuously scans each channel when performing an active OBSS scan. */
-#define dot11OBSSScanActiveDwell							10	/* in TU.min amount of time that the STA continuously scans each channel when performing an passive OBSS scan. */
-#define dot11BSSWidthTriggerScanInterval					300	/* in sec. max interval between scan operations to be performed to detect BSS channel width trigger events. */
-#define dot11OBSSScanPassiveTotalPerChannel					200	/* in TU. min total amount of time that the STA scans each channel when performing a passive OBSS scan. */
-#define dot11OBSSScanActiveTotalPerChannel					20	/*in TU. min total amount of time that the STA scans each channel when performing a active OBSS scan */
-#define dot11BSSWidthChannelTransactionDelayFactor			5	/* min ratio between the delay time in performing a switch from 20MHz BSS to 20/40 BSS operation and the maximum */
-																/*      interval between overlapping BSS scan operations. */
-#define dot11BSSScanActivityThreshold						25	/* in %%, max total time that a STA may be active on the medium during a period of */
-																/*      (dot11BSSWidthChannelTransactionDelayFactor * dot11BSSWidthTriggerScanInterval) seconds without */
-																/*      being obligated to perform OBSS Scan operations. default is 25(== 0.25%) */
-
-struct PACKED rt_overlap_bss_scan_ie {
-	u16 ScanPassiveDwell;
-	u16 ScanActiveDwell;
-	u16 TriggerScanInt;	/* Trigger scan interval */
-	u16 PassiveTalPerChannel;	/* passive total per channel */
-	u16 ActiveTalPerChannel;	/* active total per channel */
-	u16 DelayFactor;	/* BSS width channel transition delay factor */
-	u16 ScanActThre;	/* Scan Activity threshold */
-};
-
-/*  7.3.2.56. 20/40 Coexistence element used in  Element ID = 72 = IE_2040_BSS_COEXIST */
-typedef union PACKED _BSS_2040_COEXIST_IE {
-	struct PACKED {
-		u8 InfoReq:1;
-		u8 Intolerant40:1;	/* Inter-BSS. set 1 when prohibits a receiving BSS from operating as a 20/40 Mhz BSS. */
-		u8 BSS20WidthReq:1;	/* Intra-BSS set 1 when prohibits a receiving AP from operating its BSS as a 20/40MHz BSS. */
-		u8 rsv:5;
-	} field;
-	u8 word;
-} BSS_2040_COEXIST_IE, *PBSS_2040_COEXIST_IE;
-
-struct rt_trigger_eventa {
-	BOOLEAN bValid;
-	u8 BSSID[6];
-	u8 RegClass;		/* Regulatory Class */
-	u16 Channel;
-	unsigned long CDCounter;	/* Maintain a separate count down counter for each Event A. */
-};
-
-/* 20/40 trigger event table */
-/* If one Event (A) is deleted or created, or if Event (B) is detected or not detected, STA should send 2040BSSCoexistence to AP. */
-#define MAX_TRIGGER_EVENT		64
-struct rt_trigger_event_tab {
-	u8 EventANo;
-	struct rt_trigger_eventa EventA[MAX_TRIGGER_EVENT];
-	unsigned long EventBCountDown;	/* Count down counter for Event B. */
-};
-
-/* 7.3.27 20/40 Bss Coexistence Mgmt capability used in extended capabilities information IE( ID = 127 = IE_EXT_CAPABILITY). */
-/*      This is the first octet and was defined in 802.11n D3.03 and 802.11yD9.0 */
-struct PACKED rt_ext_cap_info_element {
-	u8 BssCoexistMgmtSupport:1;
-	u8 rsv:1;
-	u8 ExtendChannelSwitch:1;
-	u8 rsv2:5;
-};
-
-/* 802.11n 7.3.2.61 */
-struct PACKED rt_bss_2040_coexist_element {
-	u8 ElementID;	/* ID = IE_2040_BSS_COEXIST = 72 */
-	u8 Len;
-	BSS_2040_COEXIST_IE BssCoexistIe;
-};
-
-/*802.11n 7.3.2.59 */
-struct PACKED rt_bss_2040_intolerant_ch_report {
-	u8 ElementID;	/* ID = IE_2040_BSS_INTOLERANT_REPORT = 73 */
-	u8 Len;
-	u8 RegulatoryClass;
-	u8 ChList[0];
-};
-
-/* The structure for channel switch announcement IE. This is in 802.11n D3.03 */
-struct PACKED rt_cha_switch_announce_ie {
-	u8 SwitchMode;	/*channel switch mode */
-	u8 NewChannel;	/* */
-	u8 SwitchCount;	/* */
-};
-
-/* The structure for channel switch announcement IE. This is in 802.11n D3.03 */
-struct PACKED rt_sec_cha_offset_ie {
-	u8 SecondaryChannelOffset;	/* 1: Secondary above, 3: Secondary below, 0: no Secondary */
-};
-
-/* This structure is extracted from struct struct rt_ht_capability */
-struct rt_ht_phy_info {
-	BOOLEAN bHtEnable;	/* If we should use ht rate. */
-	BOOLEAN bPreNHt;	/* If we should use ht rate. */
-	/*Subtract from HT Capability IE */
-	u8 MCSSet[16];
-};
-
-/*This structure subtracts ralink supports from all 802.11n-related features. */
-/*Features not listed here but contained in 802.11n spec are not supported in rt2860. */
-struct rt_ht_capability {
-	u16 ChannelWidth:1;
-	u16 MimoPs:2;	/*mimo power safe MMPS_ */
-	u16 GF:1;		/*green field */
-	u16 ShortGIfor20:1;
-	u16 ShortGIfor40:1;	/*for40MHz */
-	u16 TxSTBC:1;
-	u16 RxSTBC:2;	/* 2 bits */
-	u16 AmsduEnable:1;	/* Enable to transmit A-MSDU. Suggest disable. We should use A-MPDU to gain best benefit of 802.11n */
-	u16 AmsduSize:1;	/* Max receiving A-MSDU size */
-	u16 rsv:5;
-
-	/*Subtract from Addiont HT INFO IE */
-	u8 MaxRAmpduFactor:2;
-	u8 MpduDensity:3;
-	u8 ExtChanOffset:2;	/* Please note the difference with following     u8   NewExtChannelOffset; from 802.11n */
-	u8 RecomWidth:1;
-
-	u16 OperaionMode:2;
-	u16 NonGfPresent:1;
-	u16 rsv3:1;
-	u16 OBSS_NonHTExist:1;
-	u16 rsv2:11;
-
-	/* New Extension Channel Offset IE */
-	u8 NewExtChannelOffset;
-	/* Extension Capability IE = 127 */
-	u8 BSSCoexist2040;
-};
-
-/*   field in Additional HT Information IE . */
-struct PACKED rt_add_htinfo {
-	u8 ExtChanOffset:2;
-	u8 RecomWidth:1;
-	u8 RifsMode:1;
-	u8 S_PSMPSup:1;	/*Indicate support for scheduled PSMP */
-	u8 SerInterGranu:3;	/*service interval granularity */
-};
-
-struct PACKED rt_add_htinfo2 {
-	u16 OperaionMode:2;
-	u16 NonGfPresent:1;
-	u16 rsv:1;
-	u16 OBSS_NonHTExist:1;
-	u16 rsv2:11;
-};
-
-/* TODO: Need sync with spec about the definition of StbcMcs. In Draft 3.03, it's reserved. */
-struct PACKED rt_add_htinfo3 {
-	u16 StbcMcs:6;
-	u16 DualBeacon:1;
-	u16 DualCTSProtect:1;
-	u16 STBCBeacon:1;
-	u16 LsigTxopProt:1;	/* L-SIG TXOP protection full support */
-	u16 PcoActive:1;
-	u16 PcoPhase:1;
-	u16 rsv:4;
-};
-
-#define SIZE_ADD_HT_INFO_IE		22
-struct PACKED rt_add_ht_info_ie {
-	u8 ControlChan;
-	struct rt_add_htinfo AddHtInfo;
-	struct rt_add_htinfo2 AddHtInfo2;
-	struct rt_add_htinfo3 AddHtInfo3;
-	u8 MCSSet[16];	/* Basic MCS set */
-};
-
-struct PACKED rt_new_ext_chan_ie {
-	u8 NewExtChanOffset;
-};
-
-struct PACKED rt_frame_802_11 {
-	struct rt_header_802_11 Hdr;
-	u8 Octet[1];
-};
-
-/* QoSNull embedding of management action. When HT Control MA field set to 1. */
-struct PACKED rt_ma_body {
-	u8 Category;
-	u8 Action;
-	u8 Octet[1];
-};
-
-struct PACKED rt_header_802_3 {
-	u8 DAAddr1[MAC_ADDR_LEN];
-	u8 SAAddr2[MAC_ADDR_LEN];
-	u8 Octet[2];
-};
-/*//Block ACK related format */
-/* 2-byte BA Parameter  field  in       DELBA frames to terminate an already set up bA */
-struct PACKED rt_delba_parm {
-	u16 Rsv:11;		/* always set to 0 */
-	u16 Initiator:1;	/* 1: originator    0:recipient */
-	u16 TID:4;		/* value of TC os TS */
-};
-
-/* 2-byte BA Parameter Set field  in ADDBA frames to signal parm for setting up a BA */
-struct PACKED rt_ba_parm {
-	u16 AMSDUSupported:1;	/* 0: not permitted             1: permitted */
-	u16 BAPolicy:1;	/* 1: immediately BA    0:delayed BA */
-	u16 TID:4;		/* value of TC os TS */
-	u16 BufSize:10;	/* number of buffer of size 2304 octetsr */
-};
-
-/* 2-byte BA Starting Seq CONTROL field */
-typedef union PACKED _BASEQ_CONTROL {
-	struct PACKED {
-		u16 FragNum:4;	/* always set to 0 */
-		u16 StartSeq:12;	/* sequence number of the 1st MSDU for which this BAR is sent */
-	} field;
-	u16 word;
-} BASEQ_CONTROL, *PBASEQ_CONTROL;
-
-/*BAControl and BARControl are the same */
-/* 2-byte BA CONTROL field in BA frame */
-struct PACKED rt_ba_control {
-	u16 ACKPolicy:1;	/* only related to N-Delayed BA. But not support in RT2860b. 0:NormalACK  1:No ACK */
-	u16 MTID:1;		/*EWC V1.24 */
-	u16 Compressed:1;
-	u16 Rsv:9;
-	u16 TID:4;
-};
-
-/* 2-byte BAR CONTROL field in BAR frame */
-struct PACKED rt_bar_control {
-	u16 ACKPolicy:1;	/* 0:normal ack,  1:no ack. */
-	u16 MTID:1;		/*if this bit1, use  struct rt_frame_mtba_req,  if 0, use struct rt_frame_ba_req */
-	u16 Compressed:1;
-	u16 Rsv1:9;
-	u16 TID:4;
-};
-
-/* BARControl in MTBAR frame */
-struct PACKED rt_mtbar_control {
-	u16 ACKPolicy:1;
-	u16 MTID:1;
-	u16 Compressed:1;
-	u16 Rsv1:9;
-	u16 NumTID:4;
-};
-
-struct PACKED rt_per_tid_info {
-	u16 Rsv1:12;
-	u16 TID:4;
-};
-
-struct rt_each_tid {
-	struct rt_per_tid_info PerTID;
-	BASEQ_CONTROL BAStartingSeq;
-};
-
-/* BAREQ AND MTBAREQ have the same subtype BAR, 802.11n BAR use compressed bitmap. */
-struct PACKED rt_frame_ba_req {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	struct rt_bar_control BARControl;
-	BASEQ_CONTROL BAStartingSeq;
-};
-
-struct PACKED rt_frame_mtba_req {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	struct rt_mtbar_control MTBARControl;
-	struct rt_per_tid_info PerTIDInfo;
-	BASEQ_CONTROL BAStartingSeq;
-};
-
-/* Compressed format is mandatory in HT STA */
-struct PACKED rt_frame_mtba {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	struct rt_ba_control BAControl;
-	BASEQ_CONTROL BAStartingSeq;
-	u8 BitMap[8];
-};
-
-struct PACKED rt_frame_psmp_action {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	u8 Psmp;		/* 7.3.1.25 */
-};
-
-struct PACKED rt_frame_action_hdr {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-};
-
-/*Action Frame */
-/*Action Frame  Category:Spectrum,  Action:Channel Switch. 7.3.2.20 */
-struct PACKED rt_chan_switch_announce {
-	u8 ElementID;	/* ID = IE_CHANNEL_SWITCH_ANNOUNCEMENT = 37 */
-	u8 Len;
-	struct rt_cha_switch_announce_ie CSAnnounceIe;
-};
-
-/*802.11n : 7.3.2.20a */
-struct PACKED rt_second_chan_offset {
-	u8 ElementID;	/* ID = IE_SECONDARY_CH_OFFSET = 62 */
-	u8 Len;
-	struct rt_sec_cha_offset_ie SecChOffsetIe;
-};
-
-struct PACKED rt_frame_spetrum_cs {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	struct rt_chan_switch_announce CSAnnounce;
-	struct rt_second_chan_offset SecondChannel;
-};
-
-struct PACKED rt_frame_addba_req {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	u8 Token;		/* 1 */
-	struct rt_ba_parm BaParm;		/*  2 - 10 */
-	u16 TimeOutValue;	/* 0 - 0 */
-	BASEQ_CONTROL BaStartSeq;	/* 0-0 */
-};
-
-struct PACKED rt_frame_addba_rsp {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	u8 Token;
-	u16 StatusCode;
-	struct rt_ba_parm BaParm;		/*0 - 2 */
-	u16 TimeOutValue;
-};
-
-struct PACKED rt_frame_delba_req {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	struct rt_delba_parm DelbaParm;
-	u16 ReasonCode;
-};
-
-/*7.2.1.7 */
-struct PACKED rt_frame_bar {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	struct rt_bar_control BarControl;
-	BASEQ_CONTROL StartingSeq;
-};
-
-/*7.2.1.7 */
-struct PACKED rt_frame_ba {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	struct rt_bar_control BarControl;
-	BASEQ_CONTROL StartingSeq;
-	u8 bitmask[8];
-};
-
-/* Radio Measurement Request Frame Format */
-struct PACKED rt_frame_rm_req_action {
-	struct rt_header_802_11 Hdr;
-	u8 Category;
-	u8 Action;
-	u8 Token;
-	u16 Repetition;
-	u8 data[0];
-};
-
-struct PACKED rt_ht_ext_channel_switch_announcement_ie {
-	u8 ID;
-	u8 Length;
-	u8 ChannelSwitchMode;
-	u8 NewRegClass;
-	u8 NewChannelNum;
-	u8 ChannelSwitchCount;
-};
-
-/* */
-/* _Limit must be the 2**n - 1 */
-/* _SEQ1 , _SEQ2 must be within 0 ~ _Limit */
-/* */
-#define SEQ_STEPONE(_SEQ1, _SEQ2, _Limit)	((_SEQ1 == ((_SEQ2+1) & _Limit)))
-#define SEQ_SMALLER(_SEQ1, _SEQ2, _Limit)	(((_SEQ1-_SEQ2) & ((_Limit+1)>>1)))
-#define SEQ_LARGER(_SEQ1, _SEQ2, _Limit)	((_SEQ1 != _SEQ2) && !(((_SEQ1-_SEQ2) & ((_Limit+1)>>1))))
-#define SEQ_WITHIN_WIN(_SEQ1, _SEQ2, _WIN, _Limit) (SEQ_LARGER(_SEQ1, _SEQ2, _Limit) &&  \
-												SEQ_SMALLER(_SEQ1, ((_SEQ2+_WIN+1)&_Limit), _Limit))
-
-/* */
-/* Contention-free parameter (without ID and Length) */
-/* */
-struct PACKED rt_cf_parm {
-	BOOLEAN bValid;		/* 1: variable contains valid value */
-	u8 CfpCount;
-	u8 CfpPeriod;
-	u16 CfpMaxDuration;
-	u16 CfpDurRemaining;
-};
-
-struct rt_cipher_suite {
-	NDIS_802_11_ENCRYPTION_STATUS PairCipher;	/* Unicast cipher 1, this one has more secured cipher suite */
-	NDIS_802_11_ENCRYPTION_STATUS PairCipherAux;	/* Unicast cipher 2 if AP announce two unicast cipher suite */
-	NDIS_802_11_ENCRYPTION_STATUS GroupCipher;	/* Group cipher */
-	u16 RsnCapability;	/* RSN capability from beacon */
-	BOOLEAN bMixMode;	/* Indicate Pair & Group cipher might be different */
-};
-
-/* EDCA configuration from AP's BEACON/ProbeRsp */
-struct rt_edca_parm {
-	BOOLEAN bValid;		/* 1: variable contains valid value */
-	BOOLEAN bAdd;		/* 1: variable contains valid value */
-	BOOLEAN bQAck;
-	BOOLEAN bQueueRequest;
-	BOOLEAN bTxopRequest;
-	BOOLEAN bAPSDCapable;
-/*  BOOLEAN     bMoreDataAck; */
-	u8 EdcaUpdateCount;
-	u8 Aifsn[4];		/* 0:AC_BK, 1:AC_BE, 2:AC_VI, 3:AC_VO */
-	u8 Cwmin[4];
-	u8 Cwmax[4];
-	u16 Txop[4];		/* in unit of 32-us */
-	BOOLEAN bACM[4];	/* 1: Admission Control of AC_BK is mandatory */
-};
-
-/* QBSS LOAD information from QAP's BEACON/ProbeRsp */
-struct rt_qbss_load_parm {
-	BOOLEAN bValid;		/* 1: variable contains valid value */
-	u16 StaNum;
-	u8 ChannelUtilization;
-	u16 RemainingAdmissionControl;	/* in unit of 32-us */
-};
-
-/* QBSS Info field in QSTA's assoc req */
-struct PACKED rt_qbss_sta_info_parm {
-	u8 UAPSD_AC_VO:1;
-	u8 UAPSD_AC_VI:1;
-	u8 UAPSD_AC_BK:1;
-	u8 UAPSD_AC_BE:1;
-	u8 Rsv1:1;
-	u8 MaxSPLength:2;
-	u8 Rsv2:1;
-};
-
-/* QBSS Info field in QAP's Beacon/ProbeRsp */
-struct PACKED rt_qbss_ap_info_parm {
-	u8 ParamSetCount:4;
-	u8 Rsv:3;
-	u8 UAPSD:1;
-};
-
-/* QOS Capability reported in QAP's BEACON/ProbeRsp */
-/* QOS Capability sent out in QSTA's AssociateReq/ReAssociateReq */
-struct rt_qos_capability_parm {
-	BOOLEAN bValid;		/* 1: variable contains valid value */
-	BOOLEAN bQAck;
-	BOOLEAN bQueueRequest;
-	BOOLEAN bTxopRequest;
-/*  BOOLEAN     bMoreDataAck; */
-	u8 EdcaUpdateCount;
-};
-
-struct rt_wpa_ie {
-	u8 IELen;
-	u8 IE[MAX_CUSTOM_LEN];
-};
-
-struct rt_bss_entry {
-	u8 Bssid[MAC_ADDR_LEN];
-	u8 Channel;
-	u8 CentralChannel;	/*Store the wide-band central channel for 40MHz. used in 40MHz AP. Or this is the same as Channel. */
-	u8 BssType;
-	u16 AtimWin;
-	u16 BeaconPeriod;
-
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen;
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 ExtRateLen;
-	struct rt_ht_capability_ie HtCapability;
-	u8 HtCapabilityLen;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 AddHtInfoLen;
-	u8 NewExtChanOffset;
-	char Rssi;
-	u8 Privacy;		/* Indicate security function ON/OFF. Don't mess up with auth mode. */
-	u8 Hidden;
-
-	u16 DtimPeriod;
-	u16 CapabilityInfo;
-
-	u16 CfpCount;
-	u16 CfpPeriod;
-	u16 CfpMaxDuration;
-	u16 CfpDurRemaining;
-	u8 SsidLen;
-	char Ssid[MAX_LEN_OF_SSID];
-
-	unsigned long LastBeaconRxTime;	/* OS's timestamp */
-
-	BOOLEAN bSES;
-
-	/* New for WPA2 */
-	struct rt_cipher_suite WPA;	/* AP announced WPA cipher suite */
-	struct rt_cipher_suite WPA2;	/* AP announced WPA2 cipher suite */
-
-	/* New for microsoft WPA support */
-	struct rt_ndis_802_11_fixed_ies FixIEs;
-	NDIS_802_11_AUTHENTICATION_MODE AuthModeAux;	/* Addition mode for WPA2 / WPA capable AP */
-	NDIS_802_11_AUTHENTICATION_MODE AuthMode;
-	NDIS_802_11_WEP_STATUS WepStatus;	/* Unicast Encryption Algorithm extract from VAR_IE */
-	u16 VarIELen;	/* Length of next VIE include EID & Length */
-	u8 VarIEs[MAX_VIE_LEN];
-
-	/* CCX Ckip information */
-	u8 CkipFlag;
-
-	/* CCX 2 TSF */
-	u8 PTSF[4];		/* Parent TSF */
-	u8 TTSF[8];		/* Target TSF */
-
-	/* 802.11e d9, and WMM */
-	struct rt_edca_parm EdcaParm;
-	struct rt_qos_capability_parm QosCapability;
-	struct rt_qbss_load_parm QbssLoad;
-	struct rt_wpa_ie WpaIE;
-	struct rt_wpa_ie RsnIE;
-};
-
-struct rt_bss_table {
-	u8 BssNr;
-	u8 BssOverlapNr;
-	struct rt_bss_entry BssEntry[MAX_LEN_OF_BSS_TABLE];
-};
-
-struct rt_mlme_queue_elem {
-	unsigned long Machine;
-	unsigned long MsgType;
-	unsigned long MsgLen;
-	u8 Msg[MGMT_DMA_BUFFER_SIZE];
-	LARGE_INTEGER TimeStamp;
-	u8 Rssi0;
-	u8 Rssi1;
-	u8 Rssi2;
-	u8 Signal;
-	u8 Channel;
-	u8 Wcid;
-	BOOLEAN Occupied;
-};
-
-struct rt_mlme_queue {
-	unsigned long Num;
-	unsigned long Head;
-	unsigned long Tail;
-	spinlock_t Lock;
-	struct rt_mlme_queue_elem Entry[MAX_LEN_OF_MLME_QUEUE];
-};
-
-typedef void(*STATE_MACHINE_FUNC) (void *Adaptor, struct rt_mlme_queue_elem *Elem);
-
-struct rt_state_machine {
-	unsigned long Base;
-	unsigned long NrState;
-	unsigned long NrMsg;
-	unsigned long CurrState;
-	STATE_MACHINE_FUNC *TransFunc;
-};
-
-/* MLME AUX data structure that holds temporarliy settings during a connection attempt. */
-/* Once this attempt succeeds, all settings will be copy to pAd->StaActive. */
-/* A connection attempt (user set OID, roaming, CCX fast roaming,..) consists of */
-/* several steps (JOIN, AUTH, ASSOC or REASSOC) and may fail at any step. We purposely */
-/* separate this under-trial settings away from pAd->StaActive so that once */
-/* this new attempt failed, driver can auto-recover back to the active settings. */
-struct rt_mlme_aux {
-	u8 BssType;
-	u8 Ssid[MAX_LEN_OF_SSID];
-	u8 SsidLen;
-	u8 Bssid[MAC_ADDR_LEN];
-	u8 AutoReconnectSsid[MAX_LEN_OF_SSID];
-	u8 AutoReconnectSsidLen;
-	u16 Alg;
-	u8 ScanType;
-	u8 Channel;
-	u8 CentralChannel;
-	u16 Aid;
-	u16 CapabilityInfo;
-	u16 BeaconPeriod;
-	u16 CfpMaxDuration;
-	u16 CfpPeriod;
-	u16 AtimWin;
-
-	/* Copy supported rate from desired AP's beacon. We are trying to match */
-	/* AP's supported and extended rate settings. */
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen;
-	u8 ExtRateLen;
-	struct rt_ht_capability_ie HtCapability;
-	u8 HtCapabilityLen;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 NewExtChannelOffset;
-	/*struct rt_ht_capability      SupportedHtPhy; */
-
-	/* new for QOS */
-	struct rt_qos_capability_parm APQosCapability;	/* QOS capability of the current associated AP */
-	struct rt_edca_parm APEdcaParm;	/* EDCA parameters of the current associated AP */
-	struct rt_qbss_load_parm APQbssLoad;	/* QBSS load of the current associated AP */
-
-	/* new to keep Ralink specific feature */
-	unsigned long APRalinkIe;
-
-	struct rt_bss_table SsidBssTab;	/* AP list for the same SSID */
-	struct rt_bss_table RoamTab;	/* AP list eligible for roaming */
-	unsigned long BssIdx;
-	unsigned long RoamIdx;
-
-	BOOLEAN CurrReqIsFromNdis;
-
-	struct rt_ralink_timer BeaconTimer, ScanTimer;
-	struct rt_ralink_timer AuthTimer;
-	struct rt_ralink_timer AssocTimer, ReassocTimer, DisassocTimer;
-};
-
-struct rt_mlme_addba_req {
-	u8 Wcid;		/* */
-	u8 pAddr[MAC_ADDR_LEN];
-	u8 BaBufSize;
-	u16 TimeOutValue;
-	u8 TID;
-	u8 Token;
-	u16 BaStartSeq;
-};
-
-struct rt_mlme_delba_req {
-	u8 Wcid;		/* */
-	u8 Addr[MAC_ADDR_LEN];
-	u8 TID;
-	u8 Initiator;
-};
-
-/* assoc struct is equal to reassoc */
-struct rt_mlme_assoc_req {
-	u8 Addr[MAC_ADDR_LEN];
-	u16 CapabilityInfo;
-	u16 ListenIntv;
-	unsigned long Timeout;
-};
-
-struct rt_mlme_disassoc_req {
-	u8 Addr[MAC_ADDR_LEN];
-	u16 Reason;
-};
-
-struct rt_mlme_auth_req {
-	u8 Addr[MAC_ADDR_LEN];
-	u16 Alg;
-	unsigned long Timeout;
-};
-
-struct rt_mlme_deauth_req {
-	u8 Addr[MAC_ADDR_LEN];
-	u16 Reason;
-};
-
-struct rt_mlme_join_req {
-	unsigned long BssIdx;
-};
-
-struct rt_mlme_scan_req {
-	u8 Bssid[MAC_ADDR_LEN];
-	u8 BssType;
-	u8 ScanType;
-	u8 SsidLen;
-	char Ssid[MAX_LEN_OF_SSID];
-};
-
-struct rt_mlme_start_req {
-	char Ssid[MAX_LEN_OF_SSID];
-	u8 SsidLen;
-};
-
-struct PACKED rt_eid {
-	u8 Eid;
-	u8 Len;
-	u8 Octet[1];
-};
-
-struct PACKED rt_rtmp_tx_rate_switch {
-	u8 ItemNo;
-	u8 STBC:1;
-	u8 ShortGI:1;
-	u8 BW:1;
-	u8 Rsv1:1;
-	u8 Mode:2;
-	u8 Rsv2:2;
-	u8 CurrMCS;
-	u8 TrainUp;
-	u8 TrainDown;
-};
-
-/* ========================== AP mlme.h =============================== */
-#define TBTT_PRELOAD_TIME       384	/* usec. LomgPreamble + 24-byte at 1Mbps */
-#define DEFAULT_DTIM_PERIOD     1
-
-#define MAC_TABLE_AGEOUT_TIME			300	/* unit: sec */
-#define MAC_TABLE_ASSOC_TIMEOUT			5	/* unit: sec */
-#define MAC_TABLE_FULL(Tab)				((Tab).size == MAX_LEN_OF_MAC_TABLE)
-
-/* AP shall drop the sta if continue Tx fail count reach it. */
-#define MAC_ENTRY_LIFE_CHECK_CNT		20	/* packet cnt. */
-
-/* Value domain of pMacEntry->Sst */
-typedef enum _Sst {
-	SST_NOT_AUTH,		/* 0: equivalent to IEEE 802.11/1999 state 1 */
-	SST_AUTH,		/* 1: equivalent to IEEE 802.11/1999 state 2 */
-	SST_ASSOC		/* 2: equivalent to IEEE 802.11/1999 state 3 */
-} SST;
-
-/* value domain of pMacEntry->AuthState */
-typedef enum _AuthState {
-	AS_NOT_AUTH,
-	AS_AUTH_OPEN,		/* STA has been authenticated using OPEN SYSTEM */
-	AS_AUTH_KEY,		/* STA has been authenticated using SHARED KEY */
-	AS_AUTHENTICATING	/* STA is waiting for AUTH seq#3 using SHARED KEY */
-} AUTH_STATE;
-
-/*for-wpa value domain of pMacEntry->WpaState  802.1i D3   p.114 */
-typedef enum _ApWpaState {
-	AS_NOTUSE,		/* 0 */
-	AS_DISCONNECT,		/* 1 */
-	AS_DISCONNECTED,	/* 2 */
-	AS_INITIALIZE,		/* 3 */
-	AS_AUTHENTICATION,	/* 4 */
-	AS_AUTHENTICATION2,	/* 5 */
-	AS_INITPMK,		/* 6 */
-	AS_INITPSK,		/* 7 */
-	AS_PTKSTART,		/* 8 */
-	AS_PTKINIT_NEGOTIATING,	/* 9 */
-	AS_PTKINITDONE,		/* 10 */
-	AS_UPDATEKEYS,		/* 11 */
-	AS_INTEGRITY_FAILURE,	/* 12 */
-	AS_KEYUPDATE,		/* 13 */
-} AP_WPA_STATE;
-
-/* for-wpa value domain of pMacEntry->WpaState  802.1i D3   p.114 */
-typedef enum _GTKState {
-	REKEY_NEGOTIATING,
-	REKEY_ESTABLISHED,
-	KEYERROR,
-} GTK_STATE;
-
-/*  for-wpa  value domain of pMacEntry->WpaState  802.1i D3   p.114 */
-typedef enum _WpaGTKState {
-	SETKEYS,
-	SETKEYS_DONE,
-} WPA_GTK_STATE;
-/* ====================== end of AP mlme.h ============================ */
-
-#endif /* MLME_H__ */
diff --git a/drivers/staging/rt2860/oid.h b/drivers/staging/rt2860/oid.h
deleted file mode 100644
index 5a25f0d..0000000
--- a/drivers/staging/rt2860/oid.h
+++ /dev/null
@@ -1,779 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	oid.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name			Date			Modification logs
-	Justin P. Mattock 	11/07/2010	Fix typos in comments
-*/
-#ifndef _OID_H_
-#define _OID_H_
-
-/*#include <linux/wireless.h> */
-
-#ifndef TRUE
-#define TRUE				1
-#endif
-#ifndef FALSE
-#define FALSE				0
-#endif
-/* */
-/* IEEE 802.11 Structures and definitions */
-/* */
-#define MAX_TX_POWER_LEVEL              100	/* mW */
-#define MAX_RSSI_TRIGGER                -10	/* dBm */
-#define MIN_RSSI_TRIGGER                -200	/* dBm */
-#define MAX_FRAG_THRESHOLD              2346	/* byte count */
-#define MIN_FRAG_THRESHOLD              256	/* byte count */
-#define MAX_RTS_THRESHOLD               2347	/* byte count */
-
-/* new types for Media Specific Indications */
-/* Extension channel offset */
-#define EXTCHA_NONE			0
-#define EXTCHA_ABOVE		0x1
-#define EXTCHA_BELOW		0x3
-
-/* BW */
-#define BAND_WIDTH_20		0
-#define BAND_WIDTH_40		1
-#define BAND_WIDTH_BOTH		2
-#define BAND_WIDTH_10		3	/* 802.11j has 10MHz. This definition is for internal usage. doesn't fill in the IE or other field. */
-/* SHORTGI */
-#define GAP_INTERVAL_400	1	/* only support in HT mode */
-#define GAP_INTERVAL_800	0
-#define GAP_INTERVAL_BOTH	2
-
-#define NdisMediaStateConnected			1
-#define NdisMediaStateDisconnected		0
-
-#define NDIS_802_11_LENGTH_SSID         32
-#define NDIS_802_11_LENGTH_RATES        8
-#define NDIS_802_11_LENGTH_RATES_EX     16
-#define MAC_ADDR_LENGTH                 6
-/*#define MAX_NUM_OF_CHS                                        49 // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination */
-#define MAX_NUM_OF_CHS				54	/* 14 channels @2.4G +  12@UNII(lower/middle) + 16@HiperLAN2 + 11@UNII(upper) + 0 @Japan + 1 as NULL termination */
-#define MAX_NUMBER_OF_EVENT				10	/* entry # in EVENT table */
-#define MAX_NUMBER_OF_MAC				32	/* if MAX_MBSSID_NUM is 8, this value can't be larger than 211 */
-#define MAX_NUMBER_OF_ACL				64
-#define MAX_LENGTH_OF_SUPPORT_RATES		12	/* 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54 */
-#define MAX_NUMBER_OF_DLS_ENTRY			4
-
-#define RT_QUERY_SIGNAL_CONTEXT				0x0402
-#define RT_SET_IAPP_PID				0x0404
-#define RT_SET_APD_PID						0x0405
-#define RT_SET_DEL_MAC_ENTRY				0x0406
-#define RT_QUERY_EVENT_TABLE			0x0407
-/* */
-/* IEEE 802.11 OIDs */
-/* */
-#define	OID_GET_SET_TOGGLE			0x8000
-#define	OID_GET_SET_FROM_UI			0x4000
-
-#define OID_802_11_ADD_WEP			0x0112
-#define OID_802_11_DISASSOCIATE			0x0114
-#define OID_802_11_BSSID_LIST_SCAN		0x0508
-#define OID_802_11_SSID				0x0509
-#define OID_802_11_BSSID			0x050A
-#define OID_802_11_MIC_FAILURE_REPORT_FRAME	0x0528
-
-#define	RT_OID_DEVICE_NAME							0x0607
-#define	RT_OID_VERSION_INFO							0x0608
-#define	OID_802_11_BSSID_LIST						0x0609
-#define	OID_802_3_CURRENT_ADDRESS					0x060A
-#define	OID_GEN_MEDIA_CONNECT_STATUS				0x060B
-#define	RT_OID_802_11_QUERY_LINK_STATUS				0x060C
-#define	OID_802_11_RSSI								0x060D
-#define	OID_802_11_STATISTICS						0x060E
-#define	OID_GEN_RCV_OK								0x060F
-#define	OID_GEN_RCV_NO_BUFFER						0x0610
-#define	RT_OID_802_11_QUERY_EEPROM_VERSION			0x0611
-#define	RT_OID_802_11_QUERY_FIRMWARE_VERSION		0x0612
-#define	RT_OID_802_11_QUERY_LAST_RX_RATE			0x0613
-#define	RT_OID_802_11_TX_POWER_LEVEL_1				0x0614
-#define	RT_OID_802_11_QUERY_PIDVID					0x0615
-/*for WPA_SUPPLICANT_SUPPORT */
-#define OID_SET_COUNTERMEASURES                     0x0616
-#define RT_OID_WPA_SUPPLICANT_SUPPORT               0x0621
-#define RT_OID_WE_VERSION_COMPILED                  0x0622
-#define RT_OID_NEW_DRIVER                           0x0623
-
-#define RT_OID_DRIVER_DEVICE_NAME                   0x0645
-#define RT_OID_QUERY_MULTIPLE_CARD_SUPPORT          0x0647
-
-typedef enum _NDIS_802_11_STATUS_TYPE {
-	Ndis802_11StatusType_Authentication,
-	Ndis802_11StatusType_MediaStreamMode,
-	Ndis802_11StatusType_PMKID_CandidateList,
-	Ndis802_11StatusTypeMax	/* not a real type, defined as an upper bound */
-} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
-
-typedef u8 NDIS_802_11_MAC_ADDRESS[6];
-
-struct rt_ndis_802_11_status_indication {
-	NDIS_802_11_STATUS_TYPE StatusType;
-};
-
-/* mask for authentication/integrity fields */
-#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
-
-#define NDIS_802_11_AUTH_REQUEST_REAUTH             0x01
-#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE          0x02
-#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR     0x06
-#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR        0x0E
-
-struct rt_ndis_802_11_authentication_request {
-	unsigned long Length;		/* Length of structure */
-	NDIS_802_11_MAC_ADDRESS Bssid;
-	unsigned long Flags;
-};
-
-/*Added new types for PMKID Candidate lists. */
-struct rt_pmkid_candidate {
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	unsigned long Flags;
-};
-
-struct rt_ndis_802_11_pmkid_candidate_list {
-	unsigned long Version;		/* Version of the structure */
-	unsigned long NumCandidates;	/* No. of pmkid candidates */
-	struct rt_pmkid_candidate CandidateList[1];
-};
-
-/*Flags for PMKID Candidate list structure */
-#define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01
-
-/* Added new types for OFDM 5G and 2.4G */
-typedef enum _NDIS_802_11_NETWORK_TYPE {
-	Ndis802_11FH,
-	Ndis802_11DS,
-	Ndis802_11OFDM5,
-	Ndis802_11OFDM24,
-	Ndis802_11Automode,
-	Ndis802_11OFDM5_N,
-	Ndis802_11OFDM24_N,
-	Ndis802_11NetworkTypeMax	/* not a real type, defined as an upper bound */
-} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
-
-struct rt_ndis_802_11_network_type_list {
-	u32 NumberOfItems;	/* in list below, at least 1 */
-	NDIS_802_11_NETWORK_TYPE NetworkType[1];
-};
-
-typedef enum _NDIS_802_11_POWER_MODE {
-	Ndis802_11PowerModeCAM,
-	Ndis802_11PowerModeMAX_PSP,
-	Ndis802_11PowerModeFast_PSP,
-	Ndis802_11PowerModeLegacy_PSP,
-	Ndis802_11PowerModeMax	/* not a real mode, defined as an upper bound */
-} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;
-
-typedef unsigned long NDIS_802_11_TX_POWER_LEVEL;	/* in milliwatts */
-
-/* */
-/* Received Signal Strength Indication */
-/* */
-typedef long NDIS_802_11_RSSI;	/* in dBm */
-
-struct rt_ndis_802_11_configuration_fh {
-	unsigned long Length;		/* Length of structure */
-	unsigned long HopPattern;	/* As defined by 802.11, MSB set */
-	unsigned long HopSet;		/* to one if non-802.11 */
-	unsigned long DwellTime;	/* units are Kusec */
-};
-
-struct rt_ndis_802_11_configuration {
-	unsigned long Length;		/* Length of structure */
-	unsigned long BeaconPeriod;	/* units are Kusec */
-	unsigned long ATIMWindow;	/* units are Kusec */
-	unsigned long DSConfig;		/* Frequency, units are kHz */
-	struct rt_ndis_802_11_configuration_fh FHConfig;
-};
-
-struct rt_ndis_802_11_statistics {
-	unsigned long Length;		/* Length of structure */
-	LARGE_INTEGER TransmittedFragmentCount;
-	LARGE_INTEGER MulticastTransmittedFrameCount;
-	LARGE_INTEGER FailedCount;
-	LARGE_INTEGER RetryCount;
-	LARGE_INTEGER MultipleRetryCount;
-	LARGE_INTEGER RTSSuccessCount;
-	LARGE_INTEGER RTSFailureCount;
-	LARGE_INTEGER ACKFailureCount;
-	LARGE_INTEGER FrameDuplicateCount;
-	LARGE_INTEGER ReceivedFragmentCount;
-	LARGE_INTEGER MulticastReceivedFrameCount;
-	LARGE_INTEGER FCSErrorCount;
-	LARGE_INTEGER TKIPLocalMICFailures;
-	LARGE_INTEGER TKIPRemoteMICErrors;
-	LARGE_INTEGER TKIPICVErrors;
-	LARGE_INTEGER TKIPCounterMeasuresInvoked;
-	LARGE_INTEGER TKIPReplays;
-	LARGE_INTEGER CCMPFormatErrors;
-	LARGE_INTEGER CCMPReplays;
-	LARGE_INTEGER CCMPDecryptErrors;
-	LARGE_INTEGER FourWayHandshakeFailures;
-};
-
-typedef unsigned long NDIS_802_11_KEY_INDEX;
-typedef unsigned long long NDIS_802_11_KEY_RSC;
-
-#define MAX_RADIUS_SRV_NUM			2	/* 802.1x failover number */
-
-struct PACKED rt_radius_srv_info {
-	u32 radius_ip;
-	u32 radius_port;
-	u8 radius_key[64];
-	u8 radius_key_len;
-};
-
-struct PACKED rt_radius_key_info {
-	u8 radius_srv_num;
-	struct rt_radius_srv_info radius_srv_info[MAX_RADIUS_SRV_NUM];
-	u8 ieee8021xWEP;	/* dynamic WEP */
-	u8 key_index;
-	u8 key_length;	/* length of key in bytes */
-	u8 key_material[13];
-};
-
-/* It's used by 802.1x daemon to require relative configuration */
-struct PACKED rt_radius_conf {
-	u32 Length;		/* Length of this structure */
-	u8 mbss_num;		/* indicate multiple BSS number */
-	u32 own_ip_addr;
-	u32 retry_interval;
-	u32 session_timeout_interval;
-	u8 EAPifname[8][IFNAMSIZ];
-	u8 EAPifname_len[8];
-	u8 PreAuthifname[8][IFNAMSIZ];
-	u8 PreAuthifname_len[8];
-	struct rt_radius_key_info RadiusInfo[8];
-};
-
-/* Key mapping keys require a BSSID */
-struct rt_ndis_802_11_key {
-	u32 Length;		/* Length of this structure */
-	u32 KeyIndex;
-	u32 KeyLength;		/* length of key in bytes */
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	NDIS_802_11_KEY_RSC KeyRSC;
-	u8 KeyMaterial[1];	/* variable length depending on above field */
-};
-
-struct rt_ndis_802_11_passphrase {
-	u32 KeyLength;		/* length of key in bytes */
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	u8 KeyMaterial[1];	/* variable length depending on above field */
-};
-
-struct rt_ndis_802_11_remove_key {
-	u32 Length;		/* Length of this structure */
-	u32 KeyIndex;
-	NDIS_802_11_MAC_ADDRESS BSSID;
-};
-
-struct rt_ndis_802_11_wep {
-	u32 Length;		/* Length of this structure */
-	u32 KeyIndex;		/* 0 is the per-client key, 1-N are the */
-	/* global keys */
-	u32 KeyLength;		/* length of key in bytes */
-	u8 KeyMaterial[1];	/* variable length depending on above field */
-};
-
-typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
-	Ndis802_11IBSS,
-	Ndis802_11Infrastructure,
-	Ndis802_11AutoUnknown,
-	Ndis802_11Monitor,
-	Ndis802_11InfrastructureMax	/* Not a real value, defined as upper bound */
-} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
-
-/* Add new authentication modes */
-typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
-	Ndis802_11AuthModeOpen,
-	Ndis802_11AuthModeShared,
-	Ndis802_11AuthModeAutoSwitch,
-	Ndis802_11AuthModeWPA,
-	Ndis802_11AuthModeWPAPSK,
-	Ndis802_11AuthModeWPANone,
-	Ndis802_11AuthModeWPA2,
-	Ndis802_11AuthModeWPA2PSK,
-	Ndis802_11AuthModeWPA1WPA2,
-	Ndis802_11AuthModeWPA1PSKWPA2PSK,
-	Ndis802_11AuthModeMax	/* Not a real mode, defined as upper bound */
-} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
-
-typedef u8 NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];	/* Set of 8 data rates */
-typedef u8 NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];	/* Set of 16 data rates */
-
-struct PACKED rt_ndis_802_11_ssid {
-	u32 SsidLength;	/* length of SSID field below, in bytes; */
-	/* this can be zero. */
-	u8 Ssid[NDIS_802_11_LENGTH_SSID];	/* SSID information field */
-};
-
-struct PACKED rt_ndis_wlan_bssid {
-	unsigned long Length;		/* Length of this structure */
-	NDIS_802_11_MAC_ADDRESS MacAddress;	/* BSSID */
-	u8 Reserved[2];
-	struct rt_ndis_802_11_ssid Ssid;	/* SSID */
-	unsigned long Privacy;		/* WEP encryption requirement */
-	NDIS_802_11_RSSI Rssi;	/* receive signal strength in dBm */
-	NDIS_802_11_NETWORK_TYPE NetworkTypeInUse;
-	struct rt_ndis_802_11_configuration Configuration;
-	NDIS_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
-	NDIS_802_11_RATES SupportedRates;
-};
-
-struct PACKED rt_ndis_802_11_bssid_list {
-	u32 NumberOfItems;	/* in list below, at least 1 */
-	struct rt_ndis_wlan_bssid Bssid[1];
-};
-
-/* Added Capabilities, IELength and IEs for each BSSID */
-struct PACKED rt_ndis_wlan_bssid_ex {
-	unsigned long Length;		/* Length of this structure */
-	NDIS_802_11_MAC_ADDRESS MacAddress;	/* BSSID */
-	u8 Reserved[2];
-	struct rt_ndis_802_11_ssid Ssid;	/* SSID */
-	u32 Privacy;		/* WEP encryption requirement */
-	NDIS_802_11_RSSI Rssi;	/* receive signal */
-	/* strength in dBm */
-	NDIS_802_11_NETWORK_TYPE NetworkTypeInUse;
-	struct rt_ndis_802_11_configuration Configuration;
-	NDIS_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
-	NDIS_802_11_RATES_EX SupportedRates;
-	unsigned long IELength;
-	u8 IEs[1];
-};
-
-struct PACKED rt_ndis_802_11_bssid_list_ex {
-	u32 NumberOfItems;	/* in list below, at least 1 */
-	struct rt_ndis_wlan_bssid_ex Bssid[1];
-};
-
-struct PACKED rt_ndis_802_11_fixed_ies {
-	u8 Timestamp[8];
-	u16 BeaconInterval;
-	u16 Capabilities;
-};
-
-struct rt_ndis_802_11_variable_ies {
-	u8 ElementID;
-	u8 Length;		/* Number of bytes in data field */
-	u8 data[1];
-};
-
-typedef unsigned long NDIS_802_11_FRAGMENTATION_THRESHOLD;
-
-typedef unsigned long NDIS_802_11_RTS_THRESHOLD;
-
-typedef unsigned long NDIS_802_11_ANTENNA;
-
-typedef enum _NDIS_802_11_PRIVACY_FILTER {
-	Ndis802_11PrivFilterAcceptAll,
-	Ndis802_11PrivFilter8021xWEP
-} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;
-
-/* Added new encryption types */
-/* Also aliased typedef to new name */
-typedef enum _NDIS_802_11_WEP_STATUS {
-	Ndis802_11WEPEnabled,
-	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
-	Ndis802_11WEPDisabled,
-	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
-	Ndis802_11WEPKeyAbsent,
-	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
-	Ndis802_11WEPNotSupported,
-	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
-	Ndis802_11Encryption2Enabled,
-	Ndis802_11Encryption2KeyAbsent,
-	Ndis802_11Encryption3Enabled,
-	Ndis802_11Encryption3KeyAbsent,
-	Ndis802_11Encryption4Enabled,	/* TKIP or AES mix */
-	Ndis802_11Encryption4KeyAbsent,
-	Ndis802_11GroupWEP40Enabled,
-	Ndis802_11GroupWEP104Enabled,
-} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
-    NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
-
-typedef enum _NDIS_802_11_RELOAD_DEFAULTS {
-	Ndis802_11ReloadWEPKeys
-} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
-
-#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
-#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
-#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
-
-#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
-#define NDIS_802_11_AI_RESFI_STATUSCODE        2
-#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
-
-struct rt_ndis_802_11_ai_reqfi {
-	u16 Capabilities;
-	u16 ListenInterval;
-	NDIS_802_11_MAC_ADDRESS CurrentAPAddress;
-};
-
-struct rt_ndis_802_11_ai_resfi {
-	u16 Capabilities;
-	u16 StatusCode;
-	u16 AssociationId;
-};
-
-struct rt_ndis_802_11_association_information {
-	unsigned long Length;
-	u16 AvailableRequestFixedIEs;
-	struct rt_ndis_802_11_ai_reqfi RequestFixedIEs;
-	unsigned long RequestIELength;
-	unsigned long OffsetRequestIEs;
-	u16 AvailableResponseFixedIEs;
-	struct rt_ndis_802_11_ai_resfi ResponseFixedIEs;
-	unsigned long ResponseIELength;
-	unsigned long OffsetResponseIEs;
-};
-
-struct rt_ndis_802_11_authentication_event {
-	struct rt_ndis_802_11_status_indication Status;
-	struct rt_ndis_802_11_authentication_request Request[1];
-};
-
-/* 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE */
-typedef enum _NDIS_802_11_MEDIA_STREAM_MODE {
-	Ndis802_11MediaStreamOff,
-	Ndis802_11MediaStreamOn,
-} NDIS_802_11_MEDIA_STREAM_MODE, *PNDIS_802_11_MEDIA_STREAM_MODE;
-
-/* PMKID Structures */
-typedef u8 NDIS_802_11_PMKID_VALUE[16];
-
-struct rt_bssid_info {
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	NDIS_802_11_PMKID_VALUE PMKID;
-};
-
-struct rt_ndis_802_11_pmkid {
-	u32 Length;
-	u32 BSSIDInfoCount;
-	struct rt_bssid_info BSSIDInfo[1];
-};
-
-struct rt_ndis_802_11_authentication_encryption {
-	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
-	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
-};
-
-struct rt_ndis_802_11_capability {
-	unsigned long Length;
-	unsigned long Version;
-	unsigned long NoOfPMKIDs;
-	unsigned long NoOfAuthEncryptPairsSupported;
-	struct rt_ndis_802_11_authentication_encryption
-	    AuthenticationEncryptionSupported[1];
-};
-
-#define RT_PRIV_IOCTL							(SIOCIWFIRSTPRIV + 0x01)	/* Sync. with AP for wsc upnp daemon */
-#define RTPRIV_IOCTL_SET							(SIOCIWFIRSTPRIV + 0x02)
-
-#define RTPRIV_IOCTL_STATISTICS                     (SIOCIWFIRSTPRIV + 0x09)
-#define RTPRIV_IOCTL_ADD_PMKID_CACHE                (SIOCIWFIRSTPRIV + 0x0A)
-#define RTPRIV_IOCTL_RADIUS_DATA                    (SIOCIWFIRSTPRIV + 0x0C)
-#define RTPRIV_IOCTL_GSITESURVEY					(SIOCIWFIRSTPRIV + 0x0D)
-#define RT_PRIV_IOCTL_EXT							(SIOCIWFIRSTPRIV + 0x0E)	/* Sync. with RT61 (for wpa_supplicant) */
-#define RTPRIV_IOCTL_GET_MAC_TABLE					(SIOCIWFIRSTPRIV + 0x0F)
-
-#define RTPRIV_IOCTL_SHOW							(SIOCIWFIRSTPRIV + 0x11)
-enum {
-	SHOW_CONN_STATUS = 4,
-	SHOW_DRVIER_VERION = 5,
-	SHOW_BA_INFO = 6,
-	SHOW_DESC_INFO = 7,
-#ifdef RTMP_MAC_USB
-	SHOW_RXBULK_INFO = 8,
-	SHOW_TXBULK_INFO = 9,
-#endif /* RTMP_MAC_USB // */
-	RAIO_OFF = 10,
-	RAIO_ON = 11,
-	SHOW_CFG_VALUE = 20,
-	SHOW_ADHOC_ENTRY_INFO = 21,
-};
-
-#define OID_802_11_BUILD_CHANNEL_EX				0x0714
-#define OID_802_11_GET_CH_LIST					0x0715
-#define OID_802_11_GET_COUNTRY_CODE				0x0716
-#define OID_802_11_GET_CHANNEL_GEOGRAPHY		0x0717
-
-#define RT_OID_WSC_SET_PASSPHRASE                   0x0740	/* passphrase for wpa(2)-psk */
-#define RT_OID_WSC_DRIVER_AUTO_CONNECT              0x0741
-#define RT_OID_WSC_QUERY_DEFAULT_PROFILE            0x0742
-#define RT_OID_WSC_SET_CONN_BY_PROFILE_INDEX        0x0743
-#define RT_OID_WSC_SET_ACTION                       0x0744
-#define RT_OID_WSC_SET_SSID                         0x0745
-#define RT_OID_WSC_SET_PIN_CODE                     0x0746
-#define RT_OID_WSC_SET_MODE                         0x0747	/* PIN or PBC */
-#define RT_OID_WSC_SET_CONF_MODE                    0x0748	/* Enrollee or Registrar */
-#define RT_OID_WSC_SET_PROFILE                      0x0749
-#define	RT_OID_WSC_CONFIG_STATUS					0x074F
-#define RT_OID_802_11_WSC_QUERY_PROFILE				0x0750
-/* for consistency with RT61 */
-#define RT_OID_WSC_QUERY_STATUS						0x0751
-#define RT_OID_WSC_PIN_CODE							0x0752
-#define RT_OID_WSC_UUID								0x0753
-#define RT_OID_WSC_SET_SELECTED_REGISTRAR			0x0754
-#define RT_OID_WSC_EAPMSG							0x0755
-#define RT_OID_WSC_MANUFACTURER						0x0756
-#define RT_OID_WSC_MODEL_NAME						0x0757
-#define RT_OID_WSC_MODEL_NO							0x0758
-#define RT_OID_WSC_SERIAL_NO						0x0759
-#define RT_OID_WSC_MAC_ADDRESS						0x0760
-
-/* New for MeetingHouse Api support */
-#define OID_MH_802_1X_SUPPORTED               0xFFEDC100
-
-/* MIMO Tx parameter, ShortGI, MCS, STBC, etc.  these are fields in TXWI. Don't change this definition! */
-typedef union _HTTRANSMIT_SETTING {
-	struct {
-		u16 MCS:7;	/* MCS */
-		u16 BW:1;	/*channel bandwidth 20MHz or 40 MHz */
-		u16 ShortGI:1;
-		u16 STBC:2;	/*SPACE */
-/*      u16          rsv:3; */
-		u16 rsv:2;
-		u16 TxBF:1;
-		u16 MODE:2;	/* Use definition MODE_xxx. */
-	} field;
-	u16 word;
-} HTTRANSMIT_SETTING, *PHTTRANSMIT_SETTING;
-
-typedef enum _RT_802_11_PREAMBLE {
-	Rt802_11PreambleLong,
-	Rt802_11PreambleShort,
-	Rt802_11PreambleAuto
-} RT_802_11_PREAMBLE, *PRT_802_11_PREAMBLE;
-
-typedef enum _RT_802_11_PHY_MODE {
-	PHY_11BG_MIXED = 0,
-	PHY_11B,
-	PHY_11A,
-	PHY_11ABG_MIXED,
-	PHY_11G,
-	PHY_11ABGN_MIXED,	/* both band   5 */
-	PHY_11N_2_4G,		/* 11n-only with 2.4G band      6 */
-	PHY_11GN_MIXED,		/* 2.4G band      7 */
-	PHY_11AN_MIXED,		/* 5G  band       8 */
-	PHY_11BGN_MIXED,	/* if check 802.11b.      9 */
-	PHY_11AGN_MIXED,	/* if check 802.11b.      10 */
-	PHY_11N_5G,		/* 11n-only with 5G band                11 */
-} RT_802_11_PHY_MODE;
-
-/* put all proprietery for-query objects here to reduce # of Query_OID */
-struct rt_802_11_link_status {
-	unsigned long CurrTxRate;	/* in units of 0.5Mbps */
-	unsigned long ChannelQuality;	/* 0..100 % */
-	unsigned long TxByteCount;	/* both ok and fail */
-	unsigned long RxByteCount;	/* both ok and fail */
-	unsigned long CentralChannel;	/* 40MHz central channel number */
-};
-
-struct rt_802_11_event_log {
-	LARGE_INTEGER SystemTime;	/* timestammp via NdisGetCurrentSystemTime() */
-	u8 Addr[MAC_ADDR_LENGTH];
-	u16 Event;		/* EVENT_xxx */
-};
-
-struct rt_802_11_event_table {
-	unsigned long Num;
-	unsigned long Rsv;		/* to align Log[] at LARGE_INTEGER boundary */
-	struct rt_802_11_event_log Log[MAX_NUMBER_OF_EVENT];
-};
-
-/* MIMO Tx parameter, ShortGI, MCS, STBC, etc.  these are fields in TXWI. Don't change this definition! */
-typedef union _MACHTTRANSMIT_SETTING {
-	struct {
-		u16 MCS:7;	/* MCS */
-		u16 BW:1;	/*channel bandwidth 20MHz or 40 MHz */
-		u16 ShortGI:1;
-		u16 STBC:2;	/*SPACE */
-		u16 rsv:3;
-		u16 MODE:2;	/* Use definition MODE_xxx. */
-	} field;
-	u16 word;
-} MACHTTRANSMIT_SETTING, *PMACHTTRANSMIT_SETTING;
-
-struct rt_802_11_mac_entry {
-	u8 Addr[MAC_ADDR_LENGTH];
-	u8 Aid;
-	u8 Psm;		/* 0:PWR_ACTIVE, 1:PWR_SAVE */
-	u8 MimoPs;		/* 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled */
-	char AvgRssi0;
-	char AvgRssi1;
-	char AvgRssi2;
-	u32 ConnectedTime;
-	MACHTTRANSMIT_SETTING TxRate;
-};
-
-struct rt_802_11_mac_table {
-	unsigned long Num;
-	struct rt_802_11_mac_entry Entry[MAX_NUMBER_OF_MAC];
-};
-
-/* structure for query/set hardware register - MAC, BBP, RF register */
-struct rt_802_11_hardware_register {
-	unsigned long HardwareType;	/* 0:MAC, 1:BBP, 2:RF register, 3:EEPROM */
-	unsigned long Offset;		/* Q/S register offset addr */
-	unsigned long Data;		/* R/W data buffer */
-};
-
-struct rt_802_11_ap_config {
-	unsigned long EnableTxBurst;	/* 0-disable, 1-enable */
-	unsigned long EnableTurboRate;	/* 0-disable, 1-enable 72/100mbps turbo rate */
-	unsigned long IsolateInterStaTraffic;	/* 0-disable, 1-enable isolation */
-	unsigned long HideSsid;		/* 0-disable, 1-enable hiding */
-	unsigned long UseBGProtection;	/* 0-AUTO, 1-always ON, 2-always OFF */
-	unsigned long UseShortSlotTime;	/* 0-no use, 1-use 9-us short slot time */
-	unsigned long Rsv1;		/* must be 0 */
-	unsigned long SystemErrorBitmap;	/* ignore upon SET, return system error upon QUERY */
-};
-
-/* structure to query/set STA_CONFIG */
-struct rt_802_11_sta_config {
-	unsigned long EnableTxBurst;	/* 0-disable, 1-enable */
-	unsigned long EnableTurboRate;	/* 0-disable, 1-enable 72/100mbps turbo rate */
-	unsigned long UseBGProtection;	/* 0-AUTO, 1-always ON, 2-always OFF */
-	unsigned long UseShortSlotTime;	/* 0-no use, 1-use 9-us short slot time when applicable */
-	unsigned long AdhocMode;	/* 0-11b rates only (WIFI spec), 1 - b/g mixed, 2 - g only */
-	unsigned long HwRadioStatus;	/* 0-OFF, 1-ON, default is 1, Read-Only */
-	unsigned long Rsv1;		/* must be 0 */
-	unsigned long SystemErrorBitmap;	/* ignore upon SET, return system error upon QUERY */
-};
-
-/* */
-/*  For OID Query or Set about BA structure */
-/* */
-struct rt_oid_bacap {
-	u8 RxBAWinLimit;
-	u8 TxBAWinLimit;
-	u8 Policy;		/* 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid */
-	u8 MpduDensity;	/* 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid */
-	u8 AmsduEnable;	/*Enable AMSDU transmisstion */
-	u8 AmsduSize;	/* 0:3839, 1:7935 bytes. u32  MSDUSizeToBytes[]        = { 3839, 7935}; */
-	u8 MMPSmode;		/* MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable */
-	BOOLEAN AutoBA;		/* Auto BA will automatically */
-};
-
-struct rt_802_11_acl_entry {
-	u8 Addr[MAC_ADDR_LENGTH];
-	u16 Rsv;
-};
-
-struct PACKED rt_rt_802_11_acl {
-	unsigned long Policy;		/* 0-disable, 1-positive list, 2-negative list */
-	unsigned long Num;
-	struct rt_802_11_acl_entry Entry[MAX_NUMBER_OF_ACL];
-};
-
-struct rt_802_11_wds {
-	unsigned long Num;
-	NDIS_802_11_MAC_ADDRESS Entry[24 /*MAX_NUM_OF_WDS_LINK */];
-	unsigned long KeyLength;
-	u8 KeyMaterial[32];
-};
-
-struct rt_802_11_tx_rates {
-	u8 SupRateLen;
-	u8 SupRate[MAX_LENGTH_OF_SUPPORT_RATES];
-	u8 ExtRateLen;
-	u8 ExtRate[MAX_LENGTH_OF_SUPPORT_RATES];
-};
-
-/* Definition of extra information code */
-#define	GENERAL_LINK_UP			0x0	/* Link is Up */
-#define	GENERAL_LINK_DOWN		0x1	/* Link is Down */
-#define	HW_RADIO_OFF			0x2	/* Hardware radio off */
-#define	SW_RADIO_OFF			0x3	/* Software radio off */
-#define	AUTH_FAIL				0x4	/* Open authentication fail */
-#define	AUTH_FAIL_KEYS			0x5	/* Shared authentication fail */
-#define	ASSOC_FAIL				0x6	/* Association failed */
-#define	EAP_MIC_FAILURE			0x7	/* Deauthentication because MIC failure */
-#define	EAP_4WAY_TIMEOUT		0x8	/* Deauthentication on 4-way handshake timeout */
-#define	EAP_GROUP_KEY_TIMEOUT	0x9	/* Deauthentication on group key handshake timeout */
-#define	EAP_SUCCESS				0xa	/* EAP succeed */
-#define	DETECT_RADAR_SIGNAL		0xb	/* Radar signal occur in current channel */
-#define EXTRA_INFO_MAX			0xb	/* Indicate Last OID */
-
-#define EXTRA_INFO_CLEAR		0xffffffff
-
-/* This is OID setting structure. So only GF or MM as Mode. This is valid when our wirelss mode has 802.11n in use. */
-struct rt_oid_set_ht_phymode {
-	RT_802_11_PHY_MODE PhyMode;	/* */
-	u8 TransmitNo;
-	u8 HtMode;		/*HTMODE_GF or HTMODE_MM */
-	u8 ExtOffset;	/*extension channel above or below */
-	u8 MCS;
-	u8 BW;
-	u8 STBC;
-	u8 SHORTGI;
-	u8 rsv;
-};
-
-#define MAX_CUSTOM_LEN 128
-
-typedef enum _RT_802_11_D_CLIENT_MODE {
-	Rt802_11_D_None,
-	Rt802_11_D_Flexible,
-	Rt802_11_D_Strict,
-} RT_802_11_D_CLIENT_MODE, *PRT_802_11_D_CLIENT_MODE;
-
-struct rt_channel_list_info {
-	u8 ChannelList[MAX_NUM_OF_CHS];	/* list all supported channels for site survey */
-	u8 ChannelListNum;	/* number of channel in ChannelList[] */
-};
-
-/* WSC configured credential */
-struct rt_wsc_credential {
-	struct rt_ndis_802_11_ssid SSID;	/* mandatory */
-	u16 AuthType;	/* mandatory, 1: open, 2: wpa-psk, 4: shared, 8:wpa, 0x10: wpa2, 0x20: wpa2-psk */
-	u16 EncrType;	/* mandatory, 1: none, 2: wep, 4: tkip, 8: aes */
-	u8 Key[64];		/* mandatory, Maximum 64 byte */
-	u16 KeyLength;
-	u8 MacAddr[6];	/* mandatory, AP MAC address */
-	u8 KeyIndex;		/* optional, default is 1 */
-	u8 Rsvd[3];		/* Make alignment */
-};
-
-/* WSC configured profiles */
-struct rt_wsc_profile {
-	u32 ProfileCnt;
-	u32 ApplyProfileIdx;	/* add by johnli, fix WPS test plan 5.1.1 */
-	struct rt_wsc_credential Profile[8];	/* Support up to 8 profiles */
-};
-
-#endif /* _OID_H_ */
diff --git a/drivers/staging/rt2860/pci_main_dev.c b/drivers/staging/rt2860/pci_main_dev.c
deleted file mode 100644
index 25fbb18..0000000
--- a/drivers/staging/rt2860/pci_main_dev.c
+++ /dev/null
@@ -1,1192 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    pci_main_dev.c
-
-    Abstract:
-    Create and register network interface for PCI based chipsets in Linux platform.
-
-    Revision History:
-    Who         	When            What
-    Justin P. Mattock	11/07/2010	Fix typos in some comments
-    --------    ----------      ----------------------------------------------
-*/
-
-#include "rt_config.h"
-#include <linux/pci.h>
-#include <linux/slab.h>
-
-/* Following information will be show when you run 'modinfo' */
-/* If you have a solution for a bug in current version of driver, please e-mail me. */
-/* Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. */
-MODULE_AUTHOR("Jett Chen <jett_chen@ralinktech.com>");
-MODULE_DESCRIPTION("RT2860/RT3090 Wireless Lan Linux Driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("rt3090sta");
-
-/* */
-/* Function declarations */
-/* */
-static void __devexit rt2860_remove_one(struct pci_dev *pci_dev);
-static int __devinit rt2860_probe(struct pci_dev *pci_dev,
-				  const struct pci_device_id *ent);
-static void __exit rt2860_cleanup_module(void);
-static int __init rt2860_init_module(void);
-
-static void RTMPInitPCIeDevice(IN struct pci_dev *pci_dev,
-			       struct rt_rtmp_adapter *pAd);
-
-#ifdef CONFIG_PM
-static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state);
-static int rt2860_resume(struct pci_dev *pci_dev);
-#endif /* CONFIG_PM // */
-
-/* */
-/* Ralink PCI device table, include all supported chipsets */
-/* */
-static struct pci_device_id rt2860_pci_tbl[] __devinitdata = {
-#ifdef RT2860
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCI_DEVICE_ID)},	/*RT28602.4G */
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2760_PCI_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2790_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(VEN_AWT_PCI_VENDOR_ID, VEN_AWT_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7708)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7728)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7758)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7727)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7738)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7748)},
-	{PCI_DEVICE(EDIMAX_PCI_VENDOR_ID, 0x7768)},
-#endif
-#ifdef RT3090
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3090_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3091_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3092_PCIe_DEVICE_ID)},
-#endif /* RT3090 // */
-#ifdef RT3390
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3390_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3391_PCIe_DEVICE_ID)},
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3392_PCIe_DEVICE_ID)},
-#endif /* RT3390 // */
-	{0,}			/* terminate list */
-};
-
-MODULE_DEVICE_TABLE(pci, rt2860_pci_tbl);
-#ifdef MODULE_VERSION
-MODULE_VERSION(STA_DRIVER_VERSION);
-#endif
-
-/* */
-/* Our PCI driver structure */
-/* */
-static struct pci_driver rt2860_driver = {
-name: "rt2860",
-id_table : rt2860_pci_tbl,
-probe : rt2860_probe,
-remove : __devexit_p(rt2860_remove_one),
-#ifdef CONFIG_PM
-suspend : rt2860_suspend,
-resume : rt2860_resume,
-#endif
-};
-
-/***************************************************************************
- *
- *	PCI device initialization related procedures.
- *
- ***************************************************************************/
-#ifdef CONFIG_PM
-
-void RT2860RejectPendingPackets(struct rt_rtmp_adapter *pAd)
-{
-	/* clear PS packets */
-	/* clear TxSw packets */
-}
-
-static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state)
-{
-	struct net_device *net_dev = pci_get_drvdata(pci_dev);
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)NULL;
-	int retval = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_suspend()\n"));
-
-	if (net_dev == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("net_dev == NULL!\n"));
-	} else {
-		GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-		/* we can not use IFF_UP because ra0 down but ra1 up */
-		/* and 1 suspend/resume function for 1 module, not for each interface */
-		/* so Linux will call suspend/resume function once */
-		if (VIRTUAL_IF_NUM(pAd) > 0) {
-			/* avoid users do suspend after interface is down */
-
-			/* stop interface */
-			netif_carrier_off(net_dev);
-			netif_stop_queue(net_dev);
-
-			/* mark device as removed from system and therefore no longer available */
-			netif_device_detach(net_dev);
-
-			/* mark halt flag */
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-			/* take down the device */
-			rt28xx_close((struct net_device *)net_dev);
-
-			RT_MOD_DEC_USE_COUNT();
-		}
-	}
-
-	/* reference to http://vovo2000.com/type-lab/linux/kernel-api/linux-kernel-api.html */
-	/* enable device to generate PME# when suspended */
-	/* pci_choose_state(): Choose the power state of a PCI device to be suspended */
-	retval = pci_enable_wake(pci_dev, pci_choose_state(pci_dev, state), 1);
-	/* save the PCI configuration space of a device before suspending */
-	pci_save_state(pci_dev);
-	/* disable PCI device after use */
-	pci_disable_device(pci_dev);
-
-	retval = pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_suspend()\n"));
-	return retval;
-}
-
-static int rt2860_resume(struct pci_dev *pci_dev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pci_dev);
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)NULL;
-	int retval;
-
-	/* set the power state of a PCI device */
-	/* PCI has 4 power states, DO (normal) ~ D3(less power) */
-	/* in include/linux/pci.h, you can find that */
-	/* #define PCI_D0          ((pci_power_t __force) 0) */
-	/* #define PCI_D1          ((pci_power_t __force) 1) */
-	/* #define PCI_D2          ((pci_power_t __force) 2) */
-	/* #define PCI_D3hot       ((pci_power_t __force) 3) */
-	/* #define PCI_D3cold      ((pci_power_t __force) 4) */
-	/* #define PCI_UNKNOWN     ((pci_power_t __force) 5) */
-	/* #define PCI_POWER_ERROR ((pci_power_t __force) -1) */
-	retval = pci_set_power_state(pci_dev, PCI_D0);
-
-	/* restore the saved state of a PCI device */
-	pci_restore_state(pci_dev);
-
-	/* initialize device before it's used by a driver */
-	if (pci_enable_device(pci_dev)) {
-		printk(KERN_ERR "rt2860: pci enable fail!\n");
-		return 0;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_resume()\n"));
-
-	if (net_dev == NULL)
-		DBGPRINT(RT_DEBUG_ERROR, ("net_dev == NULL!\n"));
-	else
-		GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	if (pAd != NULL) {
-		/* we can not use IFF_UP because ra0 down but ra1 up */
-		/* and 1 suspend/resume function for 1 module, not for each interface */
-		/* so Linux will call suspend/resume function once */
-		if (VIRTUAL_IF_NUM(pAd) > 0) {
-			/* mark device as attached from system and restart if needed */
-			netif_device_attach(net_dev);
-
-			if (rt28xx_open((struct net_device *)net_dev) != 0) {
-				/* open fail */
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("<=== rt2860_resume()\n"));
-				return 0;
-			}
-			/* increase MODULE use count */
-			RT_MOD_INC_USE_COUNT();
-
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
-
-			netif_start_queue(net_dev);
-			netif_carrier_on(net_dev);
-			netif_wake_queue(net_dev);
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_resume()\n"));
-	return 0;
-}
-#endif /* CONFIG_PM // */
-
-static int __init rt2860_init_module(void)
-{
-	return pci_register_driver(&rt2860_driver);
-}
-
-/* */
-/* Driver module unload function */
-/* */
-static void __exit rt2860_cleanup_module(void)
-{
-	pci_unregister_driver(&rt2860_driver);
-}
-
-module_init(rt2860_init_module);
-module_exit(rt2860_cleanup_module);
-
-/* */
-/* PCI device probe & initialization function */
-/* */
-static int __devinit rt2860_probe(IN struct pci_dev *pci_dev,
-				  IN const struct pci_device_id *pci_id)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)NULL;
-	struct net_device *net_dev;
-	void *handle;
-	char *print_name;
-	unsigned long csr_addr;
-	int rv = 0;
-	struct rt_rtmp_os_netdev_op_hook netDevHook;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_probe\n"));
-
-/*PCIDevInit============================================== */
-	/* wake up and enable device */
-	rv = pci_enable_device(pci_dev);
-
-	if (rv != 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Enable PCI device failed, errno=%d!\n", rv));
-		return rv;
-	}
-
-	print_name = (char *)pci_name(pci_dev);
-
-	rv = pci_request_regions(pci_dev, print_name);
-
-	if (rv != 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Request PCI resource failed, errno=%d!\n", rv));
-		goto err_out;
-	}
-	/* map physical address to virtual address for accessing register */
-	csr_addr =
-	    (unsigned long)ioremap(pci_resource_start(pci_dev, 0),
-				   pci_resource_len(pci_dev, 0));
-	if (!csr_addr) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("ioremap failed for device %s, region 0x%lX @ 0x%lX\n",
-			  print_name, (unsigned long)pci_resource_len(pci_dev, 0),
-			  (unsigned long)pci_resource_start(pci_dev, 0)));
-		goto err_out_free_res;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s: at 0x%lx, VA 0x%lx, IRQ %d. \n", print_name,
-			  (unsigned long)pci_resource_start(pci_dev, 0),
-			  (unsigned long)csr_addr, pci_dev->irq));
-	}
-
-	/* Set DMA master */
-	pci_set_master(pci_dev);
-
-/*RtmpDevInit============================================== */
-	/* Allocate struct rt_rtmp_adapter adapter structure */
-	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
-	if (handle == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s(): Allocate memory for os handle failed!\n",
-			  __func__));
-		goto err_out_iounmap;
-	}
-
-	((struct os_cookie *)handle)->pci_dev = pci_dev;
-
-	rv = RTMPAllocAdapterBlock(handle, &pAd);	/*shiang: we may need the pci_dev for allocate structure of "struct rt_rtmp_adapter" */
-	if (rv != NDIS_STATUS_SUCCESS)
-		goto err_out_iounmap;
-	/* Here are the struct rt_rtmp_adapter structure with pci-bus specific parameters. */
-	pAd->CSRBaseAddress = (u8 *)csr_addr;
-	DBGPRINT(RT_DEBUG_ERROR,
-		 ("pAd->CSRBaseAddress =0x%lx, csr_addr=0x%lx!\n",
-		  (unsigned long)pAd->CSRBaseAddress, csr_addr));
-	RtmpRaDevCtrlInit(pAd, RTMP_DEV_INF_PCI);
-
-/*NetDevInit============================================== */
-	net_dev = RtmpPhyNetDevInit(pAd, &netDevHook);
-	if (net_dev == NULL)
-		goto err_out_free_radev;
-
-	/* Here are the net_device structure with pci-bus specific parameters. */
-	net_dev->irq = pci_dev->irq;	/* Interrupt IRQ number */
-	net_dev->base_addr = csr_addr;	/* Save CSR virtual address and irq to device structure */
-	pci_set_drvdata(pci_dev, net_dev);	/* Set driver data */
-
-/* for supporting Network Manager */
-	/* Set the sysfs physical device reference for the network logical device
-	 * if set prior to registration will cause a symlink during initialization.
-	 */
-	SET_NETDEV_DEV(net_dev, &(pci_dev->dev));
-
-/*All done, it's time to register the net device to linux kernel. */
-	/* Register this device */
-	rv = RtmpOSNetDevAttach(net_dev, &netDevHook);
-	if (rv)
-		goto err_out_free_netdev;
-
-	pAd->StaCfg.OriDevType = net_dev->type;
-	RTMPInitPCIeDevice(pci_dev, pAd);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_probe\n"));
-
-	return 0;		/* probe ok */
-
-	/* --------------------------- ERROR HANDLE --------------------------- */
-err_out_free_netdev:
-	RtmpOSNetDevFree(net_dev);
-
-err_out_free_radev:
-	/* free struct rt_rtmp_adapter strcuture and os_cookie */
-	RTMPFreeAdapter(pAd);
-
-err_out_iounmap:
-	iounmap((void *)(csr_addr));
-	release_mem_region(pci_resource_start(pci_dev, 0),
-			   pci_resource_len(pci_dev, 0));
-
-err_out_free_res:
-	pci_release_regions(pci_dev);
-
-err_out:
-	pci_disable_device(pci_dev);
-
-	DBGPRINT(RT_DEBUG_ERROR,
-		 ("<=== rt2860_probe failed with rv = %d!\n", rv));
-
-	return -ENODEV;		/* probe fail */
-}
-
-static void __devexit rt2860_remove_one(IN struct pci_dev *pci_dev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pci_dev);
-	struct rt_rtmp_adapter *pAd = NULL;
-	unsigned long csr_addr = net_dev->base_addr;	/* pAd->CSRBaseAddress; */
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_remove_one\n"));
-
-	if (pAd != NULL) {
-		/* Unregister/Free all allocated net_device. */
-		RtmpPhyNetDevExit(pAd, net_dev);
-
-		/* Unmap CSR base address */
-		iounmap((char *)(csr_addr));
-
-		/* release memory region */
-		release_mem_region(pci_resource_start(pci_dev, 0),
-				   pci_resource_len(pci_dev, 0));
-
-		/* Free struct rt_rtmp_adapter related structures. */
-		RtmpRaDevCtrlExit(pAd);
-
-	} else {
-		/* Unregister network device */
-		RtmpOSNetDevDetach(net_dev);
-
-		/* Unmap CSR base address */
-		iounmap((char *)(net_dev->base_addr));
-
-		/* release memory region */
-		release_mem_region(pci_resource_start(pci_dev, 0),
-				   pci_resource_len(pci_dev, 0));
-	}
-
-	/* Free the root net_device */
-	RtmpOSNetDevFree(net_dev);
-
-}
-
-/*
-========================================================================
-Routine Description:
-    Check the chipset vendor/product ID.
-
-Arguments:
-    _dev_p				Point to the PCI or USB device
-
-Return Value:
-    TRUE				Check ok
-	FALSE				Check fail
-
-Note:
-========================================================================
-*/
-BOOLEAN RT28XXChipsetCheck(IN void *_dev_p)
-{
-	/* always TRUE */
-	return TRUE;
-}
-
-/***************************************************************************
- *
- *	PCIe device initialization related procedures.
- *
- ***************************************************************************/
-static void RTMPInitPCIeDevice(struct pci_dev *pci_dev, struct rt_rtmp_adapter *pAd)
-{
-	u16 device_id;
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-	pci_read_config_word(pci_dev, PCI_DEVICE_ID, &device_id);
-	device_id = le2cpu16(device_id);
-	pObj->DeviceID = device_id;
-	if (
-#ifdef RT2860
-		   (device_id == NIC2860_PCIe_DEVICE_ID) ||
-		   (device_id == NIC2790_PCIe_DEVICE_ID) ||
-		   (device_id == VEN_AWT_PCIe_DEVICE_ID) ||
-#endif
-#ifdef RT3090
-		   (device_id == NIC3090_PCIe_DEVICE_ID) ||
-		   (device_id == NIC3091_PCIe_DEVICE_ID) ||
-		   (device_id == NIC3092_PCIe_DEVICE_ID) ||
-#endif /* RT3090 // */
-		   0) {
-		u32 MacCsr0 = 0, Index = 0;
-		do {
-			RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
-
-			if ((MacCsr0 != 0x00) && (MacCsr0 != 0xFFFFFFFF))
-				break;
-
-			RTMPusecDelay(10);
-		} while (Index++ < 100);
-
-		/* Support advanced power save after 2892/2790. */
-		/* MAC version at offset 0x1000 is 0x2872XXXX/0x2870XXXX(PCIe, USB, SDIO). */
-		if ((MacCsr0 & 0xffff0000) != 0x28600000)
-			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_PCIE_DEVICE);
-	}
-}
-
-void RTMPInitPCIeLinkCtrlValue(struct rt_rtmp_adapter *pAd)
-{
-	int pos;
-	u16 reg16, data2, PCIePowerSaveLevel, Configuration;
-	u32 MacValue;
-	BOOLEAN bFindIntel = FALSE;
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
-	/* Init EEPROM, and save settings */
-	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
-		RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
-		pAd->PCIePowerSaveLevel = PCIePowerSaveLevel & 0xff;
-
-		pAd->LnkCtrlBitMask = 0;
-		if ((PCIePowerSaveLevel & 0xff) == 0xff) {
-			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_PCIE_DEVICE);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("====> PCIePowerSaveLevel = 0x%x.\n",
-				  PCIePowerSaveLevel));
-			return;
-		} else {
-			PCIePowerSaveLevel &= 0x3;
-			RT28xx_EEPROM_READ16(pAd, 0x24, data2);
-
-			if (!
-			    (((data2 & 0xff00) == 0x9200)
-			     && ((data2 & 0x80) != 0))) {
-				if (PCIePowerSaveLevel > 1)
-					PCIePowerSaveLevel = 1;
-			}
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("====> Write 0x83 = 0x%x.\n",
-				  PCIePowerSaveLevel));
-			AsicSendCommandToMcu(pAd, 0x83, 0xff,
-					     (u8)PCIePowerSaveLevel, 0x00);
-			RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
-			PCIePowerSaveLevel &= 0xff;
-			PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
-			switch (PCIePowerSaveLevel) {
-			case 0:	/* Only support L0 */
-				pAd->LnkCtrlBitMask = 0;
-				break;
-			case 1:	/* Only enable L0s */
-				pAd->LnkCtrlBitMask = 1;
-				break;
-			case 2:	/* enable L1, L0s */
-				pAd->LnkCtrlBitMask = 3;
-				break;
-			case 3:	/* sync with host clk and enable L1, L0s */
-				pAd->LnkCtrlBitMask = 0x103;
-				break;
-			}
-			RT28xx_EEPROM_READ16(pAd, 0x24, data2);
-			if ((PCIePowerSaveLevel & 0xff) != 0xff) {
-				PCIePowerSaveLevel &= 0x3;
-
-				if (!
-				    (((data2 & 0xff00) == 0x9200)
-				     && ((data2 & 0x80) != 0))) {
-					if (PCIePowerSaveLevel > 1)
-						PCIePowerSaveLevel = 1;
-				}
-
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("====> rt28xx Write 0x83 Command = 0x%x.\n",
-					  PCIePowerSaveLevel));
-
-				AsicSendCommandToMcu(pAd, 0x83, 0xff,
-						     (u8)PCIePowerSaveLevel,
-						     0x00);
-			}
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("====> LnkCtrlBitMask = 0x%x.\n",
-				  pAd->LnkCtrlBitMask));
-		}
-	} else if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
-		u8 LinkCtrlSetting = 0;
-
-		/* Check 3090E special setting chip. */
-		RT28xx_EEPROM_READ16(pAd, 0x24, data2);
-		if ((data2 == 0x9280) && ((pAd->MACVersion & 0xffff) == 0x0211)) {
-			pAd->b3090ESpecialChip = TRUE;
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Special 3090E chip \n"));
-		}
-
-		RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
-		/*enable WAKE_PCIE function, which forces to enable PCIE clock when mpu interrupt asserting. */
-		/*Force PCIE 125MHz CLK to toggle */
-		MacValue |= 0x402;
-		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     (" AUX_CTRL = 0x%32x\n", MacValue));
-
-		/* for RT30xx F and after, PCIe interface, and for power solution 3 */
-		if ((IS_VERSION_AFTER_F(pAd))
-		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode >= 2)
-		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode <= 3)) {
-			RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     (" Read AUX_CTRL = 0x%x\n", MacValue));
-			/* turn on bit 12. */
-			/*enable 32KHz clock mode for power saving */
-			MacValue |= 0x1000;
-			if (MacValue != 0xffffffff) {
-				RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
-				DBGPRINT_RAW(RT_DEBUG_ERROR,
-					     (" Write AUX_CTRL = 0x%x\n",
-					      MacValue));
-				/* 1. if use PCIePowerSetting is 2 or 3, need to program OSC_CTRL to 0x3ff11. */
-				MacValue = 0x3ff11;
-				RTMP_IO_WRITE32(pAd, OSC_CTRL, MacValue);
-				DBGPRINT_RAW(RT_DEBUG_ERROR,
-					     (" OSC_CTRL = 0x%x\n", MacValue));
-				/* 2. Write PCI register Clk ref bit */
-				RTMPrt3xSetPCIePowerLinkCtrl(pAd);
-			} else {
-				/* Error read Aux_Ctrl value.  Force to use solution 1 */
-				DBGPRINT(RT_DEBUG_ERROR,
-					 (" Error Value in AUX_CTRL = 0x%x\n",
-					  MacValue));
-				pAd->StaCfg.PSControl.field.rt30xxPowerMode = 1;
-				DBGPRINT(RT_DEBUG_ERROR,
-					 (" Force to use power solution1 \n"));
-			}
-		}
-		/* 1. read setting from inf file. */
-
-		PCIePowerSaveLevel =
-		    (u16)pAd->StaCfg.PSControl.field.rt30xxPowerMode;
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("====> rt30xx Read PowerLevelMode =  0x%x.\n",
-			  PCIePowerSaveLevel));
-		/* 2. Check EnableNewPS. */
-		if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
-			PCIePowerSaveLevel = 1;
-
-		if (IS_VERSION_BEFORE_F(pAd)
-		    && (pAd->b3090ESpecialChip == FALSE)) {
-			/* Chip Version E only allow 1, So force set 1. */
-			PCIePowerSaveLevel &= 0x1;
-			pAd->PCIePowerSaveLevel = (u16)PCIePowerSaveLevel;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("====> rt30xx E Write 0x83 Command = 0x%x.\n",
-				  PCIePowerSaveLevel));
-
-			AsicSendCommandToMcu(pAd, 0x83, 0xff,
-					     (u8)PCIePowerSaveLevel, 0x00);
-		} else {
-			/* Chip Version F and after only allow 1 or 2 or 3. This might be modified after new chip version come out. */
-			if (!
-			    ((PCIePowerSaveLevel == 1)
-			     || (PCIePowerSaveLevel == 3)))
-				PCIePowerSaveLevel = 1;
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("====> rt30xx F Write 0x83 Command = 0x%x.\n",
-				  PCIePowerSaveLevel));
-			pAd->PCIePowerSaveLevel = (u16)PCIePowerSaveLevel;
-			/* for 3090F , we need to add high-byte arg for 0x83 command to indicate the link control setting in */
-			/* PCI Configuration Space. Because firmware can't read PCI Configuration Space */
-			if ((pAd->Rt3xxRalinkLinkCtrl & 0x2)
-			    && (pAd->Rt3xxHostLinkCtrl & 0x2)) {
-				LinkCtrlSetting = 1;
-			}
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("====> rt30xxF LinkCtrlSetting = 0x%x.\n",
-				  LinkCtrlSetting));
-			AsicSendCommandToMcu(pAd, 0x83, 0xff,
-					     (u8)PCIePowerSaveLevel,
-					     LinkCtrlSetting);
-		}
-	}
-	/* Find Ralink PCIe Device's Express Capability Offset */
-	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
-
-	if (pos != 0) {
-		/* Ralink PCIe Device's Link Control Register Offset */
-		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				     &reg16);
-		Configuration = le2cpu16(reg16);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Read (Ralink PCIe Link Control Register) offset 0x%x = 0x%x\n",
-			  pAd->RLnkCtrlOffset, Configuration));
-		pAd->RLnkCtrlConfiguration = (Configuration & 0x103);
-		Configuration &= 0xfefc;
-		Configuration |= (0x0);
-#ifdef RT2860
-		if ((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-		    || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)) {
-			reg16 = cpu2le16(Configuration);
-			pci_write_config_word(pObj->pci_dev,
-					      pAd->RLnkCtrlOffset, reg16);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
-				  pos + PCI_EXP_LNKCTL, Configuration));
-		}
-#endif /* RT2860 // */
-
-		RTMPFindHostPCIDev(pAd);
-		if (pObj->parent_pci_dev) {
-			u16 vendor_id;
-
-			pci_read_config_word(pObj->parent_pci_dev,
-					     PCI_VENDOR_ID, &vendor_id);
-			vendor_id = le2cpu16(vendor_id);
-			if (vendor_id == PCIBUS_INTEL_VENDOR) {
-				bFindIntel = TRUE;
-				RTMP_SET_PSFLAG(pAd, fRTMP_PS_TOGGLE_L1);
-			}
-			/* Find PCI-to-PCI Bridge Express Capability Offset */
-			pos =
-			    pci_find_capability(pObj->parent_pci_dev,
-						PCI_CAP_ID_EXP);
-
-			if (pos != 0) {
-				BOOLEAN bChange = FALSE;
-				/* PCI-to-PCI Bridge Link Control Register Offset */
-				pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-				pci_read_config_word(pObj->parent_pci_dev,
-						     pAd->HostLnkCtrlOffset,
-						     &reg16);
-				Configuration = le2cpu16(reg16);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Read (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
-					  pAd->HostLnkCtrlOffset,
-					  Configuration));
-				pAd->HostLnkCtrlConfiguration =
-				    (Configuration & 0x103);
-				Configuration &= 0xfefc;
-				Configuration |= (0x0);
-
-				switch (pObj->DeviceID) {
-#ifdef RT2860
-				case NIC2860_PCIe_DEVICE_ID:
-				case NIC2790_PCIe_DEVICE_ID:
-					bChange = TRUE;
-					break;
-#endif /* RT2860 // */
-#ifdef RT3090
-				case NIC3090_PCIe_DEVICE_ID:
-				case NIC3091_PCIe_DEVICE_ID:
-				case NIC3092_PCIe_DEVICE_ID:
-					if (bFindIntel == FALSE)
-						bChange = TRUE;
-					break;
-#endif /* RT3090 // */
-				default:
-					break;
-				}
-
-				if (bChange) {
-					reg16 = cpu2le16(Configuration);
-					pci_write_config_word(pObj->
-							      parent_pci_dev,
-							      pAd->
-							      HostLnkCtrlOffset,
-							      reg16);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("Write (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
-						  pAd->HostLnkCtrlOffset,
-						  Configuration));
-				}
-			} else {
-				pAd->HostLnkCtrlOffset = 0;
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("%s: cannot find PCI-to-PCI Bridge PCI Express Capability!\n",
-					  __func__));
-			}
-		}
-	} else {
-		pAd->RLnkCtrlOffset = 0;
-		pAd->HostLnkCtrlOffset = 0;
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s: cannot find Ralink PCIe Device's PCI Express Capability!\n",
-			  __func__));
-	}
-
-	if (bFindIntel == FALSE) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Doesn't find Intel PCI host controller. \n"));
-		/* Doesn't switch L0, L1, So set PCIePowerSaveLevel to 0xff */
-		pAd->PCIePowerSaveLevel = 0xff;
-		if ((pAd->RLnkCtrlOffset != 0)
-#ifdef RT3090
-		    && ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-			|| (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-			|| (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
-#endif /* RT3090 // */
-		    ) {
-			pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
-					     &reg16);
-			Configuration = le2cpu16(reg16);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Read (Ralink 30xx PCIe Link Control Register) offset 0x%x = 0x%x\n",
-				  pAd->RLnkCtrlOffset, Configuration));
-			pAd->RLnkCtrlConfiguration = (Configuration & 0x103);
-			Configuration &= 0xfefc;
-			Configuration |= (0x0);
-			reg16 = cpu2le16(Configuration);
-			pci_write_config_word(pObj->pci_dev,
-					      pAd->RLnkCtrlOffset, reg16);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
-				  pos + PCI_EXP_LNKCTL, Configuration));
-		}
-	}
-}
-
-void RTMPFindHostPCIDev(struct rt_rtmp_adapter *pAd)
-{
-	u16 reg16;
-	u8 reg8;
-	u32 DevFn;
-	struct pci_dev *pPci_dev;
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
-
-	pObj->parent_pci_dev = NULL;
-	if (pObj->pci_dev->bus->parent) {
-		for (DevFn = 0; DevFn < 255; DevFn++) {
-			pPci_dev =
-			    pci_get_slot(pObj->pci_dev->bus->parent, DevFn);
-			if (pPci_dev) {
-				pci_read_config_word(pPci_dev, PCI_CLASS_DEVICE,
-						     &reg16);
-				reg16 = le2cpu16(reg16);
-				pci_read_config_byte(pPci_dev, PCI_CB_CARD_BUS,
-						     &reg8);
-				if ((reg16 == PCI_CLASS_BRIDGE_PCI)
-				    && (reg8 == pObj->pci_dev->bus->number)) {
-					pObj->parent_pci_dev = pPci_dev;
-				}
-			}
-		}
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-		Level = RESTORE_HALT : Restore PCI host and Ralink PCIe Link Control field to its default value.
-		Level = Other Value : Restore from dot11 power save or radio off status. And force PCI host Link Control fields to 0x1
-
-	========================================================================
-*/
-void RTMPPCIeLinkCtrlValueRestore(struct rt_rtmp_adapter *pAd, u8 Level)
-{
-	u16 PCIePowerSaveLevel, reg16;
-	u16 Configuration;
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-		return;
-
-#ifdef RT2860
-	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
-		return;
-#endif /* RT2860 // */
-	/* Check PSControl Configuration */
-	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
-		return;
-
-	/*3090 will not execute the following codes. */
-	/* Check interface : If not PCIe interface, return. */
-
-#ifdef RT3090
-	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
-		return;
-#endif /* RT3090 // */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
-	PCIePowerSaveLevel = pAd->PCIePowerSaveLevel;
-	if ((PCIePowerSaveLevel & 0xff) == 0xff) {
-		DBGPRINT(RT_DEBUG_TRACE, ("return  \n"));
-		return;
-	}
-
-	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0)) {
-		PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
-				  Configuration);
-		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
-			Configuration &= 0xfefc;
-			/* If call from interface down, restore to original setting. */
-			if (Level == RESTORE_CLOSE)
-				Configuration |= pAd->HostLnkCtrlConfiguration;
-			else
-				Configuration |= 0x0;
-			PCI_REG_WIRTE_WORD(pObj->parent_pci_dev,
-					   pAd->HostLnkCtrlOffset,
-					   Configuration);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Restore PCI host : offset 0x%x = 0x%x\n",
-				  pAd->HostLnkCtrlOffset, Configuration));
-		} else
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Restore PCI host : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n",
-				  Configuration));
-	}
-
-	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0)) {
-		PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				  Configuration);
-		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
-			Configuration &= 0xfefc;
-			/* If call from interface down, restore to original setting. */
-			if (Level == RESTORE_CLOSE)
-				Configuration |= pAd->RLnkCtrlConfiguration;
-			else
-				Configuration |= 0x0;
-			PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
-					   Configuration);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Restore Ralink : offset 0x%x = 0x%x\n",
-				  pAd->RLnkCtrlOffset, Configuration));
-		} else
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Restore Ralink : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n",
-				  Configuration));
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s <===\n", __func__));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-		Max : limit Host PCI and Ralink PCIe device's LINK CONTROL field's value.
-		Because now frequently set our device to mode 1 or mode 3 will cause problem.
-
-	========================================================================
-*/
-void RTMPPCIeLinkCtrlSetting(struct rt_rtmp_adapter *pAd, u16 Max)
-{
-	u16 PCIePowerSaveLevel, reg16;
-	u16 Configuration;
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-		return;
-
-#ifdef RT2860
-	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
-		return;
-#endif /* RT2860 // */
-	/* Check PSControl Configuration */
-	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
-		return;
-
-	/* Check interface : If not PCIe interface, return. */
-	/*Block 3090 to enter the following function */
-
-#ifdef RT3090
-	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
-		return;
-#endif /* RT3090 // */
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)) {
-		DBGPRINT(RT_DEBUG_INFO,
-			 ("RTMPPCIePowerLinkCtrl return on fRTMP_PS_CAN_GO_SLEEP flag\n"));
-		return;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
-	PCIePowerSaveLevel = pAd->PCIePowerSaveLevel;
-	if ((PCIePowerSaveLevel & 0xff) == 0xff) {
-		DBGPRINT(RT_DEBUG_TRACE, ("return  \n"));
-		return;
-	}
-	PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
-
-	/* Skip non-exist deice right away */
-	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0)) {
-		PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
-				  Configuration);
-		switch (PCIePowerSaveLevel) {
-		case 0:
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 */
-			Configuration &= 0xfefc;
-			break;
-		case 1:
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 */
-			Configuration &= 0xfefc;
-			Configuration |= 0x1;
-			break;
-		case 2:
-			/*  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 */
-			Configuration &= 0xfefc;
-			Configuration |= 0x3;
-			break;
-		case 3:
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1 */
-			Configuration &= 0xfefc;
-			Configuration |= 0x103;
-			break;
-		}
-		PCI_REG_WIRTE_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
-				   Configuration);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Write PCI host offset 0x%x = 0x%x\n",
-			  pAd->HostLnkCtrlOffset, Configuration));
-	}
-
-	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0)) {
-		/* first 2892 chip not allow to frequently set mode 3. will cause hang problem. */
-		if (PCIePowerSaveLevel > Max)
-			PCIePowerSaveLevel = Max;
-
-		PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				  Configuration);
-		switch (PCIePowerSaveLevel) {
-		case 0:
-			/* No PCI power safe */
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 . */
-			Configuration &= 0xfefc;
-			break;
-		case 1:
-			/*  L0 */
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 . */
-			Configuration &= 0xfefc;
-			Configuration |= 0x1;
-			break;
-		case 2:
-			/* L0 and L1 */
-			/*  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 */
-			Configuration &= 0xfefc;
-			Configuration |= 0x3;
-			break;
-		case 3:
-			/* L0 , L1 and clock management. */
-			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1 */
-			Configuration &= 0xfefc;
-			Configuration |= 0x103;
-			pAd->bPCIclkOff = TRUE;
-			break;
-		}
-		PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				   Configuration);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Write Ralink device : offset 0x%x = 0x%x\n",
-			  pAd->RLnkCtrlOffset, Configuration));
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPPCIePowerLinkCtrl <==============\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		1. Write a PCI register for rt30xx power solution 3
-
-	========================================================================
-*/
-void RTMPrt3xSetPCIePowerLinkCtrl(struct rt_rtmp_adapter *pAd)
-{
-
-	unsigned long HostConfiguration = 0;
-	unsigned long Configuration;
-	struct os_cookie *pObj;
-	int pos;
-	u16 reg16;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	DBGPRINT(RT_DEBUG_INFO,
-		 ("RTMPrt3xSetPCIePowerLinkCtrl.===> %lx\n",
-		  pAd->StaCfg.PSControl.word));
-
-	/* Check PSControl Configuration */
-	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
-		return;
-	RTMPFindHostPCIDev(pAd);
-	if (pObj->parent_pci_dev) {
-		/* Find PCI-to-PCI Bridge Express Capability Offset */
-		pos = pci_find_capability(pObj->parent_pci_dev, PCI_CAP_ID_EXP);
-
-		if (pos != 0)
-			pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-
-		/* If configured to turn on L1. */
-		HostConfiguration = 0;
-		if (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1) {
-			DBGPRINT(RT_DEBUG_TRACE, ("Enter,PSM : Force ASPM\n"));
-
-			/* Skip non-exist device right away */
-			if ((pAd->HostLnkCtrlOffset != 0)) {
-				PCI_REG_READ_WORD(pObj->parent_pci_dev,
-						  pAd->HostLnkCtrlOffset,
-						  HostConfiguration);
-				/* Prepare Configuration to write to Host */
-				HostConfiguration |= 0x3;
-				PCI_REG_WIRTE_WORD(pObj->parent_pci_dev,
-						   pAd->HostLnkCtrlOffset,
-						   HostConfiguration);
-				pAd->Rt3xxHostLinkCtrl = HostConfiguration;
-				/* Because in rt30xxForceASPMTest Mode, Force turn on L0s, L1. */
-				/* Fix HostConfiguration bit0:1 = 0x3 for later use. */
-				HostConfiguration = 0x3;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PSM : Force ASPM : "
-					  "Host device L1/L0s Value =  0x%lx\n",
-					  HostConfiguration));
-			}
-		} else if (pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM ==
-			   1) {
-
-			/* Skip non-exist deice right away */
-			if ((pAd->HostLnkCtrlOffset != 0)) {
-				PCI_REG_READ_WORD(pObj->parent_pci_dev,
-						  pAd->HostLnkCtrlOffset,
-						  HostConfiguration);
-				pAd->Rt3xxHostLinkCtrl = HostConfiguration;
-				HostConfiguration &= 0x3;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PSM : Follow Host ASPM : "
-					  "Host device L1/L0s Value =  0x%lx\n",
-					  HostConfiguration));
-			}
-		}
-	}
-	/* Prepare to write Ralink setting. */
-	/* Find Ralink PCIe Device's Express Capability Offset */
-	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
-
-	if (pos != 0) {
-		/* Ralink PCIe Device's Link Control Register Offset */
-		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				     &reg16);
-		Configuration = le2cpu16(reg16);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Read (Ralink PCIe Link Control Register) "
-			  "offset 0x%x = 0x%lx\n",
-			  pAd->RLnkCtrlOffset, Configuration));
-		Configuration |= 0x100;
-		if ((pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM == 1)
-		    || (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1)) {
-			switch (HostConfiguration) {
-			case 0:
-				Configuration &= 0xffffffc;
-				break;
-			case 1:
-				Configuration &= 0xffffffc;
-				Configuration |= 0x1;
-				break;
-			case 2:
-				Configuration &= 0xffffffc;
-				Configuration |= 0x2;
-				break;
-			case 3:
-				Configuration |= 0x3;
-				break;
-			}
-		}
-		reg16 = cpu2le16(Configuration);
-		pci_write_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
-				      reg16);
-		pAd->Rt3xxRalinkLinkCtrl = Configuration;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PSM :Write Ralink device L1/L0s Value =  0x%lx\n",
-			  Configuration));
-	}
-	DBGPRINT(RT_DEBUG_INFO,
-		 ("PSM :RTMPrt3xSetPCIePowerLinkCtrl <==============\n"));
-}
diff --git a/drivers/staging/rt2860/rt_config.h b/drivers/staging/rt2860/rt_config.h
deleted file mode 100644
index d1adef8..0000000
--- a/drivers/staging/rt2860/rt_config.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rt_config.h
-
-	Abstract:
-	Central header file to maintain all include files for all NDIS
-	miniport driver routines.
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-	Paul Lin    08-01-2002    created
-
-*/
-#ifndef	__RT_CONFIG_H__
-#define	__RT_CONFIG_H__
-
-#include    "rtmp_type.h"
-#include "rtmp_os.h"
-
-#include "rtmp_def.h"
-#include "rtmp_chip.h"
-#include "rtmp_timer.h"
-
-#include    "oid.h"
-#include    "mlme.h"
-#include    "wpa.h"
-#include "crypt_md5.h"
-#include "crypt_sha2.h"
-#include "crypt_hmac.h"
-#include    "rtmp.h"
-#include	"ap.h"
-#include	"dfs.h"
-#include	"chlist.h"
-#include	"spectrum.h"
-
-#include "eeprom.h"
-#if defined(RTMP_PCI_SUPPORT) || defined(RTMP_USB_SUPPORT)
-#include "rtmp_mcu.h"
-#endif
-
-#ifdef IGMP_SNOOP_SUPPORT
-#include "igmp_snoop.h"
-#endif /* IGMP_SNOOP_SUPPORT // */
-
-#endif /* __RT_CONFIG_H__ */
diff --git a/drivers/staging/rt2860/rt_linux.c b/drivers/staging/rt2860/rt_linux.c
deleted file mode 100644
index 1583347..0000000
--- a/drivers/staging/rt2860/rt_linux.c
+++ /dev/null
@@ -1,1367 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-#include <linux/firmware.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include "rt_config.h"
-
-unsigned long RTDebugLevel = RT_DEBUG_ERROR;
-
-/* for wireless system event message */
-char const *pWirelessSysEventText[IW_SYS_EVENT_TYPE_NUM] = {
-	/* system status event */
-	"had associated successfully",	/* IW_ASSOC_EVENT_FLAG */
-	"had disassociated",	/* IW_DISASSOC_EVENT_FLAG */
-	"had deauthenticated",	/* IW_DEAUTH_EVENT_FLAG */
-	"had been aged-out and disassociated",	/* IW_AGEOUT_EVENT_FLAG */
-	"occurred CounterMeasures attack",	/* IW_COUNTER_MEASURES_EVENT_FLAG */
-	"occurred replay counter different in Key Handshaking",	/* IW_REPLAY_COUNTER_DIFF_EVENT_FLAG */
-	"occurred RSNIE different in Key Handshaking",	/* IW_RSNIE_DIFF_EVENT_FLAG */
-	"occurred MIC different in Key Handshaking",	/* IW_MIC_DIFF_EVENT_FLAG */
-	"occurred ICV error in RX",	/* IW_ICV_ERROR_EVENT_FLAG */
-	"occurred MIC error in RX",	/* IW_MIC_ERROR_EVENT_FLAG */
-	"Group Key Handshaking timeout",	/* IW_GROUP_HS_TIMEOUT_EVENT_FLAG */
-	"Pairwise Key Handshaking timeout",	/* IW_PAIRWISE_HS_TIMEOUT_EVENT_FLAG */
-	"RSN IE sanity check failure",	/* IW_RSNIE_SANITY_FAIL_EVENT_FLAG */
-	"set key done in WPA/WPAPSK",	/* IW_SET_KEY_DONE_WPA1_EVENT_FLAG */
-	"set key done in WPA2/WPA2PSK",	/* IW_SET_KEY_DONE_WPA2_EVENT_FLAG */
-	"connects with our wireless client",	/* IW_STA_LINKUP_EVENT_FLAG */
-	"disconnects with our wireless client",	/* IW_STA_LINKDOWN_EVENT_FLAG */
-	"scan completed"	/* IW_SCAN_COMPLETED_EVENT_FLAG */
-	    "scan terminate! Busy! Enqueue fail!"	/* IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG */
-};
-
-/* for wireless IDS_spoof_attack event message */
-char const *pWirelessSpoofEventText[IW_SPOOF_EVENT_TYPE_NUM] = {
-	"detected conflict SSID",	/* IW_CONFLICT_SSID_EVENT_FLAG */
-	"detected spoofed association response",	/* IW_SPOOF_ASSOC_RESP_EVENT_FLAG */
-	"detected spoofed reassociation responses",	/* IW_SPOOF_REASSOC_RESP_EVENT_FLAG */
-	"detected spoofed probe response",	/* IW_SPOOF_PROBE_RESP_EVENT_FLAG */
-	"detected spoofed beacon",	/* IW_SPOOF_BEACON_EVENT_FLAG */
-	"detected spoofed disassociation",	/* IW_SPOOF_DISASSOC_EVENT_FLAG */
-	"detected spoofed authentication",	/* IW_SPOOF_AUTH_EVENT_FLAG */
-	"detected spoofed deauthentication",	/* IW_SPOOF_DEAUTH_EVENT_FLAG */
-	"detected spoofed unknown management frame",	/* IW_SPOOF_UNKNOWN_MGMT_EVENT_FLAG */
-	"detected replay attack"	/* IW_REPLAY_ATTACK_EVENT_FLAG */
-};
-
-/* for wireless IDS_flooding_attack event message */
-char const *pWirelessFloodEventText[IW_FLOOD_EVENT_TYPE_NUM] = {
-	"detected authentication flooding",	/* IW_FLOOD_AUTH_EVENT_FLAG */
-	"detected association request flooding",	/* IW_FLOOD_ASSOC_REQ_EVENT_FLAG */
-	"detected reassociation request flooding",	/* IW_FLOOD_REASSOC_REQ_EVENT_FLAG */
-	"detected probe request flooding",	/* IW_FLOOD_PROBE_REQ_EVENT_FLAG */
-	"detected disassociation flooding",	/* IW_FLOOD_DISASSOC_EVENT_FLAG */
-	"detected deauthentication flooding",	/* IW_FLOOD_DEAUTH_EVENT_FLAG */
-	"detected 802.1x eap-request flooding"	/* IW_FLOOD_EAP_REQ_EVENT_FLAG */
-};
-
-/* timeout -- ms */
-void RTMP_SetPeriodicTimer(struct timer_list *pTimer,
-			   IN unsigned long timeout)
-{
-	timeout = ((timeout * OS_HZ) / 1000);
-	pTimer->expires = jiffies + timeout;
-	add_timer(pTimer);
-}
-
-/* convert NdisMInitializeTimer --> RTMP_OS_Init_Timer */
-void RTMP_OS_Init_Timer(struct rt_rtmp_adapter *pAd,
-			struct timer_list *pTimer,
-			IN TIMER_FUNCTION function, void *data)
-{
-	init_timer(pTimer);
-	pTimer->data = (unsigned long)data;
-	pTimer->function = function;
-}
-
-void RTMP_OS_Add_Timer(struct timer_list *pTimer,
-		       IN unsigned long timeout)
-{
-	if (timer_pending(pTimer))
-		return;
-
-	timeout = ((timeout * OS_HZ) / 1000);
-	pTimer->expires = jiffies + timeout;
-	add_timer(pTimer);
-}
-
-void RTMP_OS_Mod_Timer(struct timer_list *pTimer,
-		       IN unsigned long timeout)
-{
-	timeout = ((timeout * OS_HZ) / 1000);
-	mod_timer(pTimer, jiffies + timeout);
-}
-
-void RTMP_OS_Del_Timer(struct timer_list *pTimer, OUT BOOLEAN *pCancelled)
-{
-	if (timer_pending(pTimer)) {
-		*pCancelled = del_timer_sync(pTimer);
-	} else {
-		*pCancelled = TRUE;
-	}
-
-}
-
-void RTMP_OS_Release_Packet(struct rt_rtmp_adapter *pAd, struct rt_queue_entry *pEntry)
-{
-	/*RTMPFreeNdisPacket(pAd, (struct sk_buff *)pEntry); */
-}
-
-/* Unify all delay routine by using udelay */
-void RTMPusecDelay(unsigned long usec)
-{
-	unsigned long i;
-
-	for (i = 0; i < (usec / 50); i++)
-		udelay(50);
-
-	if (usec % 50)
-		udelay(usec % 50);
-}
-
-void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time)
-{
-	time->u.LowPart = jiffies;
-}
-
-/* pAd MUST allow to be NULL */
-int os_alloc_mem(struct rt_rtmp_adapter *pAd, u8 ** mem, unsigned long size)
-{
-	*mem = kmalloc(size, GFP_ATOMIC);
-	if (*mem)
-		return NDIS_STATUS_SUCCESS;
-	else
-		return NDIS_STATUS_FAILURE;
-}
-
-/* pAd MUST allow to be NULL */
-int os_free_mem(struct rt_rtmp_adapter *pAd, void *mem)
-{
-
-	ASSERT(mem);
-	kfree(mem);
-	return NDIS_STATUS_SUCCESS;
-}
-
-void *RtmpOSNetPktAlloc(struct rt_rtmp_adapter *pAd, IN int size)
-{
-	struct sk_buff *skb;
-	/* Add 2 more bytes for ip header alignment */
-	skb = dev_alloc_skb(size + 2);
-
-	return (void *)skb;
-}
-
-void *RTMP_AllocateFragPacketBuffer(struct rt_rtmp_adapter *pAd,
-					   unsigned long Length)
-{
-	struct sk_buff *pkt;
-
-	pkt = dev_alloc_skb(Length);
-
-	if (pkt == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("can't allocate frag rx %ld size packet\n", Length));
-	}
-
-	if (pkt) {
-		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
-	}
-
-	return (void *)pkt;
-}
-
-void *RTMP_AllocateTxPacketBuffer(struct rt_rtmp_adapter *pAd,
-					 unsigned long Length,
-					 IN BOOLEAN Cached,
-					 void **VirtualAddress)
-{
-	struct sk_buff *pkt;
-
-	pkt = dev_alloc_skb(Length);
-
-	if (pkt == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("can't allocate tx %ld size packet\n", Length));
-	}
-
-	if (pkt) {
-		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
-		*VirtualAddress = (void *)pkt->data;
-	} else {
-		*VirtualAddress = (void *)NULL;
-	}
-
-	return (void *)pkt;
-}
-
-void build_tx_packet(struct rt_rtmp_adapter *pAd,
-		     void *pPacket,
-		     u8 *pFrame, unsigned long FrameLen)
-{
-
-	struct sk_buff *pTxPkt;
-
-	ASSERT(pPacket);
-	pTxPkt = RTPKT_TO_OSPKT(pPacket);
-
-	NdisMoveMemory(skb_put(pTxPkt, FrameLen), pFrame, FrameLen);
-}
-
-void RTMPFreeAdapter(struct rt_rtmp_adapter *pAd)
-{
-	struct os_cookie *os_cookie;
-	int index;
-
-	os_cookie = (struct os_cookie *)pAd->OS_Cookie;
-
-	kfree(pAd->BeaconBuf);
-
-	NdisFreeSpinLock(&pAd->MgmtRingLock);
-
-#ifdef RTMP_MAC_PCI
-	NdisFreeSpinLock(&pAd->RxRingLock);
-#ifdef RT3090
-	NdisFreeSpinLock(&pAd->McuCmdLock);
-#endif /* RT3090 // */
-#endif /* RTMP_MAC_PCI // */
-
-	for (index = 0; index < NUM_OF_TX_RING; index++) {
-		NdisFreeSpinLock(&pAd->TxSwQueueLock[index]);
-		NdisFreeSpinLock(&pAd->DeQueueLock[index]);
-		pAd->DeQueueRunning[index] = FALSE;
-	}
-
-	NdisFreeSpinLock(&pAd->irq_lock);
-
-	release_firmware(pAd->firmware);
-
-	vfree(pAd);		/* pci_free_consistent(os_cookie->pci_dev,sizeof(struct rt_rtmp_adapter),pAd,os_cookie->pAd_pa); */
-	kfree(os_cookie);
-}
-
-BOOLEAN OS_Need_Clone_Packet(void)
-{
-	return FALSE;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		clone an input NDIS PACKET to another one. The new internally created NDIS PACKET
-		must have only one NDIS BUFFER
-		return - byte copied. 0 means can't create NDIS PACKET
-		NOTE: internally created char should be destroyed by RTMPFreeNdisPacket
-
-	Arguments:
-		pAd 	Pointer to our adapter
-		pInsAMSDUHdr	EWC A-MSDU format has extra 14-bytes header. if TRUE, insert this 14-byte hdr in front of MSDU.
-		*pSrcTotalLen			return total packet length. This length is calculated with 802.3 format packet.
-
-	Return Value:
-		NDIS_STATUS_SUCCESS
-		NDIS_STATUS_FAILURE
-
-	Note:
-
-	========================================================================
-*/
-int RTMPCloneNdisPacket(struct rt_rtmp_adapter *pAd,
-				IN BOOLEAN pInsAMSDUHdr,
-				void *pInPacket,
-				void **ppOutPacket)
-{
-
-	struct sk_buff *pkt;
-
-	ASSERT(pInPacket);
-	ASSERT(ppOutPacket);
-
-	/* 1. Allocate a packet */
-	pkt = dev_alloc_skb(2048);
-
-	if (pkt == NULL) {
-		return NDIS_STATUS_FAILURE;
-	}
-
-	skb_put(pkt, GET_OS_PKT_LEN(pInPacket));
-	NdisMoveMemory(pkt->data, GET_OS_PKT_DATAPTR(pInPacket),
-		       GET_OS_PKT_LEN(pInPacket));
-	*ppOutPacket = OSPKT_TO_RTPKT(pkt);
-
-	RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
-
-	printk(KERN_DEBUG "###Clone###\n");
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/* the allocated NDIS PACKET must be freed via RTMPFreeNdisPacket() */
-int RTMPAllocateNdisPacket(struct rt_rtmp_adapter *pAd,
-				   void **ppPacket,
-				   u8 *pHeader,
-				   u32 HeaderLen,
-				   u8 *pData, u32 DataLen)
-{
-	void *pPacket;
-	ASSERT(pData);
-	ASSERT(DataLen);
-
-	/* 1. Allocate a packet */
-	pPacket =
-	    (void **) dev_alloc_skb(HeaderLen + DataLen +
-					   RTMP_PKT_TAIL_PADDING);
-	if (pPacket == NULL) {
-		*ppPacket = NULL;
-		pr_devel("RTMPAllocateNdisPacket Fail\n");
-
-		return NDIS_STATUS_FAILURE;
-	}
-	/* 2. clone the frame content */
-	if (HeaderLen > 0)
-		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket), pHeader, HeaderLen);
-	if (DataLen > 0)
-		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket) + HeaderLen, pData,
-			       DataLen);
-
-	/* 3. update length of packet */
-	skb_put(GET_OS_PKT_TYPE(pPacket), HeaderLen + DataLen);
-
-	RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-/*      printk("%s : pPacket = %p, len = %d\n", __func__, pPacket, GET_OS_PKT_LEN(pPacket)); */
-	*ppPacket = pPacket;
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-  ========================================================================
-  Description:
-	This routine frees a miniport internally allocated char and its
-	corresponding NDIS_BUFFER and allocated memory.
-  ========================================================================
-*/
-void RTMPFreeNdisPacket(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	dev_kfree_skb_any(RTPKT_TO_OSPKT(pPacket));
-}
-
-/* IRQL = DISPATCH_LEVEL */
-/* NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same */
-/*                       scatter gather buffer */
-int Sniff2BytesFromNdisBuffer(char *pFirstBuffer,
-				      u8 DesiredOffset,
-				      u8 *pByte0, u8 *pByte1)
-{
-	*pByte0 = *(u8 *)(pFirstBuffer + DesiredOffset);
-	*pByte1 = *(u8 *)(pFirstBuffer + DesiredOffset + 1);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-void RTMP_QueryPacketInfo(void *pPacket,
-			  struct rt_packet_info *pPacketInfo,
-			  u8 **pSrcBufVA, u32 * pSrcBufLen)
-{
-	pPacketInfo->BufferCount = 1;
-	pPacketInfo->pFirstBuffer = (char *)GET_OS_PKT_DATAPTR(pPacket);
-	pPacketInfo->PhysicalBufferCount = 1;
-	pPacketInfo->TotalPacketLength = GET_OS_PKT_LEN(pPacket);
-
-	*pSrcBufVA = GET_OS_PKT_DATAPTR(pPacket);
-	*pSrcBufLen = GET_OS_PKT_LEN(pPacket);
-}
-
-void RTMP_QueryNextPacketInfo(void **ppPacket,
-			      struct rt_packet_info *pPacketInfo,
-			      u8 **pSrcBufVA, u32 * pSrcBufLen)
-{
-	void *pPacket = NULL;
-
-	if (*ppPacket)
-		pPacket = GET_OS_PKT_NEXT(*ppPacket);
-
-	if (pPacket) {
-		pPacketInfo->BufferCount = 1;
-		pPacketInfo->pFirstBuffer =
-		    (char *)GET_OS_PKT_DATAPTR(pPacket);
-		pPacketInfo->PhysicalBufferCount = 1;
-		pPacketInfo->TotalPacketLength = GET_OS_PKT_LEN(pPacket);
-
-		*pSrcBufVA = GET_OS_PKT_DATAPTR(pPacket);
-		*pSrcBufLen = GET_OS_PKT_LEN(pPacket);
-		*ppPacket = GET_OS_PKT_NEXT(pPacket);
-	} else {
-		pPacketInfo->BufferCount = 0;
-		pPacketInfo->pFirstBuffer = NULL;
-		pPacketInfo->PhysicalBufferCount = 0;
-		pPacketInfo->TotalPacketLength = 0;
-
-		*pSrcBufVA = NULL;
-		*pSrcBufLen = 0;
-		*ppPacket = NULL;
-	}
-}
-
-void *DuplicatePacket(struct rt_rtmp_adapter *pAd,
-			     void *pPacket, u8 FromWhichBSSID)
-{
-	struct sk_buff *skb;
-	void *pRetPacket = NULL;
-	u16 DataSize;
-	u8 *pData;
-
-	DataSize = (u16)GET_OS_PKT_LEN(pPacket);
-	pData = (u8 *)GET_OS_PKT_DATAPTR(pPacket);
-
-	skb = skb_clone(RTPKT_TO_OSPKT(pPacket), MEM_ALLOC_FLAG);
-	if (skb) {
-		skb->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
-		pRetPacket = OSPKT_TO_RTPKT(skb);
-	}
-
-	return pRetPacket;
-
-}
-
-void *duplicate_pkt(struct rt_rtmp_adapter *pAd,
-			   u8 *pHeader802_3,
-			   u32 HdrLen,
-			   u8 *pData,
-			   unsigned long DataSize, u8 FromWhichBSSID)
-{
-	struct sk_buff *skb;
-	void *pPacket = NULL;
-
-	skb = __dev_alloc_skb(HdrLen + DataSize + 2, MEM_ALLOC_FLAG);
-	if (skb != NULL) {
-		skb_reserve(skb, 2);
-		NdisMoveMemory(skb_tail_pointer(skb), pHeader802_3, HdrLen);
-		skb_put(skb, HdrLen);
-		NdisMoveMemory(skb_tail_pointer(skb), pData, DataSize);
-		skb_put(skb, DataSize);
-		skb->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
-		pPacket = OSPKT_TO_RTPKT(skb);
-	}
-
-	return pPacket;
-}
-
-#define TKIP_TX_MIC_SIZE		8
-void *duplicate_pkt_with_TKIP_MIC(struct rt_rtmp_adapter *pAd,
-					 void *pPacket)
-{
-	struct sk_buff *skb, *newskb;
-
-	skb = RTPKT_TO_OSPKT(pPacket);
-	if (skb_tailroom(skb) < TKIP_TX_MIC_SIZE) {
-		/* alloc a new skb and copy the packet */
-		newskb =
-		    skb_copy_expand(skb, skb_headroom(skb), TKIP_TX_MIC_SIZE,
-				    GFP_ATOMIC);
-		dev_kfree_skb_any(skb);
-		if (newskb == NULL) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Extend Tx.MIC for packet failed!, dropping packet!\n"));
-			return NULL;
-		}
-		skb = newskb;
-	}
-
-	return OSPKT_TO_RTPKT(skb);
-}
-
-void *ClonePacket(struct rt_rtmp_adapter *pAd,
-			 void *pPacket,
-			 u8 *pData, unsigned long DataSize)
-{
-	struct sk_buff *pRxPkt;
-	struct sk_buff *pClonedPkt;
-
-	ASSERT(pPacket);
-	pRxPkt = RTPKT_TO_OSPKT(pPacket);
-
-	/* clone the packet */
-	pClonedPkt = skb_clone(pRxPkt, MEM_ALLOC_FLAG);
-
-	if (pClonedPkt) {
-		/* set the correct dataptr and data len */
-		pClonedPkt->dev = pRxPkt->dev;
-		pClonedPkt->data = pData;
-		pClonedPkt->len = DataSize;
-		skb_set_tail_pointer(pClonedPkt, DataSize)
-		ASSERT(DataSize < 1530);
-	}
-	return pClonedPkt;
-}
-
-/* */
-/* change OS packet DataPtr and DataLen */
-/* */
-void update_os_packet_info(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	struct sk_buff *pOSPkt;
-
-	ASSERT(pRxBlk->pRxPacket);
-	pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
-
-	pOSPkt->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
-	pOSPkt->data = pRxBlk->pData;
-	pOSPkt->len = pRxBlk->DataSize;
-	skb_set_tail_pointer(pOSPkt, pOSPkt->len);
-}
-
-void wlan_802_11_to_802_3_packet(struct rt_rtmp_adapter *pAd,
-				 struct rt_rx_blk *pRxBlk,
-				 u8 *pHeader802_3,
-				 u8 FromWhichBSSID)
-{
-	struct sk_buff *pOSPkt;
-
-	ASSERT(pRxBlk->pRxPacket);
-	ASSERT(pHeader802_3);
-
-	pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
-
-	pOSPkt->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
-	pOSPkt->data = pRxBlk->pData;
-	pOSPkt->len = pRxBlk->DataSize;
-	skb_set_tail_pointer(pOSPkt, pOSPkt->len);
-
-	/* */
-	/* copy 802.3 header */
-	/* */
-	/* */
-
-	NdisMoveMemory(skb_push(pOSPkt, LENGTH_802_3), pHeader802_3,
-		       LENGTH_802_3);
-}
-
-void announce_802_3_packet(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-
-	struct sk_buff *pRxPkt;
-
-	ASSERT(pPacket);
-
-	pRxPkt = RTPKT_TO_OSPKT(pPacket);
-
-	/* Push up the protocol stack */
-	pRxPkt->protocol = eth_type_trans(pRxPkt, pRxPkt->dev);
-
-	netif_rx(pRxPkt);
-}
-
-struct rt_rtmp_sg_list *
-rt_get_sg_list_from_packet(void *pPacket, struct rt_rtmp_sg_list *sg)
-{
-	sg->NumberOfElements = 1;
-	sg->Elements[0].Address = GET_OS_PKT_DATAPTR(pPacket);
-	sg->Elements[0].Length = GET_OS_PKT_LEN(pPacket);
-	return sg;
-}
-
-void hex_dump(char *str, unsigned char *pSrcBufVA, unsigned int SrcBufLen)
-{
-	unsigned char *pt;
-	int x;
-
-	if (RTDebugLevel < RT_DEBUG_TRACE)
-		return;
-
-	pt = pSrcBufVA;
-	printk(KERN_DEBUG "%s: %p, len = %d\n", str, pSrcBufVA, SrcBufLen);
-	for (x = 0; x < SrcBufLen; x++) {
-		if (x % 16 == 0)
-			printk(KERN_DEBUG "0x%04x : ", x);
-		printk(KERN_DEBUG "%02x ", ((unsigned char)pt[x]));
-		if (x % 16 == 15)
-			printk(KERN_DEBUG "\n");
-	}
-	printk(KERN_DEBUG "\n");
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Send log message through wireless event
-
-		Support standard iw_event with IWEVCUSTOM. It is used below.
-
-		iwreq_data.data.flags is used to store event_flag that is defined by user.
-		iwreq_data.data.length is the length of the event log.
-
-		The format of the event log is composed of the entry's MAC address and
-		the desired log message (refer to pWirelessEventText).
-
-			ex: 11:22:33:44:55:66 has associated successfully
-
-		p.s. The requirement of Wireless Extension is v15 or newer.
-
-	========================================================================
-*/
-void RTMPSendWirelessEvent(struct rt_rtmp_adapter *pAd,
-			   u16 Event_flag,
-			   u8 *pAddr, u8 BssIdx, char Rssi)
-{
-
-	/*union         iwreq_data      wrqu; */
-	char *pBuf = NULL, *pBufPtr = NULL;
-	u16 event, type, BufLen;
-	u8 event_table_len = 0;
-
-	type = Event_flag & 0xFF00;
-	event = Event_flag & 0x00FF;
-
-	switch (type) {
-	case IW_SYS_EVENT_FLAG_START:
-		event_table_len = IW_SYS_EVENT_TYPE_NUM;
-		break;
-
-	case IW_SPOOF_EVENT_FLAG_START:
-		event_table_len = IW_SPOOF_EVENT_TYPE_NUM;
-		break;
-
-	case IW_FLOOD_EVENT_FLAG_START:
-		event_table_len = IW_FLOOD_EVENT_TYPE_NUM;
-		break;
-	}
-
-	if (event_table_len == 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s : The type(%0x02x) is not valid.\n", __func__,
-			  type));
-		return;
-	}
-
-	if (event >= event_table_len) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s : The event(%0x02x) is not valid.\n", __func__,
-			  event));
-		return;
-	}
-	/*Allocate memory and copy the msg. */
-	pBuf = kmalloc(IW_CUSTOM_MAX_LEN, GFP_ATOMIC);
-	if (pBuf != NULL) {
-		/*Prepare the payload */
-		memset(pBuf, 0, IW_CUSTOM_MAX_LEN);
-
-		pBufPtr = pBuf;
-
-		if (pAddr)
-			pBufPtr +=
-			    sprintf(pBufPtr, "(RT2860) STA(%pM) ", pAddr);
-		else if (BssIdx < MAX_MBSSID_NUM)
-			pBufPtr +=
-			    sprintf(pBufPtr, "(RT2860) BSS(wlan%d) ", BssIdx);
-		else
-			pBufPtr += sprintf(pBufPtr, "(RT2860) ");
-
-		if (type == IW_SYS_EVENT_FLAG_START)
-			pBufPtr +=
-			    sprintf(pBufPtr, "%s",
-				    pWirelessSysEventText[event]);
-		else if (type == IW_SPOOF_EVENT_FLAG_START)
-			pBufPtr +=
-			    sprintf(pBufPtr, "%s (RSSI=%d)",
-				    pWirelessSpoofEventText[event], Rssi);
-		else if (type == IW_FLOOD_EVENT_FLAG_START)
-			pBufPtr +=
-			    sprintf(pBufPtr, "%s",
-				    pWirelessFloodEventText[event]);
-		else
-			pBufPtr += sprintf(pBufPtr, "%s", "unknown event");
-
-		pBufPtr[pBufPtr - pBuf] = '\0';
-		BufLen = pBufPtr - pBuf;
-
-		RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, Event_flag, NULL,
-					(u8 *)pBuf, BufLen);
-		/*DBGPRINT(RT_DEBUG_TRACE, ("%s : %s\n", __func__, pBuf)); */
-
-		kfree(pBuf);
-	} else
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s : Can't allocate memory for wireless event.\n",
-			  __func__));
-}
-
-void send_monitor_packets(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk)
-{
-	struct sk_buff *pOSPkt;
-	struct rt_wlan_ng_prism2_header *ph;
-	int rate_index = 0;
-	u16 header_len = 0;
-	u8 temp_header[40] = { 0 };
-
-	u_int32_t ralinkrate[256] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 109, 110, 111, 112, 13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260, 27, 54, 81, 108, 162, 216, 243, 270,	/* Last 38 */
-		54, 108, 162, 216, 324, 432, 486, 540, 14, 29, 43, 57, 87, 115,
-		    130, 144, 29, 59, 87, 115, 173, 230, 260, 288, 30, 60, 90,
-		    120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540,
-		    600, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
-		11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
-		    27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
-		    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
-		    57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
-		    72, 73, 74, 75, 76, 77, 78, 79, 80
-	};
-
-	ASSERT(pRxBlk->pRxPacket);
-	if (pRxBlk->DataSize < 10) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s : Size is too small! (%d)\n", __func__,
-			  pRxBlk->DataSize));
-		goto err_free_sk_buff;
-	}
-
-	if (pRxBlk->DataSize + sizeof(struct rt_wlan_ng_prism2_header) >
-	    RX_BUFFER_AGGRESIZE) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s : Size is too large! (%zu)\n", __func__,
-			  pRxBlk->DataSize + sizeof(struct rt_wlan_ng_prism2_header)));
-		goto err_free_sk_buff;
-	}
-
-	pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
-	pOSPkt->dev = get_netdev_from_bssid(pAd, BSS0);
-	if (pRxBlk->pHeader->FC.Type == BTYPE_DATA) {
-		pRxBlk->DataSize -= LENGTH_802_11;
-		if ((pRxBlk->pHeader->FC.ToDs == 1) &&
-		    (pRxBlk->pHeader->FC.FrDs == 1))
-			header_len = LENGTH_802_11_WITH_ADDR4;
-		else
-			header_len = LENGTH_802_11;
-
-		/* QOS */
-		if (pRxBlk->pHeader->FC.SubType & 0x08) {
-			header_len += 2;
-			/* Data skip QOS control field */
-			pRxBlk->DataSize -= 2;
-		}
-		/* Order bit: A-Ralink or HTC+ */
-		if (pRxBlk->pHeader->FC.Order) {
-			header_len += 4;
-			/* Data skip HTC control field */
-			pRxBlk->DataSize -= 4;
-		}
-		/* Copy Header */
-		if (header_len <= 40)
-			NdisMoveMemory(temp_header, pRxBlk->pData, header_len);
-
-		/* skip HW padding */
-		if (pRxBlk->RxD.L2PAD)
-			pRxBlk->pData += (header_len + 2);
-		else
-			pRxBlk->pData += header_len;
-	}			/*end if */
-
-	if (pRxBlk->DataSize < pOSPkt->len) {
-		skb_trim(pOSPkt, pRxBlk->DataSize);
-	} else {
-		skb_put(pOSPkt, (pRxBlk->DataSize - pOSPkt->len));
-	}			/*end if */
-
-	if ((pRxBlk->pData - pOSPkt->data) > 0) {
-		skb_put(pOSPkt, (pRxBlk->pData - pOSPkt->data));
-		skb_pull(pOSPkt, (pRxBlk->pData - pOSPkt->data));
-	}			/*end if */
-
-	if (skb_headroom(pOSPkt) < (sizeof(struct rt_wlan_ng_prism2_header) + header_len)) {
-		if (pskb_expand_head
-		    (pOSPkt, (sizeof(struct rt_wlan_ng_prism2_header) + header_len), 0,
-		     GFP_ATOMIC)) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s : Reallocate header size of sk_buff fail!\n",
-				  __func__));
-			goto err_free_sk_buff;
-		}		/*end if */
-	}			/*end if */
-
-	if (header_len > 0)
-		NdisMoveMemory(skb_push(pOSPkt, header_len), temp_header,
-			       header_len);
-
-	ph = (struct rt_wlan_ng_prism2_header *)skb_push(pOSPkt,
-						sizeof(struct rt_wlan_ng_prism2_header));
-	NdisZeroMemory(ph, sizeof(struct rt_wlan_ng_prism2_header));
-
-	ph->msgcode = DIDmsg_lnxind_wlansniffrm;
-	ph->msglen = sizeof(struct rt_wlan_ng_prism2_header);
-	strcpy((char *)ph->devname, (char *)pAd->net_dev->name);
-
-	ph->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
-	ph->hosttime.status = 0;
-	ph->hosttime.len = 4;
-	ph->hosttime.data = jiffies;
-
-	ph->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
-	ph->mactime.status = 0;
-	ph->mactime.len = 0;
-	ph->mactime.data = 0;
-
-	ph->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
-	ph->istx.status = 0;
-	ph->istx.len = 0;
-	ph->istx.data = 0;
-
-	ph->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
-	ph->channel.status = 0;
-	ph->channel.len = 4;
-
-	ph->channel.data = (u_int32_t) pAd->CommonCfg.Channel;
-
-	ph->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
-	ph->rssi.status = 0;
-	ph->rssi.len = 4;
-	ph->rssi.data =
-	    (u_int32_t) RTMPMaxRssi(pAd,
-				    ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI0,
-						  RSSI_0), ConvertToRssi(pAd,
-									 pRxBlk->
-									 pRxWI->
-									 RSSI1,
-									 RSSI_1),
-				    ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI2,
-						  RSSI_2));
-
-	ph->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
-	ph->signal.status = 0;
-	ph->signal.len = 4;
-	ph->signal.data = 0;	/*rssi + noise; */
-
-	ph->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
-	ph->noise.status = 0;
-	ph->noise.len = 4;
-	ph->noise.data = 0;
-
-	if (pRxBlk->pRxWI->PHYMODE >= MODE_HTMIX) {
-		rate_index =
-		    16 + ((u8)pRxBlk->pRxWI->BW * 16) +
-		    ((u8)pRxBlk->pRxWI->ShortGI * 32) +
-		    ((u8)pRxBlk->pRxWI->MCS);
-	} else if (pRxBlk->pRxWI->PHYMODE == MODE_OFDM)
-		rate_index = (u8)(pRxBlk->pRxWI->MCS) + 4;
-	else
-		rate_index = (u8)(pRxBlk->pRxWI->MCS);
-	if (rate_index < 0)
-		rate_index = 0;
-	if (rate_index > 255)
-		rate_index = 255;
-
-	ph->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
-	ph->rate.status = 0;
-	ph->rate.len = 4;
-	ph->rate.data = ralinkrate[rate_index];
-
-	ph->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
-	ph->frmlen.status = 0;
-	ph->frmlen.len = 4;
-	ph->frmlen.data = (u_int32_t) pRxBlk->DataSize;
-
-	pOSPkt->pkt_type = PACKET_OTHERHOST;
-	pOSPkt->protocol = eth_type_trans(pOSPkt, pOSPkt->dev);
-	pOSPkt->ip_summed = CHECKSUM_NONE;
-	netif_rx(pOSPkt);
-
-	return;
-
-err_free_sk_buff:
-	RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
-	return;
-
-}
-
-/*******************************************************************************
-
-	Device IRQ related functions.
-
- *******************************************************************************/
-int RtmpOSIRQRequest(struct net_device *pNetDev)
-{
-#ifdef RTMP_PCI_SUPPORT
-	struct net_device *net_dev = pNetDev;
-	struct rt_rtmp_adapter *pAd = NULL;
-	int retval = 0;
-
-	GET_PAD_FROM_NET_DEV(pAd, pNetDev);
-
-	ASSERT(pAd);
-
-	if (pAd->infType == RTMP_DEV_INF_PCI) {
-		struct os_cookie *_pObj = (struct os_cookie *)(pAd->OS_Cookie);
-		RTMP_MSI_ENABLE(pAd);
-		retval =
-		    request_irq(_pObj->pci_dev->irq, rt2860_interrupt, SA_SHIRQ,
-				(net_dev)->name, (net_dev));
-		if (retval != 0)
-			printk(KERN_ERR "rt2860: request_irq  ERROR(%d)\n", retval);
-	}
-
-	return retval;
-#else
-	return 0;
-#endif
-}
-
-int RtmpOSIRQRelease(struct net_device *pNetDev)
-{
-	struct net_device *net_dev = pNetDev;
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	ASSERT(pAd);
-
-#ifdef RTMP_PCI_SUPPORT
-	if (pAd->infType == RTMP_DEV_INF_PCI) {
-		struct os_cookie *pObj = (struct os_cookie *)(pAd->OS_Cookie);
-		synchronize_irq(pObj->pci_dev->irq);
-		free_irq(pObj->pci_dev->irq, (net_dev));
-		RTMP_MSI_DISABLE(pAd);
-	}
-#endif /* RTMP_PCI_SUPPORT // */
-
-	return 0;
-}
-
-/*******************************************************************************
-
-	File open/close related functions.
-
- *******************************************************************************/
-struct file *RtmpOSFileOpen(char *pPath, int flag, int mode)
-{
-	struct file *filePtr;
-
-	filePtr = filp_open(pPath, flag, 0);
-	if (IS_ERR(filePtr)) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("%s(): Error %ld opening %s\n", __func__,
-			  -PTR_ERR(filePtr), pPath));
-	}
-
-	return (struct file *)filePtr;
-}
-
-int RtmpOSFileClose(struct file *osfd)
-{
-	filp_close(osfd, NULL);
-	return 0;
-}
-
-void RtmpOSFileSeek(struct file *osfd, int offset)
-{
-	osfd->f_pos = offset;
-}
-
-int RtmpOSFileRead(struct file *osfd, char *pDataPtr, int readLen)
-{
-	/* The object must have a read method */
-	if (osfd->f_op && osfd->f_op->read) {
-		return osfd->f_op->read(osfd, pDataPtr, readLen, &osfd->f_pos);
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR, ("no file read method\n"));
-		return -1;
-	}
-}
-
-int RtmpOSFileWrite(struct file *osfd, char *pDataPtr, int writeLen)
-{
-	return osfd->f_op->write(osfd, pDataPtr, (size_t) writeLen,
-				 &osfd->f_pos);
-}
-
-/*******************************************************************************
-
-	Task create/management/kill related functions.
-
- *******************************************************************************/
-int RtmpOSTaskKill(struct rt_rtmp_os_task *pTask)
-{
-	struct rt_rtmp_adapter *pAd;
-	int ret = NDIS_STATUS_FAILURE;
-
-	pAd = pTask->priv;
-
-#ifdef KTHREAD_SUPPORT
-	if (pTask->kthread_task) {
-		kthread_stop(pTask->kthread_task);
-		ret = NDIS_STATUS_SUCCESS;
-	}
-#else
-	CHECK_PID_LEGALITY(pTask->taskPID) {
-		printk(KERN_INFO "Terminate the task(%s) with pid(%d)!\n",
-		       pTask->taskName, GET_PID_NUMBER(pTask->taskPID));
-		mb();
-		pTask->task_killed = 1;
-		mb();
-		ret = KILL_THREAD_PID(pTask->taskPID, SIGTERM, 1);
-		if (ret) {
-			printk(KERN_WARNING
-			       "kill task(%s) with pid(%d) failed(retVal=%d)!\n",
-			       pTask->taskName, GET_PID_NUMBER(pTask->taskPID),
-			       ret);
-		} else {
-			wait_for_completion(&pTask->taskComplete);
-			pTask->taskPID = THREAD_PID_INIT_VALUE;
-			pTask->task_killed = 0;
-			ret = NDIS_STATUS_SUCCESS;
-		}
-	}
-#endif
-
-	return ret;
-
-}
-
-int RtmpOSTaskNotifyToExit(struct rt_rtmp_os_task *pTask)
-{
-
-#ifndef KTHREAD_SUPPORT
-	complete_and_exit(&pTask->taskComplete, 0);
-#endif
-
-	return 0;
-}
-
-void RtmpOSTaskCustomize(struct rt_rtmp_os_task *pTask)
-{
-
-#ifndef KTHREAD_SUPPORT
-
-	daemonize((char *)&pTask->taskName[0] /*"%s",pAd->net_dev->name */);
-
-	allow_signal(SIGTERM);
-	allow_signal(SIGKILL);
-	current->flags |= PF_NOFREEZE;
-
-	/* signal that we've started the thread */
-	complete(&pTask->taskComplete);
-
-#endif
-}
-
-int RtmpOSTaskAttach(struct rt_rtmp_os_task *pTask,
-			     IN int (*fn) (void *), IN void *arg)
-{
-	int status = NDIS_STATUS_SUCCESS;
-
-#ifdef KTHREAD_SUPPORT
-	pTask->task_killed = 0;
-	pTask->kthread_task = NULL;
-	pTask->kthread_task = kthread_run(fn, arg, pTask->taskName);
-	if (IS_ERR(pTask->kthread_task))
-		status = NDIS_STATUS_FAILURE;
-#else
-	pid_number = kernel_thread(fn, arg, RTMP_OS_MGMT_TASK_FLAGS);
-	if (pid_number < 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Attach task(%s) failed!\n", pTask->taskName));
-		status = NDIS_STATUS_FAILURE;
-	} else {
-		pTask->taskPID = GET_PID(pid_number);
-
-		/* Wait for the thread to start */
-		wait_for_completion(&pTask->taskComplete);
-		status = NDIS_STATUS_SUCCESS;
-	}
-#endif
-	return status;
-}
-
-int RtmpOSTaskInit(struct rt_rtmp_os_task *pTask,
-			   char *pTaskName, void * pPriv)
-{
-	int len;
-
-	ASSERT(pTask);
-
-#ifndef KTHREAD_SUPPORT
-	NdisZeroMemory((u8 *)(pTask), sizeof(struct rt_rtmp_os_task));
-#endif
-
-	len = strlen(pTaskName);
-	len =
-	    len >
-	    (RTMP_OS_TASK_NAME_LEN - 1) ? (RTMP_OS_TASK_NAME_LEN - 1) : len;
-	NdisMoveMemory(&pTask->taskName[0], pTaskName, len);
-	pTask->priv = pPriv;
-
-#ifndef KTHREAD_SUPPORT
-	RTMP_SEM_EVENT_INIT_LOCKED(&(pTask->taskSema));
-	pTask->taskPID = THREAD_PID_INIT_VALUE;
-
-	init_completion(&pTask->taskComplete);
-#endif
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-void RTMP_IndicateMediaState(struct rt_rtmp_adapter *pAd)
-{
-	if (pAd->CommonCfg.bWirelessEvent) {
-		if (pAd->IndicateMediaState == NdisMediaStateConnected) {
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		} else {
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		}
-	}
-}
-
-int RtmpOSWrielessEventSend(struct rt_rtmp_adapter *pAd,
-			    u32 eventType,
-			    int flags,
-			    u8 *pSrcMac,
-			    u8 *pData, u32 dataLen)
-{
-	union iwreq_data wrqu;
-
-	memset(&wrqu, 0, sizeof(wrqu));
-
-	if (flags > -1)
-		wrqu.data.flags = flags;
-
-	if (pSrcMac)
-		memcpy(wrqu.ap_addr.sa_data, pSrcMac, MAC_ADDR_LEN);
-
-	if ((pData != NULL) && (dataLen > 0))
-		wrqu.data.length = dataLen;
-
-	wireless_send_event(pAd->net_dev, eventType, &wrqu, (char *)pData);
-	return 0;
-}
-
-int RtmpOSNetDevAddrSet(struct net_device *pNetDev, u8 *pMacAddr)
-{
-	struct net_device *net_dev;
-	struct rt_rtmp_adapter *pAd;
-
-	net_dev = pNetDev;
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	/* work-around for SuSE, due to them having their own interface name management system. */
-	{
-		NdisZeroMemory(pAd->StaCfg.dev_name, 16);
-		NdisMoveMemory(pAd->StaCfg.dev_name, net_dev->name,
-			       strlen(net_dev->name));
-	}
-
-	NdisMoveMemory(net_dev->dev_addr, pMacAddr, 6);
-
-	return 0;
-}
-
-/*
-  *	Assign the network dev name for created Ralink WiFi interface.
-  */
-static int RtmpOSNetDevRequestName(struct rt_rtmp_adapter *pAd,
-				   struct net_device *dev,
-				   char *pPrefixStr, int devIdx)
-{
-	struct net_device *existNetDev;
-	char suffixName[IFNAMSIZ];
-	char desiredName[IFNAMSIZ];
-	int ifNameIdx, prefixLen, slotNameLen;
-	int Status;
-
-	prefixLen = strlen(pPrefixStr);
-	ASSERT((prefixLen < IFNAMSIZ));
-
-	for (ifNameIdx = devIdx; ifNameIdx < 32; ifNameIdx++) {
-		memset(suffixName, 0, IFNAMSIZ);
-		memset(desiredName, 0, IFNAMSIZ);
-		strncpy(&desiredName[0], pPrefixStr, prefixLen);
-
-		sprintf(suffixName, "%d", ifNameIdx);
-
-		slotNameLen = strlen(suffixName);
-		ASSERT(((slotNameLen + prefixLen) < IFNAMSIZ));
-		strcat(desiredName, suffixName);
-
-		existNetDev = RtmpOSNetDevGetByName(dev, &desiredName[0]);
-		if (existNetDev == NULL)
-			break;
-		else
-			RtmpOSNetDeviceRefPut(existNetDev);
-	}
-
-	if (ifNameIdx < 32) {
-		strcpy(&dev->name[0], &desiredName[0]);
-		Status = NDIS_STATUS_SUCCESS;
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Cannot request DevName with preifx(%s) and in range(0~32) as suffix from OS!\n",
-			  pPrefixStr));
-		Status = NDIS_STATUS_FAILURE;
-	}
-
-	return Status;
-}
-
-void RtmpOSNetDevClose(struct net_device *pNetDev)
-{
-	dev_close(pNetDev);
-}
-
-void RtmpOSNetDevFree(struct net_device *pNetDev)
-{
-	ASSERT(pNetDev);
-
-	free_netdev(pNetDev);
-}
-
-int RtmpOSNetDevAlloc(struct net_device **new_dev_p, u32 privDataSize)
-{
-	/* assign it as null first. */
-	*new_dev_p = NULL;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Allocate a net device with private data size=%d!\n",
-		  privDataSize));
-	*new_dev_p = alloc_etherdev(privDataSize);
-	if (*new_dev_p)
-		return NDIS_STATUS_SUCCESS;
-	else
-		return NDIS_STATUS_FAILURE;
-}
-
-struct net_device *RtmpOSNetDevGetByName(struct net_device *pNetDev, char *pDevName)
-{
-	struct net_device *pTargetNetDev = NULL;
-
-	pTargetNetDev = dev_get_by_name(dev_net(pNetDev), pDevName);
-
-	return pTargetNetDev;
-}
-
-void RtmpOSNetDeviceRefPut(struct net_device *pNetDev)
-{
-	/*
-	   every time dev_get_by_name is called, and it has returned a valid struct
-	   net_device*, dev_put should be called afterwards, because otherwise the
-	   machine hangs when the device is unregistered (since dev->refcnt > 1).
-	 */
-	if (pNetDev)
-		dev_put(pNetDev);
-}
-
-int RtmpOSNetDevDestory(struct rt_rtmp_adapter *pAd, struct net_device *pNetDev)
-{
-
-	/* TODO: Need to fix this */
-	printk("WARNING: This function(%s) not implement yet!\n", __func__);
-	return 0;
-}
-
-void RtmpOSNetDevDetach(struct net_device *pNetDev)
-{
-	unregister_netdev(pNetDev);
-}
-
-int RtmpOSNetDevAttach(struct net_device *pNetDev,
-		       struct rt_rtmp_os_netdev_op_hook *pDevOpHook)
-{
-	int ret, rtnl_locked = FALSE;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RtmpOSNetDevAttach()--->\n"));
-	/* If we need hook some callback function to the net device structure, now do it. */
-	if (pDevOpHook) {
-		struct rt_rtmp_adapter *pAd = NULL;
-
-		GET_PAD_FROM_NET_DEV(pAd, pNetDev);
-
-		pNetDev->netdev_ops = pDevOpHook->netdev_ops;
-
-		/* OS specific flags, here we used to indicate if we are virtual interface */
-		pNetDev->priv_flags = pDevOpHook->priv_flags;
-
-		if (pAd->OpMode == OPMODE_STA)
-			pNetDev->wireless_handlers = &rt28xx_iw_handler_def;
-
-		/* copy the net device mac address to the net_device structure. */
-		NdisMoveMemory(pNetDev->dev_addr, &pDevOpHook->devAddr[0],
-			       MAC_ADDR_LEN);
-
-		rtnl_locked = pDevOpHook->needProtcted;
-	}
-
-	if (rtnl_locked)
-		ret = register_netdevice(pNetDev);
-	else
-		ret = register_netdev(pNetDev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<---RtmpOSNetDevAttach(), ret=%d\n", ret));
-	if (ret == 0)
-		return NDIS_STATUS_SUCCESS;
-	else
-		return NDIS_STATUS_FAILURE;
-}
-
-struct net_device *RtmpOSNetDevCreate(struct rt_rtmp_adapter *pAd,
-			    int devType,
-			    int devNum,
-			    int privMemSize, char *pNamePrefix)
-{
-	struct net_device *pNetDev = NULL;
-	int status;
-
-	/* allocate a new network device */
-	status = RtmpOSNetDevAlloc(&pNetDev, 0 /*privMemSize */);
-	if (status != NDIS_STATUS_SUCCESS) {
-		/* allocation fail, exit */
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Allocate network device fail (%s)...\n",
-			  pNamePrefix));
-		return NULL;
-	}
-
-	/* find an available interface name, max 32 interfaces */
-	status = RtmpOSNetDevRequestName(pAd, pNetDev, pNamePrefix, devNum);
-	if (status != NDIS_STATUS_SUCCESS) {
-		/* error! no available ra name can be used! */
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("Assign interface name (%s with suffix 0~32) failed...\n",
-			  pNamePrefix));
-		RtmpOSNetDevFree(pNetDev);
-
-		return NULL;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("The name of the new %s interface is %s...\n",
-			  pNamePrefix, pNetDev->name));
-	}
-
-	return pNetDev;
-}
diff --git a/drivers/staging/rt2860/rt_linux.h b/drivers/staging/rt2860/rt_linux.h
deleted file mode 100644
index 3efb88f..0000000
--- a/drivers/staging/rt2860/rt_linux.h
+++ /dev/null
@@ -1,835 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rt_linux.h
-
-    Abstract:
-
-    Revision History:
-    Who          	When         	What
-    Justin P. Mattock	11/07/2010 	Fix typo in a comment
-    ---------    ----------    ----------------------------------------------
-*/
-
-#ifndef __RT_LINUX_H__
-#define __RT_LINUX_H__
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/timer.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/ethtool.h>
-#include <linux/wireless.h>
-#include <linux/proc_fs.h>
-#include <linux/delay.h>
-#include <linux/if_arp.h>
-#include <linux/ctype.h>
-#include <linux/vmalloc.h>
-
-#include <net/iw_handler.h>
-
-/* load firmware */
-#define __KERNEL_SYSCALLS__
-#include <linux/unistd.h>
-#include <asm/uaccess.h>
-#include <asm/types.h>
-#include <asm/unaligned.h>	/* for get_unaligned() */
-
-#define KTHREAD_SUPPORT 1
-/* RT2870 2.1.0.0 has it disabled */
-
-#ifdef KTHREAD_SUPPORT
-#include <linux/err.h>
-#include <linux/kthread.h>
-#endif /* KTHREAD_SUPPORT // */
-
-/***********************************************************************************
- *	Profile related sections
- ***********************************************************************************/
-
-#ifdef RTMP_MAC_PCI
-#define STA_DRIVER_VERSION			"2.1.0.0"
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-#define STA_DRIVER_VERSION			"2.1.0.0"
-/* RT3070 version: 2.1.1.0 */
-#endif /* RTMP_MAC_USB // */
-
-extern const struct iw_handler_def rt28xx_iw_handler_def;
-
-/***********************************************************************************
- *	Compiler related definitions
- ***********************************************************************************/
-#undef __inline
-#define __inline	   static inline
-#define IN
-#define OUT
-#define INOUT
-
-/***********************************************************************************
- *	OS Specific definitions and data structures
- ***********************************************************************************/
-typedef int (*HARD_START_XMIT_FUNC) (struct sk_buff *skb,
-				     struct net_device *net_dev);
-
-#ifdef RTMP_MAC_PCI
-#ifndef PCI_DEVICE
-#define PCI_DEVICE(vend,dev) \
-	.vendor = (vend), .device = (dev), \
-	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
-#endif /* PCI_DEVICE // */
-#endif /* RTMP_MAC_PCI // */
-
-#define RT_MOD_INC_USE_COUNT() \
-	if (!try_module_get(THIS_MODULE)) \
-	{ \
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: cannot reserve module\n", __func__)); \
-		return -1; \
-	}
-
-#define RT_MOD_DEC_USE_COUNT() module_put(THIS_MODULE);
-
-#define RTMP_INC_REF(_A)		0
-#define RTMP_DEC_REF(_A)		0
-#define RTMP_GET_REF(_A)		0
-
-/* This function will be called when query /proc */
-struct iw_statistics *rt28xx_get_wireless_stats(IN struct net_device *net_dev);
-
-/***********************************************************************************
- *	Network related constant definitions
- ***********************************************************************************/
-#ifndef IFNAMSIZ
-#define IFNAMSIZ 16
-#endif
-
-#define ETH_LENGTH_OF_ADDRESS	6
-
-#define NDIS_STATUS_SUCCESS                     0x00
-#define NDIS_STATUS_FAILURE                     0x01
-#define NDIS_STATUS_INVALID_DATA				0x02
-#define NDIS_STATUS_RESOURCES                   0x03
-
-#define NDIS_SET_PACKET_STATUS(_p, _status)			do{} while(0)
-#define NdisWriteErrorLogEntry(_a, _b, _c, _d)		do{} while(0)
-
-/* statistics counter */
-#define STATS_INC_RX_PACKETS(_pAd, _dev)
-#define STATS_INC_TX_PACKETS(_pAd, _dev)
-
-#define STATS_INC_RX_BYTESS(_pAd, _dev, len)
-#define STATS_INC_TX_BYTESS(_pAd, _dev, len)
-
-#define STATS_INC_RX_ERRORS(_pAd, _dev)
-#define STATS_INC_TX_ERRORS(_pAd, _dev)
-
-#define STATS_INC_RX_DROPPED(_pAd, _dev)
-#define STATS_INC_TX_DROPPED(_pAd, _dev)
-
-/***********************************************************************************
- *	Ralink Specific network related constant definitions
- ***********************************************************************************/
-#define MIN_NET_DEVICE_FOR_AID			0x00	/*0x00~0x3f */
-#define MIN_NET_DEVICE_FOR_MBSSID		0x00	/*0x00,0x10,0x20,0x30 */
-#define MIN_NET_DEVICE_FOR_WDS			0x10	/*0x40,0x50,0x60,0x70 */
-#define MIN_NET_DEVICE_FOR_APCLI		0x20
-#define MIN_NET_DEVICE_FOR_MESH			0x30
-#define MIN_NET_DEVICE_FOR_DLS			0x40
-#define NET_DEVICE_REAL_IDX_MASK		0x0f	/* for each operation mode, we maximum support 15 entities. */
-
-#define NDIS_PACKET_TYPE_DIRECTED		0
-#define NDIS_PACKET_TYPE_MULTICAST		1
-#define NDIS_PACKET_TYPE_BROADCAST		2
-#define NDIS_PACKET_TYPE_ALL_MULTICAST	3
-#define NDIS_PACKET_TYPE_PROMISCUOUS	4
-
-/***********************************************************************************
- *	OS signaling related constant definitions
- ***********************************************************************************/
-
-/***********************************************************************************
- *	OS file operation related data structure definitions
- ***********************************************************************************/
-struct rt_rtmp_os_fs_info {
-	int fsuid;
-	int fsgid;
-	mm_segment_t fs;
-};
-
-#define IS_FILE_OPEN_ERR(_fd)	IS_ERR((_fd))
-
-/***********************************************************************************
- *	OS semaphore related data structure and definitions
- ***********************************************************************************/
-struct os_lock {
-	spinlock_t lock;
-	unsigned long flags;
-};
-
-/* */
-/*  spin_lock enhanced for Nested spin lock */
-/* */
-#define NdisAllocateSpinLock(__lock)      \
-{                                       \
-    spin_lock_init((spinlock_t *)(__lock));               \
-}
-
-#define NdisFreeSpinLock(lock)          \
-	do{}while(0)
-
-#define RTMP_SEM_LOCK(__lock)					\
-{												\
-	spin_lock_bh((spinlock_t *)(__lock));		\
-}
-
-#define RTMP_SEM_UNLOCK(__lock)					\
-{												\
-	spin_unlock_bh((spinlock_t *)(__lock));		\
-}
-
-/* sample, use semaphore lock to replace IRQ lock, 2007/11/15 */
-#define RTMP_IRQ_LOCK(__lock, __irqflags)			\
-{													\
-	__irqflags = 0;									\
-	spin_lock_bh((spinlock_t *)(__lock));			\
-	pAd->irq_disabled |= 1; \
-}
-
-#define RTMP_IRQ_UNLOCK(__lock, __irqflag)			\
-{													\
-	pAd->irq_disabled &= 0;							\
-	spin_unlock_bh((spinlock_t *)(__lock));			\
-}
-
-#define RTMP_INT_LOCK(__lock, __irqflags)			\
-{													\
-	spin_lock_irqsave((spinlock_t *)__lock, __irqflags);	\
-}
-
-#define RTMP_INT_UNLOCK(__lock, __irqflag)			\
-{													\
-	spin_unlock_irqrestore((spinlock_t *)(__lock), ((unsigned long)__irqflag));	\
-}
-
-#define NdisAcquireSpinLock		RTMP_SEM_LOCK
-#define NdisReleaseSpinLock		RTMP_SEM_UNLOCK
-
-#ifndef wait_event_interruptible_timeout
-#define __wait_event_interruptible_timeout(wq, condition, ret) \
-do { \
-        wait_queue_t __wait; \
-        init_waitqueue_entry(&__wait, current); \
-        add_wait_queue(&wq, &__wait); \
-        for (;;) { \
-                set_current_state(TASK_INTERRUPTIBLE); \
-                if (condition) \
-                        break; \
-                if (!signal_pending(current)) { \
-                        ret = schedule_timeout(ret); \
-                        if (!ret) \
-                                break; \
-                        continue; \
-                } \
-                ret = -ERESTARTSYS; \
-                break; \
-        } \
-        current->state = TASK_RUNNING; \
-        remove_wait_queue(&wq, &__wait); \
-} while (0)
-
-#define wait_event_interruptible_timeout(wq, condition, timeout) \
-({ \
-        long __ret = timeout; \
-        if (!(condition)) \
-                __wait_event_interruptible_timeout(wq, condition, __ret); \
-        __ret; \
-})
-#endif
-
-#define RTMP_SEM_EVENT_INIT_LOCKED(_pSema)	sema_init((_pSema), 0)
-#define RTMP_SEM_EVENT_INIT(_pSema)			sema_init((_pSema), 1)
-#define RTMP_SEM_EVENT_WAIT(_pSema, _status)	((_status) = down_interruptible((_pSema)))
-#define RTMP_SEM_EVENT_UP(_pSema)			up(_pSema)
-
-#ifdef KTHREAD_SUPPORT
-#define RTMP_WAIT_EVENT_INTERRUPTIBLE(_pAd, _pTask) \
-{ \
-		wait_event_interruptible(_pTask->kthread_q, \
-								 _pTask->kthread_running || kthread_should_stop()); \
-		_pTask->kthread_running = FALSE; \
-		if (kthread_should_stop()) \
-		{ \
-			RTMP_SET_FLAG(_pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS); \
-			break; \
-		} \
-}
-#endif
-
-#ifdef KTHREAD_SUPPORT
-#define WAKE_UP(_pTask) \
-	do{ \
-		if ((_pTask)->kthread_task) \
-        { \
-			(_pTask)->kthread_running = TRUE; \
-	        wake_up(&(_pTask)->kthread_q); \
-		} \
-	}while(0)
-#endif
-
-/***********************************************************************************
- *	OS Memory Access related data structure and definitions
- ***********************************************************************************/
-#define MEM_ALLOC_FLAG      (GFP_ATOMIC)	/*(GFP_DMA | GFP_ATOMIC) */
-
-#define NdisMoveMemory(Destination, Source, Length) memmove(Destination, Source, Length)
-#define NdisCopyMemory(Destination, Source, Length) memcpy(Destination, Source, Length)
-#define NdisZeroMemory(Destination, Length)         memset(Destination, 0, Length)
-#define NdisFillMemory(Destination, Length, Fill)   memset(Destination, Fill, Length)
-#define NdisCmpMemory(Destination, Source, Length)  memcmp(Destination, Source, Length)
-#define NdisEqualMemory(Source1, Source2, Length)   (!memcmp(Source1, Source2, Length))
-#define RTMPEqualMemory(Source1, Source2, Length)	(!memcmp(Source1, Source2, Length))
-
-#define MlmeAllocateMemory(_pAd, _ppVA)		os_alloc_mem(_pAd, _ppVA, MGMT_DMA_BUFFER_SIZE)
-#define MlmeFreeMemory(_pAd, _pVA)			os_free_mem(_pAd, _pVA)
-
-#define COPY_MAC_ADDR(Addr1, Addr2)             memcpy((Addr1), (Addr2), MAC_ADDR_LEN)
-
-/***********************************************************************************
- *	OS task related data structure and definitions
- ***********************************************************************************/
-#define RTMP_OS_MGMT_TASK_FLAGS	CLONE_VM
-
-#define	THREAD_PID_INIT_VALUE	NULL
-#define	GET_PID(_v)	find_get_pid((_v))
-#define	GET_PID_NUMBER(_v)	pid_nr((_v))
-#define CHECK_PID_LEGALITY(_pid)	if (pid_nr((_pid)) > 0)
-#define KILL_THREAD_PID(_A, _B, _C)	kill_pid((_A), (_B), (_C))
-
-/***********************************************************************************
- * Timer related definitions and data structures.
- **********************************************************************************/
-#define OS_HZ			HZ
-
-typedef void (*TIMER_FUNCTION) (unsigned long);
-
-#define OS_WAIT(_time) \
-{	int _i; \
-	long _loop = ((_time)/(1000/OS_HZ)) > 0 ? ((_time)/(1000/OS_HZ)) : 1;\
-	wait_queue_head_t _wait; \
-	init_waitqueue_head(&_wait); \
-	for (_i=0; _i<(_loop); _i++) \
-		wait_event_interruptible_timeout(_wait, 0, ONE_TICK); }
-
-#define RTMP_TIME_AFTER(a,b)		\
-	(typecheck(unsigned long, (unsigned long)a) && \
-	 typecheck(unsigned long, (unsigned long)b) && \
-	 ((long)(b) - (long)(a) < 0))
-
-#define RTMP_TIME_AFTER_EQ(a,b)	\
-	(typecheck(unsigned long, (unsigned long)a) && \
-	 typecheck(unsigned long, (unsigned long)b) && \
-	 ((long)(a) - (long)(b) >= 0))
-#define RTMP_TIME_BEFORE(a,b)	RTMP_TIME_AFTER_EQ(b,a)
-
-#define ONE_TICK 1
-
-static inline void NdisGetSystemUpTime(unsigned long *time)
-{
-	*time = jiffies;
-}
-
-/***********************************************************************************
- *	OS specific cookie data structure binding to struct rt_rtmp_adapter
- ***********************************************************************************/
-
-struct os_cookie {
-#ifdef RTMP_MAC_PCI
-	struct pci_dev *pci_dev;
-	struct pci_dev *parent_pci_dev;
-	u16 DeviceID;
-	dma_addr_t pAd_pa;
-#endif				/* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	struct usb_device *pUsb_Dev;
-#endif				/* RTMP_MAC_USB // */
-
-	struct tasklet_struct rx_done_task;
-	struct tasklet_struct mgmt_dma_done_task;
-	struct tasklet_struct ac0_dma_done_task;
-	struct tasklet_struct ac1_dma_done_task;
-	struct tasklet_struct ac2_dma_done_task;
-	struct tasklet_struct ac3_dma_done_task;
-	struct tasklet_struct tbtt_task;
-#ifdef RTMP_MAC_PCI
-	struct tasklet_struct fifo_statistic_full_task;
-#endif				/* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	struct tasklet_struct null_frame_complete_task;
-	struct tasklet_struct rts_frame_complete_task;
-	struct tasklet_struct pspoll_frame_complete_task;
-#endif				/* RTMP_MAC_USB // */
-
-	unsigned long apd_pid;	/*802.1x daemon pid */
-	int ioctl_if_type;
-	int ioctl_if;
-};
-
-/***********************************************************************************
- *	OS debugging and printing related definitions and data structure
- ***********************************************************************************/
-#ifdef DBG
-extern unsigned long RTDebugLevel;
-
-#define DBGPRINT_RAW(Level, Fmt)    \
-do{                                   \
-    if (Level <= RTDebugLevel)      \
-    {                               \
-        printk Fmt;               \
-    }                               \
-}while(0)
-
-#define DBGPRINT(Level, Fmt)    DBGPRINT_RAW(Level, Fmt)
-
-#define DBGPRINT_ERR(fmt, args...) printk(KERN_ERR fmt, ##args)
-
-#define DBGPRINT_S(Status, Fmt)		\
-{									\
-	printk Fmt;					\
-}
-
-#else
-#define DBGPRINT(Level, Fmt)
-#define DBGPRINT_RAW(Level, Fmt)
-#define DBGPRINT_S(Status, Fmt)
-#define DBGPRINT_ERR(Fmt)
-#endif
-
-#define ASSERT(x)
-
-void hex_dump(char *str, unsigned char *pSrcBufVA, unsigned int SrcBufLen);
-
-/*********************************************************************************************************
-	The following code are not revised, temporary put it here.
-  *********************************************************************************************************/
-
-/***********************************************************************************
- * Device DMA Access related definitions and data structures.
- **********************************************************************************/
-#ifdef RTMP_MAC_PCI
-struct rt_rtmp_adapter;
-dma_addr_t linux_pci_map_single(struct rt_rtmp_adapter *pAd, void *ptr,
-				size_t size, int sd_idx, int direction);
-void linux_pci_unmap_single(struct rt_rtmp_adapter *pAd, dma_addr_t dma_addr,
-			    size_t size, int direction);
-
-#define PCI_MAP_SINGLE(_handle, _ptr, _size, _sd_idx, _dir) \
-	linux_pci_map_single(_handle, _ptr, _size, _sd_idx, _dir)
-
-#define PCI_UNMAP_SINGLE(_handle, _ptr, _size, _dir) \
-	linux_pci_unmap_single(_handle, _ptr, _size, _dir)
-
-#define PCI_ALLOC_CONSISTENT(_pci_dev, _size, _ptr) \
-	pci_alloc_consistent(_pci_dev, _size, _ptr)
-
-#define PCI_FREE_CONSISTENT(_pci_dev, _size, _virtual_addr, _physical_addr) \
-	pci_free_consistent(_pci_dev, _size, _virtual_addr, _physical_addr)
-
-#define DEV_ALLOC_SKB(_length) \
-	dev_alloc_skb(_length)
-#endif /* RTMP_MAC_PCI // */
-
-/*
- * unsigned long
- * RTMP_GetPhysicalAddressLow(
- *   dma_addr_t  PhysicalAddress);
- */
-#define RTMP_GetPhysicalAddressLow(PhysicalAddress)		(PhysicalAddress)
-
-/*
- * unsigned long
- * RTMP_GetPhysicalAddressHigh(
- *   dma_addr_t  PhysicalAddress);
- */
-#define RTMP_GetPhysicalAddressHigh(PhysicalAddress)		(0)
-
-/*
- * void
- * RTMP_SetPhysicalAddressLow(
- *   dma_addr_t  PhysicalAddress,
- *   unsigned long  Value);
- */
-#define RTMP_SetPhysicalAddressLow(PhysicalAddress, Value)	\
-			PhysicalAddress = Value;
-
-/*
- * void
- * RTMP_SetPhysicalAddressHigh(
- *   dma_addr_t  PhysicalAddress,
- *   unsigned long  Value);
- */
-#define RTMP_SetPhysicalAddressHigh(PhysicalAddress, Value)
-
-#define NdisMIndicateStatus(_w, _x, _y, _z)
-
-/***********************************************************************************
- * Device Register I/O Access related definitions and data structures.
- **********************************************************************************/
-#ifdef RTMP_MAC_PCI
-/*Patch for ASIC turst read/write bug, needs to remove after metel fix */
-#define RTMP_IO_READ32(_A, _R, _pV)								\
-{																\
-    if ((_A)->bPCIclkOff == FALSE)                                  \
-    {                                                               \
-		(*_pV = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0)));		\
-		(*_pV = readl((void *)((_A)->CSRBaseAddress + (_R))));			\
-    }                                                               \
-    else															\
-		*_pV = 0;													\
-}
-
-#define RTMP_IO_FORCE_READ32(_A, _R, _pV)							\
-{																	\
-	(*_pV = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0)));		\
-	(*_pV = readl((void *)((_A)->CSRBaseAddress + (_R))));			\
-}
-
-#define RTMP_IO_READ8(_A, _R, _pV)								\
-{																\
-	(*_pV = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0)));			\
-	(*_pV = readb((void *)((_A)->CSRBaseAddress + (_R))));				\
-}
-#define RTMP_IO_WRITE32(_A, _R, _V)												\
-{																				\
-    if ((_A)->bPCIclkOff == FALSE)                                  \
-    {                                                               \
-	u32 Val;																\
-	Val = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0));			\
-	writel((_V), (void *)((_A)->CSRBaseAddress + (_R)));								\
-    }                                                               \
-}
-
-#define RTMP_IO_FORCE_WRITE32(_A, _R, _V)												\
-{																				\
-	u32 Val;																\
-	Val = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0));			\
-	writel(_V, (void *)((_A)->CSRBaseAddress + (_R)));								\
-}
-
-#if defined(RALINK_2880) || defined(RALINK_3052)
-#define RTMP_IO_WRITE8(_A, _R, _V)            \
-{                    \
-	unsigned long Val;                \
-	u8 _i;                \
-	_i = ((_R) & 0x3);             \
-	Val = readl((void *)((_A)->CSRBaseAddress + ((_R) - _i)));   \
-	Val = Val & (~(0x000000ff << ((_i)*8)));         \
-	Val = Val | ((unsigned long)(_V) << ((_i)*8));         \
-	writel((Val), (void *)((_A)->CSRBaseAddress + ((_R) - _i)));    \
-}
-#else
-#define RTMP_IO_WRITE8(_A, _R, _V)												\
-{																				\
-	u32 Val;																\
-	Val = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0));			\
-	writeb((_V), (u8 *)((_A)->CSRBaseAddress + (_R)));		\
-}
-#endif /* #if defined(BRCM_6358) || defined(RALINK_2880) // */
-
-#define RTMP_IO_WRITE16(_A, _R, _V)												\
-{																				\
-	u32 Val;																\
-	Val = readl((void *)((_A)->CSRBaseAddress + MAC_CSR0));			\
-	writew((_V), (u16 *)((_A)->CSRBaseAddress + (_R)));	\
-}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-/*Patch for ASIC turst read/write bug, needs to remove after metel fix */
-#define RTMP_IO_READ32(_A, _R, _pV)								\
-	RTUSBReadMACRegister((_A), (_R), (u32 *)(_pV))
-
-#define RTMP_IO_READ8(_A, _R, _pV)								\
-{																\
-}
-
-#define RTMP_IO_WRITE32(_A, _R, _V)								\
-	RTUSBWriteMACRegister((_A), (_R), (u32)(_V))
-
-#define RTMP_IO_WRITE8(_A, _R, _V)								\
-{																\
-	u16	_Val = _V;											\
-	RTUSBSingleWrite((_A), (_R), (u16)(_Val));								\
-}
-
-#define RTMP_IO_WRITE16(_A, _R, _V)								\
-{																\
-	RTUSBSingleWrite((_A), (_R), (u16)(_V));								\
-}
-#endif /* RTMP_MAC_USB // */
-
-/***********************************************************************************
- *	Network Related data structure and marco definitions
- ***********************************************************************************/
-#define PKTSRC_NDIS             0x7f
-#define PKTSRC_DRIVER           0x0f
-
-#define RTMP_OS_NETDEV_SET_PRIV(_pNetDev, _pPriv)	((_pNetDev)->ml_priv = (_pPriv))
-#define RTMP_OS_NETDEV_GET_PRIV(_pNetDev)		((_pNetDev)->ml_priv)
-#define RTMP_OS_NETDEV_GET_DEVNAME(_pNetDev)	((_pNetDev)->name)
-#define RTMP_OS_NETDEV_GET_PHYADDR(_PNETDEV)	((_PNETDEV)->dev_addr)
-
-#define RTMP_OS_NETDEV_START_QUEUE(_pNetDev)	netif_start_queue((_pNetDev))
-#define RTMP_OS_NETDEV_STOP_QUEUE(_pNetDev)	netif_stop_queue((_pNetDev))
-#define RTMP_OS_NETDEV_WAKE_QUEUE(_pNetDev)	netif_wake_queue((_pNetDev))
-#define RTMP_OS_NETDEV_CARRIER_OFF(_pNetDev)	netif_carrier_off((_pNetDev))
-
-#define QUEUE_ENTRY_TO_PACKET(pEntry) \
-	(void *)(pEntry)
-
-#define PACKET_TO_QUEUE_ENTRY(pPacket) \
-	(struct rt_queue_entry *)(pPacket)
-
-#define GET_SG_LIST_FROM_PACKET(_p, _sc)	\
-    rt_get_sg_list_from_packet(_p, _sc)
-
-#define RELEASE_NDIS_PACKET(_pAd, _pPacket, _Status)                    \
-{                                                                       \
-        RTMPFreeNdisPacket(_pAd, _pPacket);                             \
-}
-
-/*
- * packet helper
- * 	- convert internal rt packet to os packet or
- *             os packet to rt packet
- */
-#define RTPKT_TO_OSPKT(_p)		((struct sk_buff *)(_p))
-#define OSPKT_TO_RTPKT(_p)		((void *)(_p))
-
-#define GET_OS_PKT_DATAPTR(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->data)
-#define SET_OS_PKT_DATAPTR(_pkt, _dataPtr)	\
-		(RTPKT_TO_OSPKT(_pkt)->data) = (_dataPtr)
-
-#define GET_OS_PKT_LEN(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->len)
-#define SET_OS_PKT_LEN(_pkt, _len)	\
-		(RTPKT_TO_OSPKT(_pkt)->len) = (_len)
-
-#define GET_OS_PKT_DATATAIL(_pkt) \
-		(skb_tail_pointer(RTPKT_TO_OSPKT(_pkt))
-#define SET_OS_PKT_DATATAIL(_pkt, _start, _len)	\
-		(skb_set_tail_pointer(RTPKT_TO_OSPKT(_pkt), _len))
-
-#define GET_OS_PKT_HEAD(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->head)
-
-#define GET_OS_PKT_END(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->end)
-
-#define GET_OS_PKT_NETDEV(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->dev)
-#define SET_OS_PKT_NETDEV(_pkt, _pNetDev)	\
-		(RTPKT_TO_OSPKT(_pkt)->dev) = (_pNetDev)
-
-#define GET_OS_PKT_TYPE(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt))
-
-#define GET_OS_PKT_NEXT(_pkt) \
-		(RTPKT_TO_OSPKT(_pkt)->next)
-
-#define OS_PKT_CLONED(_pkt)		skb_cloned(RTPKT_TO_OSPKT(_pkt))
-
-#define OS_NTOHS(_Val) \
-		(ntohs(_Val))
-#define OS_HTONS(_Val) \
-		(htons(_Val))
-#define OS_NTOHL(_Val) \
-		(ntohl(_Val))
-#define OS_HTONL(_Val) \
-		(htonl(_Val))
-
-#define CB_OFF  10
-
-/* User Priority */
-#define RTMP_SET_PACKET_UP(_p, _prio)			(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+0] = _prio)
-#define RTMP_GET_PACKET_UP(_p)					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+0])
-
-/* Fragment # */
-#define RTMP_SET_PACKET_FRAGMENTS(_p, _num)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+1] = _num)
-#define RTMP_GET_PACKET_FRAGMENTS(_p)			(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+1])
-
-/* 0x0 ~0x7f: TX to AP's own BSS which has the specified AID. if AID>127, set bit 7 in RTMP_SET_PACKET_EMACTAB too. */
-/*(this value also as MAC(on-chip WCID) table index) */
-/* 0x80~0xff: TX to a WDS link. b0~6: WDS index */
-#define RTMP_SET_PACKET_WCID(_p, _wdsidx)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+2] = _wdsidx)
-#define RTMP_GET_PACKET_WCID(_p)          		((u8)(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+2]))
-
-/* 0xff: PKTSRC_NDIS, others: local TX buffer index. This value affects how to a packet */
-#define RTMP_SET_PACKET_SOURCE(_p, _pktsrc)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+3] = _pktsrc)
-#define RTMP_GET_PACKET_SOURCE(_p)       		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+3])
-
-/* RTS/CTS-to-self protection method */
-#define RTMP_SET_PACKET_RTS(_p, _num)      		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+4] = _num)
-#define RTMP_GET_PACKET_RTS(_p)          		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+4])
-/* see RTMP_S(G)ET_PACKET_EMACTAB */
-
-/* TX rate index */
-#define RTMP_SET_PACKET_TXRATE(_p, _rate)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+5] = _rate)
-#define RTMP_GET_PACKET_TXRATE(_p)		  		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+5])
-
-/* From which Interface */
-#define RTMP_SET_PACKET_IF(_p, _ifdx)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+6] = _ifdx)
-#define RTMP_GET_PACKET_IF(_p)		  		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+6])
-#define RTMP_SET_PACKET_NET_DEVICE_MBSSID(_p, _bss)		RTMP_SET_PACKET_IF((_p), (_bss))
-#define RTMP_SET_PACKET_NET_DEVICE_WDS(_p, _bss)		RTMP_SET_PACKET_IF((_p), ((_bss) + MIN_NET_DEVICE_FOR_WDS))
-#define RTMP_SET_PACKET_NET_DEVICE_APCLI(_p, _idx)   	RTMP_SET_PACKET_IF((_p), ((_idx) + MIN_NET_DEVICE_FOR_APCLI))
-#define RTMP_SET_PACKET_NET_DEVICE_MESH(_p, _idx)   	RTMP_SET_PACKET_IF((_p), ((_idx) + MIN_NET_DEVICE_FOR_MESH))
-#define RTMP_GET_PACKET_NET_DEVICE_MBSSID(_p)			RTMP_GET_PACKET_IF((_p))
-#define RTMP_GET_PACKET_NET_DEVICE(_p)					RTMP_GET_PACKET_IF((_p))
-
-#define RTMP_SET_PACKET_MOREDATA(_p, _morebit)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7] = _morebit)
-#define RTMP_GET_PACKET_MOREDATA(_p)				(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7])
-
-/* */
-/*      Specific Packet Type definition */
-/* */
-#define RTMP_PACKET_SPECIFIC_CB_OFFSET	11
-
-#define RTMP_PACKET_SPECIFIC_DHCP		0x01
-#define RTMP_PACKET_SPECIFIC_EAPOL		0x02
-#define RTMP_PACKET_SPECIFIC_IPV4		0x04
-#define RTMP_PACKET_SPECIFIC_WAI		0x08
-#define RTMP_PACKET_SPECIFIC_VLAN		0x10
-#define RTMP_PACKET_SPECIFIC_LLCSNAP	0x20
-
-/*Specific */
-#define RTMP_SET_PACKET_SPECIFIC(_p, _flg)	   	(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] = _flg)
-
-/*DHCP */
-#define RTMP_SET_PACKET_DHCP(_p, _flg)   													\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_DHCP);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_DHCP);	\
-			}while(0)
-#define RTMP_GET_PACKET_DHCP(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_DHCP)
-
-/*EAPOL */
-#define RTMP_SET_PACKET_EAPOL(_p, _flg)   													\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_EAPOL);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_EAPOL);	\
-			}while(0)
-#define RTMP_GET_PACKET_EAPOL(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_EAPOL)
-
-/*WAI */
-#define RTMP_SET_PACKET_WAI(_p, _flg)   													\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_WAI);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_WAI);	\
-			}while(0)
-#define RTMP_GET_PACKET_WAI(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_WAI)
-
-#define RTMP_GET_PACKET_LOWRATE(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & (RTMP_PACKET_SPECIFIC_EAPOL | RTMP_PACKET_SPECIFIC_DHCP | RTMP_PACKET_SPECIFIC_WAI))
-
-/*VLAN */
-#define RTMP_SET_PACKET_VLAN(_p, _flg)   													\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_VLAN);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_VLAN);	\
-			}while(0)
-#define RTMP_GET_PACKET_VLAN(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_VLAN)
-
-/*LLC/SNAP */
-#define RTMP_SET_PACKET_LLCSNAP(_p, _flg)   													\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_LLCSNAP);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_LLCSNAP);		\
-			}while(0)
-
-#define RTMP_GET_PACKET_LLCSNAP(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_LLCSNAP)
-
-/* IP */
-#define RTMP_SET_PACKET_IPV4(_p, _flg)														\
-			do{																				\
-				if (_flg)																	\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) |= (RTMP_PACKET_SPECIFIC_IPV4);		\
-				else																		\
-					(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11]) &= (!RTMP_PACKET_SPECIFIC_IPV4);	\
-			}while(0)
-
-#define RTMP_GET_PACKET_IPV4(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_IPV4)
-
-/* If this flag is set, it indicates that this EAPoL frame MUST be clear. */
-#define RTMP_SET_PACKET_CLEAR_EAP_FRAME(_p, _flg)   (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+12] = _flg)
-#define RTMP_GET_PACKET_CLEAR_EAP_FRAME(_p)         (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+12])
-
-/* use bit3 of cb[CB_OFF+16] */
-
-#define RTMP_SET_PACKET_5VT(_p, _flg)   (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+22] = _flg)
-#define RTMP_GET_PACKET_5VT(_p)         (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+22])
-
-/* Max skb->cb = 48B = [CB_OFF+38] */
-
-/***********************************************************************************
- *	Other function prototypes definitions
- ***********************************************************************************/
-void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time);
-int rt28xx_packet_xmit(struct sk_buff *skb);
-
-#ifdef RTMP_MAC_PCI
-/* function declarations */
-#define IRQ_HANDLE_TYPE  irqreturn_t
-
-IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance);
-#endif /* RTMP_MAC_PCI // */
-
-int rt28xx_sta_ioctl(struct net_device *net_dev, IN OUT struct ifreq *rq, int cmd);
-
-extern int ra_mtd_write(int num, loff_t to, size_t len, const u_char *buf);
-extern int ra_mtd_read(int num, loff_t from, size_t len, u_char *buf);
-
-#define GET_PAD_FROM_NET_DEV(_pAd, _net_dev)	(_pAd) = (struct rt_rtmp_adapter *)(_net_dev)->ml_priv;
-
-#endif /* __RT_LINUX_H__ // */
diff --git a/drivers/staging/rt2860/rt_main_dev.c b/drivers/staging/rt2860/rt_main_dev.c
deleted file mode 100644
index 236dd36..0000000
--- a/drivers/staging/rt2860/rt_main_dev.c
+++ /dev/null
@@ -1,736 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rt_main_dev.c
-
-    Abstract:
-    Create and register network interface.
-
-    Revision History:
-    Who         	When            What
-    Justin P. Mattock	11/07/2010	Fix typos in comments
-    --------    ----------      ----------------------------------------------
-*/
-
-#include "rt_config.h"
-
-/*---------------------------------------------------------------------*/
-/* Private Variables Used                                              */
-/*---------------------------------------------------------------------*/
-
-char *mac = "";		/* default 00:00:00:00:00:00 */
-char *hostname = "";		/* default CMPC */
-module_param(mac, charp, 0);
-MODULE_PARM_DESC(mac, "rt28xx: wireless mac addr");
-
-/*---------------------------------------------------------------------*/
-/* Prototypes of Functions Used                                        */
-/*---------------------------------------------------------------------*/
-
-/* public function prototype */
-int rt28xx_close(IN struct net_device *net_dev);
-int rt28xx_open(struct net_device *net_dev);
-
-/* private function prototype */
-static int rt28xx_send_packets(IN struct sk_buff *skb_p,
-			       IN struct net_device *net_dev);
-
-static struct net_device_stats *RT28xx_get_ether_stats(IN struct net_device
-						       *net_dev);
-
-/*
-========================================================================
-Routine Description:
-    Close raxx interface.
-
-Arguments:
-	*net_dev			the raxx interface pointer
-
-Return Value:
-    0					Open OK
-	otherwise			Open Fail
-
-Note:
-	1. if open fail, kernel will not call the close function.
-	2. Free memory for
-		(1) Mlme Memory Handler:		MlmeHalt()
-		(2) TX & RX:					RTMPFreeTxRxRingMemory()
-		(3) BA Reordering: 				ba_reordering_resource_release()
-========================================================================
-*/
-int MainVirtualIF_close(IN struct net_device *net_dev)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	/* Sanity check for pAd */
-	if (pAd == NULL)
-		return 0;	/* close ok */
-
-	netif_carrier_off(pAd->net_dev);
-	netif_stop_queue(pAd->net_dev);
-
-	{
-		BOOLEAN Cancelled;
-
-		if (INFRA_ON(pAd) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-			struct rt_mlme_disassoc_req DisReq;
-			struct rt_mlme_queue_elem *MsgElem =
-				kmalloc(sizeof(struct rt_mlme_queue_elem),
-					MEM_ALLOC_FLAG);
-
-			if (MsgElem) {
-				COPY_MAC_ADDR(DisReq.Addr,
-					      pAd->CommonCfg.Bssid);
-				DisReq.Reason = REASON_DEAUTH_STA_LEAVING;
-
-				MsgElem->Machine = ASSOC_STATE_MACHINE;
-				MsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-				MsgElem->MsgLen =
-				    sizeof(struct rt_mlme_disassoc_req);
-				NdisMoveMemory(MsgElem->Msg, &DisReq,
-					       sizeof
-					       (struct rt_mlme_disassoc_req));
-
-				/* Prevent to connect AP again in STAMlmePeriodicExec */
-				pAd->MlmeAux.AutoReconnectSsidLen = 32;
-				NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
-					       pAd->MlmeAux.
-					       AutoReconnectSsidLen);
-
-				pAd->Mlme.CntlMachine.CurrState =
-				    CNTL_WAIT_OID_DISASSOC;
-				MlmeDisassocReqAction(pAd, MsgElem);
-				kfree(MsgElem);
-			}
-
-			RTMPusecDelay(1000);
-		}
-
-		RTMPCancelTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer,
-				&Cancelled);
-		RTMPCancelTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer,
-				&Cancelled);
-	}
-
-	VIRTUAL_IF_DOWN(pAd);
-
-	RT_MOD_DEC_USE_COUNT();
-
-	return 0;		/* close ok */
-}
-
-/*
-========================================================================
-Routine Description:
-    Open raxx interface.
-
-Arguments:
-	*net_dev			the raxx interface pointer
-
-Return Value:
-    0					Open OK
-	otherwise			Open Fail
-
-Note:
-	1. if open fail, kernel will not call the close function.
-	2. Free memory for
-		(1) Mlme Memory Handler:		MlmeHalt()
-		(2) TX & RX:					RTMPFreeTxRxRingMemory()
-		(3) BA Reordering: 				ba_reordering_resource_release()
-========================================================================
-*/
-int MainVirtualIF_open(IN struct net_device *net_dev)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	/* Sanity check for pAd */
-	if (pAd == NULL)
-		return 0;	/* close ok */
-
-	if (VIRTUAL_IF_UP(pAd) != 0)
-		return -1;
-
-	/* increase MODULE use count */
-	RT_MOD_INC_USE_COUNT();
-
-	netif_start_queue(net_dev);
-	netif_carrier_on(net_dev);
-	netif_wake_queue(net_dev);
-
-	return 0;
-}
-
-/*
-========================================================================
-Routine Description:
-    Close raxx interface.
-
-Arguments:
-	*net_dev			the raxx interface pointer
-
-Return Value:
-    0					Open OK
-	otherwise			Open Fail
-
-Note:
-	1. if open fail, kernel will not call the close function.
-	2. Free memory for
-		(1) Mlme Memory Handler:		MlmeHalt()
-		(2) TX & RX:					RTMPFreeTxRxRingMemory()
-		(3) BA Reordering: 				ba_reordering_resource_release()
-========================================================================
-*/
-int rt28xx_close(struct net_device *dev)
-{
-	struct net_device *net_dev = (struct net_device *)dev;
-	struct rt_rtmp_adapter *pAd = NULL;
-	BOOLEAN Cancelled;
-	u32 i = 0;
-
-#ifdef RTMP_MAC_USB
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(unlink_wakeup);
-	DECLARE_WAITQUEUE(wait, current);
-#endif /* RTMP_MAC_USB // */
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt28xx_close\n"));
-
-	Cancelled = FALSE;
-	/* Sanity check for pAd */
-	if (pAd == NULL)
-		return 0;	/* close ok */
-
-	{
-#ifdef RTMP_MAC_PCI
-		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_CLOSE);
-#endif /* RTMP_MAC_PCI // */
-
-		/* If driver doesn't wake up firmware here, */
-		/* NICLoadFirmware will hang forever when interface is up again. */
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-			AsicForceWakeup(pAd, TRUE);
-		}
-#ifdef RTMP_MAC_USB
-		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
-#endif /* RTMP_MAC_USB // */
-
-		MlmeRadioOff(pAd);
-#ifdef RTMP_MAC_PCI
-		pAd->bPCIclkOff = FALSE;
-#endif /* RTMP_MAC_PCI // */
-	}
-
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-
-	for (i = 0; i < NUM_OF_TX_RING; i++) {
-		while (pAd->DeQueueRunning[i] == TRUE) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Waiting for TxQueue[%d] done..........\n",
-				  i));
-			RTMPusecDelay(1000);
-		}
-	}
-
-#ifdef RTMP_MAC_USB
-	/* ensure there are no more active urbs. */
-	add_wait_queue(&unlink_wakeup, &wait);
-	pAd->wait = &unlink_wakeup;
-
-	/* maybe wait for deletions to finish. */
-	i = 0;
-	/*while((i < 25) && atomic_read(&pAd->PendingRx) > 0) */
-	while (i < 25) {
-		unsigned long IrqFlags;
-
-		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-		if (pAd->PendingRx == 0) {
-			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-			break;
-		}
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-		msleep(UNLINK_TIMEOUT_MS);	/*Time in millisecond */
-		i++;
-	}
-	pAd->wait = NULL;
-	remove_wait_queue(&unlink_wakeup, &wait);
-#endif /* RTMP_MAC_USB // */
-
-	/* Stop Mlme state machine */
-	MlmeHalt(pAd);
-
-	/* Close net tasklets */
-	RtmpNetTaskExit(pAd);
-
-	{
-		MacTableReset(pAd);
-	}
-
-	MeasureReqTabExit(pAd);
-	TpcReqTabExit(pAd);
-
-	/* Close kernel threads */
-	RtmpMgmtTaskExit(pAd);
-
-#ifdef RTMP_MAC_PCI
-	{
-		BOOLEAN brc;
-		/*      unsigned long                   Value; */
-
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
-			RTMP_ASIC_INTERRUPT_DISABLE(pAd);
-		}
-		/* Receive packets to clear DMA index after disable interrupt. */
-		/* RTMPHandleRxDoneInterrupt(pAd); */
-		/* put radio off to save power when driver unloads.  After radiooff, can't write/read register, so need to finish all. */
-		/* register access before Radio off. */
-
-		brc = RT28xxPciAsicRadioOff(pAd, RTMP_HALT, 0);
-
-/*In  solution 3 of 3090F, the bPCIclkOff will be set to TRUE after calling RT28xxPciAsicRadioOff */
-		pAd->bPCIclkOff = FALSE;
-
-		if (brc == FALSE) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s call RT28xxPciAsicRadioOff fail!\n",
-				  __func__));
-		}
-	}
-
-/*
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
-	{
-		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
-	}
-
-	// Disable Rx, register value supposed will remain after reset
-	NICIssueReset(pAd);
-*/
-#endif /* RTMP_MAC_PCI // */
-
-	/* Free IRQ */
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-#ifdef RTMP_MAC_PCI
-		/* Deregister interrupt function */
-		RtmpOSIRQRelease(net_dev);
-#endif /* RTMP_MAC_PCI // */
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
-	}
-	/* Free Ring or USB buffers */
-	RTMPFreeTxRxRingMemory(pAd);
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-
-	/* Free BA reorder resource */
-	ba_reordering_resource_release(pAd);
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_START_UP);
-
-/*+++Modify by woody to solve the bulk fail+++*/
-	{
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt28xx_close\n"));
-	return 0;		/* close ok */
-}				/* End of rt28xx_close */
-
-/*
-========================================================================
-Routine Description:
-    Open raxx interface.
-
-Arguments:
-	*net_dev			the raxx interface pointer
-
-Return Value:
-    0					Open OK
-	otherwise			Open Fail
-
-Note:
-========================================================================
-*/
-int rt28xx_open(struct net_device *dev)
-{
-	struct net_device *net_dev = (struct net_device *)dev;
-	struct rt_rtmp_adapter *pAd = NULL;
-	int retval = 0;
-	/*struct os_cookie *pObj; */
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	/* Sanity check for pAd */
-	if (pAd == NULL) {
-		/* if 1st open fail, pAd will be free;
-		   So the net_dev->ml_priv will be NULL in 2rd open */
-		return -1;
-	}
-
-	if (net_dev->priv_flags == INT_MAIN) {
-		if (pAd->OpMode == OPMODE_STA)
-			net_dev->wireless_handlers =
-			    (struct iw_handler_def *)&rt28xx_iw_handler_def;
-	}
-	/* Request interrupt service routine for PCI device */
-	/* register the interrupt routine with the os */
-	RtmpOSIRQRequest(net_dev);
-
-	/* Init IRQ parameters stored in pAd */
-	RTMP_IRQ_INIT(pAd);
-
-	/* Chip & other init */
-	if (rt28xx_init(pAd, mac, hostname) == FALSE)
-		goto err;
-
-	/* Enable Interrupt */
-	RTMP_IRQ_ENABLE(pAd);
-
-	/* Now Enable RxTx */
-	RTMPEnableRxTx(pAd);
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_START_UP);
-
-	{
-		u32 reg = 0;
-		RTMP_IO_READ32(pAd, 0x1300, &reg);	/* clear garbage interrupts */
-		printk(KERN_DEBUG "0x1300 = %08x\n", reg);
-	}
-
-	{
-/*      u32 reg; */
-/*      u8  byte; */
-/*      u16 tmp; */
-
-/*      RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg); */
-
-/*      tmp = 0x0805; */
-/*      reg  = (reg & 0xffff0000) | tmp; */
-/*      RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg); */
-
-	}
-#ifdef RTMP_MAC_PCI
-	RTMPInitPCIeLinkCtrlValue(pAd);
-#endif /* RTMP_MAC_PCI // */
-
-	return retval;
-
-err:
-/*+++Add by shiang, move from rt28xx_init() to here. */
-	RtmpOSIRQRelease(net_dev);
-/*---Add by shiang, move from rt28xx_init() to here. */
-	return -1;
-}				/* End of rt28xx_open */
-
-static const struct net_device_ops rt2860_netdev_ops = {
-	.ndo_open = MainVirtualIF_open,
-	.ndo_stop = MainVirtualIF_close,
-	.ndo_do_ioctl = rt28xx_sta_ioctl,
-	.ndo_get_stats = RT28xx_get_ether_stats,
-	.ndo_validate_addr = NULL,
-	.ndo_set_mac_address = eth_mac_addr,
-	.ndo_change_mtu = eth_change_mtu,
-	.ndo_start_xmit = rt28xx_send_packets,
-};
-
-struct net_device *RtmpPhyNetDevInit(struct rt_rtmp_adapter *pAd,
-			   struct rt_rtmp_os_netdev_op_hook *pNetDevHook)
-{
-	struct net_device *net_dev = NULL;
-/*      int             Status; */
-
-	net_dev =
-	    RtmpOSNetDevCreate(pAd, INT_MAIN, 0, sizeof(struct rt_rtmp_adapter *),
-			       INF_MAIN_DEV_NAME);
-	if (net_dev == NULL) {
-		printk
-		    ("RtmpPhyNetDevInit(): creation failed for main physical net device!\n");
-		return NULL;
-	}
-
-	NdisZeroMemory((unsigned char *)pNetDevHook,
-		       sizeof(struct rt_rtmp_os_netdev_op_hook));
-	pNetDevHook->netdev_ops = &rt2860_netdev_ops;
-	pNetDevHook->priv_flags = INT_MAIN;
-	pNetDevHook->needProtcted = FALSE;
-
-	net_dev->ml_priv = (void *)pAd;
-	pAd->net_dev = net_dev;
-
-	return net_dev;
-
-}
-
-/*
-========================================================================
-Routine Description:
-    The entry point for Linux kernel sent packet to our driver.
-
-Arguments:
-    sk_buff *skb		the pointer refer to a sk_buffer.
-
-Return Value:
-    0
-
-Note:
-	This function is the entry point of Tx Path for Os delivery packet to
-	our driver. You only can put OS-depened & STA/AP common handle procedures
-	in here.
-========================================================================
-*/
-int rt28xx_packet_xmit(struct sk_buff *skb)
-{
-	struct net_device *net_dev = skb->dev;
-	struct rt_rtmp_adapter *pAd = NULL;
-	int status = NETDEV_TX_OK;
-	void *pPacket = (void *)skb;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	/* RT2870STA does this in RTMPSendPackets() */
-
-	{
-		/* Drop send request since we are in monitor mode */
-		if (MONITOR_ON(pAd)) {
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-			goto done;
-		}
-	}
-
-	/* EapolStart size is 18 */
-	if (skb->len < 14) {
-		/*printk("bad packet size: %d\n", pkt->len); */
-		hex_dump("bad packet", skb->data, skb->len);
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		goto done;
-	}
-
-	RTMP_SET_PACKET_5VT(pPacket, 0);
-	STASendPackets((void *)pAd, (void **)&pPacket, 1);
-
-	status = NETDEV_TX_OK;
-done:
-
-	return status;
-}
-
-/*
-========================================================================
-Routine Description:
-    Send a packet to WLAN.
-
-Arguments:
-    skb_p           points to our adapter
-    dev_p           which WLAN network interface
-
-Return Value:
-    0: transmit successfully
-    otherwise: transmit fail
-
-Note:
-========================================================================
-*/
-static int rt28xx_send_packets(IN struct sk_buff *skb_p,
-			       IN struct net_device *net_dev)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	if (!(net_dev->flags & IFF_UP)) {
-		RELEASE_NDIS_PACKET(pAd, (void *)skb_p,
-				    NDIS_STATUS_FAILURE);
-		return NETDEV_TX_OK;
-	}
-
-	NdisZeroMemory((u8 *)&skb_p->cb[CB_OFF], 15);
-	RTMP_SET_PACKET_NET_DEVICE_MBSSID(skb_p, MAIN_MBSSID);
-
-	return rt28xx_packet_xmit(skb_p);
-}
-
-/* This function will be called when query /proc */
-struct iw_statistics *rt28xx_get_wireless_stats(IN struct net_device *net_dev)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("rt28xx_get_wireless_stats --->\n"));
-
-	pAd->iw_stats.status = 0;	/* Status - device dependent for now */
-
-	/* link quality */
-	if (pAd->OpMode == OPMODE_STA)
-		pAd->iw_stats.qual.qual =
-		    ((pAd->Mlme.ChannelQuality * 12) / 10 + 10);
-
-	if (pAd->iw_stats.qual.qual > 100)
-		pAd->iw_stats.qual.qual = 100;
-
-	if (pAd->OpMode == OPMODE_STA) {
-		pAd->iw_stats.qual.level =
-		    RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0,
-				pAd->StaCfg.RssiSample.LastRssi1,
-				pAd->StaCfg.RssiSample.LastRssi2);
-	}
-
-	pAd->iw_stats.qual.noise = pAd->BbpWriteLatch[66];	/* noise level (dBm) */
-
-	pAd->iw_stats.qual.noise += 256 - 143;
-	pAd->iw_stats.qual.updated = 1;	/* Flags to know if updated */
-#ifdef IW_QUAL_DBM
-	pAd->iw_stats.qual.updated |= IW_QUAL_DBM;	/* Level + Noise are dBm */
-#endif /* IW_QUAL_DBM // */
-
-	pAd->iw_stats.discard.nwid = 0;	/* Rx : Wrong nwid/essid */
-	pAd->iw_stats.miss.beacon = 0;	/* Missed beacons/superframe */
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<--- rt28xx_get_wireless_stats\n"));
-	return &pAd->iw_stats;
-}
-
-void tbtt_tasklet(unsigned long data)
-{
-/*#define MAX_TX_IN_TBTT                (16) */
-
-}
-
-/*
-    ========================================================================
-
-    Routine Description:
-	return ethernet statistics counter
-
-    Arguments:
-	net_dev				Pointer to net_device
-
-    Return Value:
-	net_device_stats*
-
-    Note:
-
-    ========================================================================
-*/
-static struct net_device_stats *RT28xx_get_ether_stats(IN struct net_device
-						       *net_dev)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	if (net_dev)
-		GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	if (pAd) {
-
-		pAd->stats.rx_packets =
-		    pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
-		pAd->stats.tx_packets =
-		    pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
-
-		pAd->stats.rx_bytes = pAd->RalinkCounters.ReceivedByteCount;
-		pAd->stats.tx_bytes = pAd->RalinkCounters.TransmittedByteCount;
-
-		pAd->stats.rx_errors = pAd->Counters8023.RxErrors;
-		pAd->stats.tx_errors = pAd->Counters8023.TxErrors;
-
-		pAd->stats.rx_dropped = 0;
-		pAd->stats.tx_dropped = 0;
-
-		pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;	/* multicast packets received */
-		pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;	/* Collision packets */
-
-		pAd->stats.rx_length_errors = 0;
-		pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;	/* receiver ring buff overflow */
-		pAd->stats.rx_crc_errors = 0;	/*pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error */
-		pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;	/* recv'd frame alignment error */
-		pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;	/* recv'r fifo overrun */
-		pAd->stats.rx_missed_errors = 0;	/* receiver missed packet */
-
-		/* detailed tx_errors */
-		pAd->stats.tx_aborted_errors = 0;
-		pAd->stats.tx_carrier_errors = 0;
-		pAd->stats.tx_fifo_errors = 0;
-		pAd->stats.tx_heartbeat_errors = 0;
-		pAd->stats.tx_window_errors = 0;
-
-		/* for cslip etc */
-		pAd->stats.rx_compressed = 0;
-		pAd->stats.tx_compressed = 0;
-
-		return &pAd->stats;
-	} else
-		return NULL;
-}
-
-BOOLEAN RtmpPhyNetDevExit(struct rt_rtmp_adapter *pAd, struct net_device *net_dev)
-{
-
-	/* Unregister network device */
-	if (net_dev != NULL) {
-		printk
-		    ("RtmpOSNetDevDetach(): RtmpOSNetDeviceDetach(), dev->name=%s!\n",
-		     net_dev->name);
-		RtmpOSNetDevDetach(net_dev);
-	}
-
-	return TRUE;
-
-}
-
-/*
-========================================================================
-Routine Description:
-    Allocate memory for adapter control block.
-
-Arguments:
-    pAd					Pointer to our adapter
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-	NDIS_STATUS_FAILURE
-	NDIS_STATUS_RESOURCES
-
-Note:
-========================================================================
-*/
-int AdapterBlockAllocateMemory(void *handle, void ** ppAd)
-{
-
-	*ppAd = vmalloc(sizeof(struct rt_rtmp_adapter));
-	/* pci_alloc_consistent(pci_dev, sizeof(struct rt_rtmp_adapter), phy_addr); */
-
-	if (*ppAd) {
-		NdisZeroMemory(*ppAd, sizeof(struct rt_rtmp_adapter));
-		((struct rt_rtmp_adapter *)*ppAd)->OS_Cookie = handle;
-		return NDIS_STATUS_SUCCESS;
-	} else {
-		return NDIS_STATUS_FAILURE;
-	}
-}
diff --git a/drivers/staging/rt2860/rt_pci_rbus.c b/drivers/staging/rt2860/rt_pci_rbus.c
deleted file mode 100644
index f80ab4e..0000000
--- a/drivers/staging/rt2860/rt_pci_rbus.c
+++ /dev/null
@@ -1,837 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rt_pci_rbus.c
-
-    Abstract:
-    Create and register network interface.
-
-    Revision History:
-    Who         	When            What
-    Justin P. Mattock	11/07/2010	Fix a typo
-    --------    ----------      ----------------------------------------------
-*/
-
-#include "rt_config.h"
-#include <linux/pci.h>
-
-IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance);
-
-static void rx_done_tasklet(unsigned long data);
-static void mgmt_dma_done_tasklet(unsigned long data);
-static void ac0_dma_done_tasklet(unsigned long data);
-static void ac1_dma_done_tasklet(unsigned long data);
-static void ac2_dma_done_tasklet(unsigned long data);
-static void ac3_dma_done_tasklet(unsigned long data);
-static void fifo_statistic_full_tasklet(unsigned long data);
-
-/*---------------------------------------------------------------------*/
-/* Symbol & Macro Definitions                                          */
-/*---------------------------------------------------------------------*/
-#define RT2860_INT_RX_DLY				(1<<0)	/* bit 0 */
-#define RT2860_INT_TX_DLY				(1<<1)	/* bit 1 */
-#define RT2860_INT_RX_DONE				(1<<2)	/* bit 2 */
-#define RT2860_INT_AC0_DMA_DONE			(1<<3)	/* bit 3 */
-#define RT2860_INT_AC1_DMA_DONE			(1<<4)	/* bit 4 */
-#define RT2860_INT_AC2_DMA_DONE			(1<<5)	/* bit 5 */
-#define RT2860_INT_AC3_DMA_DONE			(1<<6)	/* bit 6 */
-#define RT2860_INT_HCCA_DMA_DONE		(1<<7)	/* bit 7 */
-#define RT2860_INT_MGMT_DONE			(1<<8)	/* bit 8 */
-
-#define INT_RX			RT2860_INT_RX_DONE
-
-#define INT_AC0_DLY		(RT2860_INT_AC0_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
-#define INT_AC1_DLY		(RT2860_INT_AC1_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
-#define INT_AC2_DLY		(RT2860_INT_AC2_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
-#define INT_AC3_DLY		(RT2860_INT_AC3_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
-#define INT_HCCA_DLY	(RT2860_INT_HCCA_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
-#define INT_MGMT_DLY	RT2860_INT_MGMT_DONE
-
-/***************************************************************************
-  *
-  *	Interface-depended memory allocation/Free related procedures.
-  *		Mainly for Hardware TxDesc/RxDesc/MgmtDesc, DMA Memory for TxData/RxData, etc.,
-  *
-  **************************************************************************/
-/* Function for TxDesc Memory allocation. */
-void RTMP_AllocateTxDescMemory(struct rt_rtmp_adapter *pAd,
-			       u32 Index,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	*VirtualAddress =
-	    (void *)pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
-					 PhysicalAddress);
-
-}
-
-/* Function for MgmtDesc Memory allocation. */
-void RTMP_AllocateMgmtDescMemory(struct rt_rtmp_adapter *pAd,
-				 unsigned long Length,
-				 IN BOOLEAN Cached,
-				 void **VirtualAddress,
-				 dma_addr_t *PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	*VirtualAddress =
-	    (void *)pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
-					 PhysicalAddress);
-
-}
-
-/* Function for RxDesc Memory allocation. */
-void RTMP_AllocateRxDescMemory(struct rt_rtmp_adapter *pAd,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	*VirtualAddress =
-	    (void *)pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
-					 PhysicalAddress);
-
-}
-
-/* Function for free allocated Desc Memory. */
-void RTMP_FreeDescMemory(struct rt_rtmp_adapter *pAd,
-			 unsigned long Length,
-			 void *VirtualAddress,
-			 dma_addr_t PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress,
-			    PhysicalAddress);
-}
-
-/* Function for TxData DMA Memory allocation. */
-void RTMP_AllocateFirstTxBuffer(struct rt_rtmp_adapter *pAd,
-				u32 Index,
-				unsigned long Length,
-				IN BOOLEAN Cached,
-				void **VirtualAddress,
-				dma_addr_t *PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	*VirtualAddress =
-	    (void *)pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
-					 PhysicalAddress);
-}
-
-void RTMP_FreeFirstTxBuffer(struct rt_rtmp_adapter *pAd,
-			    unsigned long Length,
-			    IN BOOLEAN Cached,
-			    void *VirtualAddress,
-			    dma_addr_t PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress,
-			    PhysicalAddress);
-}
-
-/*
- * FUNCTION: Allocate a common buffer for DMA
- * ARGUMENTS:
- *     AdapterHandle:  AdapterHandle
- *     Length:  Number of bytes to allocate
- *     Cached:  Whether or not the memory can be cached
- *     VirtualAddress:  Pointer to memory is returned here
- *     PhysicalAddress:  Physical address corresponding to virtual address
- */
-void RTMP_AllocateSharedMemory(struct rt_rtmp_adapter *pAd,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	*VirtualAddress =
-	    (void *)pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
-					 PhysicalAddress);
-}
-
-/*
- * FUNCTION: Allocate a packet buffer for DMA
- * ARGUMENTS:
- *     AdapterHandle:  AdapterHandle
- *     Length:  Number of bytes to allocate
- *     Cached:  Whether or not the memory can be cached
- *     VirtualAddress:  Pointer to memory is returned here
- *     PhysicalAddress:  Physical address corresponding to virtual address
- * Notes:
- *     Cached is ignored: always cached memory
- */
-void *RTMP_AllocateRxPacketBuffer(struct rt_rtmp_adapter *pAd,
-					 unsigned long Length,
-					 IN BOOLEAN Cached,
-					 void **VirtualAddress,
-					 OUT dma_addr_t *
-					 PhysicalAddress)
-{
-	struct sk_buff *pkt;
-
-	pkt = dev_alloc_skb(Length);
-
-	if (pkt == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("can't allocate rx %ld size packet\n", Length));
-	}
-
-	if (pkt) {
-		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
-		*VirtualAddress = (void *)pkt->data;
-		*PhysicalAddress =
-		    PCI_MAP_SINGLE(pAd, *VirtualAddress, Length, -1,
-				   PCI_DMA_FROMDEVICE);
-	} else {
-		*VirtualAddress = (void *)NULL;
-		*PhysicalAddress = (dma_addr_t)NULL;
-	}
-
-	return (void *)pkt;
-}
-
-void Invalid_Remaining_Packet(struct rt_rtmp_adapter *pAd, unsigned long VirtualAddress)
-{
-	dma_addr_t PhysicalAddress;
-
-	PhysicalAddress =
-	    PCI_MAP_SINGLE(pAd, (void *)(VirtualAddress + 1600),
-			   RX_BUFFER_NORMSIZE - 1600, -1, PCI_DMA_FROMDEVICE);
-}
-
-int RtmpNetTaskInit(struct rt_rtmp_adapter *pAd)
-{
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->mgmt_dma_done_task, mgmt_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac0_dma_done_task, ac0_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac1_dma_done_task, ac1_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac2_dma_done_task, ac2_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac3_dma_done_task, ac3_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->tbtt_task, tbtt_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->fifo_statistic_full_task,
-		     fifo_statistic_full_tasklet, (unsigned long)pAd);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-void RtmpNetTaskExit(struct rt_rtmp_adapter *pAd)
-{
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	tasklet_kill(&pObj->rx_done_task);
-	tasklet_kill(&pObj->mgmt_dma_done_task);
-	tasklet_kill(&pObj->ac0_dma_done_task);
-	tasklet_kill(&pObj->ac1_dma_done_task);
-	tasklet_kill(&pObj->ac2_dma_done_task);
-	tasklet_kill(&pObj->ac3_dma_done_task);
-	tasklet_kill(&pObj->tbtt_task);
-	tasklet_kill(&pObj->fifo_statistic_full_task);
-}
-
-int RtmpMgmtTaskInit(struct rt_rtmp_adapter *pAd)
-{
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-========================================================================
-Routine Description:
-    Close kernel threads.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-    NONE
-
-Note:
-========================================================================
-*/
-void RtmpMgmtTaskExit(struct rt_rtmp_adapter *pAd)
-{
-
-	return;
-}
-
-static inline void rt2860_int_enable(struct rt_rtmp_adapter *pAd, unsigned int mode)
-{
-	u32 regValue;
-
-	pAd->int_disable_mask &= ~(mode);
-	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
-	/*if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) */
-	{
-		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	/* 1:enable */
-	}
-	/*else */
-	/*      DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_DOZE !\n")); */
-
-	if (regValue != 0)
-		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
-}
-
-static inline void rt2860_int_disable(struct rt_rtmp_adapter *pAd, unsigned int mode)
-{
-	u32 regValue;
-
-	pAd->int_disable_mask |= mode;
-	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
-	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	/* 0: disable */
-
-	if (regValue == 0) {
-		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
-	}
-}
-
-/***************************************************************************
-  *
-  *	tasklet related procedures.
-  *
-  **************************************************************************/
-static void mgmt_dma_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-/*      printk("mgmt_dma_done_process\n"); */
-	IntSource.word = 0;
-	IntSource.field.MgmtDmaDone = 1;
-	pAd->int_pending &= ~INT_MGMT_DLY;
-
-	RTMPHandleMgmtRingDmaDoneInterrupt(pAd);
-
-	/* if you use RTMP_SEM_LOCK, sometimes kernel will hang up, without any */
-	/* bug report output */
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid lose of interrupts
-	 */
-	if (pAd->int_pending & INT_MGMT_DLY) {
-		tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable TxDataInt again */
-	rt2860_int_enable(pAd, INT_MGMT_DLY);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-}
-
-static void rx_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	BOOLEAN bReschedule = 0;
-	struct os_cookie *pObj;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pAd->int_pending &= ~(INT_RX);
-	bReschedule = STARxDoneInterruptHandle(pAd, 0);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid rotting packet
-	 */
-	if (pAd->int_pending & INT_RX || bReschedule) {
-		tasklet_hi_schedule(&pObj->rx_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable Rxint again */
-	rt2860_int_enable(pAd, INT_RX);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-
-}
-
-void fifo_statistic_full_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	struct os_cookie *pObj;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pAd->int_pending &= ~(FifoStaFullInt);
-	NICUpdateFifoStaCounters(pAd);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid rotting packet
-	 */
-	if (pAd->int_pending & FifoStaFullInt) {
-		tasklet_hi_schedule(&pObj->fifo_statistic_full_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable Rxint again */
-
-	rt2860_int_enable(pAd, FifoStaFullInt);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-
-}
-
-static void ac3_dma_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-	BOOLEAN bReschedule = 0;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-/*      printk("ac0_dma_done_process\n"); */
-	IntSource.word = 0;
-	IntSource.field.Ac3DmaDone = 1;
-	pAd->int_pending &= ~INT_AC3_DLY;
-
-	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid lose of interrupts
-	 */
-	if ((pAd->int_pending & INT_AC3_DLY) || bReschedule) {
-		tasklet_hi_schedule(&pObj->ac3_dma_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable TxDataInt again */
-	rt2860_int_enable(pAd, INT_AC3_DLY);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-}
-
-static void ac2_dma_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-	BOOLEAN bReschedule = 0;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	IntSource.word = 0;
-	IntSource.field.Ac2DmaDone = 1;
-	pAd->int_pending &= ~INT_AC2_DLY;
-
-	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-
-	/*
-	 * double check to avoid lose of interrupts
-	 */
-	if ((pAd->int_pending & INT_AC2_DLY) || bReschedule) {
-		tasklet_hi_schedule(&pObj->ac2_dma_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable TxDataInt again */
-	rt2860_int_enable(pAd, INT_AC2_DLY);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-}
-
-static void ac1_dma_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-	BOOLEAN bReschedule = 0;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-/*      printk("ac0_dma_done_process\n"); */
-	IntSource.word = 0;
-	IntSource.field.Ac1DmaDone = 1;
-	pAd->int_pending &= ~INT_AC1_DLY;
-
-	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid lose of interrupts
-	 */
-	if ((pAd->int_pending & INT_AC1_DLY) || bReschedule) {
-		tasklet_hi_schedule(&pObj->ac1_dma_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable TxDataInt again */
-	rt2860_int_enable(pAd, INT_AC1_DLY);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-}
-
-static void ac0_dma_done_tasklet(unsigned long data)
-{
-	unsigned long flags;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)data;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-	BOOLEAN bReschedule = 0;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-/*      printk("ac0_dma_done_process\n"); */
-	IntSource.word = 0;
-	IntSource.field.Ac0DmaDone = 1;
-	pAd->int_pending &= ~INT_AC0_DLY;
-
-/*      RTMPHandleMgmtRingDmaDoneInterrupt(pAd); */
-	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
-
-	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-	/*
-	 * double check to avoid lose of interrupts
-	 */
-	if ((pAd->int_pending & INT_AC0_DLY) || bReschedule) {
-		tasklet_hi_schedule(&pObj->ac0_dma_done_task);
-		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-		return;
-	}
-
-	/* enable TxDataInt again */
-	rt2860_int_enable(pAd, INT_AC0_DLY);
-	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
-}
-
-/***************************************************************************
-  *
-  *	interrupt handler related procedures.
-  *
-  **************************************************************************/
-int print_int_count;
-
-IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance)
-{
-	struct net_device *net_dev = (struct net_device *)dev_instance;
-	struct rt_rtmp_adapter *pAd = NULL;
-	INT_SOURCE_CSR_STRUC IntSource;
-	struct os_cookie *pObj;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	/* Note 03312008: we can not return here before
-	   RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
-	   RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);
-	   Or kernel will panic after ifconfig ra0 down sometimes */
-
-	/* */
-	/* Initial the Interrupt source. */
-	/* */
-	IntSource.word = 0x00000000L;
-/*      McuIntSource.word = 0x00000000L; */
-
-	/* */
-	/* Get the interrupt sources & saved to local variable */
-	/* */
-	/*RTMP_IO_READ32(pAd, where, &McuIntSource.word); */
-	/*RTMP_IO_WRITE32(pAd, , McuIntSource.word); */
-
-	/* */
-	/* Flag fOP_STATUS_DOZE On, means ASIC put to sleep, elase means ASICK WakeUp */
-	/* And at the same time, clock maybe turned off that say there is no DMA service. */
-	/* when ASIC get to sleep. */
-	/* To prevent system hang on power saving. */
-	/* We need to check it before handle the INT_SOURCE_CSR, ASIC must be wake up. */
-	/* */
-	/* RT2661 => when ASIC is sleeping, MAC register cannot be read and written. */
-	/* RT2860 => when ASIC is sleeping, MAC register can be read and written. */
-/*      if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) */
-	{
-		RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
-		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);	/* write 1 to clear */
-	}
-/*      else */
-/*              DBGPRINT(RT_DEBUG_TRACE, (">>>fOP_STATUS_DOZE<<<\n")); */
-
-/*      RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IsrAfterClear); */
-/*      RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &McuIsrAfterClear); */
-/*      DBGPRINT(RT_DEBUG_INFO, ("====> RTMPHandleInterrupt(ISR=%08x,Mcu ISR=%08x, After clear ISR=%08x, MCU ISR=%08x)\n", */
-/*                      IntSource.word, McuIntSource.word, IsrAfterClear, McuIsrAfterClear)); */
-
-	/* Do nothing if Reset in progress */
-	if (RTMP_TEST_FLAG
-	    (pAd,
-	     (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-	      fRTMP_ADAPTER_HALT_IN_PROGRESS))) {
-		return IRQ_HANDLED;
-	}
-	/* */
-	/* Handle interrupt, walk through all bits */
-	/* Should start from highest priority interrupt */
-	/* The priority can be adjust by altering processing if statement */
-	/* */
-
-#ifdef DBG
-
-#endif
-
-	pAd->bPCIclkOff = FALSE;
-
-	/* If required spinlock, each interrupt service routine has to acquire */
-	/* and release itself. */
-	/* */
-
-	/* Do nothing if NIC doesn't exist */
-	if (IntSource.word == 0xffffffff) {
-		RTMP_SET_FLAG(pAd,
-			      (fRTMP_ADAPTER_NIC_NOT_EXIST |
-			       fRTMP_ADAPTER_HALT_IN_PROGRESS));
-		return IRQ_HANDLED;
-	}
-
-	if (IntSource.word & TxCoherent) {
-		DBGPRINT(RT_DEBUG_ERROR, (">>>TxCoherent<<<\n"));
-		RTMPHandleRxCoherentInterrupt(pAd);
-	}
-
-	if (IntSource.word & RxCoherent) {
-		DBGPRINT(RT_DEBUG_ERROR, (">>>RxCoherent<<<\n"));
-		RTMPHandleRxCoherentInterrupt(pAd);
-	}
-
-	if (IntSource.word & FifoStaFullInt) {
-		if ((pAd->int_disable_mask & FifoStaFullInt) == 0) {
-			/* mask FifoStaFullInt */
-			rt2860_int_disable(pAd, FifoStaFullInt);
-			tasklet_hi_schedule(&pObj->fifo_statistic_full_task);
-		}
-		pAd->int_pending |= FifoStaFullInt;
-	}
-
-	if (IntSource.word & INT_MGMT_DLY) {
-		if ((pAd->int_disable_mask & INT_MGMT_DLY) == 0) {
-			rt2860_int_disable(pAd, INT_MGMT_DLY);
-			tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
-		}
-		pAd->int_pending |= INT_MGMT_DLY;
-	}
-
-	if (IntSource.word & INT_RX) {
-		if ((pAd->int_disable_mask & INT_RX) == 0) {
-
-			/* mask Rxint */
-			rt2860_int_disable(pAd, INT_RX);
-			tasklet_hi_schedule(&pObj->rx_done_task);
-		}
-		pAd->int_pending |= INT_RX;
-	}
-
-	if (IntSource.word & INT_AC3_DLY) {
-
-		if ((pAd->int_disable_mask & INT_AC3_DLY) == 0) {
-			/* mask TxDataInt */
-			rt2860_int_disable(pAd, INT_AC3_DLY);
-			tasklet_hi_schedule(&pObj->ac3_dma_done_task);
-		}
-		pAd->int_pending |= INT_AC3_DLY;
-	}
-
-	if (IntSource.word & INT_AC2_DLY) {
-
-		if ((pAd->int_disable_mask & INT_AC2_DLY) == 0) {
-			/* mask TxDataInt */
-			rt2860_int_disable(pAd, INT_AC2_DLY);
-			tasklet_hi_schedule(&pObj->ac2_dma_done_task);
-		}
-		pAd->int_pending |= INT_AC2_DLY;
-	}
-
-	if (IntSource.word & INT_AC1_DLY) {
-
-		pAd->int_pending |= INT_AC1_DLY;
-
-		if ((pAd->int_disable_mask & INT_AC1_DLY) == 0) {
-			/* mask TxDataInt */
-			rt2860_int_disable(pAd, INT_AC1_DLY);
-			tasklet_hi_schedule(&pObj->ac1_dma_done_task);
-		}
-
-	}
-
-	if (IntSource.word & INT_AC0_DLY) {
-
-/*
-		if (IntSource.word & 0x2) {
-			u32 reg;
-			RTMP_IO_READ32(pAd, DELAY_INT_CFG, &reg);
-			printk("IntSource.word = %08x, DELAY_REG = %08x\n", IntSource.word, reg);
-		}
-*/
-		pAd->int_pending |= INT_AC0_DLY;
-
-		if ((pAd->int_disable_mask & INT_AC0_DLY) == 0) {
-			/* mask TxDataInt */
-			rt2860_int_disable(pAd, INT_AC0_DLY);
-			tasklet_hi_schedule(&pObj->ac0_dma_done_task);
-		}
-
-	}
-
-	if (IntSource.word & PreTBTTInt) {
-		RTMPHandlePreTBTTInterrupt(pAd);
-	}
-
-	if (IntSource.word & TBTTInt) {
-		RTMPHandleTBTTInterrupt(pAd);
-	}
-
-	{
-		if (IntSource.word & AutoWakeupInt)
-			RTMPHandleTwakeupInterrupt(pAd);
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * invalid or writeback cache
- * and convert virtual address to physical address
- */
-dma_addr_t linux_pci_map_single(struct rt_rtmp_adapter *pAd, void *ptr,
-				size_t size, int sd_idx, int direction)
-{
-	struct os_cookie *pObj;
-
-	/*
-	   ------ Porting Information ------
-	   > For Tx Alloc:
-	   mgmt packets => sd_idx = 0
-	   SwIdx: pAd->MgmtRing.TxCpuIdx
-	   pTxD : pAd->MgmtRing.Cell[SwIdx].AllocVa;
-
-	   data packets => sd_idx = 1
-	   TxIdx : pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx
-	   QueIdx: pTxBlk->QueIdx
-	   pTxD  : pAd->TxRing[pTxBlk->QueIdx].Cell[TxIdx].AllocVa;
-
-	   > For Rx Alloc:
-	   sd_idx = -1
-	 */
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (sd_idx == 1) {
-		struct rt_tx_blk *pTxBlk;
-		pTxBlk = (struct rt_tx_blk *)ptr;
-		return pci_map_single(pObj->pci_dev, pTxBlk->pSrcBufData,
-				      pTxBlk->SrcBufLen, direction);
-	} else {
-		return pci_map_single(pObj->pci_dev, ptr, size, direction);
-	}
-
-}
-
-void linux_pci_unmap_single(struct rt_rtmp_adapter *pAd, dma_addr_t dma_addr,
-			    size_t size, int direction)
-{
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pci_unmap_single(pObj->pci_dev, dma_addr, size, direction);
-
-}
diff --git a/drivers/staging/rt2860/rt_usb.c b/drivers/staging/rt2860/rt_usb.c
deleted file mode 100644
index eb037d2..0000000
--- a/drivers/staging/rt2860/rt_usb.c
+++ /dev/null
@@ -1,794 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtusb_bulk.c
-
-	Abstract:
-
-	Revision History:
-	Who			When		What
-	--------	----------	----------------------------------------------
-	Name			Date		Modification logs
-	Justin P. Mattock	11/07/2010	Fix some typos.
-
-*/
-
-#include "rt_config.h"
-
-void dump_urb(struct urb *purb)
-{
-	printk(KERN_DEBUG "urb                  :0x%08lx\n", (unsigned long)purb);
-	printk(KERN_DEBUG "\tdev                   :0x%08lx\n", (unsigned long)purb->dev);
-	printk(KERN_DEBUG "\t\tdev->state          :0x%d\n", purb->dev->state);
-	printk(KERN_DEBUG "\tpipe                  :0x%08x\n", purb->pipe);
-	printk(KERN_DEBUG "\tstatus                :%d\n", purb->status);
-	printk(KERN_DEBUG "\ttransfer_flags        :0x%08x\n", purb->transfer_flags);
-	printk(KERN_DEBUG "\ttransfer_buffer       :0x%08lx\n",
-	       (unsigned long)purb->transfer_buffer);
-	printk(KERN_DEBUG "\ttransfer_buffer_length:%d\n", purb->transfer_buffer_length);
-	printk(KERN_DEBUG "\tactual_length         :%d\n", purb->actual_length);
-	printk(KERN_DEBUG "\tsetup_packet          :0x%08lx\n",
-	       (unsigned long)purb->setup_packet);
-	printk(KERN_DEBUG "\tstart_frame           :%d\n", purb->start_frame);
-	printk(KERN_DEBUG "\tnumber_of_packets     :%d\n", purb->number_of_packets);
-	printk(KERN_DEBUG "\tinterval              :%d\n", purb->interval);
-	printk(KERN_DEBUG "\terror_count           :%d\n", purb->error_count);
-	printk(KERN_DEBUG "\tcontext               :0x%08lx\n",
-	       (unsigned long)purb->context);
-	printk(KERN_DEBUG "\tcomplete              :0x%08lx\n\n",
-	       (unsigned long)purb->complete);
-}
-
-/*
-========================================================================
-Routine Description:
-    Create kernel threads & tasklets.
-
-Arguments:
-    *net_dev			Pointer to wireless net device interface
-
-Return Value:
-	NDIS_STATUS_SUCCESS
-	NDIS_STATUS_FAILURE
-
-Note:
-========================================================================
-*/
-int RtmpMgmtTaskInit(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rtmp_os_task *pTask;
-	int status;
-
-	/*
-	   Creat TimerQ Thread, We need init timerQ related structure before create the timer thread.
-	 */
-	RtmpTimerQInit(pAd);
-
-	pTask = &pAd->timerTask;
-	RtmpOSTaskInit(pTask, "RtmpTimerTask", pAd);
-	status = RtmpOSTaskAttach(pTask, RtmpTimerQThread, pTask);
-	if (status == NDIS_STATUS_FAILURE) {
-		printk(KERN_WARNING "%s: unable to start RtmpTimerQThread\n",
-		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
-		return NDIS_STATUS_FAILURE;
-	}
-
-	/* Creat MLME Thread */
-	pTask = &pAd->mlmeTask;
-	RtmpOSTaskInit(pTask, "RtmpMlmeTask", pAd);
-	status = RtmpOSTaskAttach(pTask, MlmeThread, pTask);
-	if (status == NDIS_STATUS_FAILURE) {
-		printk(KERN_WARNING "%s: unable to start MlmeThread\n",
-		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
-		return NDIS_STATUS_FAILURE;
-	}
-
-	/* Creat Command Thread */
-	pTask = &pAd->cmdQTask;
-	RtmpOSTaskInit(pTask, "RtmpCmdQTask", pAd);
-	status = RtmpOSTaskAttach(pTask, RTUSBCmdThread, pTask);
-	if (status == NDIS_STATUS_FAILURE) {
-		printk(KERN_WARNING "%s: unable to start RTUSBCmdThread\n",
-		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
-		return NDIS_STATUS_FAILURE;
-	}
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-========================================================================
-Routine Description:
-    Close kernel threads.
-
-Arguments:
-	*pAd				the raxx interface data pointer
-
-Return Value:
-    NONE
-
-Note:
-========================================================================
-*/
-void RtmpMgmtTaskExit(struct rt_rtmp_adapter *pAd)
-{
-	int ret;
-	struct rt_rtmp_os_task *pTask;
-
-	/* Sleep 50 milliseconds so pending io might finish normally */
-	RTMPusecDelay(50000);
-
-	/* We want to wait until all pending receives and sends to the */
-	/* device object. We cancel any */
-	/* irps. Wait until sends and receives have stopped. */
-	RTUSBCancelPendingIRPs(pAd);
-
-	/* We need clear timerQ related structure before exits of the timer thread. */
-	RtmpTimerQExit(pAd);
-
-	/* Terminate Mlme Thread */
-	pTask = &pAd->mlmeTask;
-	ret = RtmpOSTaskKill(pTask);
-	if (ret == NDIS_STATUS_FAILURE) {
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-					  RTMP_OS_NETDEV_GET_DEVNAME(pAd->
-								     net_dev),
-					  pTask->taskName));
-	}
-
-	/* Terminate cmdQ thread */
-	pTask = &pAd->cmdQTask;
-#ifdef KTHREAD_SUPPORT
-	if (pTask->kthread_task)
-#else
-	CHECK_PID_LEGALITY(pTask->taskPID)
-#endif
-	{
-		mb();
-		NdisAcquireSpinLock(&pAd->CmdQLock);
-		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
-		NdisReleaseSpinLock(&pAd->CmdQLock);
-		mb();
-		/*RTUSBCMDUp(pAd); */
-		ret = RtmpOSTaskKill(pTask);
-		if (ret == NDIS_STATUS_FAILURE) {
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-						  RTMP_OS_NETDEV_GET_DEVNAME
-						  (pAd->net_dev),
-						  pTask->taskName));
-		}
-		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_UNKNOWN;
-	}
-
-	/* Terminate timer thread */
-	pTask = &pAd->timerTask;
-	ret = RtmpOSTaskKill(pTask);
-	if (ret == NDIS_STATUS_FAILURE) {
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-					  RTMP_OS_NETDEV_GET_DEVNAME(pAd->
-								     net_dev),
-					  pTask->taskName));
-	}
-
-}
-
-static void rtusb_dataout_complete(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct urb *pUrb;
-	struct os_cookie *pObj;
-	struct rt_ht_tx_context *pHTTXContext;
-	u8 BulkOutPipeId;
-	int Status;
-	unsigned long IrqFlags;
-
-	pUrb = (struct urb *)data;
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-	Status = pUrb->status;
-
-	/* Store BulkOut PipeId */
-	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
-	pAd->BulkOutDataOneSecCount++;
-
-	/*DBGPRINT(RT_DEBUG_LOUD, ("Done-B(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", BulkOutPipeId, in_interrupt(), pHTTXContext->CurWritePosition, */
-	/*              pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad)); */
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-	pHTTXContext->IRPPending = FALSE;
-	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 0;
-
-	if (Status == USB_ST_NOERROR) {
-		pAd->BulkOutComplete++;
-
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-
-		pAd->Counters8023.GoodTransmits++;
-		/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
-		FREE_HTTX_RING(pAd, BulkOutPipeId, pHTTXContext);
-		/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
-
-	} else {		/* STATUS_OTHER */
-		u8 *pBuf;
-
-		pAd->BulkOutCompleteOther++;
-
-		pBuf =
-		    &pHTTXContext->TransferBuffer->field.
-		    WirelessPacket[pHTTXContext->NextBulkOutPosition];
-
-		if (!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-					  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-					  fRTMP_ADAPTER_NIC_NOT_EXIST |
-					  fRTMP_ADAPTER_BULKOUT_RESET))) {
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = BulkOutPipeId;
-			pAd->bulkResetReq[BulkOutPipeId] = pAd->BulkOutReq;
-		}
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("BulkOutDataPacket failed: ReasonCode=%d!\n",
-			      Status));
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("\t>>BulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n",
-			      pAd->BulkOutReq, pAd->BulkOutComplete,
-			      pAd->BulkOutCompleteOther));
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("\t>>BulkOut Header:%x %x %x %x %x %x %x %x\n",
-			      pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4],
-			      pBuf[5], pBuf[6], pBuf[7]));
-		/*DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther)); */
-
-	}
-
-	/* */
-	/* bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut */
-	/* bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out. */
-	/* */
-	/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
-	if ((pHTTXContext->ENextBulkOutPosition !=
-	     pHTTXContext->CurWritePosition)
-	    && (pHTTXContext->ENextBulkOutPosition !=
-		(pHTTXContext->CurWritePosition + 8))
-	    && !RTUSB_TEST_BULK_FLAG(pAd,
-				     (fRTUSB_BULK_OUT_DATA_FRAG <<
-				      BulkOutPipeId))) {
-		/* Indicate There is data available */
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
-				     BulkOutPipeId));
-	}
-	/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
-
-	/* Always call Bulk routine, even reset bulk. */
-	/* The protection of rest bulk should be in BulkOut routine */
-	RTUSBKickBulkOut(pAd);
-}
-
-static void rtusb_null_frame_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pNullContext;
-	struct urb *pUrb;
-	int Status;
-	unsigned long irqFlag;
-
-	pUrb = (struct urb *)data;
-	pNullContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pNullContext->pAd;
-	Status = pUrb->status;
-
-	/* Reset Null frame context flags */
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
-	pNullContext->IRPPending = FALSE;
-	pNullContext->InUse = FALSE;
-	pAd->BulkOutPending[0] = FALSE;
-	pAd->watchDogTxPendingCnt[0] = 0;
-
-	if (Status == USB_ST_NOERROR) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-
-		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else {		/* STATUS_OTHER */
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("Bulk Out Null Frame Failed, ReasonCode=%d!\n",
-				      Status));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid =
-			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-		}
-	}
-
-	/* Always call Bulk routine, even reset bulk. */
-	/* The protection of rest bulk should be in BulkOut routine */
-	RTUSBKickBulkOut(pAd);
-}
-
-static void rtusb_rts_frame_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pRTSContext;
-	struct urb *pUrb;
-	int Status;
-	unsigned long irqFlag;
-
-	pUrb = (struct urb *)data;
-	pRTSContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pRTSContext->pAd;
-	Status = pUrb->status;
-
-	/* Reset RTS frame context flags */
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
-	pRTSContext->IRPPending = FALSE;
-	pRTSContext->InUse = FALSE;
-
-	if (Status == USB_ST_NOERROR) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else {		/* STATUS_OTHER */
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("Bulk Out RTS Frame Failed\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid =
-			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-		}
-	}
-
-	RTMP_SEM_LOCK(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId]);
-	pAd->BulkOutPending[pRTSContext->BulkOutPipeId] = FALSE;
-	RTMP_SEM_UNLOCK(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId]);
-
-	/* Always call Bulk routine, even reset bulk. */
-	/* The protection of rest bulk should be in BulkOut routine */
-	RTUSBKickBulkOut(pAd);
-
-}
-
-static void rtusb_pspoll_frame_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pPsPollContext;
-	struct urb *pUrb;
-	int Status;
-
-	pUrb = (struct urb *)data;
-	pPsPollContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pPsPollContext->pAd;
-	Status = pUrb->status;
-
-	/* Reset PsPoll context flags */
-	pPsPollContext->IRPPending = FALSE;
-	pPsPollContext->InUse = FALSE;
-	pAd->watchDogTxPendingCnt[0] = 0;
-
-	if (Status == USB_ST_NOERROR) {
-		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else {		/* STATUS_OTHER */
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("Bulk Out PSPoll Failed\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid =
-			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		}
-	}
-
-	RTMP_SEM_LOCK(&pAd->BulkOutLock[0]);
-	pAd->BulkOutPending[0] = FALSE;
-	RTMP_SEM_UNLOCK(&pAd->BulkOutLock[0]);
-
-	/* Always call Bulk routine, even reset bulk. */
-	/* The protection of rest bulk should be in BulkOut routine */
-	RTUSBKickBulkOut(pAd);
-
-}
-
-/*
-========================================================================
-Routine Description:
-    Handle received packets.
-
-Arguments:
-	data				- URB information pointer
-
-Return Value:
-    None
-
-Note:
-========================================================================
-*/
-static void rx_done_tasklet(unsigned long data)
-{
-	struct urb *pUrb;
-	struct rt_rx_context *pRxContext;
-	struct rt_rtmp_adapter *pAd;
-	int Status;
-	unsigned int IrqFlags;
-
-	pUrb = (struct urb *)data;
-	pRxContext = (struct rt_rx_context *)pUrb->context;
-	pAd = pRxContext->pAd;
-	Status = pUrb->status;
-
-	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-	pRxContext->InUse = FALSE;
-	pRxContext->IRPPending = FALSE;
-	pRxContext->BulkInOffset += pUrb->actual_length;
-	/*NdisInterlockedDecrement(&pAd->PendingRx); */
-	pAd->PendingRx--;
-
-	if (Status == USB_ST_NOERROR) {
-		pAd->BulkInComplete++;
-		pAd->NextRxBulkInPosition = 0;
-		if (pRxContext->BulkInOffset) { /* As jan's comment, it may bulk-in success but size is zero. */
-			pRxContext->Readable = TRUE;
-			INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
-		}
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-	} else {			/* STATUS_OTHER */
-		pAd->BulkInCompleteFail++;
-		/* Still read this packet although it may comtain wrong bytes. */
-		pRxContext->Readable = FALSE;
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-		/* Parsing all packets. because after reset, the index will reset to all zero. */
-		if ((!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-					   fRTMP_ADAPTER_BULKIN_RESET |
-					   fRTMP_ADAPTER_HALT_IN_PROGRESS |
-					   fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("Bulk In Failed. Status=%d, BIIdx=0x%x, BIRIdx=0x%x, actual_length= 0x%x\n",
-				      Status, pAd->NextRxBulkInIndex,
-				      pAd->NextRxBulkInReadIndex,
-				      pRxContext->pUrb->actual_length));
-
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN,
-						NULL, 0);
-		}
-	}
-
-	ASSERT((pRxContext->InUse == pRxContext->IRPPending));
-
-	RTUSBBulkReceive(pAd);
-
-	return;
-
-}
-
-static void rtusb_mgmt_dma_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pMLMEContext;
-	int index;
-	void *pPacket;
-	struct urb *pUrb;
-	int Status;
-	unsigned long IrqFlags;
-
-	pUrb = (struct urb *)data;
-	pMLMEContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pMLMEContext->pAd;
-	Status = pUrb->status;
-	index = pMLMEContext->SelfIdx;
-
-	ASSERT((pAd->MgmtRing.TxDmaIdx == index));
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-	if (Status != USB_ST_NOERROR) {
-		/*Bulk-Out fail status handle */
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("Bulk Out MLME Failed, Status=%d!\n",
-				      Status));
-			/* TODO: How to handle about the MLMEBulkOut failed issue. Need to resend the mgmt pkt? */
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid =
-			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-		}
-	}
-
-	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-	/* Reset MLME context flags */
-	pMLMEContext->IRPPending = FALSE;
-	pMLMEContext->InUse = FALSE;
-	pMLMEContext->bWaitingBulkOut = FALSE;
-	pMLMEContext->BulkOutSize = 0;
-
-	pPacket = pAd->MgmtRing.Cell[index].pNdisPacket;
-	pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
-
-	/* Increase MgmtRing Index */
-	INC_RING_INDEX(pAd->MgmtRing.TxDmaIdx, MGMT_RING_SIZE);
-	pAd->MgmtRing.TxSwFreeIdx++;
-	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-
-	/* No-matter success or fail, we free the mgmt packet. */
-	if (pPacket)
-		RTMPFreeNdisPacket(pAd, pPacket);
-
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		/* do nothing and return directly. */
-	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET) && ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)) {	/* For Mgmt Bulk-Out failed, ignore it now. */
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-
-			/* Always call Bulk routine, even reset bulk. */
-			/* The protection of rest bulk should be in BulkOut routine */
-			if (pAd->MgmtRing.TxSwFreeIdx <
-			    MGMT_RING_SIZE
-			    /* pMLMEContext->bWaitingBulkOut == TRUE */) {
-				RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-			}
-			RTUSBKickBulkOut(pAd);
-		}
-	}
-
-}
-
-static void rtusb_ac3_dma_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_ht_tx_context *pHTTXContext;
-	u8 BulkOutPipeId = 3;
-	struct urb *pUrb;
-
-	pUrb = (struct urb *)data;
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-
-	rtusb_dataout_complete((unsigned long)pUrb);
-
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		/* do nothing and return directly. */
-	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-			    (pHTTXContext->bCurWriting == FALSE)) {
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
-						  MAX_TX_PROCESS);
-			}
-
-			RTUSB_SET_BULK_FLAG(pAd,
-					    fRTUSB_BULK_OUT_DATA_NORMAL << 3);
-			RTUSBKickBulkOut(pAd);
-		}
-	}
-
-	return;
-}
-
-static void rtusb_ac2_dma_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_ht_tx_context *pHTTXContext;
-	u8 BulkOutPipeId = 2;
-	struct urb *pUrb;
-
-	pUrb = (struct urb *)data;
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-
-	rtusb_dataout_complete((unsigned long)pUrb);
-
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		/* do nothing and return directly. */
-	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-			    (pHTTXContext->bCurWriting == FALSE)) {
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
-						  MAX_TX_PROCESS);
-			}
-
-			RTUSB_SET_BULK_FLAG(pAd,
-					    fRTUSB_BULK_OUT_DATA_NORMAL << 2);
-			RTUSBKickBulkOut(pAd);
-		}
-	}
-
-	return;
-}
-
-static void rtusb_ac1_dma_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_ht_tx_context *pHTTXContext;
-	u8 BulkOutPipeId = 1;
-	struct urb *pUrb;
-
-	pUrb = (struct urb *)data;
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-
-	rtusb_dataout_complete((unsigned long)pUrb);
-
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		/* do nothing and return directly. */
-	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-			    (pHTTXContext->bCurWriting == FALSE)) {
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
-						  MAX_TX_PROCESS);
-			}
-
-			RTUSB_SET_BULK_FLAG(pAd,
-					    fRTUSB_BULK_OUT_DATA_NORMAL << 1);
-			RTUSBKickBulkOut(pAd);
-		}
-	}
-	return;
-
-}
-
-static void rtusb_ac0_dma_done_tasklet(unsigned long data)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_ht_tx_context *pHTTXContext;
-	u8 BulkOutPipeId = 0;
-	struct urb *pUrb;
-
-	pUrb = (struct urb *)data;
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-
-	rtusb_dataout_complete((unsigned long)pUrb);
-
-	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		/* do nothing and return directly. */
-	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
-						NULL, 0);
-		} else {
-			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-			    /*  ((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-			    (pHTTXContext->bCurWriting == FALSE)) {
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
-						  MAX_TX_PROCESS);
-			}
-
-			RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL);
-			RTUSBKickBulkOut(pAd);
-		}
-	}
-
-	return;
-
-}
-
-int RtmpNetTaskInit(struct rt_rtmp_adapter *pAd)
-{
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	/* Create receive tasklet */
-	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->mgmt_dma_done_task, rtusb_mgmt_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac0_dma_done_task, rtusb_ac0_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac1_dma_done_task, rtusb_ac1_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac2_dma_done_task, rtusb_ac2_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->ac3_dma_done_task, rtusb_ac3_dma_done_tasklet,
-		     (unsigned long)pAd);
-	tasklet_init(&pObj->tbtt_task, tbtt_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->null_frame_complete_task,
-		     rtusb_null_frame_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->rts_frame_complete_task,
-		     rtusb_rts_frame_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->pspoll_frame_complete_task,
-		     rtusb_pspoll_frame_done_tasklet, (unsigned long)pAd);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-void RtmpNetTaskExit(struct rt_rtmp_adapter *pAd)
-{
-	struct os_cookie *pObj;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	tasklet_kill(&pObj->rx_done_task);
-	tasklet_kill(&pObj->mgmt_dma_done_task);
-	tasklet_kill(&pObj->ac0_dma_done_task);
-	tasklet_kill(&pObj->ac1_dma_done_task);
-	tasklet_kill(&pObj->ac2_dma_done_task);
-	tasklet_kill(&pObj->ac3_dma_done_task);
-	tasklet_kill(&pObj->tbtt_task);
-	tasklet_kill(&pObj->null_frame_complete_task);
-	tasklet_kill(&pObj->rts_frame_complete_task);
-	tasklet_kill(&pObj->pspoll_frame_complete_task);
-}
diff --git a/drivers/staging/rt2860/rtmp.h b/drivers/staging/rt2860/rtmp.h
deleted file mode 100644
index 3c31340..0000000
--- a/drivers/staging/rt2860/rtmp.h
+++ /dev/null
@@ -1,4332 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rtmp.h
-
-    Abstract:
-    Miniport generic portion header file
-
-    Revision History:
-    Who         	When          	What
-    --------    ----------    ----------------------------------------------
-    Paul Lin    	2002-08-01    	created
-    James Tan   	2002-09-06    	modified (Revise NTCRegTable)
-    John Chang  	2004-09-06    	modified for RT2600
-    Justin P. Mattock	11/07/2010	Fix some typos
-*/
-#ifndef __RTMP_H__
-#define __RTMP_H__
-
-#include "spectrum_def.h"
-#include "rtmp_dot11.h"
-#include "rtmp_chip.h"
-
-struct rt_rtmp_adapter;
-
-/*#define DBG           1 */
-
-/*#define DBG_DIAGNOSE          1 */
-
-/*+++Add by shiang for merge MiniportMMRequest() and MiniportDataMMRequest() into one function */
-#define MAX_DATAMM_RETRY	3
-#define MGMT_USE_QUEUE_FLAG	0x80
-/*---Add by shiang for merge MiniportMMRequest() and MiniportDataMMRequest() into one function */
-
-#define	MAXSEQ		(0xFFF)
-
-extern unsigned char SNAP_AIRONET[];
-extern unsigned char CISCO_OUI[];
-extern u8 BaSizeArray[4];
-
-extern u8 BROADCAST_ADDR[MAC_ADDR_LEN];
-extern u8 ZERO_MAC_ADDR[MAC_ADDR_LEN];
-extern unsigned long BIT32[32];
-extern u8 BIT8[8];
-extern char *CipherName[];
-extern char *MCSToMbps[];
-extern u8 RxwiMCSToOfdmRate[12];
-extern u8 SNAP_802_1H[6];
-extern u8 SNAP_BRIDGE_TUNNEL[6];
-extern u8 SNAP_AIRONET[8];
-extern u8 CKIP_LLC_SNAP[8];
-extern u8 EAPOL_LLC_SNAP[8];
-extern u8 EAPOL[2];
-extern u8 IPX[2];
-extern u8 APPLE_TALK[2];
-extern u8 RateIdToPlcpSignal[12];	/* see IEEE802.11a-1999 p.14 */
-extern u8 OfdmRateToRxwiMCS[];
-extern u8 OfdmSignalToRateId[16];
-extern u8 default_cwmin[4];
-extern u8 default_cwmax[4];
-extern u8 default_sta_aifsn[4];
-extern u8 MapUserPriorityToAccessCategory[8];
-
-extern u16 RateUpPER[];
-extern u16 RateDownPER[];
-extern u8 Phy11BNextRateDownward[];
-extern u8 Phy11BNextRateUpward[];
-extern u8 Phy11BGNextRateDownward[];
-extern u8 Phy11BGNextRateUpward[];
-extern u8 Phy11ANextRateDownward[];
-extern u8 Phy11ANextRateUpward[];
-extern char RssiSafeLevelForTxRate[];
-extern u8 RateIdToMbps[];
-extern u16 RateIdTo500Kbps[];
-
-extern u8 CipherSuiteWpaNoneTkip[];
-extern u8 CipherSuiteWpaNoneTkipLen;
-
-extern u8 CipherSuiteWpaNoneAes[];
-extern u8 CipherSuiteWpaNoneAesLen;
-
-extern u8 SsidIe;
-extern u8 SupRateIe;
-extern u8 ExtRateIe;
-
-extern u8 HtCapIe;
-extern u8 AddHtInfoIe;
-extern u8 NewExtChanIe;
-
-extern u8 ErpIe;
-extern u8 DsIe;
-extern u8 TimIe;
-extern u8 WpaIe;
-extern u8 Wpa2Ie;
-extern u8 IbssIe;
-extern u8 Ccx2Ie;
-extern u8 WapiIe;
-
-extern u8 WPA_OUI[];
-extern u8 RSN_OUI[];
-extern u8 WAPI_OUI[];
-extern u8 WME_INFO_ELEM[];
-extern u8 WME_PARM_ELEM[];
-extern u8 Ccx2QosInfo[];
-extern u8 Ccx2IeInfo[];
-extern u8 RALINK_OUI[];
-extern u8 PowerConstraintIE[];
-
-extern u8 RateSwitchTable[];
-extern u8 RateSwitchTable11B[];
-extern u8 RateSwitchTable11G[];
-extern u8 RateSwitchTable11BG[];
-
-extern u8 RateSwitchTable11BGN1S[];
-extern u8 RateSwitchTable11BGN2S[];
-extern u8 RateSwitchTable11BGN2SForABand[];
-extern u8 RateSwitchTable11N1S[];
-extern u8 RateSwitchTable11N2S[];
-extern u8 RateSwitchTable11N2SForABand[];
-
-extern u8 PRE_N_HT_OUI[];
-
-struct rt_rssi_sample {
-	char LastRssi0;		/* last received RSSI */
-	char LastRssi1;		/* last received RSSI */
-	char LastRssi2;		/* last received RSSI */
-	char AvgRssi0;
-	char AvgRssi1;
-	char AvgRssi2;
-	short AvgRssi0X8;
-	short AvgRssi1X8;
-	short AvgRssi2X8;
-};
-
-/* */
-/*  Queue structure and macros */
-/* */
-struct rt_queue_entry;
-
-struct rt_queue_entry {
-	struct rt_queue_entry *Next;
-};
-
-/* Queue structure */
-struct rt_queue_header {
-	struct rt_queue_entry *Head;
-	struct rt_queue_entry *Tail;
-	unsigned long Number;
-};
-
-#define InitializeQueueHeader(QueueHeader)              \
-{                                                       \
-	(QueueHeader)->Head = (QueueHeader)->Tail = NULL;   \
-	(QueueHeader)->Number = 0;                          \
-}
-
-#define RemoveHeadQueue(QueueHeader)                \
-(QueueHeader)->Head;                                \
-{                                                   \
-	struct rt_queue_entry *pNext;                             \
-	if ((QueueHeader)->Head != NULL) {				\
-		pNext = (QueueHeader)->Head->Next;          \
-		(QueueHeader)->Head->Next = NULL;		\
-		(QueueHeader)->Head = pNext;                \
-		if (pNext == NULL)                          \
-			(QueueHeader)->Tail = NULL;             \
-		(QueueHeader)->Number--;                    \
-	}												\
-}
-
-#define InsertHeadQueue(QueueHeader, QueueEntry)            \
-{                                                           \
-		((struct rt_queue_entry *)QueueEntry)->Next = (QueueHeader)->Head; \
-		(QueueHeader)->Head = (struct rt_queue_entry *)(QueueEntry);       \
-		if ((QueueHeader)->Tail == NULL)                        \
-			(QueueHeader)->Tail = (struct rt_queue_entry *)(QueueEntry);   \
-		(QueueHeader)->Number++;                                \
-}
-
-#define InsertTailQueue(QueueHeader, QueueEntry)                \
-{                                                               \
-	((struct rt_queue_entry *)QueueEntry)->Next = NULL;                    \
-	if ((QueueHeader)->Tail)                                    \
-		(QueueHeader)->Tail->Next = (struct rt_queue_entry *)(QueueEntry); \
-	else                                                        \
-		(QueueHeader)->Head = (struct rt_queue_entry *)(QueueEntry);       \
-	(QueueHeader)->Tail = (struct rt_queue_entry *)(QueueEntry);           \
-	(QueueHeader)->Number++;                                    \
-}
-
-#define InsertTailQueueAc(pAd, pEntry, QueueHeader, QueueEntry)			\
-{																		\
-	((struct rt_queue_entry *)QueueEntry)->Next = NULL;							\
-	if ((QueueHeader)->Tail)											\
-		(QueueHeader)->Tail->Next = (struct rt_queue_entry *)(QueueEntry);			\
-	else																\
-		(QueueHeader)->Head = (struct rt_queue_entry *)(QueueEntry);				\
-	(QueueHeader)->Tail = (struct rt_queue_entry *)(QueueEntry);					\
-	(QueueHeader)->Number++;											\
-}
-
-/* */
-/*  Macros for flag and ref count operations */
-/* */
-#define RTMP_SET_FLAG(_M, _F)       ((_M)->Flags |= (_F))
-#define RTMP_CLEAR_FLAG(_M, _F)     ((_M)->Flags &= ~(_F))
-#define RTMP_CLEAR_FLAGS(_M)        ((_M)->Flags = 0)
-#define RTMP_TEST_FLAG(_M, _F)      (((_M)->Flags & (_F)) != 0)
-#define RTMP_TEST_FLAGS(_M, _F)     (((_M)->Flags & (_F)) == (_F))
-/* Macro for power save flag. */
-#define RTMP_SET_PSFLAG(_M, _F)       ((_M)->PSFlags |= (_F))
-#define RTMP_CLEAR_PSFLAG(_M, _F)     ((_M)->PSFlags &= ~(_F))
-#define RTMP_CLEAR_PSFLAGS(_M)        ((_M)->PSFlags = 0)
-#define RTMP_TEST_PSFLAG(_M, _F)      (((_M)->PSFlags & (_F)) != 0)
-#define RTMP_TEST_PSFLAGS(_M, _F)     (((_M)->PSFlags & (_F)) == (_F))
-
-#define OPSTATUS_SET_FLAG(_pAd, _F)     ((_pAd)->CommonCfg.OpStatusFlags |= (_F))
-#define OPSTATUS_CLEAR_FLAG(_pAd, _F)   ((_pAd)->CommonCfg.OpStatusFlags &= ~(_F))
-#define OPSTATUS_TEST_FLAG(_pAd, _F)    (((_pAd)->CommonCfg.OpStatusFlags & (_F)) != 0)
-
-#define CLIENT_STATUS_SET_FLAG(_pEntry, _F)      ((_pEntry)->ClientStatusFlags |= (_F))
-#define CLIENT_STATUS_CLEAR_FLAG(_pEntry, _F)    ((_pEntry)->ClientStatusFlags &= ~(_F))
-#define CLIENT_STATUS_TEST_FLAG(_pEntry, _F)     (((_pEntry)->ClientStatusFlags & (_F)) != 0)
-
-#define RX_FILTER_SET_FLAG(_pAd, _F)    ((_pAd)->CommonCfg.PacketFilter |= (_F))
-#define RX_FILTER_CLEAR_FLAG(_pAd, _F)  ((_pAd)->CommonCfg.PacketFilter &= ~(_F))
-#define RX_FILTER_TEST_FLAG(_pAd, _F)   (((_pAd)->CommonCfg.PacketFilter & (_F)) != 0)
-
-#define STA_NO_SECURITY_ON(_p)          (_p->StaCfg.WepStatus == Ndis802_11EncryptionDisabled)
-#define STA_WEP_ON(_p)                  (_p->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
-#define STA_TKIP_ON(_p)                 (_p->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
-#define STA_AES_ON(_p)                  (_p->StaCfg.WepStatus == Ndis802_11Encryption3Enabled)
-
-#define STA_TGN_WIFI_ON(_p)             (_p->StaCfg.bTGnWifiTest == TRUE)
-
-#define CKIP_KP_ON(_p)				((((_p)->StaCfg.CkipFlag) & 0x10) && ((_p)->StaCfg.bCkipCmicOn == TRUE))
-#define CKIP_CMIC_ON(_p)			((((_p)->StaCfg.CkipFlag) & 0x08) && ((_p)->StaCfg.bCkipCmicOn == TRUE))
-
-#define INC_RING_INDEX(_idx, _RingSize)    \
-{                                          \
-    (_idx) = (_idx+1) % (_RingSize);       \
-}
-
-/* StaActive.SupportedHtPhy.MCSSet is copied from AP beacon.  Don't need to update here. */
-#define COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd)                                 \
-{                                                                                       \
-	_pAd->StaActive.SupportedHtPhy.ChannelWidth = _pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth;      \
-	_pAd->StaActive.SupportedHtPhy.MimoPs = _pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs;      \
-	_pAd->StaActive.SupportedHtPhy.GF = _pAd->MlmeAux.HtCapability.HtCapInfo.GF;      \
-	_pAd->StaActive.SupportedHtPhy.ShortGIfor20 = _pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20;      \
-	_pAd->StaActive.SupportedHtPhy.ShortGIfor40 = _pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40;      \
-	_pAd->StaActive.SupportedHtPhy.TxSTBC = _pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC;      \
-	_pAd->StaActive.SupportedHtPhy.RxSTBC = _pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC;      \
-	_pAd->StaActive.SupportedHtPhy.ExtChanOffset = _pAd->MlmeAux.AddHtInfo.AddHtInfo.ExtChanOffset;      \
-	_pAd->StaActive.SupportedHtPhy.RecomWidth = _pAd->MlmeAux.AddHtInfo.AddHtInfo.RecomWidth;      \
-	_pAd->StaActive.SupportedHtPhy.OperaionMode = _pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode;      \
-	_pAd->StaActive.SupportedHtPhy.NonGfPresent = _pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent;      \
-	NdisMoveMemory((_pAd)->MacTab.Content[BSSID_WCID].HTCapability.MCSSet, (_pAd)->StaActive.SupportedPhyInfo.MCSSet, sizeof(u8) * 16);\
-}
-
-#define COPY_AP_HTSETTINGS_FROM_BEACON(_pAd, _pHtCapability)                                 \
-{                                                                                       \
-	_pAd->MacTab.Content[BSSID_WCID].AMsduSize = (u8)(_pHtCapability->HtCapInfo.AMsduSize);	\
-	_pAd->MacTab.Content[BSSID_WCID].MmpsMode = (u8)(_pHtCapability->HtCapInfo.MimoPs);	\
-	_pAd->MacTab.Content[BSSID_WCID].MaxRAmpduFactor = (u8)(_pHtCapability->HtCapParm.MaxRAmpduFactor);	\
-}
-
-/* */
-/* MACRO for 32-bit PCI register read / write */
-/* */
-/* Usage : RTMP_IO_READ32( */
-/*              struct rt_rtmp_adapter *pAd, */
-/*              unsigned long Register_Offset, */
-/*              unsigned long * pValue) */
-/* */
-/*         RTMP_IO_WRITE32( */
-/*              struct rt_rtmp_adapter *pAd, */
-/*              unsigned long Register_Offset, */
-/*              unsigned long Value) */
-/* */
-
-/* */
-/* Common fragment list structure -  Identical to the scatter gather frag list structure */
-/* */
-/*#define struct rt_rtmp_sg_element         SCATTER_GATHER_ELEMENT */
-/*#define struct rt_rtmp_sg_element *PSCATTER_GATHER_ELEMENT */
-#define NIC_MAX_PHYS_BUF_COUNT              8
-
-struct rt_rtmp_sg_element {
-	void *Address;
-	unsigned long Length;
-	unsigned long *Reserved;
-};
-
-struct rt_rtmp_sg_list {
-	unsigned long NumberOfElements;
-	unsigned long *Reserved;
-	struct rt_rtmp_sg_element Elements[NIC_MAX_PHYS_BUF_COUNT];
-};
-
-/* */
-/*  Some utility macros */
-/* */
-#define GET_LNA_GAIN(_pAd)	((_pAd->LatchRfRegs.Channel <= 14) ? (_pAd->BLNAGain) : ((_pAd->LatchRfRegs.Channel <= 64) ? (_pAd->ALNAGain0) : ((_pAd->LatchRfRegs.Channel <= 128) ? (_pAd->ALNAGain1) : (_pAd->ALNAGain2))))
-
-#define INC_COUNTER64(Val)          (Val.QuadPart++)
-
-#define INFRA_ON(_p)                (OPSTATUS_TEST_FLAG(_p, fOP_STATUS_INFRA_ON))
-#define ADHOC_ON(_p)                (OPSTATUS_TEST_FLAG(_p, fOP_STATUS_ADHOC_ON))
-#define MONITOR_ON(_p)              (((_p)->StaCfg.BssType) == BSS_MONITOR)
-#define IDLE_ON(_p)                 (!INFRA_ON(_p) && !ADHOC_ON(_p))
-
-/* Check LEAP & CCKM flags */
-#define LEAP_ON(_p)                 (((_p)->StaCfg.LeapAuthMode) == CISCO_AuthModeLEAP)
-#define LEAP_CCKM_ON(_p)            ((((_p)->StaCfg.LeapAuthMode) == CISCO_AuthModeLEAP) && ((_p)->StaCfg.LeapAuthInfo.CCKM == TRUE))
-
-/* if original Ethernet frame contains no LLC/SNAP, then an extra LLC/SNAP encap is required */
-#define EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(_pBufVA, _pExtraLlcSnapEncap)		\
-{																\
-	if (((*(_pBufVA + 12) << 8) + *(_pBufVA + 13)) > 1500) {	\
-		_pExtraLlcSnapEncap = SNAP_802_1H;						\
-		if (NdisEqualMemory(IPX, _pBufVA + 12, 2) || 			\
-			NdisEqualMemory(APPLE_TALK, _pBufVA + 12, 2)) {	\
-			_pExtraLlcSnapEncap = SNAP_BRIDGE_TUNNEL;			\
-		}														\
-	}															\
-	else {				\
-		_pExtraLlcSnapEncap = NULL;								\
-	}															\
-}
-
-/* New Define for new Tx Path. */
-#define EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(_pBufVA, _pExtraLlcSnapEncap)	\
-{																\
-	if (((*(_pBufVA) << 8) + *(_pBufVA + 1)) > 1500) {		\
-		_pExtraLlcSnapEncap = SNAP_802_1H;						\
-		if (NdisEqualMemory(IPX, _pBufVA, 2) || 				\
-			NdisEqualMemory(APPLE_TALK, _pBufVA, 2)) {		\
-			_pExtraLlcSnapEncap = SNAP_BRIDGE_TUNNEL;			\
-		}														\
-	}															\
-	else {		\
-		_pExtraLlcSnapEncap = NULL;								\
-	}															\
-}
-
-#define MAKE_802_3_HEADER(_p, _pMac1, _pMac2, _pType)                   \
-{                                                                       \
-    NdisMoveMemory(_p, _pMac1, MAC_ADDR_LEN);                           \
-    NdisMoveMemory((_p + MAC_ADDR_LEN), _pMac2, MAC_ADDR_LEN);          \
-    NdisMoveMemory((_p + MAC_ADDR_LEN * 2), _pType, LENGTH_802_3_TYPE); \
-}
-
-/* if pData has no LLC/SNAP (neither RFC1042 nor Bridge tunnel), keep it that way. */
-/* else if the received frame is LLC/SNAP-encaped IPX or APPLETALK, preserve the LLC/SNAP field */
-/* else remove the LLC/SNAP field from the result Ethernet frame */
-/* Patch for WHQL only, which did not turn on Netbios but use IPX within its payload */
-/* Note: */
-/*     _pData & _DataSize may be altered (remove 8-byte LLC/SNAP) by this MACRO */
-/*     _pRemovedLLCSNAP: pointer to removed LLC/SNAP; NULL is not removed */
-#define CONVERT_TO_802_3(_p8023hdr, _pDA, _pSA, _pData, _DataSize, _pRemovedLLCSNAP)      \
-{                                                                       \
-    char LLC_Len[2];                                                    \
-									\
-    _pRemovedLLCSNAP = NULL;                                            \
-    if (NdisEqualMemory(SNAP_802_1H, _pData, 6)  ||                     \
-	NdisEqualMemory(SNAP_BRIDGE_TUNNEL, _pData, 6))	{		\
-	u8 *pProto = _pData + 6;					\
-									\
-	if ((NdisEqualMemory(IPX, pProto, 2) || NdisEqualMemory(APPLE_TALK, pProto, 2)) &&  \
-		NdisEqualMemory(SNAP_802_1H, _pData, 6))	{	\
-		LLC_Len[0] = (u8)(_DataSize / 256);			\
-		LLC_Len[1] = (u8)(_DataSize % 256);			\
-		MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, LLC_Len);	\
-	}								\
-	else	{							\
-		MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, pProto);	\
-		_pRemovedLLCSNAP = _pData;				\
-		_DataSize -= LENGTH_802_1_H;				\
-		_pData += LENGTH_802_1_H;				\
-	}								\
-    }                                                                   \
-	else	{							\
-	LLC_Len[0] = (u8)(_DataSize / 256);				\
-	LLC_Len[1] = (u8)(_DataSize % 256);				\
-	MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, LLC_Len);		\
-    }                                                                   \
-}
-
-/* Enqueue this frame to MLME engine */
-/* We need to enqueue the whole frame because MLME need to pass data type */
-/* information from 802.11 header */
-#ifdef RTMP_MAC_PCI
-#define REPORT_MGMT_FRAME_TO_MLME(_pAd, Wcid, _pFrame, _FrameSize, _Rssi0, _Rssi1, _Rssi2, _PlcpSignal)        \
-{                                                                                       \
-    u32 High32TSF, Low32TSF;                                                          \
-    RTMP_IO_READ32(_pAd, TSF_TIMER_DW1, &High32TSF);                                       \
-    RTMP_IO_READ32(_pAd, TSF_TIMER_DW0, &Low32TSF);                                        \
-    MlmeEnqueueForRecv(_pAd, Wcid, High32TSF, Low32TSF, (u8)_Rssi0, (u8)_Rssi1, (u8)_Rssi2, _FrameSize, _pFrame, (u8)_PlcpSignal);   \
-}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-#define REPORT_MGMT_FRAME_TO_MLME(_pAd, Wcid, _pFrame, _FrameSize, _Rssi0, _Rssi1, _Rssi2, _PlcpSignal)        \
-{                                                                                       \
-    u32 High32TSF = 0, Low32TSF = 0;                                                          \
-    MlmeEnqueueForRecv(_pAd, Wcid, High32TSF, Low32TSF, (u8)_Rssi0, (u8)_Rssi1, (u8)_Rssi2, _FrameSize, _pFrame, (u8)_PlcpSignal);   \
-}
-#endif /* RTMP_MAC_USB // */
-
-#define MAC_ADDR_EQUAL(pAddr1, pAddr2)           RTMPEqualMemory((void *)(pAddr1), (void *)(pAddr2), MAC_ADDR_LEN)
-#define SSID_EQUAL(ssid1, len1, ssid2, len2)    ((len1 == len2) && (RTMPEqualMemory(ssid1, ssid2, len1)))
-
-/* */
-/* Check if it is Japan W53(ch52,56,60,64) channel. */
-/* */
-#define JapanChannelCheck(channel)  ((channel == 52) || (channel == 56) || (channel == 60) || (channel == 64))
-
-#define STA_EXTRA_SETTING(_pAd)
-
-#define STA_PORT_SECURED(_pAd) \
-{ \
-	BOOLEAN	Cancelled; \
-	(_pAd)->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; \
-	NdisAcquireSpinLock(&((_pAd)->MacTabLock)); \
-	(_pAd)->MacTab.Content[BSSID_WCID].PortSecured = (_pAd)->StaCfg.PortSecured; \
-	(_pAd)->MacTab.Content[BSSID_WCID].PrivacyFilter = Ndis802_11PrivFilterAcceptAll;\
-	NdisReleaseSpinLock(&(_pAd)->MacTabLock); \
-	RTMPCancelTimer(&((_pAd)->Mlme.LinkDownTimer), &Cancelled);\
-	STA_EXTRA_SETTING(_pAd); \
-}
-
-/* */
-/*  Data buffer for DMA operation, the buffer must be contiguous physical memory */
-/*  Both DMA to / from CPU use the same structure. */
-/* */
-struct rt_rtmp_dmabuf {
-	unsigned long AllocSize;
-	void *AllocVa;		/* TxBuf virtual address */
-	dma_addr_t AllocPa;	/* TxBuf physical address */
-};
-
-/* */
-/* Control block (Descriptor) for all ring descriptor DMA operation, buffer must be */
-/* contiguous physical memory. char stored the binding Rx packet descriptor */
-/* which won't be released, driver has to wait until upper layer return the packet */
-/* before giving up this rx ring descriptor to ASIC. NDIS_BUFFER is associated pair */
-/* to describe the packet buffer. For Tx, char stored the tx packet descriptor */
-/* which driver should ACK upper layer when the tx is physically done or failed. */
-/* */
-struct rt_rtmp_dmacb {
-	unsigned long AllocSize;	/* Control block size */
-	void *AllocVa;		/* Control block virtual address */
-	dma_addr_t AllocPa;	/* Control block physical address */
-	void *pNdisPacket;
-	void *pNextNdisPacket;
-
-	struct rt_rtmp_dmabuf DmaBuf;	/* Associated DMA buffer structure */
-};
-
-struct rt_rtmp_tx_ring {
-	struct rt_rtmp_dmacb Cell[TX_RING_SIZE];
-	u32 TxCpuIdx;
-	u32 TxDmaIdx;
-	u32 TxSwFreeIdx;	/* software next free tx index */
-};
-
-struct rt_rtmp_rx_ring {
-	struct rt_rtmp_dmacb Cell[RX_RING_SIZE];
-	u32 RxCpuIdx;
-	u32 RxDmaIdx;
-	int RxSwReadIdx;	/* software next read index */
-};
-
-struct rt_rtmp_mgmt_ring {
-	struct rt_rtmp_dmacb Cell[MGMT_RING_SIZE];
-	u32 TxCpuIdx;
-	u32 TxDmaIdx;
-	u32 TxSwFreeIdx;	/* software next free tx index */
-};
-
-/* */
-/*  Statistic counter structure */
-/* */
-struct rt_counter_802_3 {
-	/* General Stats */
-	unsigned long GoodTransmits;
-	unsigned long GoodReceives;
-	unsigned long TxErrors;
-	unsigned long RxErrors;
-	unsigned long RxNoBuffer;
-
-	/* Ethernet Stats */
-	unsigned long RcvAlignmentErrors;
-	unsigned long OneCollision;
-	unsigned long MoreCollisions;
-
-};
-
-struct rt_counter_802_11 {
-	unsigned long Length;
-	LARGE_INTEGER LastTransmittedFragmentCount;
-	LARGE_INTEGER TransmittedFragmentCount;
-	LARGE_INTEGER MulticastTransmittedFrameCount;
-	LARGE_INTEGER FailedCount;
-	LARGE_INTEGER RetryCount;
-	LARGE_INTEGER MultipleRetryCount;
-	LARGE_INTEGER RTSSuccessCount;
-	LARGE_INTEGER RTSFailureCount;
-	LARGE_INTEGER ACKFailureCount;
-	LARGE_INTEGER FrameDuplicateCount;
-	LARGE_INTEGER ReceivedFragmentCount;
-	LARGE_INTEGER MulticastReceivedFrameCount;
-	LARGE_INTEGER FCSErrorCount;
-};
-
-struct rt_counter_ralink {
-	unsigned long TransmittedByteCount;	/* both successful and failure, used to calculate TX throughput */
-	unsigned long ReceivedByteCount;	/* both CRC okay and CRC error, used to calculate RX throughput */
-	unsigned long BeenDisassociatedCount;
-	unsigned long BadCQIAutoRecoveryCount;
-	unsigned long PoorCQIRoamingCount;
-	unsigned long MgmtRingFullCount;
-	unsigned long RxCountSinceLastNULL;
-	unsigned long RxCount;
-	unsigned long RxRingErrCount;
-	unsigned long KickTxCount;
-	unsigned long TxRingErrCount;
-	LARGE_INTEGER RealFcsErrCount;
-	unsigned long PendingNdisPacketCount;
-
-	unsigned long OneSecOsTxCount[NUM_OF_TX_RING];
-	unsigned long OneSecDmaDoneCount[NUM_OF_TX_RING];
-	u32 OneSecTxDoneCount;
-	unsigned long OneSecRxCount;
-	u32 OneSecTxAggregationCount;
-	u32 OneSecRxAggregationCount;
-	u32 OneSecReceivedByteCount;
-	u32 OneSecFrameDuplicateCount;
-
-	u32 OneSecTransmittedByteCount;	/* both successful and failure, used to calculate TX throughput */
-	u32 OneSecTxNoRetryOkCount;
-	u32 OneSecTxRetryOkCount;
-	u32 OneSecTxFailCount;
-	u32 OneSecFalseCCACnt;	/* CCA error count, for debug purpose, might move to global counter */
-	u32 OneSecRxOkCnt;	/* RX without error */
-	u32 OneSecRxOkDataCnt;	/* unicast-to-me DATA frame count */
-	u32 OneSecRxFcsErrCnt;	/* CRC error */
-	u32 OneSecBeaconSentCnt;
-	u32 LastOneSecTotalTxCount;	/* OneSecTxNoRetryOkCount + OneSecTxRetryOkCount + OneSecTxFailCount */
-	u32 LastOneSecRxOkDataCnt;	/* OneSecRxOkDataCnt */
-	unsigned long DuplicateRcv;
-	unsigned long TxAggCount;
-	unsigned long TxNonAggCount;
-	unsigned long TxAgg1MPDUCount;
-	unsigned long TxAgg2MPDUCount;
-	unsigned long TxAgg3MPDUCount;
-	unsigned long TxAgg4MPDUCount;
-	unsigned long TxAgg5MPDUCount;
-	unsigned long TxAgg6MPDUCount;
-	unsigned long TxAgg7MPDUCount;
-	unsigned long TxAgg8MPDUCount;
-	unsigned long TxAgg9MPDUCount;
-	unsigned long TxAgg10MPDUCount;
-	unsigned long TxAgg11MPDUCount;
-	unsigned long TxAgg12MPDUCount;
-	unsigned long TxAgg13MPDUCount;
-	unsigned long TxAgg14MPDUCount;
-	unsigned long TxAgg15MPDUCount;
-	unsigned long TxAgg16MPDUCount;
-
-	LARGE_INTEGER TransmittedOctetsInAMSDU;
-	LARGE_INTEGER TransmittedAMSDUCount;
-	LARGE_INTEGER ReceivedOctesInAMSDUCount;
-	LARGE_INTEGER ReceivedAMSDUCount;
-	LARGE_INTEGER TransmittedAMPDUCount;
-	LARGE_INTEGER TransmittedMPDUsInAMPDUCount;
-	LARGE_INTEGER TransmittedOctetsInAMPDUCount;
-	LARGE_INTEGER MPDUInReceivedAMPDUCount;
-};
-
-struct rt_counter_drs {
-	/* record each TX rate's quality. 0 is best, the bigger the worse. */
-	u16 TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-	u8 PER[MAX_STEP_OF_TX_RATE_SWITCH];
-	u8 TxRateUpPenalty;	/* extra # of second penalty due to last unstable condition */
-	unsigned long CurrTxRateStableTime;	/* # of second in current TX rate */
-	BOOLEAN fNoisyEnvironment;
-	BOOLEAN fLastSecAccordingRSSI;
-	u8 LastSecTxRateChangeAction;	/* 0: no change, 1:rate UP, 2:rate down */
-	u8 LastTimeTxRateChangeAction;	/*Keep last time value of LastSecTxRateChangeAction */
-	unsigned long LastTxOkCount;
-};
-
-/***************************************************************************
-  *	security key related data structure
-  **************************************************************************/
-struct rt_cipher_key {
-	u8 Key[16];		/* right now we implement 4 keys, 128 bits max */
-	u8 RxMic[8];		/* make alignment */
-	u8 TxMic[8];
-	u8 TxTsc[6];		/* 48bit TSC value */
-	u8 RxTsc[6];		/* 48bit TSC value */
-	u8 CipherAlg;	/* 0-none, 1:WEP64, 2:WEP128, 3:TKIP, 4:AES, 5:CKIP64, 6:CKIP128 */
-	u8 KeyLen;
-	u8 BssId[6];
-	/* Key length for each key, 0: entry is invalid */
-	u8 Type;		/* Indicate Pairwise/Group when reporting MIC error */
-};
-
-/* structure to define WPA Group Key Rekey Interval */
-struct PACKED rt_802_11_wpa_rekey {
-	unsigned long ReKeyMethod;	/* mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based */
-	unsigned long ReKeyInterval;	/* time-based: seconds, packet-based: kilo-packets */
-};
-
-#ifdef RTMP_MAC_USB
-/***************************************************************************
-  *	RTUSB I/O related data structure
-  **************************************************************************/
-struct rt_set_asic_wcid {
-	unsigned long WCID;		/* mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based */
-	unsigned long SetTid;		/* time-based: seconds, packet-based: kilo-packets */
-	unsigned long DeleteTid;	/* time-based: seconds, packet-based: kilo-packets */
-	u8 Addr[MAC_ADDR_LEN];	/* avoid in interrupt when write key */
-};
-
-struct rt_set_asic_wcid_attri {
-	unsigned long WCID;		/* mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based */
-	unsigned long Cipher;		/* ASIC Cipher definition */
-	u8 Addr[ETH_LENGTH_OF_ADDRESS];
-};
-
-/* for USB interface, avoid in interrupt when write key */
-struct rt_add_pairwise_key_entry {
-	u8 MacAddr[6];
-	u16 MacTabMatchWCID;	/* ASIC */
-	struct rt_cipher_key CipherKey;
-};
-
-/* Cipher suite type for mixed mode group cipher, P802.11i-2004 */
-typedef enum _RT_802_11_CIPHER_SUITE_TYPE {
-	Cipher_Type_NONE,
-	Cipher_Type_WEP40,
-	Cipher_Type_TKIP,
-	Cipher_Type_RSVD,
-	Cipher_Type_CCMP,
-	Cipher_Type_WEP104
-} RT_802_11_CIPHER_SUITE_TYPE, *PRT_802_11_CIPHER_SUITE_TYPE;
-#endif /* RTMP_MAC_USB // */
-
-struct rt_rogueap_entry {
-	u8 Addr[MAC_ADDR_LEN];
-	u8 ErrorCode[2];	/*00 01-Invalid authentication type */
-	/*00 02-Authentication timeout */
-	/*00 03-Challenge from AP failed */
-	/*00 04-Challenge to AP failed */
-	BOOLEAN Reported;
-};
-
-struct rt_rogueap_table {
-	u8 RogueApNr;
-	struct rt_rogueap_entry RogueApEntry[MAX_LEN_OF_BSS_TABLE];
-};
-
-/* */
-/* Cisco IAPP format */
-/* */
-struct rt_cisco_iapp_content {
-	u16 Length;		/*IAPP Length */
-	u8 MessageType;	/*IAPP type */
-	u8 FunctionCode;	/*IAPP function type */
-	u8 DestinaionMAC[MAC_ADDR_LEN];
-	u8 SourceMAC[MAC_ADDR_LEN];
-	u16 Tag;		/*Tag(element IE) - Adjacent AP report */
-	u16 TagLength;	/*Length of element not including 4 byte header */
-	u8 OUI[4];		/*0x00, 0x40, 0x96, 0x00 */
-	u8 PreviousAP[MAC_ADDR_LEN];	/*MAC Address of access point */
-	u16 Channel;
-	u16 SsidLen;
-	u8 Ssid[MAX_LEN_OF_SSID];
-	u16 Seconds;		/*Seconds that the client has been disassociated. */
-};
-
-/*
-  *	Fragment Frame structure
-  */
-struct rt_fragment_frame {
-	void *pFragPacket;
-	unsigned long RxSize;
-	u16 Sequence;
-	u16 LastFrag;
-	unsigned long Flags;		/* Some extra frame information. bit 0: LLC presented */
-};
-
-/* */
-/* Packet information for NdisQueryPacket */
-/* */
-struct rt_packet_info {
-	u32 PhysicalBufferCount;	/* Physical breaks of buffer descriptor chained */
-	u32 BufferCount;	/* Number of Buffer descriptor chained */
-	u32 TotalPacketLength;	/* Self explained */
-	char *pFirstBuffer;	/* Pointer to first buffer descriptor */
-};
-
-/* */
-/*  Arcfour Structure Added by PaulWu */
-/* */
-struct rt_arcfourcontext {
-	u32 X;
-	u32 Y;
-	u8 STATE[256];
-};
-
-/* */
-/* Tkip Key structure which RC4 key & MIC calculation */
-/* */
-struct rt_tkip_key_info {
-	u32 nBytesInM;		/* # bytes in M for MICKEY */
-	unsigned long IV16;
-	unsigned long IV32;
-	unsigned long K0;		/* for MICKEY Low */
-	unsigned long K1;		/* for MICKEY Hig */
-	unsigned long L;		/* Current state for MICKEY */
-	unsigned long R;		/* Current state for MICKEY */
-	unsigned long M;		/* Message accumulator for MICKEY */
-	u8 RC4KEY[16];
-	u8 MIC[8];
-};
-
-/* */
-/* Private / Misc data, counters for driver internal use */
-/* */
-struct rt_private {
-	u32 SystemResetCnt;	/* System reset counter */
-	u32 TxRingFullCnt;	/* Tx ring full occurrence number */
-	u32 PhyRxErrCnt;	/* PHY Rx error count, for debug purpose, might move to global counter */
-	/* Variables for WEP encryption / decryption in rtmp_wep.c */
-	u32 FCSCRC32;
-	struct rt_arcfourcontext WEPCONTEXT;
-	/* Tkip stuff */
-	struct rt_tkip_key_info Tx;
-	struct rt_tkip_key_info Rx;
-};
-
-/***************************************************************************
-  *	Channel and BBP related data structures
-  **************************************************************************/
-/* structure to tune BBP R66 (BBP TUNING) */
-struct rt_bbp_r66_tuning {
-	BOOLEAN bEnable;
-	u16 FalseCcaLowerThreshold;	/* default 100 */
-	u16 FalseCcaUpperThreshold;	/* default 512 */
-	u8 R66Delta;
-	u8 R66CurrentValue;
-	BOOLEAN R66LowerUpperSelect;	/*Before LinkUp, Used LowerBound or UpperBound as R66 value. */
-};
-
-/* structure to store channel TX power */
-struct rt_channel_tx_power {
-	u16 RemainingTimeForUse;	/*unit: sec */
-	u8 Channel;
-	char Power;
-	char Power2;
-	u8 MaxTxPwr;
-	u8 DfsReq;
-};
-
-/* structure to store 802.11j channel TX power */
-struct rt_channel_11j_tx_power {
-	u8 Channel;
-	u8 BW;		/* BW_10 or BW_20 */
-	char Power;
-	char Power2;
-	u16 RemainingTimeForUse;	/*unit: sec */
-};
-
-struct rt_soft_rx_ant_diversity {
-	u8 EvaluatePeriod;	/* 0:not evalute status, 1: evaluate status, 2: switching status */
-	u8 EvaluateStableCnt;
-	u8 Pair1PrimaryRxAnt;	/* 0:Ant-E1, 1:Ant-E2 */
-	u8 Pair1SecondaryRxAnt;	/* 0:Ant-E1, 1:Ant-E2 */
-	u8 Pair2PrimaryRxAnt;	/* 0:Ant-E3, 1:Ant-E4 */
-	u8 Pair2SecondaryRxAnt;	/* 0:Ant-E3, 1:Ant-E4 */
-	short Pair1AvgRssi[2];	/* AvgRssi[0]:E1, AvgRssi[1]:E2 */
-	short Pair2AvgRssi[2];	/* AvgRssi[0]:E3, AvgRssi[1]:E4 */
-	short Pair1LastAvgRssi;	/* */
-	short Pair2LastAvgRssi;	/* */
-	unsigned long RcvPktNumWhenEvaluate;
-	BOOLEAN FirstPktArrivedWhenEvaluate;
-	struct rt_ralink_timer RxAntDiversityTimer;
-};
-
-/***************************************************************************
-  *	structure for radar detection and channel switch
-  **************************************************************************/
-struct rt_radar_detect {
-	/*BOOLEAN           IEEE80211H;                     // 0: disable, 1: enable IEEE802.11h */
-	u8 CSCount;		/*Channel switch counter */
-	u8 CSPeriod;		/*Channel switch period (beacon count) */
-	u8 RDCount;		/*Radar detection counter */
-	u8 RDMode;		/*Radar Detection mode */
-	u8 RDDurRegion;	/*Radar detection duration region */
-	u8 BBPR16;
-	u8 BBPR17;
-	u8 BBPR18;
-	u8 BBPR21;
-	u8 BBPR22;
-	u8 BBPR64;
-	unsigned long InServiceMonitorCount;	/* unit: sec */
-	u8 DfsSessionTime;
-	BOOLEAN bFastDfs;
-	u8 ChMovingTime;
-	u8 LongPulseRadarTh;
-};
-
-typedef enum _ABGBAND_STATE_ {
-	UNKNOWN_BAND,
-	BG_BAND,
-	A_BAND,
-} ABGBAND_STATE;
-
-#ifdef RTMP_MAC_PCI
-/* Power save method control */
-typedef union _PS_CONTROL {
-	struct {
-		unsigned long EnablePSinIdle:1;	/* Enable radio off when not connected to AP. radio on only when sitesurvey, */
-		unsigned long EnableNewPS:1;	/* Enable new  Chip power save function . New method can only be applied in chip version after 2872. and PCIe. */
-		unsigned long rt30xxPowerMode:2;	/* Power Level Mode for rt30xx chip */
-		unsigned long rt30xxFollowHostASPM:1;	/* Card Follows Host's setting for rt30xx chip. */
-		unsigned long rt30xxForceASPMTest:1;	/* Force enable L1 for rt30xx chip. This has higher priority than rt30xxFollowHostASPM Mode. */
-		unsigned long rsv:26;	/* Radio Measurement Enable */
-	} field;
-	unsigned long word;
-} PS_CONTROL, *PPS_CONTROL;
-#endif /* RTMP_MAC_PCI // */
-
-/***************************************************************************
-  *	structure for MLME state machine
-  **************************************************************************/
-struct rt_mlme {
-	/* STA state machines */
-	struct rt_state_machine CntlMachine;
-	struct rt_state_machine AssocMachine;
-	struct rt_state_machine AuthMachine;
-	struct rt_state_machine AuthRspMachine;
-	struct rt_state_machine SyncMachine;
-	struct rt_state_machine WpaPskMachine;
-	struct rt_state_machine LeapMachine;
-	STATE_MACHINE_FUNC AssocFunc[ASSOC_FUNC_SIZE];
-	STATE_MACHINE_FUNC AuthFunc[AUTH_FUNC_SIZE];
-	STATE_MACHINE_FUNC AuthRspFunc[AUTH_RSP_FUNC_SIZE];
-	STATE_MACHINE_FUNC SyncFunc[SYNC_FUNC_SIZE];
-	STATE_MACHINE_FUNC ActFunc[ACT_FUNC_SIZE];
-	/* Action */
-	struct rt_state_machine ActMachine;
-
-	/* common WPA state machine */
-	struct rt_state_machine WpaMachine;
-	STATE_MACHINE_FUNC WpaFunc[WPA_FUNC_SIZE];
-
-	unsigned long ChannelQuality;	/* 0..100, Channel Quality Indication for Roaming */
-	unsigned long Now32;		/* latch the value of NdisGetSystemUpTime() */
-	unsigned long LastSendNULLpsmTime;
-
-	BOOLEAN bRunning;
-	spinlock_t TaskLock;
-	struct rt_mlme_queue Queue;
-
-	u32 ShiftReg;
-
-	struct rt_ralink_timer PeriodicTimer;
-	struct rt_ralink_timer APSDPeriodicTimer;
-	struct rt_ralink_timer LinkDownTimer;
-	struct rt_ralink_timer LinkUpTimer;
-#ifdef RTMP_MAC_PCI
-	u8 bPsPollTimerRunning;
-	struct rt_ralink_timer PsPollTimer;
-	struct rt_ralink_timer RadioOnOffTimer;
-#endif				/* RTMP_MAC_PCI // */
-	unsigned long PeriodicRound;
-	unsigned long OneSecPeriodicRound;
-
-	u8 RealRxPath;
-	BOOLEAN bLowThroughput;
-	BOOLEAN bEnableAutoAntennaCheck;
-	struct rt_ralink_timer RxAntEvalTimer;
-
-#ifdef RT30xx
-	u8 CaliBW40RfR24;
-	u8 CaliBW20RfR24;
-#endif				/* RT30xx // */
-
-#ifdef RTMP_MAC_USB
-	struct rt_ralink_timer AutoWakeupTimer;
-	BOOLEAN AutoWakeupTimerRunning;
-#endif				/* RTMP_MAC_USB // */
-};
-
-/***************************************************************************
-  *	802.11 N related data structures
-  **************************************************************************/
-struct reordering_mpdu {
-	struct reordering_mpdu *next;
-	void *pPacket;	/* converted to 802.3 frame */
-	int Sequence;		/* sequence number of MPDU */
-	BOOLEAN bAMSDU;
-};
-
-struct reordering_list {
-	struct reordering_mpdu *next;
-	int qlen;
-};
-
-struct reordering_mpdu_pool {
-	void *mem;
-	spinlock_t lock;
-	struct reordering_list freelist;
-};
-
-typedef enum _REC_BLOCKACK_STATUS {
-	Recipient_NONE = 0,
-	Recipient_USED,
-	Recipient_HandleRes,
-	Recipient_Accept
-} REC_BLOCKACK_STATUS, *PREC_BLOCKACK_STATUS;
-
-typedef enum _ORI_BLOCKACK_STATUS {
-	Originator_NONE = 0,
-	Originator_USED,
-	Originator_WaitRes,
-	Originator_Done
-} ORI_BLOCKACK_STATUS, *PORI_BLOCKACK_STATUS;
-
-struct rt_ba_ori_entry {
-	u8 Wcid;
-	u8 TID;
-	u8 BAWinSize;
-	u8 Token;
-/* Sequence is to fill every outgoing QoS DATA frame's sequence field in 802.11 header. */
-	u16 Sequence;
-	u16 TimeOutValue;
-	ORI_BLOCKACK_STATUS ORI_BA_Status;
-	struct rt_ralink_timer ORIBATimer;
-	void *pAdapter;
-};
-
-struct rt_ba_rec_entry {
-	u8 Wcid;
-	u8 TID;
-	u8 BAWinSize;	/* 7.3.1.14. each buffer is capable of holding a max AMSDU or MSDU. */
-	/*u8 NumOfRxPkt; */
-	/*u8    Curindidx; // the head in the RX reordering buffer */
-	u16 LastIndSeq;
-/*      u16          LastIndSeqAtTimer; */
-	u16 TimeOutValue;
-	struct rt_ralink_timer RECBATimer;
-	unsigned long LastIndSeqAtTimer;
-	unsigned long nDropPacket;
-	unsigned long rcvSeq;
-	REC_BLOCKACK_STATUS REC_BA_Status;
-/*      u8   RxBufIdxUsed; */
-	/* corresponding virtual address for RX reordering packet storage. */
-	/*RTMP_REORDERDMABUF MAP_RXBuf[MAX_RX_REORDERBUF]; */
-	spinlock_t RxReRingLock;	/* Rx Ring spinlock */
-/*      struct _BA_REC_ENTRY *pNext; */
-	void *pAdapter;
-	struct reordering_list list;
-};
-
-struct rt_ba_table {
-	unsigned long numAsRecipient;	/* I am recipient of numAsRecipient clients. These client are in the BARecEntry[] */
-	unsigned long numAsOriginator;	/* I am originator of   numAsOriginator clients. These clients are in the BAOriEntry[] */
-	unsigned long numDoneOriginator;	/* count Done Originator sessions */
-	struct rt_ba_ori_entry BAOriEntry[MAX_LEN_OF_BA_ORI_TABLE];
-	struct rt_ba_rec_entry BARecEntry[MAX_LEN_OF_BA_REC_TABLE];
-};
-
-/*For QureyBATableOID use; */
-struct PACKED rt_oid_ba_rec_entry {
-	u8 MACAddr[MAC_ADDR_LEN];
-	u8 BaBitmap;		/* if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize */
-	u8 rsv;
-	u8 BufSize[8];
-	REC_BLOCKACK_STATUS REC_BA_Status[8];
-};
-
-/*For QureyBATableOID use; */
-struct PACKED rt_oid_ba_ori_entry {
-	u8 MACAddr[MAC_ADDR_LEN];
-	u8 BaBitmap;		/* if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize, read ORI_BA_Status[TID] for status */
-	u8 rsv;
-	u8 BufSize[8];
-	ORI_BLOCKACK_STATUS ORI_BA_Status[8];
-};
-
-struct rt_queryba_table {
-	struct rt_oid_ba_ori_entry BAOriEntry[32];
-	struct rt_oid_ba_rec_entry BARecEntry[32];
-	u8 OriNum;		/* Number of below BAOriEntry */
-	u8 RecNum;		/* Number of below BARecEntry */
-};
-
-typedef union _BACAP_STRUC {
-	struct {
-		u32 RxBAWinLimit:8;
-		u32 TxBAWinLimit:8;
-		u32 AutoBA:1;	/* automatically BA */
-		u32 Policy:2;	/* 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use */
-		u32 MpduDensity:3;
-		u32 AmsduEnable:1;	/*Enable AMSDU transmisstion */
-		u32 AmsduSize:1;	/* 0:3839, 1:7935 bytes. u32  MSDUSizeToBytes[]        = { 3839, 7935}; */
-		u32 MMPSmode:2;	/* MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable */
-		u32 bHtAdhoc:1;	/* adhoc can use ht rate. */
-		u32 b2040CoexistScanSup:1;	/*As Sta, support do 2040 coexistence scan for AP. As Ap, support monitor trigger event to check if can use BW 40MHz. */
-		u32: 4;
-	} field;
-	u32 word;
-} BACAP_STRUC, *PBACAP_STRUC;
-
-struct rt_oid_add_ba_entry {
-	BOOLEAN IsRecipient;
-	u8 MACAddr[MAC_ADDR_LEN];
-	u8 TID;
-	u8 nMSDU;
-	u16 TimeOut;
-	BOOLEAN bAllTid;	/* If True, delete all TID for BA sessions with this MACaddr. */
-};
-
-#define IS_HT_STA(_pMacEntry)	\
-	(_pMacEntry->MaxHTPhyMode.field.MODE >= MODE_HTMIX)
-
-#define IS_HT_RATE(_pMacEntry)	\
-	(_pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
-
-#define PEER_IS_HT_RATE(_pMacEntry)	\
-	(_pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
-
-/*This structure is for all 802.11n card InterOptibilityTest action. Reset all Num every n second.  (Details see MLMEPeriodic) */
-struct rt_iot {
-	u8 Threshold[2];
-	u8 ReorderTimeOutNum[MAX_LEN_OF_BA_REC_TABLE];	/* compare with threshold[0] */
-	u8 RefreshNum[MAX_LEN_OF_BA_REC_TABLE];	/* compare with threshold[1] */
-	unsigned long OneSecInWindowCount;
-	unsigned long OneSecFrameDuplicateCount;
-	unsigned long OneSecOutWindowCount;
-	u8 DelOriAct;
-	u8 DelRecAct;
-	u8 RTSShortProt;
-	u8 RTSLongProt;
-	BOOLEAN bRTSLongProtOn;
-	BOOLEAN bLastAtheros;
-	BOOLEAN bCurrentAtheros;
-	BOOLEAN bNowAtherosBurstOn;
-	BOOLEAN bNextDisableRxBA;
-	BOOLEAN bToggle;
-};
-
-/* This is the registry setting for 802.11n transmit setting.  Used in advanced page. */
-typedef union _REG_TRANSMIT_SETTING {
-	struct {
-		/*u32  PhyMode:4; */
-		/*u32  MCS:7;                 // MCS */
-		u32 rsv0:10;
-		u32 TxBF:1;
-		u32 BW:1;	/*channel bandwidth 20MHz or 40 MHz */
-		u32 ShortGI:1;
-		u32 STBC:1;	/*SPACE */
-		u32 TRANSNO:2;
-		u32 HTMODE:1;
-		u32 EXTCHA:2;
-		u32 rsv:13;
-	} field;
-	u32 word;
-} REG_TRANSMIT_SETTING, *PREG_TRANSMIT_SETTING;
-
-typedef union _DESIRED_TRANSMIT_SETTING {
-	struct {
-		u16 MCS:7;	/* MCS */
-		u16 PhyMode:4;
-		u16 FixedTxMode:2;	/* If MCS isn't AUTO, fix rate in CCK, OFDM or HT mode. */
-		u16 rsv:3;
-	} field;
-	u16 word;
-} DESIRED_TRANSMIT_SETTING, *PDESIRED_TRANSMIT_SETTING;
-
-#ifdef RTMP_MAC_USB
-/***************************************************************************
-  *	USB-based chip Beacon related data structures
-  **************************************************************************/
-#define BEACON_BITMAP_MASK		0xff
-struct rt_beacon_sync {
-	u8 BeaconBuf[HW_BEACON_MAX_COUNT][HW_BEACON_OFFSET];
-	u8 BeaconTxWI[HW_BEACON_MAX_COUNT][TXWI_SIZE];
-	unsigned long TimIELocationInBeacon[HW_BEACON_MAX_COUNT];
-	unsigned long CapabilityInfoLocationInBeacon[HW_BEACON_MAX_COUNT];
-	BOOLEAN EnableBeacon;	/* trigger to enable beacon transmission. */
-	u8 BeaconBitMap;	/* NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter needs to change. */
-	u8 DtimBitOn;	/* NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter needs to change. */
-};
-#endif /* RTMP_MAC_USB // */
-
-/***************************************************************************
-  *	Multiple SSID related data structures
-  **************************************************************************/
-#define WLAN_MAX_NUM_OF_TIM			((MAX_LEN_OF_MAC_TABLE >> 3) + 1)	/* /8 + 1 */
-#define WLAN_CT_TIM_BCMC_OFFSET		0	/* unit: 32B */
-
-/* clear bcmc TIM bit */
-#define WLAN_MR_TIM_BCMC_CLEAR(apidx) \
-	pAd->ApCfg.MBSSID[apidx].TimBitmaps[WLAN_CT_TIM_BCMC_OFFSET] &= ~BIT8[0];
-
-/* set bcmc TIM bit */
-#define WLAN_MR_TIM_BCMC_SET(apidx) \
-	pAd->ApCfg.MBSSID[apidx].TimBitmaps[WLAN_CT_TIM_BCMC_OFFSET] |= BIT8[0];
-
-/* clear a station PS TIM bit */
-#define WLAN_MR_TIM_BIT_CLEAR(ad_p, apidx, wcid) \
-	{	u8 tim_offset = wcid >> 3; \
-		u8 bit_offset = wcid & 0x7; \
-		ad_p->ApCfg.MBSSID[apidx].TimBitmaps[tim_offset] &= (~BIT8[bit_offset]); }
-
-/* set a station PS TIM bit */
-#define WLAN_MR_TIM_BIT_SET(ad_p, apidx, wcid) \
-	{	u8 tim_offset = wcid >> 3; \
-		u8 bit_offset = wcid & 0x7; \
-		ad_p->ApCfg.MBSSID[apidx].TimBitmaps[tim_offset] |= BIT8[bit_offset]; }
-
-/* configuration common to OPMODE_AP as well as OPMODE_STA */
-struct rt_common_config {
-
-	BOOLEAN bCountryFlag;
-	u8 CountryCode[3];
-	u8 Geography;
-	u8 CountryRegion;	/* Enum of country region, 0:FCC, 1:IC, 2:ETSI, 3:SPAIN, 4:France, 5:MKK, 6:MKK1, 7:Israel */
-	u8 CountryRegionForABand;	/* Enum of country region for A band */
-	u8 PhyMode;		/* PHY_11A, PHY_11B, PHY_11BG_MIXED, PHY_ABG_MIXED */
-	u16 Dsifs;		/* in units of usec */
-	unsigned long PacketFilter;	/* Packet filter for receiving */
-	u8 RegulatoryClass;
-
-	char Ssid[MAX_LEN_OF_SSID];	/* NOT NULL-terminated */
-	u8 SsidLen;		/* the actual ssid length in used */
-	u8 LastSsidLen;	/* the actual ssid length in used */
-	char LastSsid[MAX_LEN_OF_SSID];	/* NOT NULL-terminated */
-	u8 LastBssid[MAC_ADDR_LEN];
-
-	u8 Bssid[MAC_ADDR_LEN];
-	u16 BeaconPeriod;
-	u8 Channel;
-	u8 CentralChannel;	/* Central Channel when using 40MHz is indicating. not real channel. */
-
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen;
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 ExtRateLen;
-	u8 DesireRate[MAX_LEN_OF_SUPPORTED_RATES];	/* OID_802_11_DESIRED_RATES */
-	u8 MaxDesiredRate;
-	u8 ExpectedACKRate[MAX_LEN_OF_SUPPORTED_RATES];
-
-	unsigned long BasicRateBitmap;	/* backup basic ratebitmap */
-
-	BOOLEAN bAPSDCapable;
-	BOOLEAN bInServicePeriod;
-	BOOLEAN bAPSDAC_BE;
-	BOOLEAN bAPSDAC_BK;
-	BOOLEAN bAPSDAC_VI;
-	BOOLEAN bAPSDAC_VO;
-
-	/* because TSPEC can modify the APSD flag, we need to keep the APSD flag
-	   requested in association stage from the station;
-	   we need to recover the APSD flag after the TSPEC is deleted. */
-	BOOLEAN bACMAPSDBackup[4];	/* for delivery-enabled & trigger-enabled both */
-	BOOLEAN bACMAPSDTr[4];	/* no use */
-
-	BOOLEAN bNeedSendTriggerFrame;
-	BOOLEAN bAPSDForcePowerSave;	/* Force power save mode, should only use in APSD-STAUT */
-	unsigned long TriggerTimerCount;
-	u8 MaxSPLength;
-	u8 BBPCurrentBW;	/* BW_10,       BW_20, BW_40 */
-	/* move to MULTISSID_STRUCT for MBSS */
-	/*HTTRANSMIT_SETTING    HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI. */
-	REG_TRANSMIT_SETTING RegTransmitSetting;	/*registry transmit setting. this is for reading registry setting only. not useful. */
-	/*u8       FixedTxMode;              // Fixed Tx Mode (CCK, OFDM), for HT fixed tx mode (GF, MIX) , refer to RegTransmitSetting.field.HTMode */
-	u8 TxRate;		/* Same value to fill in TXD. TxRate is 6-bit */
-	u8 MaxTxRate;	/* RATE_1, RATE_2, RATE_5_5, RATE_11 */
-	u8 TxRateIndex;	/* Tx rate index in RateSwitchTable */
-	u8 TxRateTableSize;	/* Valid Tx rate table size in RateSwitchTable */
-	/*BOOLEAN               bAutoTxRateSwitch; */
-	u8 MinTxRate;	/* RATE_1, RATE_2, RATE_5_5, RATE_11 */
-	u8 RtsRate;		/* RATE_xxx */
-	HTTRANSMIT_SETTING MlmeTransmit;	/* MGMT frame PHY rate setting when operation at Ht rate. */
-	u8 MlmeRate;		/* RATE_xxx, used to send MLME frames */
-	u8 BasicMlmeRate;	/* Default Rate for sending MLME frames */
-
-	u16 RtsThreshold;	/* in unit of BYTE */
-	u16 FragmentThreshold;	/* in unit of BYTE */
-
-	u8 TxPower;		/* in unit of mW */
-	unsigned long TxPowerPercentage;	/* 0~100 % */
-	unsigned long TxPowerDefault;	/* keep for TxPowerPercentage */
-	u8 PwrConstraint;
-
-	BACAP_STRUC BACapability;	/*   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0 */
-	BACAP_STRUC REGBACapability;	/*   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0 */
-
-	struct rt_iot IOTestParm;	/* 802.11n InterOpbility Test Parameter; */
-	unsigned long TxPreamble;	/* Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto */
-	BOOLEAN bUseZeroToDisableFragment;	/* Microsoft use 0 as disable */
-	unsigned long UseBGProtection;	/* 0: auto, 1: always use, 2: always not use */
-	BOOLEAN bUseShortSlotTime;	/* 0: disable, 1 - use short slot (9us) */
-	BOOLEAN bEnableTxBurst;	/* 1: enble TX PACKET BURST (when BA is established or AP is not a legacy WMM AP), 0: disable TX PACKET BURST */
-	BOOLEAN bAggregationCapable;	/* 1: enable TX aggregation when the peer supports it */
-	BOOLEAN bPiggyBackCapable;	/* 1: enable TX piggy-back according MAC's version */
-	BOOLEAN bIEEE80211H;	/* 1: enable IEEE802.11h spec. */
-	unsigned long DisableOLBCDetect;	/* 0: enable OLBC detect; 1 disable OLBC detect */
-
-	BOOLEAN bRdg;
-
-	BOOLEAN bWmmCapable;	/* 0:disable WMM, 1:enable WMM */
-	struct rt_qos_capability_parm APQosCapability;	/* QOS capability of the current associated AP */
-	struct rt_edca_parm APEdcaParm;	/* EDCA parameters of the current associated AP */
-	struct rt_qbss_load_parm APQbssLoad;	/* QBSS load of the current associated AP */
-	u8 AckPolicy[4];	/* ACK policy of the specified AC. see ACK_xxx */
-	BOOLEAN bDLSCapable;	/* 0:disable DLS, 1:enable DLS */
-	/* a bitmap of BOOLEAN flags. each bit represent an operation status of a particular */
-	/* BOOLEAN control, either ON or OFF. These flags should always be accessed via */
-	/* OPSTATUS_TEST_FLAG(), OPSTATUS_SET_FLAG(), OP_STATUS_CLEAR_FLAG() macros. */
-	/* see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition */
-	unsigned long OpStatusFlags;
-
-	BOOLEAN NdisRadioStateOff;	/*For HCT 12.0, set this flag to TRUE instead of called MlmeRadioOff. */
-	ABGBAND_STATE BandState;	/* For setting BBP used on B/G or A mode. */
-
-	/* IEEE802.11H--DFS. */
-	struct rt_radar_detect RadarDetect;
-
-	/* HT */
-	u8 BASize;		/* USer desired BAWindowSize. Should not exceed our max capability */
-	/*struct rt_ht_capability      SupportedHtPhy; */
-	struct rt_ht_capability DesiredHtPhy;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHTInfo;	/* Useful as AP. */
-	/*This IE is used with channel switch announcement element when changing to a new 40MHz. */
-	/*This IE is included in channel switch announcement frames 7.4.1.5, beacons, probe Rsp. */
-	struct rt_new_ext_chan_ie NewExtChanOffset;	/*7.3.2.20A, 1 if extension channel is above the control channel, 3 if below, 0 if not present */
-
-	BOOLEAN bHTProtect;
-	BOOLEAN bMIMOPSEnable;
-	BOOLEAN bBADecline;
-/*2008/11/05: KH add to support Antenna power-saving of AP<-- */
-	BOOLEAN bGreenAPEnable;
-/*2008/11/05: KH add to support Antenna power-saving of AP--> */
-	BOOLEAN bDisableReordering;
-	BOOLEAN bForty_Mhz_Intolerant;
-	BOOLEAN bExtChannelSwitchAnnouncement;
-	BOOLEAN bRcvBSSWidthTriggerEvents;
-	unsigned long LastRcvBSSWidthTriggerEventsTime;
-
-	u8 TxBASize;
-
-	/* Enable wireless event */
-	BOOLEAN bWirelessEvent;
-	BOOLEAN bWiFiTest;	/* Enable this parameter for WiFi test */
-
-	/* Tx & Rx Stream number selection */
-	u8 TxStream;
-	u8 RxStream;
-
-	BOOLEAN bHardwareRadio;	/* Hardware controlled Radio enabled */
-
-#ifdef RTMP_MAC_USB
-	BOOLEAN bMultipleIRP;	/* Multiple Bulk IN flag */
-	u8 NumOfBulkInIRP;	/* if bMultipleIRP == TRUE, NumOfBulkInIRP will be 4 otherwise be 1 */
-	struct rt_ht_capability SupportedHtPhy;
-	unsigned long MaxPktOneTxBulk;
-	u8 TxBulkFactor;
-	u8 RxBulkFactor;
-
-	BOOLEAN IsUpdateBeacon;
-	struct rt_beacon_sync *pBeaconSync;
-	struct rt_ralink_timer BeaconUpdateTimer;
-	u32 BeaconAdjust;
-	u32 BeaconFactor;
-	u32 BeaconRemain;
-#endif				/* RTMP_MAC_USB // */
-
-	spinlock_t MeasureReqTabLock;
-	struct rt_measure_req_tab *pMeasureReqTab;
-
-	spinlock_t TpcReqTabLock;
-	struct rt_tpc_req_tab *pTpcReqTab;
-
-	BOOLEAN PSPXlink;	/* 0: Disable. 1: Enable */
-
-#if defined(RT305x) || defined(RT30xx)
-	/* request by Gary, for High Power issue */
-	u8 HighPowerPatchDisabled;
-#endif
-
-	BOOLEAN HT_DisallowTKIP;	/* Restrict the encryption type in 11n HT mode */
-};
-
-/* Modified by Wu Xi-Kun 4/21/2006 */
-/* STA configuration and status */
-struct rt_sta_admin_config {
-	/* GROUP 1 - */
-	/*   User configuration loaded from Registry, E2PROM or OID_xxx. These settings describe */
-	/*   the user intended configuration, but not necessary fully equal to the final */
-	/*   settings in ACTIVE BSS after negotiation/compromise with the BSS holder (either */
-	/*   AP or IBSS holder). */
-	/*   Once initialized, user configuration can only be changed via OID_xxx */
-	u8 BssType;		/* BSS_INFRA or BSS_ADHOC */
-	u16 AtimWin;		/* used when starting a new IBSS */
-
-	/* GROUP 2 - */
-	/*   User configuration loaded from Registry, E2PROM or OID_xxx. These settings describe */
-	/*   the user intended configuration, and should be always applied to the final */
-	/*   settings in ACTIVE BSS without compromising with the BSS holder. */
-	/*   Once initialized, user configuration can only be changed via OID_xxx */
-	u8 RssiTrigger;
-	u8 RssiTriggerMode;	/* RSSI_TRIGGERED_UPON_BELOW_THRESHOLD or RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD */
-	u16 DefaultListenCount;	/* default listen count; */
-	unsigned long WindowsPowerMode;	/* Power mode for AC power */
-	unsigned long WindowsBatteryPowerMode;	/* Power mode for battery if exists */
-	BOOLEAN bWindowsACCAMEnable;	/* Enable CAM power mode when AC on */
-	BOOLEAN bAutoReconnect;	/* Set to TRUE when setting OID_802_11_SSID with no matching BSSID */
-	unsigned long WindowsPowerProfile;	/* Windows power profile, for NDIS5.1 PnP */
-
-	/* MIB:ieee802dot11.dot11smt(1).dot11StationConfigTable(1) */
-	u16 Psm;		/* power management mode   (PWR_ACTIVE|PWR_SAVE) */
-	u16 DisassocReason;
-	u8 DisassocSta[MAC_ADDR_LEN];
-	u16 DeauthReason;
-	u8 DeauthSta[MAC_ADDR_LEN];
-	u16 AuthFailReason;
-	u8 AuthFailSta[MAC_ADDR_LEN];
-
-	NDIS_802_11_PRIVACY_FILTER PrivacyFilter;	/* PrivacyFilter enum for 802.1X */
-	NDIS_802_11_AUTHENTICATION_MODE AuthMode;	/* This should match to whatever microsoft defined */
-	NDIS_802_11_WEP_STATUS WepStatus;
-	NDIS_802_11_WEP_STATUS OrigWepStatus;	/* Original wep status set from OID */
-
-	/* Add to support different cipher suite for WPA2/WPA mode */
-	NDIS_802_11_ENCRYPTION_STATUS GroupCipher;	/* Multicast cipher suite */
-	NDIS_802_11_ENCRYPTION_STATUS PairCipher;	/* Unicast cipher suite */
-	BOOLEAN bMixCipher;	/* Indicate current Pair & Group use different cipher suites */
-	u16 RsnCapability;
-
-	NDIS_802_11_WEP_STATUS GroupKeyWepStatus;
-
-	u8 WpaPassPhrase[64];	/* WPA PSK pass phrase */
-	u32 WpaPassPhraseLen;	/* the length of WPA PSK pass phrase */
-	u8 PMK[32];		/* WPA PSK mode PMK */
-	u8 PTK[64];		/* WPA PSK mode PTK */
-	u8 GTK[32];		/* GTK from authenticator */
-	struct rt_bssid_info SavedPMK[PMKID_NO];
-	u32 SavedPMKNum;	/* Saved PMKID number */
-
-	u8 DefaultKeyId;
-
-	/* WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED */
-	u8 PortSecured;
-
-	/* For WPA countermeasures */
-	unsigned long LastMicErrorTime;	/* record last MIC error time */
-	unsigned long MicErrCnt;	/* Should be 0, 1, 2, then reset to zero (after disassociation). */
-	BOOLEAN bBlockAssoc;	/* Block associate attempt for 60 seconds after counter measure occurred. */
-	/* For WPA-PSK supplicant state */
-	WPA_STATE WpaState;	/* Default is SS_NOTUSE and handled by microsoft 802.1x */
-	u8 ReplayCounter[8];
-	u8 ANonce[32];	/* ANonce for WPA-PSK from auhenticator */
-	u8 SNonce[32];	/* SNonce for WPA-PSK */
-
-	u8 LastSNR0;		/* last received BEACON's SNR */
-	u8 LastSNR1;		/* last received BEACON's SNR for 2nd  antenna */
-	struct rt_rssi_sample RssiSample;
-	unsigned long NumOfAvgRssiSample;
-
-	unsigned long LastBeaconRxTime;	/* OS's timestamp of the last BEACON RX time */
-	unsigned long Last11bBeaconRxTime;	/* OS's timestamp of the last 11B BEACON RX time */
-	unsigned long Last11gBeaconRxTime;	/* OS's timestamp of the last 11G BEACON RX time */
-	unsigned long Last20NBeaconRxTime;	/* OS's timestamp of the last 20MHz N BEACON RX time */
-
-	unsigned long LastScanTime;	/* Record last scan time for issue BSSID_SCAN_LIST */
-	unsigned long ScanCnt;		/* Scan counts since most recent SSID, BSSID, SCAN OID request */
-	BOOLEAN bSwRadio;	/* Software controlled Radio On/Off, TRUE: On */
-	BOOLEAN bHwRadio;	/* Hardware controlled Radio On/Off, TRUE: On */
-	BOOLEAN bRadio;		/* Radio state, And of Sw & Hw radio state */
-	BOOLEAN bHardwareRadio;	/* Hardware controlled Radio enabled */
-	BOOLEAN bShowHiddenSSID;	/* Show all known SSID in SSID list get operation */
-
-	/* New for WPA, windows want us to keep association information and */
-	/* Fixed IEs from last association response */
-	struct rt_ndis_802_11_association_information AssocInfo;
-	u16 ReqVarIELen;	/* Length of next VIE include EID & Length */
-	u8 ReqVarIEs[MAX_VIE_LEN];	/* The content saved here should be little-endian format. */
-	u16 ResVarIELen;	/* Length of next VIE include EID & Length */
-	u8 ResVarIEs[MAX_VIE_LEN];
-
-	u8 RSNIE_Len;
-	u8 RSN_IE[MAX_LEN_OF_RSNIE];	/* The content saved here should be little-endian format. */
-
-	unsigned long CLBusyBytes;	/* Save the total bytes received during channel load scan time */
-	u16 RPIDensity[8];	/* Array for RPI density collection */
-
-	u8 RMReqCnt;		/* Number of measurement request saved. */
-	u8 CurrentRMReqIdx;	/* Number of measurement request saved. */
-	BOOLEAN ParallelReq;	/* Parallel measurement, only one request performed, */
-	/* It must be the same channel with maximum duration */
-	u16 ParallelDuration;	/* Maximum duration for parallel measurement */
-	u8 ParallelChannel;	/* Only one channel with parallel measurement */
-	u16 IAPPToken;	/* IAPP dialog token */
-	/* Hack for channel load and noise histogram parameters */
-	u8 NHFactor;		/* Parameter for Noise histogram */
-	u8 CLFactor;		/* Parameter for channel load */
-
-	struct rt_ralink_timer StaQuickResponeForRateUpTimer;
-	BOOLEAN StaQuickResponeForRateUpTimerRunning;
-
-	u8 DtimCount;	/* 0.. DtimPeriod-1 */
-	u8 DtimPeriod;	/* default = 3 */
-
-	/*////////////////////////////////////////////////////////////////////////////////////// */
-	/* This is only for WHQL test. */
-	BOOLEAN WhqlTest;
-	/*////////////////////////////////////////////////////////////////////////////////////// */
-
-	struct rt_ralink_timer WpaDisassocAndBlockAssocTimer;
-	/* Fast Roaming */
-	BOOLEAN bAutoRoaming;	/* 0:disable auto roaming by RSSI, 1:enable auto roaming by RSSI */
-	char dBmToRoam;		/* the condition to roam when receiving Rssi less than this value. It's negative value. */
-
-	BOOLEAN IEEE8021X;
-	BOOLEAN IEEE8021x_required_keys;
-	struct rt_cipher_key DesireSharedKey[4];	/* Record user desired WEP keys */
-	u8 DesireSharedKeyId;
-
-	/* 0: driver ignores wpa_supplicant */
-	/* 1: wpa_supplicant initiates scanning and AP selection */
-	/* 2: driver takes care of scanning, AP selection, and IEEE 802.11 association parameters */
-	u8 WpaSupplicantUP;
-	u8 WpaSupplicantScanCount;
-	BOOLEAN bRSN_IE_FromWpaSupplicant;
-
-	char dev_name[16];
-	u16 OriDevType;
-
-	BOOLEAN bTGnWifiTest;
-	BOOLEAN bScanReqIsFromWebUI;
-
-	HTTRANSMIT_SETTING HTPhyMode, MaxHTPhyMode, MinHTPhyMode;	/* For transmit phy setting in TXWI. */
-	DESIRED_TRANSMIT_SETTING DesiredTransmitSetting;
-	struct rt_ht_phy_info DesiredHtPhyInfo;
-	BOOLEAN bAutoTxRateSwitch;
-
-#ifdef RTMP_MAC_PCI
-	u8 BBPR3;
-	/* PS Control has 2 meanings for advanced power save function. */
-	/* 1. EnablePSinIdle : When no connection, always radio off except need to do site survey. */
-	/* 2. EnableNewPS  : will save more current in sleep or radio off mode. */
-	PS_CONTROL PSControl;
-#endif				/* RTMP_MAC_PCI // */
-
-	BOOLEAN bAutoConnectByBssid;
-	unsigned long BeaconLostTime;	/* seconds */
-	BOOLEAN bForceTxBurst;	/* 1: force enble TX PACKET BURST, 0: disable */
-};
-
-/* This data structure keeps the current active BSS/IBSS's configuration that this STA */
-/* had agreed upon joining the network. Which means these parameters are usually decided */
-/* by the BSS/IBSS creator instead of user configuration. Data in this data structure */
-/* is valid only when either ADHOC_ON(pAd) or INFRA_ON(pAd) is TRUE. */
-/* Normally, after SCAN or failed roaming attempts, we need to recover back to */
-/* the current active settings. */
-struct rt_sta_active_config {
-	u16 Aid;
-	u16 AtimWin;		/* in kusec; IBSS parameter set element */
-	u16 CapabilityInfo;
-	u16 CfpMaxDuration;
-	u16 CfpPeriod;
-
-	/* Copy supported rate from desired AP's beacon. We are trying to match */
-	/* AP's supported and extended rate settings. */
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen;
-	u8 ExtRateLen;
-	/* Copy supported ht from desired AP's beacon. We are trying to match */
-	struct rt_ht_phy_info SupportedPhyInfo;
-	struct rt_ht_capability SupportedHtPhy;
-};
-
-struct rt_mac_table_entry;
-
-struct rt_mac_table_entry {
-	/*Choose 1 from ValidAsWDS and ValidAsCLI  to validize. */
-	BOOLEAN ValidAsCLI;	/* Sta mode, set this TRUE after Linkup,too. */
-	BOOLEAN ValidAsWDS;	/* This is WDS Entry. only for AP mode. */
-	BOOLEAN ValidAsApCli;	/* This is a AP-Client entry, only for AP mode which enable AP-Client functions. */
-	BOOLEAN ValidAsMesh;
-	BOOLEAN ValidAsDls;	/* This is DLS Entry. only for STA mode. */
-	BOOLEAN isCached;
-	BOOLEAN bIAmBadAtheros;	/* Flag if this is Atheros chip that has IOT problem.  We need to turn on RTS/CTS protection. */
-
-	u8 EnqueueEapolStartTimerRunning;	/* Enqueue EAPoL-Start for triggering EAP SM */
-	/*jan for wpa */
-	/* record which entry revoke MIC Failure, if it leaves the BSS itself, AP won't update aMICFailTime MIB */
-	u8 CMTimerRunning;
-	u8 apidx;		/* MBSS number */
-	u8 RSNIE_Len;
-	u8 RSN_IE[MAX_LEN_OF_RSNIE];
-	u8 ANonce[LEN_KEY_DESC_NONCE];
-	u8 SNonce[LEN_KEY_DESC_NONCE];
-	u8 R_Counter[LEN_KEY_DESC_REPLAY];
-	u8 PTK[64];
-	u8 ReTryCounter;
-	struct rt_ralink_timer RetryTimer;
-	struct rt_ralink_timer EnqueueStartForPSKTimer;	/* A timer which enqueue EAPoL-Start for triggering PSK SM */
-	NDIS_802_11_AUTHENTICATION_MODE AuthMode;	/* This should match to whatever microsoft defined */
-	NDIS_802_11_WEP_STATUS WepStatus;
-	NDIS_802_11_WEP_STATUS GroupKeyWepStatus;
-	AP_WPA_STATE WpaState;
-	GTK_STATE GTKState;
-	u16 PortSecured;
-	NDIS_802_11_PRIVACY_FILTER PrivacyFilter;	/* PrivacyFilter enum for 802.1X */
-	struct rt_cipher_key PairwiseKey;
-	void *pAd;
-	int PMKID_CacheIdx;
-	u8 PMKID[LEN_PMKID];
-
-	u8 Addr[MAC_ADDR_LEN];
-	u8 PsMode;
-	SST Sst;
-	AUTH_STATE AuthState;	/* for SHARED KEY authentication state machine used only */
-	BOOLEAN IsReassocSta;	/* Indicate whether this is a reassociation procedure */
-	u16 Aid;
-	u16 CapabilityInfo;
-	u8 LastRssi;
-	unsigned long NoDataIdleCount;
-	u16 StationKeepAliveCount;	/* unit: second */
-	unsigned long PsQIdleCount;
-	struct rt_queue_header PsQueue;
-
-	u32 StaConnectTime;	/* the live time of this station since associated with AP */
-
-	BOOLEAN bSendBAR;
-	u16 NoBADataCountDown;
-
-	u32 CachedBuf[16];	/* u32 (4 bytes) for alignment */
-	u32 TxBFCount;		/* 3*3 */
-	u32 FIFOCount;
-	u32 DebugFIFOCount;
-	u32 DebugTxCount;
-	BOOLEAN bDlsInit;
-
-/*==================================================== */
-/*WDS entry needs these */
-/* if ValidAsWDS==TRUE, MatchWDSTabIdx is the index in WdsTab.MacTab */
-	u32 MatchWDSTabIdx;
-	u8 MaxSupportedRate;
-	u8 CurrTxRate;
-	u8 CurrTxRateIndex;
-	/* to record the each TX rate's quality. 0 is best, the bigger the worse. */
-	u16 TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-/*      u16          OneSecTxOkCount; */
-	u32 OneSecTxNoRetryOkCount;
-	u32 OneSecTxRetryOkCount;
-	u32 OneSecTxFailCount;
-	u32 ContinueTxFailCnt;
-	u32 CurrTxRateStableTime;	/* # of second in current TX rate */
-	u8 TxRateUpPenalty;	/* extra # of second penalty due to last unstable condition */
-/*==================================================== */
-
-	BOOLEAN fNoisyEnvironment;
-	BOOLEAN fLastSecAccordingRSSI;
-	u8 LastSecTxRateChangeAction;	/* 0: no change, 1:rate UP, 2:rate down */
-	char LastTimeTxRateChangeAction;	/*Keep last time value of LastSecTxRateChangeAction */
-	unsigned long LastTxOkCount;
-	u8 PER[MAX_STEP_OF_TX_RATE_SWITCH];
-
-	/* a bitmap of BOOLEAN flags. each bit represent an operation status of a particular */
-	/* BOOLEAN control, either ON or OFF. These flags should always be accessed via */
-	/* CLIENT_STATUS_TEST_FLAG(), CLIENT_STATUS_SET_FLAG(), CLIENT_STATUS_CLEAR_FLAG() macros. */
-	/* see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition. fCLIENT_STATUS_AMSDU_INUSED */
-	unsigned long ClientStatusFlags;
-
-	HTTRANSMIT_SETTING HTPhyMode, MaxHTPhyMode, MinHTPhyMode;	/* For transmit phy setting in TXWI. */
-
-	/* HT EWC MIMO-N used parameters */
-	u16 RXBAbitmap;	/* fill to on-chip  RXWI_BA_BITMASK in 8.1.3RX attribute entry format */
-	u16 TXBAbitmap;	/* This bitmap as originator, only keep in software used to mark AMPDU bit in TXWI */
-	u16 TXAutoBAbitmap;
-	u16 BADeclineBitmap;
-	u16 BARecWcidArray[NUM_OF_TID];	/* The mapping wcid of recipient session. if RXBAbitmap bit is masked */
-	u16 BAOriWcidArray[NUM_OF_TID];	/* The mapping wcid of originator session. if TXBAbitmap bit is masked */
-	u16 BAOriSequence[NUM_OF_TID];	/* The mapping wcid of originator session. if TXBAbitmap bit is masked */
-
-	/* 802.11n features. */
-	u8 MpduDensity;
-	u8 MaxRAmpduFactor;
-	u8 AMsduSize;
-	u8 MmpsMode;		/* MIMO power save more. */
-
-	struct rt_ht_capability_ie HTCapability;
-
-	BOOLEAN bAutoTxRateSwitch;
-
-	u8 RateLen;
-	struct rt_mac_table_entry *pNext;
-	u16 TxSeq[NUM_OF_TID];
-	u16 NonQosDataSeq;
-
-	struct rt_rssi_sample RssiSample;
-
-	u32 TXMCSExpected[16];
-	u32 TXMCSSuccessful[16];
-	u32 TXMCSFailed[16];
-	u32 TXMCSAutoFallBack[16][16];
-
-	unsigned long LastBeaconRxTime;
-
-	unsigned long AssocDeadLine;
-};
-
-struct rt_mac_table {
-	u16 Size;
-	struct rt_mac_table_entry *Hash[HASH_TABLE_SIZE];
-	struct rt_mac_table_entry Content[MAX_LEN_OF_MAC_TABLE];
-	struct rt_queue_header McastPsQueue;
-	unsigned long PsQIdleCount;
-	BOOLEAN fAnyStationInPsm;
-	BOOLEAN fAnyStationBadAtheros;	/* Check if any Station is atheros 802.11n Chip.  We need to use RTS/CTS with Atheros 802,.11n chip. */
-	BOOLEAN fAnyTxOPForceDisable;	/* Check if it is necessary to disable BE TxOP */
-	BOOLEAN fAllStationAsRalink;	/* Check if all stations are ralink-chipset */
-	BOOLEAN fAnyStationIsLegacy;	/* Check if I use legacy rate to transmit to my BSS Station/ */
-	BOOLEAN fAnyStationNonGF;	/* Check if any Station can't support GF. */
-	BOOLEAN fAnyStation20Only;	/* Check if any Station can't support GF. */
-	BOOLEAN fAnyStationMIMOPSDynamic;	/* Check if any Station is MIMO Dynamic */
-	BOOLEAN fAnyBASession;	/* Check if there is BA session.  Force turn on RTS/CTS */
-/*2008/10/28: KH add to support Antenna power-saving of AP<-- */
-/*2008/10/28: KH add to support Antenna power-saving of AP--> */
-};
-
-struct wificonf {
-	BOOLEAN bShortGI;
-	BOOLEAN bGreenField;
-};
-
-struct rt_rtmp_dev_info {
-	u8 chipName[16];
-	RTMP_INF_TYPE infType;
-};
-
-struct rt_rtmp_chip_op {
-	/*  Calibration access related callback functions */
-	int (*eeinit) (struct rt_rtmp_adapter *pAd);	/* int (*eeinit)(struct rt_rtmp_adapter *pAd); */
-	int (*eeread) (struct rt_rtmp_adapter *pAd, u16 offset, u16 *pValue);	/* int (*eeread)(struct rt_rtmp_adapter *pAd, int offset, u16 *pValue); */
-
-	/* MCU related callback functions */
-	int (*loadFirmware) (struct rt_rtmp_adapter *pAd);	/* int (*loadFirmware)(struct rt_rtmp_adapter *pAd); */
-	int (*eraseFirmware) (struct rt_rtmp_adapter *pAd);	/* int (*eraseFirmware)(struct rt_rtmp_adapter *pAd); */
-	int (*sendCommandToMcu) (struct rt_rtmp_adapter *pAd, u8 cmd, u8 token, u8 arg0, u8 arg1);;	/* int (*sendCommandToMcu)(struct rt_rtmp_adapter *pAd, u8 cmd, u8 token, u8 arg0, u8 arg1); */
-
-	/* RF access related callback functions */
-	struct rt_reg_pair *pRFRegTable;
-	void (*AsicRfInit) (struct rt_rtmp_adapter *pAd);
-	void (*AsicRfTurnOn) (struct rt_rtmp_adapter *pAd);
-	void (*AsicRfTurnOff) (struct rt_rtmp_adapter *pAd);
-	void (*AsicReverseRfFromSleepMode) (struct rt_rtmp_adapter *pAd);
-	void (*AsicHaltAction) (struct rt_rtmp_adapter *pAd);
-};
-
-/* */
-/*  The miniport adapter structure */
-/* */
-struct rt_rtmp_adapter {
-	void *OS_Cookie;	/* save specific structure relative to OS */
-	struct net_device *net_dev;
-	unsigned long VirtualIfCnt;
-	const struct firmware *firmware;
-
-	struct rt_rtmp_chip_op chipOps;
-	u16 ThisTbttNumToNextWakeUp;
-
-#ifdef RTMP_MAC_PCI
-/*****************************************************************************************/
-/*      PCI related parameters																  */
-/*****************************************************************************************/
-	u8 *CSRBaseAddress;	/* PCI MMIO Base Address, all access will use */
-	unsigned int irq_num;
-
-	u16 LnkCtrlBitMask;
-	u16 RLnkCtrlConfiguration;
-	u16 RLnkCtrlOffset;
-	u16 HostLnkCtrlConfiguration;
-	u16 HostLnkCtrlOffset;
-	u16 PCIePowerSaveLevel;
-	unsigned long Rt3xxHostLinkCtrl;	/* USed for 3090F chip */
-	unsigned long Rt3xxRalinkLinkCtrl;	/* USed for 3090F chip */
-	u16 DeviceID;	/* Read from PCI config */
-	unsigned long AccessBBPFailCount;
-	BOOLEAN bPCIclkOff;	/* flag that indicates if the PICE power status in Configuration Space.. */
-	BOOLEAN bPCIclkOffDisableTx;	/* */
-
-	BOOLEAN brt30xxBanMcuCmd;	/*when = 0xff means all commands are ok to set . */
-	BOOLEAN b3090ESpecialChip;	/*3090E special chip that write EEPROM 0x24=0x9280. */
-	unsigned long CheckDmaBusyCount;	/* Check Interrupt Status Register Count. */
-
-	u32 int_enable_reg;
-	u32 int_disable_mask;
-	u32 int_pending;
-
-	struct rt_rtmp_dmabuf TxBufSpace[NUM_OF_TX_RING];	/* Shared memory of all 1st pre-allocated TxBuf associated with each TXD */
-	struct rt_rtmp_dmabuf RxDescRing;	/* Shared memory for RX descriptors */
-	struct rt_rtmp_dmabuf TxDescRing[NUM_OF_TX_RING];	/* Shared memory for Tx descriptors */
-	struct rt_rtmp_tx_ring TxRing[NUM_OF_TX_RING];	/* AC0~4 + HCCA */
-#endif				/* RTMP_MAC_PCI // */
-
-	spinlock_t irq_lock;
-	u8 irq_disabled;
-
-#ifdef RTMP_MAC_USB
-/*****************************************************************************************/
-/*      USB related parameters                                                           */
-/*****************************************************************************************/
-	struct usb_config_descriptor *config;
-	u32 BulkInEpAddr;	/* bulk-in endpoint address */
-	u32 BulkOutEpAddr[6];	/* bulk-out endpoint address */
-
-	u32 NumberOfPipes;
-	u16 BulkOutMaxPacketSize;
-	u16 BulkInMaxPacketSize;
-
-	/*======Control Flags */
-	long PendingIoCount;
-	unsigned long BulkFlags;
-	BOOLEAN bUsbTxBulkAggre;	/* Flags for bulk out data priority */
-
-	/*======Cmd Thread */
-	struct rt_cmdq CmdQ;
-	spinlock_t CmdQLock;	/* CmdQLock spinlock */
-	struct rt_rtmp_os_task cmdQTask;
-
-	/*======Semaphores (event) */
-	struct semaphore UsbVendorReq_semaphore;
-	void *UsbVendorReqBuf;
-	wait_queue_head_t *wait;
-#endif				/* RTMP_MAC_USB // */
-
-/*****************************************************************************************/
-/*      RBUS related parameters																  */
-/*****************************************************************************************/
-
-/*****************************************************************************************/
-/*      Both PCI/USB related parameters														  */
-/*****************************************************************************************/
-	/*struct rt_rtmp_dev_info                 chipInfo; */
-	RTMP_INF_TYPE infType;
-
-/*****************************************************************************************/
-/*      Driver Mgmt related parameters														  */
-/*****************************************************************************************/
-	struct rt_rtmp_os_task mlmeTask;
-#ifdef RTMP_TIMER_TASK_SUPPORT
-	/* If you want use timer task to handle the timer related jobs, enable this. */
-	struct rt_rtmp_timer_task_queue TimerQ;
-	spinlock_t TimerQLock;
-	struct rt_rtmp_os_task timerTask;
-#endif				/* RTMP_TIMER_TASK_SUPPORT // */
-
-/*****************************************************************************************/
-/*      Tx related parameters                                                           */
-/*****************************************************************************************/
-	BOOLEAN DeQueueRunning[NUM_OF_TX_RING];	/* for ensuring RTUSBDeQueuePacket get call once */
-	spinlock_t DeQueueLock[NUM_OF_TX_RING];
-
-#ifdef RTMP_MAC_USB
-	/* Data related context and AC specified, 4 AC supported */
-	spinlock_t BulkOutLock[6];	/* BulkOut spinlock for 4 ACs */
-	spinlock_t MLMEBulkOutLock;	/* MLME BulkOut lock */
-
-	struct rt_ht_tx_context TxContext[NUM_OF_TX_RING];
-	spinlock_t TxContextQueueLock[NUM_OF_TX_RING];	/* TxContextQueue spinlock */
-
-	/* 4 sets of Bulk Out index and pending flag */
-	u8 NextBulkOutIndex[4];	/* only used for 4 EDCA bulkout pipe */
-
-	BOOLEAN BulkOutPending[6];	/* used for total 6 bulkout pipe */
-	u8 bulkResetPipeid;
-	BOOLEAN MgmtBulkPending;
-	unsigned long bulkResetReq[6];
-#endif				/* RTMP_MAC_USB // */
-
-	/* resource for software backlog queues */
-	struct rt_queue_header TxSwQueue[NUM_OF_TX_RING];	/* 4 AC + 1 HCCA */
-	spinlock_t TxSwQueueLock[NUM_OF_TX_RING];	/* TxSwQueue spinlock */
-
-	struct rt_rtmp_dmabuf MgmtDescRing;	/* Shared memory for MGMT descriptors */
-	struct rt_rtmp_mgmt_ring MgmtRing;
-	spinlock_t MgmtRingLock;	/* Prio Ring spinlock */
-
-/*****************************************************************************************/
-/*      Rx related parameters                                                           */
-/*****************************************************************************************/
-
-#ifdef RTMP_MAC_PCI
-	struct rt_rtmp_rx_ring RxRing;
-	spinlock_t RxRingLock;	/* Rx Ring spinlock */
-#ifdef RT3090
-	spinlock_t McuCmdLock;	/*MCU Command Queue spinlock */
-#endif				/* RT3090 // */
-#endif				/* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-	struct rt_rx_context RxContext[RX_RING_SIZE];	/* 1 for redundant multiple IRP bulk in. */
-	spinlock_t BulkInLock;	/* BulkIn spinlock for 4 ACs */
-	u8 PendingRx;	/* The Maximum pending Rx value should be       RX_RING_SIZE. */
-	u8 NextRxBulkInIndex;	/* Indicate the current RxContext Index which hold by Host controller. */
-	u8 NextRxBulkInReadIndex;	/* Indicate the current RxContext Index which driver can read & process it. */
-	unsigned long NextRxBulkInPosition;	/* Want to contatenate 2 URB buffer while 1st is bulkin failed URB. This Position is 1st URB TransferLength. */
-	unsigned long TransferBufferLength;	/* current length of the packet buffer */
-	unsigned long ReadPosition;	/* current read position in a packet buffer */
-#endif				/* RTMP_MAC_USB // */
-
-/*****************************************************************************************/
-/*      ASIC related parameters                                                          */
-/*****************************************************************************************/
-	u32 MACVersion;	/* MAC version. Record rt2860C(0x28600100) or rt2860D (0x28600101).. */
-
-	/* --------------------------- */
-	/* E2PROM */
-	/* --------------------------- */
-	unsigned long EepromVersion;	/* byte 0: version, byte 1: revision, byte 2~3: unused */
-	unsigned long FirmwareVersion;	/* byte 0: Minor version, byte 1: Major version, otherwise unused. */
-	u16 EEPROMDefaultValue[NUM_EEPROM_BBP_PARMS];
-	u8 EEPROMAddressNum;	/* 93c46=6  93c66=8 */
-	BOOLEAN EepromAccess;
-	u8 EFuseTag;
-
-	/* --------------------------- */
-	/* BBP Control */
-	/* --------------------------- */
-	u8 BbpWriteLatch[140];	/* record last BBP register value written via BBP_IO_WRITE/BBP_IO_WRITE_VY_REG_ID */
-	char BbpRssiToDbmDelta;	/* change from u8 to char for high power */
-	struct rt_bbp_r66_tuning BbpTuning;
-
-	/* ---------------------------- */
-	/* RFIC control */
-	/* ---------------------------- */
-	u8 RfIcType;		/* RFIC_xxx */
-	unsigned long RfFreqOffset;	/* Frequency offset for channel switching */
-	struct rt_rtmp_rf_regs LatchRfRegs;	/* latch the latest RF programming value since RF IC doesn't support READ */
-
-	EEPROM_ANTENNA_STRUC Antenna;	/* Since Antenna definition is different for a & g. We need to save it for future reference. */
-	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
-
-	/* This soft Rx Antenna Diversity mechanism is used only when user set */
-	/* RX Antenna = DIVERSITY ON */
-	struct rt_soft_rx_ant_diversity RxAnt;
-
-	u8 RFProgSeq;
-	struct rt_channel_tx_power TxPower[MAX_NUM_OF_CHANNELS];	/* Store Tx power value for all channels. */
-	struct rt_channel_tx_power ChannelList[MAX_NUM_OF_CHANNELS];	/* list all supported channels for site survey */
-	struct rt_channel_11j_tx_power TxPower11J[MAX_NUM_OF_11JCHANNELS];	/* 802.11j channel and bw */
-	struct rt_channel_11j_tx_power ChannelList11J[MAX_NUM_OF_11JCHANNELS];	/* list all supported channels for site survey */
-
-	u8 ChannelListNum;	/* number of channel in ChannelList[] */
-	u8 Bbp94;
-	BOOLEAN BbpForCCK;
-	unsigned long Tx20MPwrCfgABand[5];
-	unsigned long Tx20MPwrCfgGBand[5];
-	unsigned long Tx40MPwrCfgABand[5];
-	unsigned long Tx40MPwrCfgGBand[5];
-
-	BOOLEAN bAutoTxAgcA;	/* Enable driver auto Tx Agc control */
-	u8 TssiRefA;		/* Store Tssi reference value as 25 temperature. */
-	u8 TssiPlusBoundaryA[5];	/* Tssi boundary for increase Tx power to compensate. */
-	u8 TssiMinusBoundaryA[5];	/* Tssi boundary for decrease Tx power to compensate. */
-	u8 TxAgcStepA;	/* Store Tx TSSI delta increment / decrement value */
-	char TxAgcCompensateA;	/* Store the compensation (TxAgcStep * (idx-1)) */
-
-	BOOLEAN bAutoTxAgcG;	/* Enable driver auto Tx Agc control */
-	u8 TssiRefG;		/* Store Tssi reference value as 25 temperature. */
-	u8 TssiPlusBoundaryG[5];	/* Tssi boundary for increase Tx power to compensate. */
-	u8 TssiMinusBoundaryG[5];	/* Tssi boundary for decrease Tx power to compensate. */
-	u8 TxAgcStepG;	/* Store Tx TSSI delta increment / decrement value */
-	char TxAgcCompensateG;	/* Store the compensation (TxAgcStep * (idx-1)) */
-
-	char BGRssiOffset0;	/* Store B/G RSSI#0 Offset value on EEPROM 0x46h */
-	char BGRssiOffset1;	/* Store B/G RSSI#1 Offset value */
-	char BGRssiOffset2;	/* Store B/G RSSI#2 Offset value */
-
-	char ARssiOffset0;	/* Store A RSSI#0 Offset value on EEPROM 0x4Ah */
-	char ARssiOffset1;	/* Store A RSSI#1 Offset value */
-	char ARssiOffset2;	/* Store A RSSI#2 Offset value */
-
-	char BLNAGain;		/* Store B/G external LNA#0 value on EEPROM 0x44h */
-	char ALNAGain0;		/* Store A external LNA#0 value for ch36~64 */
-	char ALNAGain1;		/* Store A external LNA#1 value for ch100~128 */
-	char ALNAGain2;		/* Store A external LNA#2 value for ch132~165 */
-#ifdef RT30xx
-	/* for 3572 */
-	u8 Bbp25;
-	u8 Bbp26;
-
-	u8 TxMixerGain24G;	/* Tx mixer gain value from EEPROM to improve Tx EVM / Tx DAC, 2.4G */
-	u8 TxMixerGain5G;
-#endif				/* RT30xx // */
-	/* ---------------------------- */
-	/* LED control */
-	/* ---------------------------- */
-	MCU_LEDCS_STRUC LedCntl;
-	u16 Led1;		/* read from EEPROM 0x3c */
-	u16 Led2;		/* EEPROM 0x3e */
-	u16 Led3;		/* EEPROM 0x40 */
-	u8 LedIndicatorStrength;
-	u8 RssiSingalstrengthOffet;
-	BOOLEAN bLedOnScanning;
-	u8 LedStatus;
-
-/*****************************************************************************************/
-/*      802.11 related parameters                                                        */
-/*****************************************************************************************/
-	/* outgoing BEACON frame buffer and corresponding TXD */
-	struct rt_txwi BeaconTxWI;
-	u8 *BeaconBuf;
-	u16 BeaconOffset[HW_BEACON_MAX_COUNT];
-
-	/* pre-build PS-POLL and NULL frame upon link up. for efficiency purpose. */
-	struct rt_pspoll_frame PsPollFrame;
-	struct rt_header_802_11 NullFrame;
-
-#ifdef RTMP_MAC_USB
-	struct rt_tx_context BeaconContext[BEACON_RING_SIZE];
-	struct rt_tx_context NullContext;
-	struct rt_tx_context PsPollContext;
-	struct rt_tx_context RTSContext;
-#endif				/* RTMP_MAC_USB // */
-
-/*=========AP=========== */
-
-/*=======STA=========== */
-	/* ----------------------------------------------- */
-	/* STA specific configuration & operation status */
-	/* used only when pAd->OpMode == OPMODE_STA */
-	/* ----------------------------------------------- */
-	struct rt_sta_admin_config StaCfg;	/* user desired settings */
-	struct rt_sta_active_config StaActive;	/* valid only when ADHOC_ON(pAd) || INFRA_ON(pAd) */
-	char nickname[IW_ESSID_MAX_SIZE + 1];	/* nickname, only used in the iwconfig i/f */
-	int PreMediaState;
-
-/*=======Common=========== */
-	/* OP mode: either AP or STA */
-	u8 OpMode;		/* OPMODE_STA, OPMODE_AP */
-
-	int IndicateMediaState;	/* Base on Indication state, default is NdisMediaStateDisConnected */
-
-	/* MAT related parameters */
-
-	/* configuration: read from Registry & E2PROM */
-	BOOLEAN bLocalAdminMAC;	/* Use user changed MAC */
-	u8 PermanentAddress[MAC_ADDR_LEN];	/* Factory default MAC address */
-	u8 CurrentAddress[MAC_ADDR_LEN];	/* User changed MAC address */
-
-	/* ------------------------------------------------------ */
-	/* common configuration to both OPMODE_STA and OPMODE_AP */
-	/* ------------------------------------------------------ */
-	struct rt_common_config CommonCfg;
-	struct rt_mlme Mlme;
-
-	/* AP needs those variables for site survey feature. */
-	struct rt_mlme_aux MlmeAux;	/* temporary settings used during MLME state machine */
-	struct rt_bss_table ScanTab;	/* store the latest SCAN result */
-
-	/*About MacTab, the sta driver will use #0 and #1 for multicast and AP. */
-	struct rt_mac_table MacTab;	/* ASIC on-chip WCID entry table.  At TX, ASIC always use key according to this on-chip table. */
-	spinlock_t MacTabLock;
-
-	struct rt_ba_table BATable;
-
-	spinlock_t BATabLock;
-	struct rt_ralink_timer RECBATimer;
-
-	/* encryption/decryption KEY tables */
-	struct rt_cipher_key SharedKey[MAX_MBSSID_NUM][4];	/* STA always use SharedKey[BSS0][0..3] */
-
-	/* RX re-assembly buffer for fragmentation */
-	struct rt_fragment_frame FragFrame;	/* Frame storage for fragment frame */
-
-	/* various Counters */
-	struct rt_counter_802_3 Counters8023;	/* 802.3 counters */
-	struct rt_counter_802_11 WlanCounters;	/* 802.11 MIB counters */
-	struct rt_counter_ralink RalinkCounters;	/* Ralink proprietary counters */
-	struct rt_counter_drs DrsCounters;	/* counters for Dynamic TX Rate Switching */
-	struct rt_private PrivateInfo;	/* Private information & counters */
-
-	/* flags, see fRTMP_ADAPTER_xxx flags */
-	unsigned long Flags;		/* Represent current device status */
-	unsigned long PSFlags;		/* Power Save operation flag. */
-
-	/* current TX sequence # */
-	u16 Sequence;
-
-	/* Control disconnect / connect event generation */
-	/*+++Not used anymore */
-	unsigned long LinkDownTime;
-	/*--- */
-	unsigned long LastRxRate;
-	unsigned long LastTxRate;
-	/*+++Used only for Station */
-	BOOLEAN bConfigChanged;	/* Config Change flag for the same SSID setting */
-	/*--- */
-
-	unsigned long ExtraInfo;	/* Extra information for displaying status */
-	unsigned long SystemErrorBitmap;	/* b0: E2PROM version error */
-
-	/*+++Not used anymore */
-	unsigned long MacIcVersion;	/* MAC/BBP serial interface issue solved after ver.D */
-	/*--- */
-
-	/* --------------------------- */
-	/* System event log */
-	/* --------------------------- */
-	struct rt_802_11_event_table EventTab;
-
-	BOOLEAN HTCEnable;
-
-	/*****************************************************************************************/
-	/*      Statistic related parameters                                                     */
-	/*****************************************************************************************/
-#ifdef RTMP_MAC_USB
-	unsigned long BulkOutDataOneSecCount;
-	unsigned long BulkInDataOneSecCount;
-	unsigned long BulkLastOneSecCount;	/* BulkOutDataOneSecCount + BulkInDataOneSecCount */
-	unsigned long watchDogRxCnt;
-	unsigned long watchDogRxOverFlowCnt;
-	unsigned long watchDogTxPendingCnt[NUM_OF_TX_RING];
-	int TransferedLength[NUM_OF_TX_RING];
-#endif				/* RTMP_MAC_USB // */
-
-	BOOLEAN bUpdateBcnCntDone;
-	unsigned long watchDogMacDeadlock;	/* prevent MAC/BBP into deadlock condition */
-	/* ---------------------------- */
-	/* DEBUG paramerts */
-	/* ---------------------------- */
-	/*unsigned long         DebugSetting[4]; */
-	BOOLEAN bBanAllBaSetup;
-	BOOLEAN bPromiscuous;
-
-	/* ---------------------------- */
-	/* rt2860c emulation-use Parameters */
-	/* ---------------------------- */
-	/*unsigned long         rtsaccu[30]; */
-	/*unsigned long         ctsaccu[30]; */
-	/*unsigned long         cfendaccu[30]; */
-	/*unsigned long         bacontent[16]; */
-	/*unsigned long         rxint[RX_RING_SIZE+1]; */
-	/*u8         rcvba[60]; */
-	BOOLEAN bLinkAdapt;
-	BOOLEAN bForcePrintTX;
-	BOOLEAN bForcePrintRX;
-	/*BOOLEAN               bDisablescanning;               //defined in RT2870 USB */
-	BOOLEAN bStaFifoTest;
-	BOOLEAN bProtectionTest;
-	BOOLEAN bBroadComHT;
-	/*+++Following add from RT2870 USB. */
-	unsigned long BulkOutReq;
-	unsigned long BulkOutComplete;
-	unsigned long BulkOutCompleteOther;
-	unsigned long BulkOutCompleteCancel;	/* seems not used now? */
-	unsigned long BulkInReq;
-	unsigned long BulkInComplete;
-	unsigned long BulkInCompleteFail;
-	/*--- */
-
-	struct wificonf WIFItestbed;
-
-	struct reordering_mpdu_pool mpdu_blk_pool;
-
-	unsigned long OneSecondnonBEpackets;	/* record non BE packets per second */
-
-#ifdef LINUX
-	struct iw_statistics iw_stats;
-
-	struct net_device_stats stats;
-#endif				/* LINUX // */
-
-	unsigned long TbttTickCount;
-#ifdef PCI_MSI_SUPPORT
-	BOOLEAN HaveMsi;
-#endif				/* PCI_MSI_SUPPORT // */
-
-	u8 is_on;
-
-#define TIME_BASE			(1000000/OS_HZ)
-#define TIME_ONE_SECOND		(1000000/TIME_BASE)
-	u8 flg_be_adjust;
-	unsigned long be_adjust_last_time;
-
-	u8 FlgCtsEnabled;
-	u8 PM_FlgSuspend;
-
-#ifdef RT30xx
-#ifdef RTMP_EFUSE_SUPPORT
-	BOOLEAN bUseEfuse;
-	u8 EEPROMImage[1024];
-#endif				/* RTMP_EFUSE_SUPPORT // */
-#endif				/* RT30xx // */
-};
-
-#define DELAYINTMASK		0x0003fffb
-#define INTMASK				0x0003fffb
-#define IndMask				0x0003fffc
-#define RxINT				0x00000005	/* Delayed Rx or indivi rx */
-#define TxDataInt			0x000000fa	/* Delayed Tx or indivi tx */
-#define TxMgmtInt			0x00000102	/* Delayed Tx or indivi tx */
-#define TxCoherent			0x00020000	/* tx coherent */
-#define RxCoherent			0x00010000	/* rx coherent */
-#define McuCommand			0x00000200	/* mcu */
-#define PreTBTTInt			0x00001000	/* Pre-TBTT interrupt */
-#define TBTTInt				0x00000800	/* TBTT interrupt */
-#define GPTimeOutInt			0x00008000	/* GPtimeout interrupt */
-#define AutoWakeupInt		0x00004000	/* AutoWakeupInt interrupt */
-#define FifoStaFullInt			0x00002000	/*  fifo statistics full interrupt */
-
-/***************************************************************************
-  *	Rx Path software control block related data structures
-  **************************************************************************/
-struct rt_rx_blk {
-	RT28XX_RXD_STRUC RxD;
-	struct rt_rxwi *pRxWI;
-	struct rt_header_802_11 *pHeader;
-	void *pRxPacket;
-	u8 *pData;
-	u16 DataSize;
-	u16 Flags;
-	u8 UserPriority;	/* for calculate TKIP MIC using */
-};
-
-#define RX_BLK_SET_FLAG(_pRxBlk, _flag)		(_pRxBlk->Flags |= _flag)
-#define RX_BLK_TEST_FLAG(_pRxBlk, _flag)	(_pRxBlk->Flags & _flag)
-#define RX_BLK_CLEAR_FLAG(_pRxBlk, _flag)	(_pRxBlk->Flags &= ~(_flag))
-
-#define fRX_WDS			0x0001
-#define fRX_AMSDU       0x0002
-#define fRX_ARALINK     0x0004
-#define fRX_HTC         0x0008
-#define fRX_PAD         0x0010
-#define fRX_AMPDU       0x0020
-#define fRX_QOS			0x0040
-#define fRX_INFRA		0x0080
-#define fRX_EAP			0x0100
-#define fRX_MESH		0x0200
-#define fRX_APCLI		0x0400
-#define fRX_DLS			0x0800
-#define fRX_WPI			0x1000
-
-#define LENGTH_AMSDU_SUBFRAMEHEAD	14
-#define LENGTH_ARALINK_SUBFRAMEHEAD	14
-#define LENGTH_ARALINK_HEADER_FIELD	 2
-
-/***************************************************************************
-  *	Tx Path software control block related data structures
-  **************************************************************************/
-#define TX_UNKOWN_FRAME			0x00
-#define TX_MCAST_FRAME			0x01
-#define TX_LEGACY_FRAME			0x02
-#define TX_AMPDU_FRAME			0x04
-#define TX_AMSDU_FRAME			0x08
-#define TX_RALINK_FRAME			0x10
-#define TX_FRAG_FRAME			0x20
-
-/*      Currently the sizeof(struct rt_tx_blk) is 148 bytes. */
-struct rt_tx_blk {
-	u8 QueIdx;
-	u8 TxFrameType;	/* Indicate the Transmission type of the all frames in one batch */
-	u8 TotalFrameNum;	/* Total frame number that wants to send-out in one batch */
-	u16 TotalFragNum;	/* Total frame fragments required in one batch */
-	u16 TotalFrameLen;	/* Total length of all frames that wants to send-out in one batch */
-
-	struct rt_queue_header TxPacketList;
-	struct rt_mac_table_entry *pMacEntry;	/* NULL: packet with 802.11 RA field is multicast/broadcast address */
-	HTTRANSMIT_SETTING *pTransmit;
-
-	/* Following structure used for the characteristics of a specific packet. */
-	void *pPacket;
-	u8 *pSrcBufHeader;	/* Reference to the head of sk_buff->data */
-	u8 *pSrcBufData;	/* Reference to the sk_buff->data, will change depending on the handling progresss */
-	u32 SrcBufLen;		/* Length of packet payload which not including Layer 2 header */
-	u8 *pExtraLlcSnapEncap;	/* NULL means no extra LLC/SNAP is required */
-	u8 HeaderBuf[128];	/* TempBuffer for TX_INFO + TX_WI + 802.11 Header + padding + AMSDU SubHeader + LLC/SNAP */
-	/*RT2870 2.1.0.0 uses only 80 bytes */
-	/*RT3070 2.1.1.0 uses only 96 bytes */
-	/*RT3090 2.1.0.0 uses only 96 bytes */
-	u8 MpduHeaderLen;	/* 802.11 header length NOT including the padding */
-	u8 HdrPadLen;	/* recording Header Padding Length; */
-	u8 apidx;		/* The interface associated to this packet */
-	u8 Wcid;		/* The MAC entry associated to this packet */
-	u8 UserPriority;	/* priority class of packet */
-	u8 FrameGap;		/* what kind of IFS does this packet use */
-	u8 MpduReqNum;	/* number of fragments of this frame */
-	u8 TxRate;		/* TODO: Obsoleted? Should change to MCS? */
-	u8 CipherAlg;	/* cipher alogrithm */
-	struct rt_cipher_key *pKey;
-
-	u16 Flags;		/*See following definitions for detail. */
-
-	/*YOU SHOULD NOT TOUCH IT! Following parameters are used for hardware-depended layer. */
-	unsigned long Priv;		/* Hardware specific value saved in here. */
-};
-
-#define fTX_bRtsRequired	0x0001	/* Indicate if need send RTS frame for protection. Not used in RT2860/RT2870. */
-#define fTX_bAckRequired	0x0002	/* the packet need ack response */
-#define fTX_bPiggyBack		0x0004	/* Legacy device use Piggback or not */
-#define fTX_bHTRate		0x0008	/* allow to use HT rate */
-#define fTX_bForceNonQoS	0x0010	/* force to transmit frame without WMM-QoS in HT mode */
-#define fTX_bAllowFrag		0x0020	/* allow to fragment the packet, A-MPDU, A-MSDU, A-Ralink is not allowed to fragment */
-#define fTX_bMoreData		0x0040	/* there are more data packets in PowerSave Queue */
-#define fTX_bWMM		0x0080	/* QOS Data */
-#define fTX_bClearEAPFrame	0x0100
-
-#define TX_BLK_SET_FLAG(_pTxBlk, _flag)		(_pTxBlk->Flags |= _flag)
-#define TX_BLK_TEST_FLAG(_pTxBlk, _flag)	(((_pTxBlk->Flags & _flag) == _flag) ? 1 : 0)
-#define TX_BLK_CLEAR_FLAG(_pTxBlk, _flag)	(_pTxBlk->Flags &= ~(_flag))
-
-/***************************************************************************
-  *	Other static inline function definitions
-  **************************************************************************/
-static inline void ConvertMulticastIP2MAC(u8 *pIpAddr,
-					  u8 **ppMacAddr,
-					  u16 ProtoType)
-{
-	if (pIpAddr == NULL)
-		return;
-
-	if (ppMacAddr == NULL || *ppMacAddr == NULL)
-		return;
-
-	switch (ProtoType) {
-	case ETH_P_IPV6:
-/*                      memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS); */
-		*(*ppMacAddr) = 0x33;
-		*(*ppMacAddr + 1) = 0x33;
-		*(*ppMacAddr + 2) = pIpAddr[12];
-		*(*ppMacAddr + 3) = pIpAddr[13];
-		*(*ppMacAddr + 4) = pIpAddr[14];
-		*(*ppMacAddr + 5) = pIpAddr[15];
-		break;
-
-	case ETH_P_IP:
-	default:
-/*                      memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS); */
-		*(*ppMacAddr) = 0x01;
-		*(*ppMacAddr + 1) = 0x00;
-		*(*ppMacAddr + 2) = 0x5e;
-		*(*ppMacAddr + 3) = pIpAddr[1] & 0x7f;
-		*(*ppMacAddr + 4) = pIpAddr[2];
-		*(*ppMacAddr + 5) = pIpAddr[3];
-		break;
-	}
-
-	return;
-}
-
-char *GetPhyMode(int Mode);
-char *GetBW(int BW);
-
-/* */
-/*  Private routines in rtmp_init.c */
-/* */
-int RTMPAllocAdapterBlock(void *handle,
-				  struct rt_rtmp_adapter **ppAdapter);
-
-int RTMPAllocTxRxRingMemory(struct rt_rtmp_adapter *pAd);
-
-void RTMPFreeAdapter(struct rt_rtmp_adapter *pAd);
-
-int NICReadRegParameters(struct rt_rtmp_adapter *pAd,
-				 void *WrapperConfigurationContext);
-
-#ifdef RTMP_RF_RW_SUPPORT
-void NICInitRFRegisters(struct rt_rtmp_adapter *pAd);
-
-void RtmpChipOpsRFHook(struct rt_rtmp_adapter *pAd);
-
-int RT30xxWriteRFRegister(struct rt_rtmp_adapter *pAd,
-				  u8 regID, u8 value);
-
-int RT30xxReadRFRegister(struct rt_rtmp_adapter *pAd,
-				 u8 regID, u8 *pValue);
-#endif /* RTMP_RF_RW_SUPPORT // */
-
-void NICReadEEPROMParameters(struct rt_rtmp_adapter *pAd, u8 *mac_addr);
-
-void NICInitAsicFromEEPROM(struct rt_rtmp_adapter *pAd);
-
-int NICInitializeAdapter(struct rt_rtmp_adapter *pAd, IN BOOLEAN bHardReset);
-
-int NICInitializeAsic(struct rt_rtmp_adapter *pAd, IN BOOLEAN bHardReset);
-
-void NICIssueReset(struct rt_rtmp_adapter *pAd);
-
-void RTMPRingCleanUp(struct rt_rtmp_adapter *pAd, u8 RingType);
-
-void UserCfgInit(struct rt_rtmp_adapter *pAd);
-
-void NICResetFromError(struct rt_rtmp_adapter *pAd);
-
-int NICLoadFirmware(struct rt_rtmp_adapter *pAd);
-
-void NICEraseFirmware(struct rt_rtmp_adapter *pAd);
-
-int NICLoadRateSwitchingParams(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN NICCheckForHang(struct rt_rtmp_adapter *pAd);
-
-void NICUpdateFifoStaCounters(struct rt_rtmp_adapter *pAd);
-
-void NICUpdateRawCounters(struct rt_rtmp_adapter *pAd);
-
-void RTMPZeroMemory(void *pSrc, unsigned long Length);
-
-unsigned long RTMPCompareMemory(void *pSrc1, void *pSrc2, unsigned long Length);
-
-void RTMPMoveMemory(void *pDest, void *pSrc, unsigned long Length);
-
-void AtoH(char *src, u8 *dest, int destlen);
-
-void RTMPPatchMacBbpBug(struct rt_rtmp_adapter *pAd);
-
-void RTMPInitTimer(struct rt_rtmp_adapter *pAd,
-		   struct rt_ralink_timer *pTimer,
-		   void *pTimerFunc, void *pData, IN BOOLEAN Repeat);
-
-void RTMPSetTimer(struct rt_ralink_timer *pTimer, unsigned long Value);
-
-void RTMPModTimer(struct rt_ralink_timer *pTimer, unsigned long Value);
-
-void RTMPCancelTimer(struct rt_ralink_timer *pTimer, OUT BOOLEAN * pCancelled);
-
-void RTMPSetLED(struct rt_rtmp_adapter *pAd, u8 Status);
-
-void RTMPSetSignalLED(struct rt_rtmp_adapter *pAd, IN NDIS_802_11_RSSI Dbm);
-
-void RTMPEnableRxTx(struct rt_rtmp_adapter *pAd);
-
-/* */
-/* prototype in action.c */
-/* */
-void ActionStateMachineInit(struct rt_rtmp_adapter *pAd,
-			    struct rt_state_machine *S,
-			    OUT STATE_MACHINE_FUNC Trans[]);
-
-void MlmeADDBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeDELBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeDLSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeInvalidAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeQOSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAddBAReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAddBARspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerDelBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerBAAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void SendPSMPAction(struct rt_rtmp_adapter *pAd, u8 Wcid, u8 Psmp);
-
-void PeerRMAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerPublicAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerHTAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerQOSAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void RECBATimerTimeout(void *SystemSpecific1,
-		       void *FunctionContext,
-		       void *SystemSpecific2, void *SystemSpecific3);
-
-void ORIBATimerTimeout(struct rt_rtmp_adapter *pAd);
-
-void SendRefreshBAR(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry);
-
-void ActHeaderInit(struct rt_rtmp_adapter *pAd,
-		   struct rt_header_802_11 *pHdr80211,
-		   u8 *Addr1, u8 *Addr2, u8 *Addr3);
-
-void BarHeaderInit(struct rt_rtmp_adapter *pAd,
-		   struct rt_frame_bar *pCntlBar, u8 *pDA, u8 *pSA);
-
-void InsertActField(struct rt_rtmp_adapter *pAd,
-		    u8 *pFrameBuf,
-		    unsigned long *pFrameLen, u8 Category, u8 ActCode);
-
-BOOLEAN CntlEnqueueForRecv(struct rt_rtmp_adapter *pAd,
-			   unsigned long Wcid,
-			   unsigned long MsgLen, struct rt_frame_ba_req *pMsg);
-
-/* */
-/* Private routines in rtmp_data.c */
-/* */
-BOOLEAN RTMPHandleRxDoneInterrupt(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(struct rt_rtmp_adapter *pAd,
-					 INT_SOURCE_CSR_STRUC TxRingBitmap);
-
-void RTMPHandleMgmtRingDmaDoneInterrupt(struct rt_rtmp_adapter *pAd);
-
-void RTMPHandleTBTTInterrupt(struct rt_rtmp_adapter *pAd);
-
-void RTMPHandlePreTBTTInterrupt(struct rt_rtmp_adapter *pAd);
-
-void RTMPHandleTwakeupInterrupt(struct rt_rtmp_adapter *pAd);
-
-void RTMPHandleRxCoherentInterrupt(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN TxFrameIsAggregatible(struct rt_rtmp_adapter *pAd,
-			      u8 *pPrevAddr1, u8 *p8023hdr);
-
-BOOLEAN PeerIsAggreOn(struct rt_rtmp_adapter *pAd,
-		      unsigned long TxRate, struct rt_mac_table_entry *pMacEntry);
-
-int Sniff2BytesFromNdisBuffer(char *pFirstBuffer,
-				      u8 DesiredOffset,
-				      u8 *pByte0, u8 *pByte1);
-
-int STASendPacket(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-void STASendPackets(void *MiniportAdapterContext,
-		    void **ppPacketArray, u32 NumberOfPackets);
-
-void RTMPDeQueuePacket(struct rt_rtmp_adapter *pAd,
-		       IN BOOLEAN bIntContext,
-		       u8 QueIdx, u8 Max_Tx_Packets);
-
-int RTMPHardTransmit(struct rt_rtmp_adapter *pAd,
-			     void *pPacket,
-			     u8 QueIdx, unsigned long *pFreeTXDLeft);
-
-int STAHardTransmit(struct rt_rtmp_adapter *pAd,
-			    struct rt_tx_blk *pTxBlk, u8 QueIdx);
-
-void STARxEAPOLFrameIndicate(struct rt_rtmp_adapter *pAd,
-			     struct rt_mac_table_entry *pEntry,
-			     struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-int RTMPFreeTXDRequest(struct rt_rtmp_adapter *pAd,
-			       u8 RingType,
-			       u8 NumberRequired, u8 *FreeNumberIs);
-
-int MlmeHardTransmit(struct rt_rtmp_adapter *pAd,
-			     u8 QueIdx, void *pPacket);
-
-int MlmeHardTransmitMgmtRing(struct rt_rtmp_adapter *pAd,
-				     u8 QueIdx, void *pPacket);
-
-#ifdef RTMP_MAC_PCI
-int MlmeHardTransmitTxRing(struct rt_rtmp_adapter *pAd,
-				   u8 QueIdx, void *pPacket);
-
-int MlmeDataHardTransmit(struct rt_rtmp_adapter *pAd,
-				 u8 QueIdx, void *pPacket);
-
-void RTMPWriteTxDescriptor(struct rt_rtmp_adapter *pAd,
-			   struct rt_txd *pTxD, IN BOOLEAN bWIV, u8 QSEL);
-#endif /* RTMP_MAC_PCI // */
-
-u16 RTMPCalcDuration(struct rt_rtmp_adapter *pAd, u8 Rate, unsigned long Size);
-
-void RTMPWriteTxWI(struct rt_rtmp_adapter *pAd, struct rt_txwi * pTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	/* HW new a sequence. */
-		   u8 BASize,
-		   u8 WCID,
-		   unsigned long Length,
-		   u8 PID,
-		   u8 TID,
-		   u8 TxRate,
-		   u8 Txopmode,
-		   IN BOOLEAN CfAck, IN HTTRANSMIT_SETTING *pTransmit);
-
-void RTMPWriteTxWI_Data(struct rt_rtmp_adapter *pAd,
-			struct rt_txwi *pTxWI, struct rt_tx_blk *pTxBlk);
-
-void RTMPWriteTxWI_Cache(struct rt_rtmp_adapter *pAd,
-			 struct rt_txwi *pTxWI, struct rt_tx_blk *pTxBlk);
-
-void RTMPSuspendMsduTransmission(struct rt_rtmp_adapter *pAd);
-
-void RTMPResumeMsduTransmission(struct rt_rtmp_adapter *pAd);
-
-int MiniportMMRequest(struct rt_rtmp_adapter *pAd,
-			      u8 QueIdx, u8 *pData, u32 Length);
-
-/*+++mark by shiang, now this function merge to MiniportMMRequest() */
-/*---mark by shiang, now this function merge to MiniportMMRequest() */
-
-void RTMPSendNullFrame(struct rt_rtmp_adapter *pAd,
-		       u8 TxRate, IN BOOLEAN bQosNull);
-
-void RTMPSendDisassociationFrame(struct rt_rtmp_adapter *pAd);
-
-void RTMPSendRTSFrame(struct rt_rtmp_adapter *pAd,
-		      u8 *pDA,
-		      IN unsigned int NextMpduSize,
-		      u8 TxRate,
-		      u8 RTSRate,
-		      u16 AckDuration,
-		      u8 QueIdx, u8 FrameGap);
-
-struct rt_queue_header *RTMPCheckTxSwQueue(struct rt_rtmp_adapter *pAd, u8 * QueIdx);
-
-void RTMPReportMicError(struct rt_rtmp_adapter *pAd, struct rt_cipher_key *pWpaKey);
-
-void WpaMicFailureReportFrame(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void WpaDisassocApAndBlockAssoc(void *SystemSpecific1,
-				void *FunctionContext,
-				void *SystemSpecific2,
-				void *SystemSpecific3);
-
-void WpaStaPairwiseKeySetting(struct rt_rtmp_adapter *pAd);
-
-void WpaStaGroupKeySetting(struct rt_rtmp_adapter *pAd);
-
-int RTMPCloneNdisPacket(struct rt_rtmp_adapter *pAd,
-				IN BOOLEAN pInsAMSDUHdr,
-				void *pInPacket,
-				void **ppOutPacket);
-
-int RTMPAllocateNdisPacket(struct rt_rtmp_adapter *pAd,
-				   void **pPacket,
-				   u8 *pHeader,
-				   u32 HeaderLen,
-				   u8 *pData, u32 DataLen);
-
-void RTMPFreeNdisPacket(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-BOOLEAN RTMPFreeTXDUponTxDmaDone(struct rt_rtmp_adapter *pAd, u8 QueIdx);
-
-BOOLEAN RTMPCheckDHCPFrame(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-BOOLEAN RTMPCheckEtherType(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-/* */
-/* Private routines in rtmp_wep.c */
-/* */
-void RTMPInitWepEngine(struct rt_rtmp_adapter *pAd,
-		       u8 *pKey,
-		       u8 KeyId, u8 KeyLen, u8 *pDest);
-
-void RTMPEncryptData(struct rt_rtmp_adapter *pAd,
-		     u8 *pSrc, u8 *pDest, u32 Len);
-
-BOOLEAN RTMPSoftDecryptWEP(struct rt_rtmp_adapter *pAd,
-			   u8 *pData,
-			   unsigned long DataByteCnt, struct rt_cipher_key *pGroupKey);
-
-void RTMPSetICV(struct rt_rtmp_adapter *pAd, u8 *pDest);
-
-void ARCFOUR_INIT(struct rt_arcfourcontext *Ctx, u8 *pKey, u32 KeyLen);
-
-u8 ARCFOUR_BYTE(struct rt_arcfourcontext *Ctx);
-
-void ARCFOUR_DECRYPT(struct rt_arcfourcontext *Ctx,
-		     u8 *pDest, u8 *pSrc, u32 Len);
-
-void ARCFOUR_ENCRYPT(struct rt_arcfourcontext *Ctx,
-		     u8 *pDest, u8 *pSrc, u32 Len);
-
-void WPAARCFOUR_ENCRYPT(struct rt_arcfourcontext *Ctx,
-			u8 *pDest, u8 *pSrc, u32 Len);
-
-u32 RTMP_CALC_FCS32(u32 Fcs, u8 *Cp, int Len);
-
-/* */
-/* MLME routines */
-/* */
-
-/* Asic/RF/BBP related functions */
-
-void AsicAdjustTxPower(struct rt_rtmp_adapter *pAd);
-
-void AsicUpdateProtect(struct rt_rtmp_adapter *pAd,
-		       u16 OperaionMode,
-		       u8 SetMask,
-		       IN BOOLEAN bDisableBGProtect, IN BOOLEAN bNonGFExist);
-
-void AsicSwitchChannel(struct rt_rtmp_adapter *pAd,
-		       u8 Channel, IN BOOLEAN bScan);
-
-void AsicLockChannel(struct rt_rtmp_adapter *pAd, u8 Channel);
-
-void AsicRfTuningExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3);
-
-void AsicResetBBPAgent(struct rt_rtmp_adapter *pAd);
-
-void AsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-			     u16 TbttNumToNextWakeUp);
-
-void AsicForceSleep(struct rt_rtmp_adapter *pAd);
-
-void AsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx);
-
-void AsicSetBssid(struct rt_rtmp_adapter *pAd, u8 *pBssid);
-
-void AsicSetMcastWC(struct rt_rtmp_adapter *pAd);
-
-void AsicDelWcidTab(struct rt_rtmp_adapter *pAd, u8 Wcid);
-
-void AsicEnableRDG(struct rt_rtmp_adapter *pAd);
-
-void AsicDisableRDG(struct rt_rtmp_adapter *pAd);
-
-void AsicDisableSync(struct rt_rtmp_adapter *pAd);
-
-void AsicEnableBssSync(struct rt_rtmp_adapter *pAd);
-
-void AsicEnableIbssSync(struct rt_rtmp_adapter *pAd);
-
-void AsicSetEdcaParm(struct rt_rtmp_adapter *pAd, struct rt_edca_parm *pEdcaParm);
-
-void AsicSetSlotTime(struct rt_rtmp_adapter *pAd, IN BOOLEAN bUseShortSlotTime);
-
-void AsicAddSharedKeyEntry(struct rt_rtmp_adapter *pAd,
-			   u8 BssIndex,
-			   u8 KeyIdx,
-			   u8 CipherAlg,
-			   u8 *pKey, u8 *pTxMic, u8 *pRxMic);
-
-void AsicRemoveSharedKeyEntry(struct rt_rtmp_adapter *pAd,
-			      u8 BssIndex, u8 KeyIdx);
-
-void AsicUpdateWCIDAttribute(struct rt_rtmp_adapter *pAd,
-			     u16 WCID,
-			     u8 BssIndex,
-			     u8 CipherAlg,
-			     IN BOOLEAN bUsePairewiseKeyTable);
-
-void AsicUpdateWCIDIVEIV(struct rt_rtmp_adapter *pAd,
-			 u16 WCID, unsigned long uIV, unsigned long uEIV);
-
-void AsicUpdateRxWCIDTable(struct rt_rtmp_adapter *pAd,
-			   u16 WCID, u8 *pAddr);
-
-void AsicAddKeyEntry(struct rt_rtmp_adapter *pAd,
-		     u16 WCID,
-		     u8 BssIndex,
-		     u8 KeyIdx,
-		     struct rt_cipher_key *pCipherKey,
-		     IN BOOLEAN bUsePairewiseKeyTable, IN BOOLEAN bTxKey);
-
-void AsicAddPairwiseKeyEntry(struct rt_rtmp_adapter *pAd,
-			     u8 *pAddr,
-			     u8 WCID, struct rt_cipher_key *pCipherKey);
-
-void AsicRemovePairwiseKeyEntry(struct rt_rtmp_adapter *pAd,
-				u8 BssIdx, u8 Wcid);
-
-BOOLEAN AsicSendCommandToMcu(struct rt_rtmp_adapter *pAd,
-			     u8 Command,
-			     u8 Token, u8 Arg0, u8 Arg1);
-
-#ifdef RTMP_MAC_PCI
-BOOLEAN AsicCheckCommanOk(struct rt_rtmp_adapter *pAd, u8 Command);
-#endif /* RTMP_MAC_PCI // */
-
-void MacAddrRandomBssid(struct rt_rtmp_adapter *pAd, u8 *pAddr);
-
-void MgtMacHeaderInit(struct rt_rtmp_adapter *pAd,
-		      struct rt_header_802_11 *pHdr80211,
-		      u8 SubType,
-		      u8 ToDs, u8 *pDA, u8 *pBssid);
-
-void MlmeRadioOff(struct rt_rtmp_adapter *pAd);
-
-void MlmeRadioOn(struct rt_rtmp_adapter *pAd);
-
-void BssTableInit(struct rt_bss_table *Tab);
-
-void BATableInit(struct rt_rtmp_adapter *pAd, struct rt_ba_table *Tab);
-
-unsigned long BssTableSearch(struct rt_bss_table *Tab, u8 *pBssid, u8 Channel);
-
-unsigned long BssSsidTableSearch(struct rt_bss_table *Tab,
-			 u8 *pBssid,
-			 u8 *pSsid, u8 SsidLen, u8 Channel);
-
-unsigned long BssTableSearchWithSSID(struct rt_bss_table *Tab,
-			     u8 *Bssid,
-			     u8 *pSsid,
-			     u8 SsidLen, u8 Channel);
-
-unsigned long BssSsidTableSearchBySSID(struct rt_bss_table *Tab,
-			       u8 *pSsid, u8 SsidLen);
-
-void BssTableDeleteEntry(struct rt_bss_table *pTab,
-			 u8 *pBssid, u8 Channel);
-
-void BATableDeleteORIEntry(struct rt_rtmp_adapter *pAd,
-			   struct rt_ba_ori_entry *pBAORIEntry);
-
-void BssEntrySet(struct rt_rtmp_adapter *pAd, struct rt_bss_entry *pBss, u8 *pBssid, char Ssid[], u8 SsidLen, u8 BssType, u16 BeaconPeriod, struct rt_cf_parm * CfParm, u16 AtimWin, u16 CapabilityInfo, u8 SupRate[], u8 SupRateLen, u8 ExtRate[], u8 ExtRateLen, struct rt_ht_capability_ie * pHtCapability, struct rt_add_ht_info_ie * pAddHtInfo,	/* AP might use this additional ht info IE */
-		 u8 HtCapabilityLen,
-		 u8 AddHtInfoLen,
-		 u8 NewExtChanOffset,
-		 u8 Channel,
-		 char Rssi,
-		 IN LARGE_INTEGER TimeStamp,
-		 u8 CkipFlag,
-		 struct rt_edca_parm *pEdcaParm,
-		 struct rt_qos_capability_parm *pQosCapability,
-		 struct rt_qbss_load_parm *pQbssLoad,
-		 u16 LengthVIE, struct rt_ndis_802_11_variable_ies *pVIE);
-
-unsigned long BssTableSetEntry(struct rt_rtmp_adapter *pAd, struct rt_bss_table *pTab, u8 *pBssid, char Ssid[], u8 SsidLen, u8 BssType, u16 BeaconPeriod, struct rt_cf_parm * CfParm, u16 AtimWin, u16 CapabilityInfo, u8 SupRate[], u8 SupRateLen, u8 ExtRate[], u8 ExtRateLen, struct rt_ht_capability_ie * pHtCapability, struct rt_add_ht_info_ie * pAddHtInfo,	/* AP might use this additional ht info IE */
-		       u8 HtCapabilityLen,
-		       u8 AddHtInfoLen,
-		       u8 NewExtChanOffset,
-		       u8 Channel,
-		       char Rssi,
-		       IN LARGE_INTEGER TimeStamp,
-		       u8 CkipFlag,
-		       struct rt_edca_parm *pEdcaParm,
-		       struct rt_qos_capability_parm *pQosCapability,
-		       struct rt_qbss_load_parm *pQbssLoad,
-		       u16 LengthVIE, struct rt_ndis_802_11_variable_ies *pVIE);
-
-void BATableInsertEntry(struct rt_rtmp_adapter *pAd,
-			u16 Aid,
-			u16 TimeOutValue,
-			u16 StartingSeq,
-			u8 TID,
-			u8 BAWinSize,
-			u8 OriginatorStatus, IN BOOLEAN IsRecipient);
-
-void BssTableSsidSort(struct rt_rtmp_adapter *pAd,
-		      struct rt_bss_table *OutTab, char Ssid[], u8 SsidLen);
-
-void BssTableSortByRssi(struct rt_bss_table *OutTab);
-
-void BssCipherParse(struct rt_bss_entry *pBss);
-
-int MlmeQueueInit(struct rt_mlme_queue *Queue);
-
-void MlmeQueueDestroy(struct rt_mlme_queue *Queue);
-
-BOOLEAN MlmeEnqueue(struct rt_rtmp_adapter *pAd,
-		    unsigned long Machine,
-		    unsigned long MsgType, unsigned long MsgLen, void *Msg);
-
-BOOLEAN MlmeEnqueueForRecv(struct rt_rtmp_adapter *pAd,
-			   unsigned long Wcid,
-			   unsigned long TimeStampHigh,
-			   unsigned long TimeStampLow,
-			   u8 Rssi0,
-			   u8 Rssi1,
-			   u8 Rssi2,
-			   unsigned long MsgLen, void *Msg, u8 Signal);
-
-BOOLEAN MlmeDequeue(struct rt_mlme_queue *Queue, struct rt_mlme_queue_elem **Elem);
-
-void MlmeRestartStateMachine(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN MlmeQueueEmpty(struct rt_mlme_queue *Queue);
-
-BOOLEAN MlmeQueueFull(struct rt_mlme_queue *Queue);
-
-BOOLEAN MsgTypeSubst(struct rt_rtmp_adapter *pAd,
-		     struct rt_frame_802_11 *pFrame,
-		     int *Machine, int *MsgType);
-
-void StateMachineInit(struct rt_state_machine *Sm,
-		      IN STATE_MACHINE_FUNC Trans[],
-		      unsigned long StNr,
-		      unsigned long MsgNr,
-		      IN STATE_MACHINE_FUNC DefFunc,
-		      unsigned long InitState, unsigned long Base);
-
-void StateMachineSetAction(struct rt_state_machine *S,
-			   unsigned long St, unsigned long Msg, IN STATE_MACHINE_FUNC F);
-
-void StateMachinePerformAction(struct rt_rtmp_adapter *pAd,
-			       struct rt_state_machine *S, struct rt_mlme_queue_elem *Elem);
-
-void Drop(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void AssocStateMachineInit(struct rt_rtmp_adapter *pAd,
-			   struct rt_state_machine *Sm,
-			   OUT STATE_MACHINE_FUNC Trans[]);
-
-void ReassocTimeout(void *SystemSpecific1,
-		    void *FunctionContext,
-		    void *SystemSpecific2, void *SystemSpecific3);
-
-void AssocTimeout(void *SystemSpecific1,
-		  void *FunctionContext,
-		  void *SystemSpecific2, void *SystemSpecific3);
-
-void DisassocTimeout(void *SystemSpecific1,
-		     void *FunctionContext,
-		     void *SystemSpecific2, void *SystemSpecific3);
-
-/*---------------------------------------------- */
-void MlmeAssocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeReassocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeDisassocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAssocRspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerReassocRspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerDisassocAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void DisassocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void AssocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void ReassocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void Cls3errAction(struct rt_rtmp_adapter *pAd, u8 *pAddr);
-
-void InvalidStateWhenAssoc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void InvalidStateWhenReassoc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void InvalidStateWhenDisassociate(struct rt_rtmp_adapter *pAd,
-				  struct rt_mlme_queue_elem *Elem);
-
-#ifdef RTMP_MAC_USB
-void MlmeCntlConfirm(struct rt_rtmp_adapter *pAd, unsigned long MsgType, u16 Msg);
-#endif /* RTMP_MAC_USB // */
-
-void ComposePsPoll(struct rt_rtmp_adapter *pAd);
-
-void ComposeNullFrame(struct rt_rtmp_adapter *pAd);
-
-void AssocPostProc(struct rt_rtmp_adapter *pAd,
-		   u8 *pAddr2,
-		   u16 CapabilityInfo,
-		   u16 Aid,
-		   u8 SupRate[],
-		   u8 SupRateLen,
-		   u8 ExtRate[],
-		   u8 ExtRateLen,
-		   struct rt_edca_parm *pEdcaParm,
-		   struct rt_ht_capability_ie *pHtCapability,
-		   u8 HtCapabilityLen, struct rt_add_ht_info_ie *pAddHtInfo);
-
-void AuthStateMachineInit(struct rt_rtmp_adapter *pAd,
-			  struct rt_state_machine *sm, OUT STATE_MACHINE_FUNC Trans[]);
-
-void AuthTimeout(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3);
-
-void MlmeAuthReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAuthRspAtSeq2Action(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAuthRspAtSeq4Action(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void AuthTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void Cls2errAction(struct rt_rtmp_adapter *pAd, u8 *pAddr);
-
-void MlmeDeauthReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void InvalidStateWhenAuth(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-/*============================================= */
-
-void AuthRspStateMachineInit(struct rt_rtmp_adapter *pAd,
-			     struct rt_state_machine *Sm,
-			     IN STATE_MACHINE_FUNC Trans[]);
-
-void PeerDeauthAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerAuthSimpleRspGenAndSend(struct rt_rtmp_adapter *pAd,
-				 struct rt_header_802_11 *pHdr80211,
-				 u16 Alg,
-				 u16 Seq,
-				 u16 Reason, u16 Status);
-
-/* */
-/* Private routines in dls.c */
-/* */
-
-/*======================================== */
-
-void SyncStateMachineInit(struct rt_rtmp_adapter *pAd,
-			  struct rt_state_machine *Sm,
-			  OUT STATE_MACHINE_FUNC Trans[]);
-
-void BeaconTimeout(void *SystemSpecific1,
-		   void *FunctionContext,
-		   void *SystemSpecific2, void *SystemSpecific3);
-
-void ScanTimeout(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3);
-
-void InvalidStateWhenScan(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void InvalidStateWhenJoin(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void InvalidStateWhenStart(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void EnqueueProbeRequest(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN ScanRunning(struct rt_rtmp_adapter *pAd);
-/*========================================= */
-
-void MlmeCntlInit(struct rt_rtmp_adapter *pAd,
-		  struct rt_state_machine *S, OUT STATE_MACHINE_FUNC Trans[]);
-
-void MlmeCntlMachinePerformAction(struct rt_rtmp_adapter *pAd,
-				  struct rt_state_machine *S,
-				  struct rt_mlme_queue_elem *Elem);
-
-void CntlIdleProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlOidScanProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlOidSsidProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlOidRTBssidProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlMlmeRoamingProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitDisassocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitJoinProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitReassocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitStartProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitAuthProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitAuthProc2(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void CntlWaitAssocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void LinkUp(struct rt_rtmp_adapter *pAd, u8 BssType);
-
-void LinkDown(struct rt_rtmp_adapter *pAd, IN BOOLEAN IsReqFromAP);
-
-void IterateOnBssTab(struct rt_rtmp_adapter *pAd);
-
-void IterateOnBssTab2(struct rt_rtmp_adapter *pAd);
-
-void JoinParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_join_req *JoinReq, unsigned long BssIdx);
-
-void AssocParmFill(struct rt_rtmp_adapter *pAd,
-		   struct rt_mlme_assoc_req *AssocReq,
-		   u8 *pAddr,
-		   u16 CapabilityInfo,
-		   unsigned long Timeout, u16 ListenIntv);
-
-void ScanParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_scan_req *ScanReq,
-		  char Ssid[],
-		  u8 SsidLen, u8 BssType, u8 ScanType);
-
-void DisassocParmFill(struct rt_rtmp_adapter *pAd,
-		      struct rt_mlme_disassoc_req *DisassocReq,
-		      u8 *pAddr, u16 Reason);
-
-void StartParmFill(struct rt_rtmp_adapter *pAd,
-		   struct rt_mlme_start_req *StartReq,
-		   char Ssid[], u8 SsidLen);
-
-void AuthParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_auth_req *AuthReq,
-		  u8 *pAddr, u16 Alg);
-
-void EnqueuePsPoll(struct rt_rtmp_adapter *pAd);
-
-void EnqueueBeaconFrame(struct rt_rtmp_adapter *pAd);
-
-void MlmeJoinReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeScanReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void MlmeStartReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void ScanTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void BeaconTimeoutAtJoinAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerBeaconAtScanAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerBeaconAtJoinAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerBeacon(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void PeerProbeReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-void ScanNextChannel(struct rt_rtmp_adapter *pAd);
-
-unsigned long MakeIbssBeacon(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN MlmeScanReqSanity(struct rt_rtmp_adapter *pAd,
-			  void *Msg,
-			  unsigned long MsgLen,
-			  u8 *BssType,
-			  char ssid[],
-			  u8 *SsidLen, u8 *ScanType);
-
-BOOLEAN PeerBeaconAndProbeRspSanity(struct rt_rtmp_adapter *pAd,
-				    void *Msg,
-				    unsigned long MsgLen,
-				    u8 MsgChannel,
-				    u8 *pAddr2,
-				    u8 *pBssid,
-				    char Ssid[],
-				    u8 *pSsidLen,
-				    u8 *pBssType,
-				    u16 *pBeaconPeriod,
-				    u8 *pChannel,
-				    u8 *pNewChannel,
-				    OUT LARGE_INTEGER *pTimestamp,
-				    struct rt_cf_parm *pCfParm,
-				    u16 *pAtimWin,
-				    u16 *pCapabilityInfo,
-				    u8 *pErp,
-				    u8 *pDtimCount,
-				    u8 *pDtimPeriod,
-				    u8 *pBcastFlag,
-				    u8 *pMessageToMe,
-				    u8 SupRate[],
-				    u8 *pSupRateLen,
-				    u8 ExtRate[],
-				    u8 *pExtRateLen,
-				    u8 *pCkipFlag,
-				    u8 *pAironetCellPowerLimit,
-				    struct rt_edca_parm *pEdcaParm,
-				    struct rt_qbss_load_parm *pQbssLoad,
-				    struct rt_qos_capability_parm *pQosCapability,
-				    unsigned long *pRalinkIe,
-				    u8 *pHtCapabilityLen,
-				    u8 *pPreNHtCapabilityLen,
-				    struct rt_ht_capability_ie *pHtCapability,
-				    u8 *AddHtInfoLen,
-				    struct rt_add_ht_info_ie *AddHtInfo,
-				    u8 *NewExtChannel,
-				    u16 *LengthVIE,
-				    struct rt_ndis_802_11_variable_ies *pVIE);
-
-BOOLEAN PeerAddBAReqActionSanity(struct rt_rtmp_adapter *pAd,
-				 void *pMsg,
-				 unsigned long MsgLen, u8 *pAddr2);
-
-BOOLEAN PeerAddBARspActionSanity(struct rt_rtmp_adapter *pAd,
-				 void *pMsg, unsigned long MsgLen);
-
-BOOLEAN PeerDelBAActionSanity(struct rt_rtmp_adapter *pAd,
-			      u8 Wcid, void *pMsg, unsigned long MsgLen);
-
-BOOLEAN MlmeAssocReqSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg,
-			   unsigned long MsgLen,
-			   u8 *pApAddr,
-			   u16 *CapabilityInfo,
-			   unsigned long *Timeout, u16 *ListenIntv);
-
-BOOLEAN MlmeAuthReqSanity(struct rt_rtmp_adapter *pAd,
-			  void *Msg,
-			  unsigned long MsgLen,
-			  u8 *pAddr,
-			  unsigned long *Timeout, u16 *Alg);
-
-BOOLEAN MlmeStartReqSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg,
-			   unsigned long MsgLen,
-			   char Ssid[], u8 *Ssidlen);
-
-BOOLEAN PeerAuthSanity(struct rt_rtmp_adapter *pAd,
-		       void *Msg,
-		       unsigned long MsgLen,
-		       u8 *pAddr,
-		       u16 *Alg,
-		       u16 *Seq,
-		       u16 *Status, char ChlgText[]);
-
-BOOLEAN PeerAssocRspSanity(struct rt_rtmp_adapter *pAd, void *pMsg, unsigned long MsgLen, u8 *pAddr2, u16 *pCapabilityInfo, u16 *pStatus, u16 *pAid, u8 SupRate[], u8 *pSupRateLen, u8 ExtRate[], u8 *pExtRateLen, struct rt_ht_capability_ie *pHtCapability, struct rt_add_ht_info_ie *pAddHtInfo,	/* AP might use this additional ht info IE */
-			   u8 *pHtCapabilityLen,
-			   u8 *pAddHtInfoLen,
-			   u8 *pNewExtChannelOffset,
-			   struct rt_edca_parm *pEdcaParm, u8 *pCkipFlag);
-
-BOOLEAN PeerDisassocSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg,
-			   unsigned long MsgLen,
-			   u8 *pAddr2, u16 *Reason);
-
-BOOLEAN PeerWpaMessageSanity(struct rt_rtmp_adapter *pAd,
-			     struct rt_eapol_packet *pMsg,
-			     unsigned long MsgLen,
-			     u8 MsgType, struct rt_mac_table_entry *pEntry);
-
-BOOLEAN PeerDeauthSanity(struct rt_rtmp_adapter *pAd,
-			 void *Msg,
-			 unsigned long MsgLen,
-			 u8 *pAddr2, u16 *Reason);
-
-BOOLEAN PeerProbeReqSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg,
-			   unsigned long MsgLen,
-			   u8 *pAddr2,
-			   char Ssid[], u8 *pSsidLen);
-
-BOOLEAN GetTimBit(char *Ptr,
-		  u16 Aid,
-		  u8 *TimLen,
-		  u8 *BcastFlag,
-		  u8 *DtimCount,
-		  u8 *DtimPeriod, u8 *MessageToMe);
-
-u8 ChannelSanity(struct rt_rtmp_adapter *pAd, u8 channel);
-
-NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(struct rt_bss_entry *pBss);
-
-BOOLEAN MlmeDelBAReqSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg, unsigned long MsgLen);
-
-BOOLEAN MlmeAddBAReqSanity(struct rt_rtmp_adapter *pAd,
-			   void *Msg, unsigned long MsgLen, u8 *pAddr2);
-
-unsigned long MakeOutgoingFrame(u8 *Buffer, unsigned long *Length, ...);
-
-void LfsrInit(struct rt_rtmp_adapter *pAd, unsigned long Seed);
-
-u8 RandomByte(struct rt_rtmp_adapter *pAd);
-
-void AsicUpdateAutoFallBackTable(struct rt_rtmp_adapter *pAd, u8 *pTxRate);
-
-void MlmePeriodicExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3);
-
-void LinkDownExec(void *SystemSpecific1,
-		  void *FunctionContext,
-		  void *SystemSpecific2, void *SystemSpecific3);
-
-void STAMlmePeriodicExec(struct rt_rtmp_adapter *pAd);
-
-void MlmeAutoScan(struct rt_rtmp_adapter *pAd);
-
-void MlmeAutoReconnectLastSSID(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN MlmeValidateSSID(u8 *pSsid, u8 SsidLen);
-
-void MlmeCheckForRoaming(struct rt_rtmp_adapter *pAd, unsigned long Now32);
-
-BOOLEAN MlmeCheckForFastRoaming(struct rt_rtmp_adapter *pAd);
-
-void MlmeDynamicTxRateSwitching(struct rt_rtmp_adapter *pAd);
-
-void MlmeSetTxRate(struct rt_rtmp_adapter *pAd,
-		   struct rt_mac_table_entry *pEntry, struct rt_rtmp_tx_rate_switch * pTxRate);
-
-void MlmeSelectTxRateTable(struct rt_rtmp_adapter *pAd,
-			   struct rt_mac_table_entry *pEntry,
-			   u8 **ppTable,
-			   u8 *pTableSize, u8 *pInitTxRateIdx);
-
-void MlmeCalculateChannelQuality(struct rt_rtmp_adapter *pAd,
-				 struct rt_mac_table_entry *pMacEntry, unsigned long Now);
-
-void MlmeCheckPsmChange(struct rt_rtmp_adapter *pAd, unsigned long Now32);
-
-void MlmeSetPsmBit(struct rt_rtmp_adapter *pAd, u16 psm);
-
-void MlmeSetTxPreamble(struct rt_rtmp_adapter *pAd, u16 TxPreamble);
-
-void UpdateBasicRateBitmap(struct rt_rtmp_adapter *pAd);
-
-void MlmeUpdateTxRates(struct rt_rtmp_adapter *pAd,
-		       IN BOOLEAN bLinkUp, u8 apidx);
-
-void MlmeUpdateHtTxRates(struct rt_rtmp_adapter *pAd, u8 apidx);
-
-void RTMPCheckRates(struct rt_rtmp_adapter *pAd,
-		    IN u8 SupRate[], IN u8 *SupRateLen);
-
-BOOLEAN RTMPCheckChannel(struct rt_rtmp_adapter *pAd,
-			 u8 CentralChannel, u8 Channel);
-
-BOOLEAN RTMPCheckHt(struct rt_rtmp_adapter *pAd,
-		    u8 Wcid,
-		    struct rt_ht_capability_ie *pHtCapability,
-		    struct rt_add_ht_info_ie *pAddHtInfo);
-
-void StaQuickResponeForRateUpExec(void *SystemSpecific1,
-				  void *FunctionContext,
-				  void *SystemSpecific2,
-				  void *SystemSpecific3);
-
-void RTMPUpdateMlmeRate(struct rt_rtmp_adapter *pAd);
-
-char RTMPMaxRssi(struct rt_rtmp_adapter *pAd,
-		 char Rssi0, char Rssi1, char Rssi2);
-
-#ifdef RT30xx
-void AsicSetRxAnt(struct rt_rtmp_adapter *pAd, u8 Ant);
-
-void RTMPFilterCalibration(struct rt_rtmp_adapter *pAd);
-
-#ifdef RTMP_EFUSE_SUPPORT
-/*2008/09/11:KH add to support efuse<-- */
-int set_eFuseGetFreeBlockCount_Proc(struct rt_rtmp_adapter *pAd, char *arg);
-
-int set_eFusedump_Proc(struct rt_rtmp_adapter *pAd, char *arg);
-
-void eFusePhysicalReadRegisters(struct rt_rtmp_adapter *pAd,
-				u16 Offset,
-				u16 Length, u16 *pData);
-
-int RtmpEfuseSupportCheck(struct rt_rtmp_adapter *pAd);
-
-void eFuseGetFreeBlockCount(struct rt_rtmp_adapter *pAd, u32 *EfuseFreeBlock);
-
-int eFuse_init(struct rt_rtmp_adapter *pAd);
-/*2008/09/11:KH add to support efuse--> */
-#endif /* RTMP_EFUSE_SUPPORT // */
-
-/* add by johnli, RF power sequence setup */
-void RT30xxLoadRFNormalModeSetup(struct rt_rtmp_adapter *pAd);
-
-void RT30xxLoadRFSleepModeSetup(struct rt_rtmp_adapter *pAd);
-
-void RT30xxReverseRFSleepModeSetup(struct rt_rtmp_adapter *pAd);
-/* end johnli */
-
-#ifdef RT3070
-void NICInitRT3070RFRegisters(struct rt_rtmp_adapter *pAd);
-#endif /* RT3070 // */
-#ifdef RT3090
-void NICInitRT3090RFRegisters(struct rt_rtmp_adapter *pAd);
-#endif /* RT3090 // */
-
-void RT30xxHaltAction(struct rt_rtmp_adapter *pAd);
-
-void RT30xxSetRxAnt(struct rt_rtmp_adapter *pAd, u8 Ant);
-#endif /* RT30xx // */
-
-void AsicEvaluateRxAnt(struct rt_rtmp_adapter *pAd);
-
-void AsicRxAntEvalTimeout(void *SystemSpecific1,
-			  void *FunctionContext,
-			  void *SystemSpecific2, void *SystemSpecific3);
-
-void APSDPeriodicExec(void *SystemSpecific1,
-		      void *FunctionContext,
-		      void *SystemSpecific2, void *SystemSpecific3);
-
-BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(struct rt_rtmp_adapter *pAd,
-					   struct rt_mac_table_entry *pEntry);
-
-u8 RTMPStaFixedTxMode(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry);
-
-void RTMPUpdateLegacyTxSetting(u8 fixed_tx_mode, struct rt_mac_table_entry *pEntry);
-
-BOOLEAN RTMPAutoRateSwitchCheck(struct rt_rtmp_adapter *pAd);
-
-int MlmeInit(struct rt_rtmp_adapter *pAd);
-
-void MlmeHandler(struct rt_rtmp_adapter *pAd);
-
-void MlmeHalt(struct rt_rtmp_adapter *pAd);
-
-void MlmeResetRalinkCounters(struct rt_rtmp_adapter *pAd);
-
-void BuildChannelList(struct rt_rtmp_adapter *pAd);
-
-u8 FirstChannel(struct rt_rtmp_adapter *pAd);
-
-u8 NextChannel(struct rt_rtmp_adapter *pAd, u8 channel);
-
-void ChangeToCellPowerLimit(struct rt_rtmp_adapter *pAd,
-			    u8 AironetCellPowerLimit);
-
-/* */
-/* Prototypes of function definition in rtmp_tkip.c */
-/* */
-void RTMPInitTkipEngine(struct rt_rtmp_adapter *pAd,
-			u8 *pTKey,
-			u8 KeyId,
-			u8 *pTA,
-			u8 *pMICKey,
-			u8 *pTSC, unsigned long *pIV16, unsigned long *pIV32);
-
-void RTMPInitMICEngine(struct rt_rtmp_adapter *pAd,
-		       u8 *pKey,
-		       u8 *pDA,
-		       u8 *pSA, u8 UserPriority, u8 *pMICKey);
-
-BOOLEAN RTMPTkipCompareMICValue(struct rt_rtmp_adapter *pAd,
-				u8 *pSrc,
-				u8 *pDA,
-				u8 *pSA,
-				u8 *pMICKey,
-				u8 UserPriority, u32 Len);
-
-void RTMPCalculateMICValue(struct rt_rtmp_adapter *pAd,
-			   void *pPacket,
-			   u8 *pEncap,
-			   struct rt_cipher_key *pKey, u8 apidx);
-
-void RTMPTkipAppendByte(struct rt_tkip_key_info *pTkip, u8 uChar);
-
-void RTMPTkipAppend(struct rt_tkip_key_info *pTkip, u8 *pSrc, u32 nBytes);
-
-void RTMPTkipGetMIC(struct rt_tkip_key_info *pTkip);
-
-BOOLEAN RTMPSoftDecryptTKIP(struct rt_rtmp_adapter *pAd,
-			    u8 *pData,
-			    unsigned long DataByteCnt,
-			    u8 UserPriority, struct rt_cipher_key *pWpaKey);
-
-BOOLEAN RTMPSoftDecryptAES(struct rt_rtmp_adapter *pAd,
-			   u8 *pData,
-			   unsigned long DataByteCnt, struct rt_cipher_key *pWpaKey);
-
-/* */
-/* Prototypes of function definition in cmm_info.c */
-/* */
-int RT_CfgSetCountryRegion(struct rt_rtmp_adapter *pAd, char *arg, int band);
-
-int RT_CfgSetWirelessMode(struct rt_rtmp_adapter *pAd, char *arg);
-
-int RT_CfgSetShortSlot(struct rt_rtmp_adapter *pAd, char *arg);
-
-int RT_CfgSetWepKey(struct rt_rtmp_adapter *pAd,
-		    char *keyString,
-		    struct rt_cipher_key *pSharedKey, int keyIdx);
-
-int RT_CfgSetWPAPSKKey(struct rt_rtmp_adapter *pAd,
-		       char *keyString,
-		       u8 *pHashStr,
-		       int hashStrLen, u8 *pPMKBuf);
-
-/* */
-/* Prototypes of function definition in cmm_info.c */
-/* */
-void RTMPWPARemoveAllKeys(struct rt_rtmp_adapter *pAd);
-
-void RTMPSetPhyMode(struct rt_rtmp_adapter *pAd, unsigned long phymode);
-
-void RTMPUpdateHTIE(struct rt_ht_capability *pRtHt,
-		    u8 *pMcsSet,
-		    struct rt_ht_capability_ie *pHtCapability,
-		    struct rt_add_ht_info_ie *pAddHtInfo);
-
-void RTMPAddWcidAttributeEntry(struct rt_rtmp_adapter *pAd,
-			       u8 BssIdx,
-			       u8 KeyIdx,
-			       u8 CipherAlg, struct rt_mac_table_entry *pEntry);
-
-char *GetEncryptType(char enc);
-
-char *GetAuthMode(char auth);
-
-void RTMPSetHT(struct rt_rtmp_adapter *pAd, struct rt_oid_set_ht_phymode *pHTPhyMode);
-
-void RTMPSetIndividualHT(struct rt_rtmp_adapter *pAd, u8 apidx);
-
-void RTMPSendWirelessEvent(struct rt_rtmp_adapter *pAd,
-			   u16 Event_flag,
-			   u8 *pAddr, u8 BssIdx, char Rssi);
-
-char ConvertToRssi(struct rt_rtmp_adapter *pAd, char Rssi, u8 RssiNumber);
-
-/*===================================
-	Function prototype in cmm_wpa.c
-  =================================== */
-void RTMPToWirelessSta(struct rt_rtmp_adapter *pAd,
-		       struct rt_mac_table_entry *pEntry,
-		       u8 *pHeader802_3,
-		       u32 HdrLen,
-		       u8 *pData,
-		       u32 DataLen, IN BOOLEAN bClearFrame);
-
-void WpaDerivePTK(struct rt_rtmp_adapter *pAd,
-		  u8 *PMK,
-		  u8 *ANonce,
-		  u8 *AA,
-		  u8 *SNonce,
-		  u8 *SA, u8 *output, u32 len);
-
-void GenRandom(struct rt_rtmp_adapter *pAd, u8 *macAddr, u8 *random);
-
-BOOLEAN RTMPCheckWPAframe(struct rt_rtmp_adapter *pAd,
-			  struct rt_mac_table_entry *pEntry,
-			  u8 *pData,
-			  unsigned long DataByteCount, u8 FromWhichBSSID);
-
-void AES_GTK_KEY_UNWRAP(u8 *key,
-			u8 *plaintext,
-			u32 c_len, u8 *ciphertext);
-
-BOOLEAN RTMPParseEapolKeyData(struct rt_rtmp_adapter *pAd,
-			      u8 *pKeyData,
-			      u8 KeyDataLen,
-			      u8 GroupKeyIndex,
-			      u8 MsgType,
-			      IN BOOLEAN bWPA2, struct rt_mac_table_entry *pEntry);
-
-void ConstructEapolMsg(struct rt_mac_table_entry *pEntry,
-		       u8 GroupKeyWepStatus,
-		       u8 MsgType,
-		       u8 DefaultKeyIdx,
-		       u8 *KeyNonce,
-		       u8 *TxRSC,
-		       u8 *GTK,
-		       u8 *RSNIE,
-		       u8 RSNIE_Len, struct rt_eapol_packet *pMsg);
-
-int RTMPSoftDecryptBroadCastData(struct rt_rtmp_adapter *pAd,
-					 struct rt_rx_blk *pRxBlk,
-					 IN NDIS_802_11_ENCRYPTION_STATUS
-					 GroupCipher,
-					 struct rt_cipher_key *pShard_key);
-
-void RTMPMakeRSNIE(struct rt_rtmp_adapter *pAd,
-		   u32 AuthMode, u32 WepStatus, u8 apidx);
-
-/* */
-/* function prototype in ap_wpa.c */
-/* */
-void RTMPGetTxTscFromAsic(struct rt_rtmp_adapter *pAd,
-			  u8 apidx, u8 *pTxTsc);
-
-void APInstallPairwiseKey(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry);
-
-u32 APValidateRSNIE(struct rt_rtmp_adapter *pAd,
-		     struct rt_mac_table_entry *pEntry,
-		     u8 *pRsnIe, u8 rsnie_len);
-
-void HandleCounterMeasure(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry);
-
-void WPAStart4WayHS(struct rt_rtmp_adapter *pAd,
-		    struct rt_mac_table_entry *pEntry, unsigned long TimeInterval);
-
-void WPAStart2WayGroupHS(struct rt_rtmp_adapter *pAd, struct rt_mac_table_entry *pEntry);
-
-void PeerPairMsg1Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem);
-
-void PeerPairMsg2Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem);
-
-void PeerPairMsg3Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem);
-
-void PeerPairMsg4Action(struct rt_rtmp_adapter *pAd,
-			struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem);
-
-void PeerGroupMsg1Action(struct rt_rtmp_adapter *pAd,
-			 struct rt_mac_table_entry *pEntry, struct rt_mlme_queue_elem *Elem);
-
-void PeerGroupMsg2Action(struct rt_rtmp_adapter *pAd,
-			 struct rt_mac_table_entry *pEntry,
-			 void *Msg, u32 MsgLen);
-
-void WpaDeriveGTK(u8 *PMK,
-		  u8 *GNonce,
-		  u8 *AA, u8 *output, u32 len);
-
-void AES_GTK_KEY_WRAP(u8 *key,
-		      u8 *plaintext,
-		      u32 p_len, u8 *ciphertext);
-
-/*typedef void (*TIMER_FUNCTION)(unsigned long); */
-
-/* timeout -- ms */
-void RTMP_SetPeriodicTimer(struct timer_list *pTimer,
-			   IN unsigned long timeout);
-
-void RTMP_OS_Init_Timer(struct rt_rtmp_adapter *pAd,
-			struct timer_list *pTimer,
-			IN TIMER_FUNCTION function, void *data);
-
-void RTMP_OS_Add_Timer(struct timer_list *pTimer,
-		       IN unsigned long timeout);
-
-void RTMP_OS_Mod_Timer(struct timer_list *pTimer,
-		       IN unsigned long timeout);
-
-void RTMP_OS_Del_Timer(struct timer_list *pTimer,
-		       OUT BOOLEAN *pCancelled);
-
-void RTMP_OS_Release_Packet(struct rt_rtmp_adapter *pAd, struct rt_queue_entry *pEntry);
-
-void RTMPusecDelay(unsigned long usec);
-
-int os_alloc_mem(struct rt_rtmp_adapter *pAd,
-			 u8 **mem, unsigned long size);
-
-int os_free_mem(struct rt_rtmp_adapter *pAd, void *mem);
-
-void RTMP_AllocateSharedMemory(struct rt_rtmp_adapter *pAd,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress);
-
-void RTMPFreeTxRxRingMemory(struct rt_rtmp_adapter *pAd);
-
-int AdapterBlockAllocateMemory(void *handle, void **ppAd);
-
-void RTMP_AllocateTxDescMemory(struct rt_rtmp_adapter *pAd,
-			       u32 Index,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress);
-
-void RTMP_AllocateFirstTxBuffer(struct rt_rtmp_adapter *pAd,
-				u32 Index,
-				unsigned long Length,
-				IN BOOLEAN Cached,
-				void **VirtualAddress,
-				dma_addr_t *PhysicalAddress);
-
-void RTMP_FreeFirstTxBuffer(struct rt_rtmp_adapter *pAd,
-			    unsigned long Length,
-			    IN BOOLEAN Cached,
-			    void *VirtualAddress,
-			    dma_addr_t PhysicalAddress);
-
-void RTMP_AllocateMgmtDescMemory(struct rt_rtmp_adapter *pAd,
-				 unsigned long Length,
-				 IN BOOLEAN Cached,
-				 void **VirtualAddress,
-				 dma_addr_t *PhysicalAddress);
-
-void RTMP_AllocateRxDescMemory(struct rt_rtmp_adapter *pAd,
-			       unsigned long Length,
-			       IN BOOLEAN Cached,
-			       void **VirtualAddress,
-			       dma_addr_t *PhysicalAddress);
-
-void RTMP_FreeDescMemory(struct rt_rtmp_adapter *pAd,
-			 unsigned long Length,
-			 void *VirtualAddress,
-			 dma_addr_t PhysicalAddress);
-
-void *RtmpOSNetPktAlloc(struct rt_rtmp_adapter *pAd, IN int size);
-
-void *RTMP_AllocateRxPacketBuffer(struct rt_rtmp_adapter *pAd,
-					 unsigned long Length,
-					 IN BOOLEAN Cached,
-					 void **VirtualAddress,
-					 OUT dma_addr_t *PhysicalAddress);
-
-void *RTMP_AllocateTxPacketBuffer(struct rt_rtmp_adapter *pAd,
-					 unsigned long Length,
-					 IN BOOLEAN Cached,
-					 void **VirtualAddress);
-
-void *RTMP_AllocateFragPacketBuffer(struct rt_rtmp_adapter *pAd,
-					   unsigned long Length);
-
-void RTMP_QueryPacketInfo(void *pPacket,
-			  struct rt_packet_info *pPacketInfo,
-			  u8 **pSrcBufVA, u32 *pSrcBufLen);
-
-void RTMP_QueryNextPacketInfo(void **ppPacket,
-			      struct rt_packet_info *pPacketInfo,
-			      u8 **pSrcBufVA, u32 *pSrcBufLen);
-
-BOOLEAN RTMP_FillTxBlkInfo(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk);
-
-struct rt_rtmp_sg_list *rt_get_sg_list_from_packet(void *pPacket,
-						struct rt_rtmp_sg_list *sg);
-
-void announce_802_3_packet(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-u32 BA_Reorder_AMSDU_Announce(struct rt_rtmp_adapter *pAd, void *pPacket);
-
-struct net_device *get_netdev_from_bssid(struct rt_rtmp_adapter *pAd, u8 FromWhichBSSID);
-
-void *duplicate_pkt(struct rt_rtmp_adapter *pAd,
-			   u8 *pHeader802_3,
-			   u32 HdrLen,
-			   u8 *pData,
-			   unsigned long DataSize, u8 FromWhichBSSID);
-
-void *duplicate_pkt_with_TKIP_MIC(struct rt_rtmp_adapter *pAd,
-					 void *pOldPkt);
-
-void ba_flush_reordering_timeout_mpdus(struct rt_rtmp_adapter *pAd,
-				       struct rt_ba_rec_entry *pBAEntry,
-				       unsigned long Now32);
-
-void BAOriSessionSetUp(struct rt_rtmp_adapter *pAd,
-		       struct rt_mac_table_entry *pEntry,
-		       u8 TID,
-		       u16 TimeOut,
-		       unsigned long DelayTime, IN BOOLEAN isForced);
-
-void BASessionTearDownALL(struct rt_rtmp_adapter *pAd, u8 Wcid);
-
-BOOLEAN OS_Need_Clone_Packet(void);
-
-void build_tx_packet(struct rt_rtmp_adapter *pAd,
-		     void *pPacket,
-		     u8 *pFrame, unsigned long FrameLen);
-
-void BAOriSessionTearDown(struct rt_rtmp_adapter *pAd,
-			  u8 Wcid,
-			  u8 TID,
-			  IN BOOLEAN bPassive, IN BOOLEAN bForceSend);
-
-void BARecSessionTearDown(struct rt_rtmp_adapter *pAd,
-			  u8 Wcid, u8 TID, IN BOOLEAN bPassive);
-
-BOOLEAN ba_reordering_resource_init(struct rt_rtmp_adapter *pAd, int num);
-void ba_reordering_resource_release(struct rt_rtmp_adapter *pAd);
-
-char *rstrtok(char *s, IN const char *ct);
-
-/*//////// common ioctl functions ////////// */
-int SetCommonHT(struct rt_rtmp_adapter *pAd);
-
-int WpaCheckEapCode(struct rt_rtmp_adapter *pAd,
-		    u8 *pFrame, u16 FrameLen, u16 OffSet);
-
-void WpaSendMicFailureToWpaSupplicant(struct rt_rtmp_adapter *pAd,
-				      IN BOOLEAN bUnicast);
-
-int wext_notify_event_assoc(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN STARxDoneInterruptHandle(struct rt_rtmp_adapter *pAd, IN BOOLEAN argc);
-
-/* AMPDU packet indication */
-void Indicate_AMPDU_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-/* AMSDU packet indication */
-void Indicate_AMSDU_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-/* Normal legacy Rx packet indication */
-void Indicate_Legacy_Packet(struct rt_rtmp_adapter *pAd,
-			    struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-void Indicate_EAPOL_Packet(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-void update_os_packet_info(struct rt_rtmp_adapter *pAd,
-			   struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-void wlan_802_11_to_802_3_packet(struct rt_rtmp_adapter *pAd,
-				 struct rt_rx_blk *pRxBlk,
-				 u8 *pHeader802_3,
-				 u8 FromWhichBSSID);
-
-/* remove LLC and get 802_3 Header */
-#define  RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(_pRxBlk, _pHeader802_3)	\
-{																				\
-	u8 *_pRemovedLLCSNAP = NULL, *_pDA, *_pSA;                                 \
-																				\
-	if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_MESH))	{            \
-		_pDA = _pRxBlk->pHeader->Addr3;                                         \
-		_pSA = (u8 *)_pRxBlk->pHeader + sizeof(struct rt_header_802_11);                \
-	}                                                                           \
-	else	{\
-		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_INFRA))	{\
-			_pDA = _pRxBlk->pHeader->Addr1;                                     \
-		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_DLS))									\
-			_pSA = _pRxBlk->pHeader->Addr2;										\
-		else																	\
-			_pSA = _pRxBlk->pHeader->Addr3;                                     \
-		}                                                                       \
-		else	{	\
-			_pDA = _pRxBlk->pHeader->Addr1;                                     \
-			_pSA = _pRxBlk->pHeader->Addr2;                                     \
-		}                                                                       \
-	}                                                                           \
-																				\
-	CONVERT_TO_802_3(_pHeader802_3, _pDA, _pSA, _pRxBlk->pData, 				\
-		_pRxBlk->DataSize, _pRemovedLLCSNAP);                                   \
-}
-
-void Sta_Announce_or_Forward_802_3_Packet(struct rt_rtmp_adapter *pAd,
-					  void *pPacket,
-					  u8 FromWhichBSSID);
-
-#define ANNOUNCE_OR_FORWARD_802_3_PACKET(_pAd, _pPacket, _FromWhichBSS)\
-			Sta_Announce_or_Forward_802_3_Packet(_pAd, _pPacket, _FromWhichBSS);
-			/*announce_802_3_packet(_pAd, _pPacket); */
-
-void *DuplicatePacket(struct rt_rtmp_adapter *pAd,
-			     void *pPacket, u8 FromWhichBSSID);
-
-void *ClonePacket(struct rt_rtmp_adapter *pAd,
-			 void *pPacket,
-			 u8 *pData, unsigned long DataSize);
-
-/* Normal, AMPDU or AMSDU */
-void CmmRxnonRalinkFrameIndicate(struct rt_rtmp_adapter *pAd,
-				 struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-void CmmRxRalinkFrameIndicate(struct rt_rtmp_adapter *pAd,
-			      struct rt_mac_table_entry *pEntry,
-			      struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID);
-
-void Update_Rssi_Sample(struct rt_rtmp_adapter *pAd,
-			struct rt_rssi_sample *pRssi, struct rt_rxwi * pRxWI);
-
-void *GetPacketFromRxRing(struct rt_rtmp_adapter *pAd,
-				 OUT PRT28XX_RXD_STRUC pSaveRxD,
-				 OUT BOOLEAN *pbReschedule,
-				 IN u32 *pRxPending);
-
-void *RTMPDeFragmentDataFrame(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk);
-
-enum {
-	DIDmsg_lnxind_wlansniffrm = 0x00000044,
-	DIDmsg_lnxind_wlansniffrm_hosttime = 0x00010044,
-	DIDmsg_lnxind_wlansniffrm_mactime = 0x00020044,
-	DIDmsg_lnxind_wlansniffrm_channel = 0x00030044,
-	DIDmsg_lnxind_wlansniffrm_rssi = 0x00040044,
-	DIDmsg_lnxind_wlansniffrm_sq = 0x00050044,
-	DIDmsg_lnxind_wlansniffrm_signal = 0x00060044,
-	DIDmsg_lnxind_wlansniffrm_noise = 0x00070044,
-	DIDmsg_lnxind_wlansniffrm_rate = 0x00080044,
-	DIDmsg_lnxind_wlansniffrm_istx = 0x00090044,
-	DIDmsg_lnxind_wlansniffrm_frmlen = 0x000A0044
-};
-enum {
-	P80211ENUM_msgitem_status_no_value = 0x00
-};
-enum {
-	P80211ENUM_truth_false = 0x00,
-	P80211ENUM_truth_true = 0x01
-};
-
-/* Definition from madwifi */
-struct rt_p80211item_uint32 {
-	u32 did;
-	u16 status;
-	u16 len;
-	u32 data;
-};
-
-struct rt_wlan_ng_prism2_header {
-	u32 msgcode;
-	u32 msglen;
-#define WLAN_DEVNAMELEN_MAX 16
-	u8 devname[WLAN_DEVNAMELEN_MAX];
-	struct rt_p80211item_uint32 hosttime;
-	struct rt_p80211item_uint32 mactime;
-	struct rt_p80211item_uint32 channel;
-	struct rt_p80211item_uint32 rssi;
-	struct rt_p80211item_uint32 sq;
-	struct rt_p80211item_uint32 signal;
-	struct rt_p80211item_uint32 noise;
-	struct rt_p80211item_uint32 rate;
-	struct rt_p80211item_uint32 istx;
-	struct rt_p80211item_uint32 frmlen;
-};
-
-/* The radio capture header precedes the 802.11 header. */
-struct PACKED rt_ieee80211_radiotap_header {
-	u8 it_version;	/* Version 0. Only increases
-				 * for drastic changes,
-				 * introduction of compatible
-				 * new fields does not count.
-				 */
-	u8 it_pad;
-	u16 it_len;		/* length of the whole
-				 * header in bytes, including
-				 * it_version, it_pad,
-				 * it_len, and data fields.
-				 */
-	u32 it_present;	/* A bitmap telling which
-				 * fields are present. Set bit 31
-				 * (0x80000000) to extend the
-				 * bitmap by another 32 bits.
-				 * Additional extensions are made
-				 * by setting bit 31.
-				 */
-};
-
-enum ieee80211_radiotap_type {
-	IEEE80211_RADIOTAP_TSFT = 0,
-	IEEE80211_RADIOTAP_FLAGS = 1,
-	IEEE80211_RADIOTAP_RATE = 2,
-	IEEE80211_RADIOTAP_CHANNEL = 3,
-	IEEE80211_RADIOTAP_FHSS = 4,
-	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
-	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
-	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
-	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
-	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
-	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
-	IEEE80211_RADIOTAP_ANTENNA = 11,
-	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
-	IEEE80211_RADIOTAP_DB_ANTNOISE = 13
-};
-
-#define WLAN_RADIOTAP_PRESENT (			\
-	(1 << IEEE80211_RADIOTAP_TSFT)	|	\
-	(1 << IEEE80211_RADIOTAP_FLAGS) |	\
-	(1 << IEEE80211_RADIOTAP_RATE)  | 	\
-	 0)
-
-struct rt_wlan_radiotap_header {
-	struct rt_ieee80211_radiotap_header wt_ihdr;
-	long long wt_tsft;
-	u8 wt_flags;
-	u8 wt_rate;
-};
-/* Definition from madwifi */
-
-void send_monitor_packets(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk);
-
-void RTMPSetDesiredRates(struct rt_rtmp_adapter *pAdapter, long Rates);
-
-int Set_FixedTxMode_Proc(struct rt_rtmp_adapter *pAd, char *arg);
-
-BOOLEAN RT28XXChipsetCheck(IN void *_dev_p);
-
-void RT28XXDMADisable(struct rt_rtmp_adapter *pAd);
-
-void RT28XXDMAEnable(struct rt_rtmp_adapter *pAd);
-
-void RT28xx_UpdateBeaconToAsic(struct rt_rtmp_adapter *pAd,
-			       int apidx,
-			       unsigned long BeaconLen, unsigned long UpdatePos);
-
-int rt28xx_init(struct rt_rtmp_adapter *pAd,
-		char *pDefaultMac, char *pHostName);
-
-int RtmpNetTaskInit(struct rt_rtmp_adapter *pAd);
-
-void RtmpNetTaskExit(struct rt_rtmp_adapter *pAd);
-
-int RtmpMgmtTaskInit(struct rt_rtmp_adapter *pAd);
-
-void RtmpMgmtTaskExit(struct rt_rtmp_adapter *pAd);
-
-void tbtt_tasklet(unsigned long data);
-
-struct net_device *RtmpPhyNetDevInit(struct rt_rtmp_adapter *pAd,
-			   struct rt_rtmp_os_netdev_op_hook *pNetHook);
-
-BOOLEAN RtmpPhyNetDevExit(struct rt_rtmp_adapter *pAd, struct net_device *net_dev);
-
-int RtmpRaDevCtrlInit(struct rt_rtmp_adapter *pAd, IN RTMP_INF_TYPE infType);
-
-BOOLEAN RtmpRaDevCtrlExit(struct rt_rtmp_adapter *pAd);
-
-#ifdef RTMP_MAC_PCI
-/* */
-/* Function Prototype in cmm_data_pci.c */
-/* */
-u16 RtmpPCI_WriteTxResource(struct rt_rtmp_adapter *pAd,
-			       struct rt_tx_blk *pTxBlk,
-			       IN BOOLEAN bIsLast, u16 *FreeNumber);
-
-u16 RtmpPCI_WriteSingleTxResource(struct rt_rtmp_adapter *pAd,
-				     struct rt_tx_blk *pTxBlk,
-				     IN BOOLEAN bIsLast,
-				     u16 *FreeNumber);
-
-u16 RtmpPCI_WriteMultiTxResource(struct rt_rtmp_adapter *pAd,
-				    struct rt_tx_blk *pTxBlk,
-				    u8 frameNum, u16 *FreeNumber);
-
-u16 RtmpPCI_WriteFragTxResource(struct rt_rtmp_adapter *pAd,
-				   struct rt_tx_blk *pTxBlk,
-				   u8 fragNum, u16 *FreeNumber);
-
-u16 RtmpPCI_WriteSubTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  IN BOOLEAN bIsLast, u16 *FreeNumber);
-
-void RtmpPCI_FinalWriteTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  u16 totalMPDUSize,
-				  u16 FirstTxIdx);
-
-void RtmpPCIDataLastTxIdx(struct rt_rtmp_adapter *pAd,
-			  u8 QueIdx, u16 LastTxIdx);
-
-void RtmpPCIDataKickOut(struct rt_rtmp_adapter *pAd,
-			struct rt_tx_blk *pTxBlk, u8 QueIdx);
-
-int RtmpPCIMgmtKickOut(struct rt_rtmp_adapter *pAd,
-		       u8 QueIdx,
-		       void *pPacket,
-		       u8 *pSrcBufVA, u32 SrcBufLen);
-
-int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
-			     struct rt_header_802_11 *pHeader,
-			     struct rt_rxwi *pRxWI, IN PRT28XX_RXD_STRUC pRxD);
-
-BOOLEAN RT28xxPciAsicRadioOff(struct rt_rtmp_adapter *pAd,
-			      u8 Level, u16 TbttNumToNextWakeUp);
-
-BOOLEAN RT28xxPciAsicRadioOn(struct rt_rtmp_adapter *pAd, u8 Level);
-
-void RTMPInitPCIeLinkCtrlValue(struct rt_rtmp_adapter *pAd);
-
-void RTMPFindHostPCIDev(struct rt_rtmp_adapter *pAd);
-
-void RTMPPCIeLinkCtrlValueRestore(struct rt_rtmp_adapter *pAd, u8 Level);
-
-void RTMPPCIeLinkCtrlSetting(struct rt_rtmp_adapter *pAd, u16 Max);
-
-void RTMPrt3xSetPCIePowerLinkCtrl(struct rt_rtmp_adapter *pAd);
-
-void PsPollWakeExec(void *SystemSpecific1,
-		    void *FunctionContext,
-		    void *SystemSpecific2, void *SystemSpecific3);
-
-void RadioOnExec(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3);
-
-void RT28xxPciStaAsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx);
-
-void RT28xxPciStaAsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-					 u16 TbttNumToNextWakeUp);
-
-void RT28xxPciMlmeRadioOn(struct rt_rtmp_adapter *pAd);
-
-void RT28xxPciMlmeRadioOFF(struct rt_rtmp_adapter *pAd);
-#endif /* RTMP_MAC_PCI // */
-
-#ifdef RTMP_MAC_USB
-/* */
-/* Function Prototype in rtusb_bulk.c */
-/* */
-void RTUSBInitTxDesc(struct rt_rtmp_adapter *pAd,
-		     struct rt_tx_context *pTxContext,
-		     u8 BulkOutPipeId, IN usb_complete_t Func);
-
-void RTUSBInitHTTxDesc(struct rt_rtmp_adapter *pAd,
-		       struct rt_ht_tx_context *pTxContext,
-		       u8 BulkOutPipeId,
-		       unsigned long BulkOutSize, IN usb_complete_t Func);
-
-void RTUSBInitRxDesc(struct rt_rtmp_adapter *pAd, struct rt_rx_context *pRxContext);
-
-void RTUSBCleanUpDataBulkOutQueue(struct rt_rtmp_adapter *pAd);
-
-void RTUSBCancelPendingBulkOutIRP(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBulkOutDataPacket(struct rt_rtmp_adapter *pAd,
-			    u8 BulkOutPipeId, u8 Index);
-
-void RTUSBBulkOutNullFrame(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBulkOutRTSFrame(struct rt_rtmp_adapter *pAd);
-
-void RTUSBCancelPendingBulkInIRP(struct rt_rtmp_adapter *pAd);
-
-void RTUSBCancelPendingIRPs(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBulkOutMLMEPacket(struct rt_rtmp_adapter *pAd, u8 Index);
-
-void RTUSBBulkOutPsPoll(struct rt_rtmp_adapter *pAd);
-
-void RTUSBCleanUpMLMEBulkOutQueue(struct rt_rtmp_adapter *pAd);
-
-void RTUSBKickBulkOut(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBulkReceive(struct rt_rtmp_adapter *pAd);
-
-void DoBulkIn(struct rt_rtmp_adapter *pAd);
-
-void RTUSBInitRxDesc(struct rt_rtmp_adapter *pAd, struct rt_rx_context *pRxContext);
-
-void RTUSBBulkRxHandle(IN unsigned long data);
-
-/* */
-/* Function Prototype in rtusb_io.c */
-/* */
-int RTUSBMultiRead(struct rt_rtmp_adapter *pAd,
-			u16 Offset, u8 *pData, u16 length);
-
-int RTUSBMultiWrite(struct rt_rtmp_adapter *pAd,
-		    u16 Offset, const u8 *pData, u16 length);
-
-int RTUSBMultiWrite_OneByte(struct rt_rtmp_adapter *pAd,
-			    u16 Offset, const u8 *pData);
-
-int RTUSBReadBBPRegister(struct rt_rtmp_adapter *pAd,
-			      u8 Id, u8 *pValue);
-
-int RTUSBWriteBBPRegister(struct rt_rtmp_adapter *pAd,
-			       u8 Id, u8 Value);
-
-int RTUSBWriteRFRegister(struct rt_rtmp_adapter *pAd, u32 Value);
-
-int RTUSB_VendorRequest(struct rt_rtmp_adapter *pAd,
-			     u32 TransferFlags,
-			     u8 ReservedBits,
-			     u8 Request,
-			     u16 Value,
-			     u16 Index,
-			     void *TransferBuffer,
-			     u32 TransferBufferLength);
-
-int RTUSBReadEEPROM(struct rt_rtmp_adapter *pAd,
-			 u16 Offset, u8 *pData, u16 length);
-
-int RTUSBWriteEEPROM(struct rt_rtmp_adapter *pAd,
-			  u16 Offset, u8 *pData, u16 length);
-
-void RTUSBPutToSleep(struct rt_rtmp_adapter *pAd);
-
-int RTUSBWakeUp(struct rt_rtmp_adapter *pAd);
-
-void RTUSBInitializeCmdQ(struct rt_cmdq *cmdq);
-
-int RTUSBEnqueueCmdFromNdis(struct rt_rtmp_adapter *pAd,
-				    IN NDIS_OID Oid,
-				    IN BOOLEAN SetInformation,
-				    void *pInformationBuffer,
-				    u32 InformationBufferLength);
-
-int RTUSBEnqueueInternalCmd(struct rt_rtmp_adapter *pAd,
-				    IN NDIS_OID Oid,
-				    void *pInformationBuffer,
-				    u32 InformationBufferLength);
-
-void RTUSBDequeueCmd(struct rt_cmdq *cmdq, struct rt_cmdqelmt * * pcmdqelmt);
-
-int RTUSBCmdThread(IN void *Context);
-
-void RTUSBBssBeaconExit(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBssBeaconStop(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBssBeaconStart(struct rt_rtmp_adapter *pAd);
-
-void RTUSBBssBeaconInit(struct rt_rtmp_adapter *pAd);
-
-void RTUSBWatchDog(struct rt_rtmp_adapter *pAd);
-
-int RTUSBWriteMACRegister(struct rt_rtmp_adapter *pAd,
-			       u16 Offset, u32 Value);
-
-int RTUSBReadMACRegister(struct rt_rtmp_adapter *pAd,
-			      u16 Offset, u32 *pValue);
-
-int RTUSBSingleWrite(struct rt_rtmp_adapter *pAd,
-			  u16 Offset, u16 Value);
-
-int RTUSBFirmwareWrite(struct rt_rtmp_adapter *pAd,
-		       const u8 *pFwImage, unsigned long FwLen);
-
-int RTUSBVenderReset(struct rt_rtmp_adapter *pAd);
-
-int RTUSBSetHardWareRegister(struct rt_rtmp_adapter *pAdapter, void *pBuf);
-
-int RTUSBQueryHardWareRegister(struct rt_rtmp_adapter *pAdapter,
-				       void *pBuf);
-
-void CMDHandler(struct rt_rtmp_adapter *pAd);
-
-int RTUSBWriteHWMACAddress(struct rt_rtmp_adapter *pAdapter);
-
-void MacTableInitialize(struct rt_rtmp_adapter *pAd);
-
-void MlmeSetPsm(struct rt_rtmp_adapter *pAd, u16 psm);
-
-int RTMPWPAAddKeyProc(struct rt_rtmp_adapter *pAd, void *pBuf);
-
-void AsicRxAntEvalAction(struct rt_rtmp_adapter *pAd);
-
-void append_pkt(struct rt_rtmp_adapter *pAd,
-		u8 *pHeader802_3,
-		u32 HdrLen,
-		u8 *pData,
-		unsigned long DataSize, void **ppPacket);
-
-u32 deaggregate_AMSDU_announce(struct rt_rtmp_adapter *pAd,
-				void *pPacket,
-				u8 *pData, unsigned long DataSize);
-
-int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
-			     struct rt_header_802_11 *pHeader,
-			     struct rt_rxwi *pRxWI,
-			     IN PRT28XX_RXD_STRUC pRxINFO);
-
-void RTUSBMlmeHardTransmit(struct rt_rtmp_adapter *pAd, struct rt_mgmt *pMgmt);
-
-int MlmeThread(void *Context);
-
-/* */
-/* Function Prototype in rtusb_data.c */
-/* */
-int RTUSBFreeDescriptorRequest(struct rt_rtmp_adapter *pAd,
-				       u8 BulkOutPipeId,
-				       u32 NumberRequired);
-
-BOOLEAN RTUSBNeedQueueBackForAgg(struct rt_rtmp_adapter *pAd, u8 BulkOutPipeId);
-
-void RTMPWriteTxInfo(struct rt_rtmp_adapter *pAd,
-		     struct rt_txinfo *pTxInfo,
-		     u16 USBDMApktLen,
-		     IN BOOLEAN bWiv,
-		     u8 QueueSel, u8 NextValid, u8 TxBurst);
-
-/* */
-/* Function Prototype in cmm_data_usb.c */
-/* */
-u16 RtmpUSB_WriteSubTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  IN BOOLEAN bIsLast, u16 *FreeNumber);
-
-u16 RtmpUSB_WriteSingleTxResource(struct rt_rtmp_adapter *pAd,
-				     struct rt_tx_blk *pTxBlk,
-				     IN BOOLEAN bIsLast,
-				     u16 *FreeNumber);
-
-u16 RtmpUSB_WriteFragTxResource(struct rt_rtmp_adapter *pAd,
-				   struct rt_tx_blk *pTxBlk,
-				   u8 fragNum, u16 *FreeNumber);
-
-u16 RtmpUSB_WriteMultiTxResource(struct rt_rtmp_adapter *pAd,
-				    struct rt_tx_blk *pTxBlk,
-				    u8 frameNum, u16 *FreeNumber);
-
-void RtmpUSB_FinalWriteTxResource(struct rt_rtmp_adapter *pAd,
-				  struct rt_tx_blk *pTxBlk,
-				  u16 totalMPDUSize, u16 TxIdx);
-
-void RtmpUSBDataLastTxIdx(struct rt_rtmp_adapter *pAd,
-			  u8 QueIdx, u16 TxIdx);
-
-void RtmpUSBDataKickOut(struct rt_rtmp_adapter *pAd,
-			struct rt_tx_blk *pTxBlk, u8 QueIdx);
-
-int RtmpUSBMgmtKickOut(struct rt_rtmp_adapter *pAd,
-		       u8 QueIdx,
-		       void *pPacket,
-		       u8 *pSrcBufVA, u32 SrcBufLen);
-
-void RtmpUSBNullFrameKickOut(struct rt_rtmp_adapter *pAd,
-			     u8 QueIdx,
-			     u8 *pNullFrame, u32 frameLen);
-
-void RtmpUsbStaAsicForceWakeupTimeout(void *SystemSpecific1,
-				      void *FunctionContext,
-				      void *SystemSpecific2,
-				      void *SystemSpecific3);
-
-void RT28xxUsbStaAsicForceWakeup(struct rt_rtmp_adapter *pAd, IN BOOLEAN bFromTx);
-
-void RT28xxUsbStaAsicSleepThenAutoWakeup(struct rt_rtmp_adapter *pAd,
-					 u16 TbttNumToNextWakeUp);
-
-void RT28xxUsbMlmeRadioOn(struct rt_rtmp_adapter *pAd);
-
-void RT28xxUsbMlmeRadioOFF(struct rt_rtmp_adapter *pAd);
-#endif /* RTMP_MAC_USB // */
-
-void AsicTurnOffRFClk(struct rt_rtmp_adapter *pAd, u8 Channel);
-
-void AsicTurnOnRFClk(struct rt_rtmp_adapter *pAd, u8 Channel);
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-int RtmpTimerQThread(IN void *Context);
-
-struct rt_rtmp_timer_task_entry *RtmpTimerQInsert(struct rt_rtmp_adapter *pAd,
-					struct rt_ralink_timer *pTimer);
-
-BOOLEAN RtmpTimerQRemove(struct rt_rtmp_adapter *pAd,
-			 struct rt_ralink_timer *pTimer);
-
-void RtmpTimerQExit(struct rt_rtmp_adapter *pAd);
-
-void RtmpTimerQInit(struct rt_rtmp_adapter *pAd);
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
-
-void AsicStaBbpTuning(struct rt_rtmp_adapter *pAd);
-
-BOOLEAN StaAddMacTableEntry(struct rt_rtmp_adapter *pAd,
-			    struct rt_mac_table_entry *pEntry,
-			    u8 MaxSupportedRateIn500Kbps,
-			    struct rt_ht_capability_ie *pHtCapability,
-			    u8 HtCapabilityLen,
-			    struct rt_add_ht_info_ie *pAddHtInfo,
-			    u8 AddHtInfoLen, u16 CapabilityInfo);
-
-BOOLEAN AUTH_ReqSend(struct rt_rtmp_adapter *pAd,
-		     struct rt_mlme_queue_elem *pElem,
-		     struct rt_ralink_timer *pAuthTimer,
-		     char *pSMName,
-		     u16 SeqNo,
-		     u8 *pNewElement, unsigned long ElementLen);
-
-void RTMP_IndicateMediaState(struct rt_rtmp_adapter *pAd);
-
-void ReSyncBeaconTime(struct rt_rtmp_adapter *pAd);
-
-void RTMPSetAGCInitValue(struct rt_rtmp_adapter *pAd, u8 BandWidth);
-
-int rt28xx_close(struct net_device *dev);
-int rt28xx_open(struct net_device *dev);
-
-#define VIRTUAL_IF_INC(__pAd) ((__pAd)->VirtualIfCnt++)
-#define VIRTUAL_IF_DEC(__pAd) ((__pAd)->VirtualIfCnt--)
-#define VIRTUAL_IF_NUM(__pAd) ((__pAd)->VirtualIfCnt)
-
-#ifdef LINUX
-__inline int VIRTUAL_IF_UP(struct rt_rtmp_adapter *pAd)
-{
-	if (VIRTUAL_IF_NUM(pAd) == 0) {
-		if (rt28xx_open(pAd->net_dev) != 0) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("rt28xx_open return fail!\n"));
-			return -1;
-		}
-	} else {
-	}
-	VIRTUAL_IF_INC(pAd);
-	return 0;
-}
-
-__inline void VIRTUAL_IF_DOWN(struct rt_rtmp_adapter *pAd)
-{
-	VIRTUAL_IF_DEC(pAd);
-	if (VIRTUAL_IF_NUM(pAd) == 0)
-		rt28xx_close(pAd->net_dev);
-	return;
-}
-#endif /* LINUX // */
-
-/*
-	OS Related funciton prototype definitions.
-	TODO: Maybe we need to move these function prototypes to other proper place.
-*/
-int RtmpOSWrielessEventSend(struct rt_rtmp_adapter *pAd,
-			    u32 eventType,
-			    int flags,
-			    u8 *pSrcMac,
-			    u8 *pData, u32 dataLen);
-
-int RtmpOSNetDevAddrSet(struct net_device *pNetDev, u8 *pMacAddr);
-
-int RtmpOSNetDevAttach(struct net_device *pNetDev,
-		       struct rt_rtmp_os_netdev_op_hook *pDevOpHook);
-
-void RtmpOSNetDevClose(struct net_device *pNetDev);
-
-void RtmpOSNetDevDetach(struct net_device *pNetDev);
-
-int RtmpOSNetDevAlloc(struct net_device **pNewNetDev, u32 privDataSize);
-
-void RtmpOSNetDevFree(struct net_device *pNetDev);
-
-struct net_device *RtmpOSNetDevGetByName(struct net_device *pNetDev, char *pDevName);
-
-void RtmpOSNetDeviceRefPut(struct net_device *pNetDev);
-
-struct net_device *RtmpOSNetDevCreate(struct rt_rtmp_adapter *pAd,
-			    int devType,
-			    int devNum,
-			    int privMemSize, char *pNamePrefix);
-
-/*
-	Task operation related function prototypes
-*/
-void RtmpOSTaskCustomize(struct rt_rtmp_os_task *pTask);
-
-int RtmpOSTaskNotifyToExit(struct rt_rtmp_os_task *pTask);
-
-int RtmpOSTaskKill(struct rt_rtmp_os_task *pTask);
-
-int RtmpOSTaskInit(struct rt_rtmp_os_task *pTask,
-			   char *pTaskName, void * pPriv);
-
-int RtmpOSTaskAttach(struct rt_rtmp_os_task *pTask,
-			     IN int (*fn) (void *), IN void *arg);
-
-/*
-	File operation related function prototypes
-*/
-struct file *RtmpOSFileOpen(IN char *pPath, IN int flag, IN int mode);
-
-int RtmpOSFileClose(struct file *osfd);
-
-void RtmpOSFileSeek(struct file *osfd, IN int offset);
-
-int RtmpOSFileRead(struct file *osfd, IN char *pDataPtr, IN int readLen);
-
-int RtmpOSFileWrite(struct file *osfd, IN char *pDataPtr, IN int writeLen);
-
-#endif /* __RTMP_H__ */
diff --git a/drivers/staging/rt2860/rtmp_chip.h b/drivers/staging/rt2860/rtmp_chip.h
deleted file mode 100644
index 0adf2cd..0000000
--- a/drivers/staging/rt2860/rtmp_chip.h
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_chip.h
-
-	Abstract:
-	Ralink Wireless Chip related definition & structures
-
-	Revision History:
-	Who			When		  What
-	--------	----------	  ----------------------------------------------
-*/
-
-#ifndef	__RTMP_CHIP_H__
-#define	__RTMP_CHIP_H__
-
-#include "rtmp_type.h"
-
-#ifdef RT2860
-#include "chip/rt2860.h"
-#endif /* RT2860 // */
-#ifdef RT2870
-#include "chip/rt2870.h"
-#endif /* RT2870 // */
-#ifdef RT3070
-#include "chip/rt3070.h"
-#endif /* RT3070 // */
-#ifdef RT3090
-#include "chip/rt3090.h"
-#endif /* RT3090 // */
-
-/* We will have a cost down version which mac version is 0x3090xxxx */
-/* */
-/* RT3090A facts */
-/* */
-/* a) 2.4 GHz */
-/* b) Replacement for RT3090 */
-/* c) Internal LNA */
-/* d) Interference over channel #14 */
-/* e) New BBP features (e.g., SIG re-modulation) */
-/* */
-#define IS_RT3090A(_pAd)				((((_pAd)->MACVersion & 0xffff0000) == 0x30900000))
-
-/* We will have a cost down version which mac version is 0x3090xxxx */
-#define IS_RT3090(_pAd)				((((_pAd)->MACVersion & 0xffff0000) == 0x30710000) || (IS_RT3090A(_pAd)))
-
-#define IS_RT3070(_pAd)		(((_pAd)->MACVersion & 0xffff0000) == 0x30700000)
-#define IS_RT3071(_pAd)		(((_pAd)->MACVersion & 0xffff0000) == 0x30710000)
-#define IS_RT2070(_pAd)		(((_pAd)->RfIcType == RFIC_2020) || ((_pAd)->EFuseTag == 0x27))
-
-#define IS_RT30xx(_pAd)		(((_pAd)->MACVersion & 0xfff00000) == 0x30700000||IS_RT3090A(_pAd))
-/*#define IS_RT305X(_pAd)               ((_pAd)->MACVersion == 0x28720200) */
-
-/* RT3572, 3592, 3562, 3062 share the same MAC version */
-#define IS_RT3572(_pAd)		(((_pAd)->MACVersion & 0xffff0000) == 0x35720000)
-#define IS_VERSION_BEFORE_F(_pAd)			(((_pAd)->MACVersion&0xffff) <= 0x0211)
-/* F version is 0x0212, E version is 0x0211. 309x can save more power after F version. */
-#define IS_VERSION_AFTER_F(_pAd)			((((_pAd)->MACVersion&0xffff) >= 0x0212) || (((_pAd)->b3090ESpecialChip == TRUE)))
-/* */
-/* RT3390 facts */
-/* */
-/* a) Base on RT3090 (RF IC: RT3020) */
-/* b) 2.4 GHz */
-/* c) 1x1 */
-/* d) Single chip */
-/* e) Internal components: PA and LNA */
-/* */
-/*RT3390,RT3370 */
-#define IS_RT3390(_pAd)				(((_pAd)->MACVersion & 0xFFFF0000) == 0x33900000)
-
-/* ------------------------------------------------------ */
-/* PCI registers - base address 0x0000 */
-/* ------------------------------------------------------ */
-#define CHIP_PCI_CFG		0x0000
-#define CHIP_PCI_EECTRL		0x0004
-#define CHIP_PCI_MCUCTRL	0x0008
-
-#define OPT_14			0x114
-
-#define RETRY_LIMIT		10
-
-/* ------------------------------------------------------ */
-/* BBP & RF     definition */
-/* ------------------------------------------------------ */
-#define	BUSY		                1
-#define	IDLE		                0
-
-/*------------------------------------------------------------------------- */
-/* EEPROM definition */
-/*------------------------------------------------------------------------- */
-#define EEDO                        0x08
-#define EEDI                        0x04
-#define EECS                        0x02
-#define EESK                        0x01
-#define EERL                        0x80
-
-#define EEPROM_WRITE_OPCODE         0x05
-#define EEPROM_READ_OPCODE          0x06
-#define EEPROM_EWDS_OPCODE          0x10
-#define EEPROM_EWEN_OPCODE          0x13
-
-#define NUM_EEPROM_BBP_PARMS		19	/* Include NIC Config 0, 1, CR, TX ALC step, BBPs */
-#define NUM_EEPROM_TX_G_PARMS		7
-#define EEPROM_NIC1_OFFSET          0x34	/* The address is from NIC config 0, not BBP register ID */
-#define EEPROM_NIC2_OFFSET          0x36	/* The address is from NIC config 0, not BBP register ID */
-#define EEPROM_BBP_BASE_OFFSET		0xf0	/* The address is from NIC config 0, not BBP register ID */
-#define EEPROM_G_TX_PWR_OFFSET		0x52
-#define EEPROM_G_TX2_PWR_OFFSET		0x60
-#define EEPROM_LED1_OFFSET			0x3c
-#define EEPROM_LED2_OFFSET			0x3e
-#define EEPROM_LED3_OFFSET			0x40
-#define EEPROM_LNA_OFFSET			0x44
-#define EEPROM_RSSI_BG_OFFSET		0x46
-#define EEPROM_TXMIXER_GAIN_2_4G	0x48
-#define EEPROM_RSSI_A_OFFSET		0x4a
-#define EEPROM_TXMIXER_GAIN_5G		0x4c
-#define EEPROM_DEFINE_MAX_TXPWR		0x4e
-#define EEPROM_TXPOWER_BYRATE_20MHZ_2_4G	0xde	/* 20MHZ 2.4G tx power. */
-#define EEPROM_TXPOWER_BYRATE_40MHZ_2_4G	0xee	/* 40MHZ 2.4G tx power. */
-#define EEPROM_TXPOWER_BYRATE_20MHZ_5G		0xfa	/* 20MHZ 5G tx power. */
-#define EEPROM_TXPOWER_BYRATE_40MHZ_5G		0x10a	/* 40MHZ 5G tx power. */
-#define EEPROM_A_TX_PWR_OFFSET      0x78
-#define EEPROM_A_TX2_PWR_OFFSET      0xa6
-/*#define EEPROM_Japan_TX_PWR_OFFSET      0x90 // 802.11j */
-/*#define EEPROM_Japan_TX2_PWR_OFFSET      0xbe */
-/*#define EEPROM_TSSI_REF_OFFSET        0x54 */
-/*#define EEPROM_TSSI_DELTA_OFFSET      0x24 */
-/*#define EEPROM_CCK_TX_PWR_OFFSET  0x62 */
-/*#define EEPROM_CALIBRATE_OFFSET       0x7c */
-#define EEPROM_VERSION_OFFSET       0x02
-#define EEPROM_FREQ_OFFSET			0x3a
-#define EEPROM_TXPOWER_BYRATE	0xde	/* 20MHZ power. */
-#define EEPROM_TXPOWER_DELTA		0x50	/* 20MHZ AND 40 MHZ use different power. This is delta in 40MHZ. */
-#define VALID_EEPROM_VERSION        1
-
-/*
-  *   EEPROM operation related marcos
-  */
-#define RT28xx_EEPROM_READ16(_pAd, _offset, _value)			\
-	(_pAd)->chipOps.eeread((struct rt_rtmp_adapter *)(_pAd), (u16)(_offset), (u16 *)&(_value))
-
-/* ------------------------------------------------------------------- */
-/*  E2PROM data layout */
-/* ------------------------------------------------------------------- */
-
-/* */
-/* MCU_LEDCS: MCU LED Control Setting. */
-/* */
-typedef union _MCU_LEDCS_STRUC {
-	struct {
-		u8 LedMode:7;
-		u8 Polarity:1;
-	} field;
-	u8 word;
-} MCU_LEDCS_STRUC, *PMCU_LEDCS_STRUC;
-
-/* */
-/* EEPROM antenna select format */
-/* */
-typedef union _EEPROM_ANTENNA_STRUC {
-	struct {
-		u16 RxPath:4;	/* 1: 1R, 2: 2R, 3: 3R */
-		u16 TxPath:4;	/* 1: 1T, 2: 2T */
-		u16 RfIcType:4;	/* see E2PROM document */
-		u16 Rsv:4;
-	} field;
-	u16 word;
-} EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
-
-typedef union _EEPROM_NIC_CINFIG2_STRUC {
-	struct {
-		u16 HardwareRadioControl:1;	/* 1:enable, 0:disable */
-		u16 DynamicTxAgcControl:1;	/* */
-		u16 ExternalLNAForG:1;	/* */
-		u16 ExternalLNAForA:1;	/* external LNA enable for 2.4G */
-		u16 CardbusAcceleration:1;	/* ! NOTE: 0 - enable, 1 - disable */
-		u16 BW40MSidebandForG:1;
-		u16 BW40MSidebandForA:1;
-		u16 EnableWPSPBC:1;	/* WPS PBC Control bit */
-		u16 BW40MAvailForG:1;	/* 0:enable, 1:disable */
-		u16 BW40MAvailForA:1;	/* 0:enable, 1:disable */
-		u16 Rsv1:1;	/* must be 0 */
-		u16 AntDiversity:1;	/* Antenna diversity */
-		u16 Rsv2:3;	/* must be 0 */
-		u16 DACTestBit:1;	/* control if driver should patch the DAC issue */
-	} field;
-	u16 word;
-} EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
-
-/* */
-/* TX_PWR Value valid range 0xFA(-6) ~ 0x24(36) */
-/* */
-typedef union _EEPROM_TX_PWR_STRUC {
-	struct {
-		char Byte0;	/* Low Byte */
-		char Byte1;	/* High Byte */
-	} field;
-	u16 word;
-} EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
-
-typedef union _EEPROM_VERSION_STRUC {
-	struct {
-		u8 FaeReleaseNumber;	/* Low Byte */
-		u8 Version;	/* High Byte */
-	} field;
-	u16 word;
-} EEPROM_VERSION_STRUC, *PEEPROM_VERSION_STRUC;
-
-typedef union _EEPROM_LED_STRUC {
-	struct {
-		u16 PolarityRDY_G:1;	/* Polarity RDY_G setting. */
-		u16 PolarityRDY_A:1;	/* Polarity RDY_A setting. */
-		u16 PolarityACT:1;	/* Polarity ACT setting. */
-		u16 PolarityGPIO_0:1;	/* Polarity GPIO#0 setting. */
-		u16 PolarityGPIO_1:1;	/* Polarity GPIO#1 setting. */
-		u16 PolarityGPIO_2:1;	/* Polarity GPIO#2 setting. */
-		u16 PolarityGPIO_3:1;	/* Polarity GPIO#3 setting. */
-		u16 PolarityGPIO_4:1;	/* Polarity GPIO#4 setting. */
-		u16 LedMode:5;	/* Led mode. */
-		u16 Rsvd:3;	/* Reserved */
-	} field;
-	u16 word;
-} EEPROM_LED_STRUC, *PEEPROM_LED_STRUC;
-
-typedef union _EEPROM_TXPOWER_DELTA_STRUC {
-	struct {
-		u8 DeltaValue:6;	/* Tx Power dalta value (MAX=4) */
-		u8 Type:1;	/* 1: plus the delta value, 0: minus the delta value */
-		u8 TxPowerEnable:1;	/* Enable */
-	} field;
-	u8 value;
-} EEPROM_TXPOWER_DELTA_STRUC, *PEEPROM_TXPOWER_DELTA_STRUC;
-
-#endif /* __RTMP_CHIP_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_ckipmic.h b/drivers/staging/rt2860/rtmp_ckipmic.h
deleted file mode 100644
index 6ff935d..0000000
--- a/drivers/staging/rt2860/rtmp_ckipmic.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_ckipmic.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name		Date			Modification logs
-*/
-#ifndef	__RTMP_CKIPMIC_H__
-#define	__RTMP_CKIPMIC_H__
-
-struct rt_mic_context {
-	/* --- MMH context                            */
-	u8 CK[16];		/* the key                                    */
-	u8 coefficient[16];	/* current aes counter mode coefficients      */
-	unsigned long long accum;	/* accumulated mic, reduced to u32 in final() */
-	u32 position;		/* current position (byte offset) in message  */
-	u8 part[4];		/* for conversion of message to u32 for mmh   */
-};
-
-void xor_128(u8 *a, u8 *b, u8 *out);
-
-u8 RTMPCkipSbox(u8 a);
-
-void xor_32(u8 *a, u8 *b, u8 *out);
-
-void next_key(u8 *key, int round);
-
-void byte_sub(u8 *in, u8 *out);
-
-void shift_row(u8 *in, u8 *out);
-
-void mix_column(u8 *in, u8 *out);
-
-#endif /*__RTMP_CKIPMIC_H__ */
diff --git a/drivers/staging/rt2860/rtmp_def.h b/drivers/staging/rt2860/rtmp_def.h
deleted file mode 100644
index 6ac617e..0000000
--- a/drivers/staging/rt2860/rtmp_def.h
+++ /dev/null
@@ -1,1427 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rtmp_def.h
-
-    Abstract:
-    Miniport related definition header
-
-    Revision History:
-    Who        	 	When          	What
-    --------    ----------    ----------------------------------------------
-    Paul Lin    	08-01-2002    	created
-    John Chang  	08-05-2003    	add definition for 11g & other drafts
-    Justin P. Mattock	11/07/2010	Fix some typos
-*/
-#ifndef __RTMP_DEF_H__
-#define __RTMP_DEF_H__
-
-#include "oid.h"
-
-/* */
-/*  Debug information verbosity: lower values indicate higher urgency */
-/* */
-#define RT_DEBUG_OFF        0
-#define RT_DEBUG_ERROR      1
-#define RT_DEBUG_WARN       2
-#define RT_DEBUG_TRACE      3
-#define RT_DEBUG_INFO       4
-#define RT_DEBUG_LOUD       5
-
-#define NIC_TAG             ((unsigned long)'0682')
-#define NIC_DBG_char      ("**RT28xx**")
-
-#ifdef RTMP_MAC_USB
-#define TX_RING_SIZE            8	/* 1 */
-#define PRIO_RING_SIZE          8
-#define MGMT_RING_SIZE		32	/* PRIO_RING_SIZE */
-#define RX_RING_SIZE            8
-#define MAX_TX_PROCESS          4
-#define LOCAL_TXBUF_SIZE        2048
-#endif /* RTMP_MAC_USB // */
-
-/*#define PACKED */
-
-#define RALINK_2883_VERSION		((u32)0x28830300)
-#define RALINK_2880E_VERSION	((u32)0x28720200)
-#define RALINK_3070_VERSION		((u32)0x30700200)
-
-#define MAX_RX_PKT_LEN	1520
-
-/* */
-/* Entry number for each DMA descriptor ring */
-/* */
-
-#ifdef RTMP_MAC_PCI
-#define TX_RING_SIZE            64	/*64 */
-#define MGMT_RING_SIZE          128
-#define RX_RING_SIZE            128	/*64 */
-#define MAX_TX_PROCESS          TX_RING_SIZE	/*8 */
-#define MAX_DMA_DONE_PROCESS    TX_RING_SIZE
-#define MAX_TX_DONE_PROCESS     TX_RING_SIZE	/*8 */
-#define LOCAL_TXBUF_SIZE        2
-#endif /* RTMP_MAC_PCI // */
-
-#define MAX_RX_PROCESS          128	/*64 //32 */
-#define NUM_OF_LOCAL_TXBUF      2
-#define TXD_SIZE                16
-#define TXWI_SIZE               16
-#define RXD_SIZE               	16
-#define RXWI_SIZE             	16
-/* TXINFO_SIZE + TXWI_SIZE + 802.11 Header Size + AMSDU sub frame header */
-#define TX_DMA_1ST_BUFFER_SIZE  96	/* only the 1st physical buffer is pre-allocated */
-#define MGMT_DMA_BUFFER_SIZE    1536	/*2048 */
-#define RX_BUFFER_AGGRESIZE     3840	/*3904 //3968 //4096 //2048 //4096 */
-#define RX_BUFFER_NORMSIZE      3840	/*3904 //3968 //4096 //2048 //4096 */
-#define TX_BUFFER_NORMSIZE		RX_BUFFER_NORMSIZE
-#define MAX_FRAME_SIZE          2346	/* Maximum 802.11 frame size */
-#define MAX_AGGREGATION_SIZE    3840	/*3904 //3968 //4096 */
-#define MAX_NUM_OF_TUPLE_CACHE  2
-#define MAX_MCAST_LIST_SIZE     32
-#define MAX_LEN_OF_VENDOR_DESC  64
-/*#define MAX_SIZE_OF_MCAST_PSQ   (NUM_OF_LOCAL_TXBUF >> 2) // AP won't spend more than 1/4 of total buffers on M/BCAST PSQ */
-#define MAX_SIZE_OF_MCAST_PSQ               32
-
-#define MAX_RX_PROCESS_CNT	(RX_RING_SIZE)
-
-/*
-	WMM Note: If memory of your system is not much, please reduce the definition;
-	or when you do WMM test, the queue for low priority AC will be full, i.e.
-	TX_RING_SIZE + MAX_PACKETS_IN_QUEUE packets for the AC will be buffered in
-	WLAN, maybe no packet buffers can get into the Ethernet driver.
-
-	Sometimes no packet buffer can be get into the Ethernet driver, the system will
-	send flow control packet to the sender to slow down its sending rate.
-	So no WMM can be seen in the air.
-*/
-
-/*
-	Need to use 64 in vxworks for test case WMM A5-T07
-	Two dnlink (10Mbps) from a WMM station to a non-WMM station.
-	If use 256, queue is not enough.
-	And in rt_main_end.c, clConfig.clNum = RX_RING_SIZE * 3; is changed to
-	clConfig.clNum = RX_RING_SIZE * 4;
-*/
-/* TODO: For VxWorks the size is 256. Shall we change the value as 256 for all OS? */
-#define MAX_PACKETS_IN_QUEUE				(512)	/*(512)    // to pass WMM A5-WPAPSK */
-
-#define MAX_PACKETS_IN_MCAST_PS_QUEUE		32
-#define MAX_PACKETS_IN_PS_QUEUE				128	/*32 */
-#define WMM_NUM_OF_AC                       4	/* AC0, AC1, AC2, and AC3 */
-
-#ifdef RTMP_EFUSE_SUPPORT
-/*2008/09/11:KH add to support efuse<-- */
-#define MAX_EEPROM_BIN_FILE_SIZE					1024
-#define EFUSE_BUFFER_PATH						"/tmp/RT30xxEEPROM.bin"
-/*2008/09/11:KH add to support efuse--> */
-#endif /* RTMP_EFUSE_SUPPORT // */
-
-/* RxFilter */
-#define STANORMAL	 0x17f97
-#define APNORMAL	 0x15f97
-#define PSPXLINK	 0x17f93
-/* */
-/*  struct rt_rtmp_adapter flags */
-/* */
-#define fRTMP_ADAPTER_MAP_REGISTER          0x00000001
-#define fRTMP_ADAPTER_INTERRUPT_IN_USE      0x00000002
-#define fRTMP_ADAPTER_HARDWARE_ERROR        0x00000004
-#define fRTMP_ADAPTER_SCATTER_GATHER        0x00000008
-#define fRTMP_ADAPTER_SEND_PACKET_ERROR     0x00000010
-#define fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS 0x00000020
-#define fRTMP_ADAPTER_HALT_IN_PROGRESS      0x00000040
-#define fRTMP_ADAPTER_RESET_IN_PROGRESS     0x00000080
-#define fRTMP_ADAPTER_NIC_NOT_EXIST         0x00000100
-#define fRTMP_ADAPTER_TX_RING_ALLOCATED     0x00000200
-#define fRTMP_ADAPTER_REMOVE_IN_PROGRESS    0x00000400
-#define fRTMP_ADAPTER_MIMORATE_INUSED       0x00000800
-#define fRTMP_ADAPTER_RX_RING_ALLOCATED     0x00001000
-#define fRTMP_ADAPTER_INTERRUPT_ACTIVE      0x00002000
-#define fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS  0x00004000
-#define	fRTMP_ADAPTER_REASSOC_IN_PROGRESS	0x00008000
-#define	fRTMP_ADAPTER_MEDIA_STATE_PENDING	0x00010000
-#define	fRTMP_ADAPTER_RADIO_OFF				0x00020000
-#define fRTMP_ADAPTER_BULKOUT_RESET			0x00040000
-#define	fRTMP_ADAPTER_BULKIN_RESET			0x00080000
-#define fRTMP_ADAPTER_RDG_ACTIVE			0x00100000
-#define fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE 0x00200000
-#define fRTMP_ADAPTER_SCAN_2040 			0x04000000
-#define	fRTMP_ADAPTER_RADIO_MEASUREMENT		0x08000000
-
-#define fRTMP_ADAPTER_START_UP         		0x10000000	/*Device already initialized and enabled Tx/Rx. */
-#define fRTMP_ADAPTER_MEDIA_STATE_CHANGE    0x20000000
-#define fRTMP_ADAPTER_IDLE_RADIO_OFF        0x40000000
-
-/* */
-/*  STA operation status flags */
-/* */
-#define fOP_STATUS_INFRA_ON                 0x00000001
-#define fOP_STATUS_ADHOC_ON                 0x00000002
-#define fOP_STATUS_BG_PROTECTION_INUSED     0x00000004
-#define fOP_STATUS_SHORT_SLOT_INUSED        0x00000008
-#define fOP_STATUS_SHORT_PREAMBLE_INUSED    0x00000010
-#define fOP_STATUS_RECEIVE_DTIM             0x00000020
-#define fOP_STATUS_MEDIA_STATE_CONNECTED    0x00000080
-#define fOP_STATUS_WMM_INUSED               0x00000100
-#define fOP_STATUS_AGGREGATION_INUSED       0x00000200
-#define fOP_STATUS_DOZE                     0x00000400	/* debug purpose */
-#define fOP_STATUS_PIGGYBACK_INUSED         0x00000800	/* piggy-back, and aggregation */
-#define fOP_STATUS_APSD_INUSED				0x00001000
-#define fOP_STATUS_TX_AMSDU_INUSED			0x00002000
-#define fOP_STATUS_MAX_RETRY_ENABLED		0x00004000
-#define fOP_STATUS_WAKEUP_NOW               0x00008000
-#define fOP_STATUS_PCIE_DEVICE       0x00020000
-#define fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE fOP_STATUS_PCIE_DEVICE
-
-/* */
-/*  struct rt_rtmp_adapter PSFlags : related to advanced power save. */
-/* */
-/* Indicate whether driver can go to sleep mode from now. This flag is useful AFTER link up */
-#define fRTMP_PS_CAN_GO_SLEEP          0x00000001
-/* Indicate whether driver has issue a LinkControl command to PCIe L1 */
-#define fRTMP_PS_SET_PCI_CLK_OFF_COMMAND          0x00000002
-/* Indicate driver should disable kick off hardware to send packets from now. */
-#define fRTMP_PS_DISABLE_TX         0x00000004
-/* Indicate driver should IMMEDIATELY go to sleep after receiving AP's beacon in which doesn't indicate unicate nor multicast packets for me */
-/* This flag is used ONLY in RTMPHandleRxDoneInterrupt routine. */
-#define fRTMP_PS_GO_TO_SLEEP_NOW         0x00000008
-#define fRTMP_PS_TOGGLE_L1		0x00000010	/* Use Toggle L1 mechanism for rt28xx PCIe */
-
-#ifdef RT3090
-#define WAKE_MCU_CMD				0x31
-#define SLEEP_MCU_CMD					0x30
-#define RFOFF_MCU_CMD				0x35
-#endif /* RT3090 // */
-
-#define CCKSETPROTECT		0x1
-#define OFDMSETPROTECT		0x2
-#define MM20SETPROTECT		0x4
-#define MM40SETPROTECT		0x8
-#define GF20SETPROTECT		0x10
-#define GR40SETPROTECT		0x20
-#define ALLN_SETPROTECT		(GR40SETPROTECT | GF20SETPROTECT | MM40SETPROTECT | MM20SETPROTECT)
-
-/* */
-/*  AP's client table operation status flags */
-/* */
-#define fCLIENT_STATUS_WMM_CAPABLE          0x00000001	/* CLIENT can parse QOS DATA frame */
-#define fCLIENT_STATUS_AGGREGATION_CAPABLE  0x00000002	/* CLIENT can receive Ralink's proprietary TX aggregation frame */
-#define fCLIENT_STATUS_PIGGYBACK_CAPABLE    0x00000004	/* CLIENT support piggy-back */
-#define fCLIENT_STATUS_AMSDU_INUSED			0x00000008
-#define fCLIENT_STATUS_SGI20_CAPABLE		0x00000010
-#define fCLIENT_STATUS_SGI40_CAPABLE		0x00000020
-#define fCLIENT_STATUS_TxSTBC_CAPABLE		0x00000040
-#define fCLIENT_STATUS_RxSTBC_CAPABLE		0x00000080
-#define fCLIENT_STATUS_HTC_CAPABLE			0x00000100
-#define fCLIENT_STATUS_RDG_CAPABLE			0x00000200
-#define fCLIENT_STATUS_MCSFEEDBACK_CAPABLE  0x00000400
-#define fCLIENT_STATUS_APSD_CAPABLE         0x00000800	/* UAPSD STATION */
-
-#define fCLIENT_STATUS_RALINK_CHIPSET		0x00100000
-/* */
-/*  STA configuration flags */
-/* */
-
-/* 802.11n Operating Mode Definition. 0-3 also used in ASICUPdateProtect switch case */
-#define HT_NO_PROTECT	0
-#define HT_LEGACY_PROTECT	1
-#define HT_40_PROTECT	2
-#define HT_2040_PROTECT	3
-#define HT_RTSCTS_6M	7
-/*following is our own definition in order to turn on our ASIC protection register in INFRASTRUCTURE. */
-#define HT_ATHEROS	8	/* rt2860c has problem with atheros chip. we need to turn on RTS/CTS . */
-#define HT_FORCERTSCTS	9	/* Force turn on RTS/CTS first. then go to evaluate if this force RTS is necessary. */
-
-/* */
-/* RX Packet Filter control flags. Apply on pAd->PacketFilter */
-/* */
-#define fRX_FILTER_ACCEPT_DIRECT            NDIS_PACKET_TYPE_DIRECTED
-#define fRX_FILTER_ACCEPT_MULTICAST         NDIS_PACKET_TYPE_MULTICAST
-#define fRX_FILTER_ACCEPT_BROADCAST         NDIS_PACKET_TYPE_BROADCAST
-#define fRX_FILTER_ACCEPT_ALL_MULTICAST     NDIS_PACKET_TYPE_ALL_MULTICAST
-#define fRX_FILTER_ACCEPT_PROMISCUOUS       NDIS_PACKET_TYPE_PROMISCUOUS
-
-/* */
-/* Error code section */
-/* */
-/* NDIS_ERROR_CODE_ADAPTER_NOT_FOUND */
-#define ERRLOG_READ_PCI_SLOT_FAILED     0x00000101L
-#define ERRLOG_WRITE_PCI_SLOT_FAILED    0x00000102L
-#define ERRLOG_VENDOR_DEVICE_NOMATCH    0x00000103L
-
-/* NDIS_ERROR_CODE_ADAPTER_DISABLED */
-#define ERRLOG_BUS_MASTER_DISABLED      0x00000201L
-
-/* NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION */
-#define ERRLOG_INVALID_SPEED_DUPLEX     0x00000301L
-#define ERRLOG_SET_SECONDARY_FAILED     0x00000302L
-
-/* NDIS_ERROR_CODE_OUT_OF_RESOURCES */
-#define ERRLOG_OUT_OF_MEMORY            0x00000401L
-#define ERRLOG_OUT_OF_SHARED_MEMORY     0x00000402L
-#define ERRLOG_OUT_OF_MAP_REGISTERS     0x00000403L
-#define ERRLOG_OUT_OF_BUFFER_POOL       0x00000404L
-#define ERRLOG_OUT_OF_NDIS_BUFFER       0x00000405L
-#define ERRLOG_OUT_OF_PACKET_POOL       0x00000406L
-#define ERRLOG_OUT_OF_NDIS_PACKET       0x00000407L
-#define ERRLOG_OUT_OF_LOOKASIDE_MEMORY  0x00000408L
-
-/* NDIS_ERROR_CODE_HARDWARE_FAILURE */
-#define ERRLOG_SELFTEST_FAILED          0x00000501L
-#define ERRLOG_INITIALIZE_ADAPTER       0x00000502L
-#define ERRLOG_REMOVE_MINIPORT          0x00000503L
-
-/* NDIS_ERROR_CODE_RESOURCE_CONFLICT */
-#define ERRLOG_MAP_IO_SPACE             0x00000601L
-#define ERRLOG_QUERY_ADAPTER_RESOURCES  0x00000602L
-#define ERRLOG_NO_IO_RESOURCE           0x00000603L
-#define ERRLOG_NO_INTERRUPT_RESOURCE    0x00000604L
-#define ERRLOG_NO_MEMORY_RESOURCE       0x00000605L
-
-/* WDS definition */
-#define	MAX_WDS_ENTRY               4
-#define WDS_PAIRWISE_KEY_OFFSET     60	/* WDS links use pairwise key#60 ~ 63 in ASIC pairwise key table */
-
-#define	WDS_DISABLE_MODE            0
-#define	WDS_RESTRICT_MODE           1
-#define	WDS_BRIDGE_MODE             2
-#define	WDS_REPEATER_MODE           3
-#define	WDS_LAZY_MODE               4
-
-#define MAX_MESH_NUM				0
-
-#define MAX_APCLI_NUM				0
-
-#define MAX_MBSSID_NUM				1
-#ifdef MBSS_SUPPORT
-#undef	MAX_MBSSID_NUM
-#define MAX_MBSSID_NUM				(8 - MAX_MESH_NUM - MAX_APCLI_NUM)
-#endif /* MBSS_SUPPORT // */
-
-/* sanity check for apidx */
-#define MBSS_MR_APIDX_SANITY_CHECK(apidx) \
-    { if (apidx > MAX_MBSSID_NUM) { \
-          DBGPRINT(RT_DEBUG_ERROR, ("%s> Error! apidx = %d > MAX_MBSSID_NUM!\n", __func__, apidx)); \
-	  apidx = MAIN_MBSSID; } }
-
-#define VALID_WCID(_wcid)	((_wcid) > 0 && (_wcid) < MAX_LEN_OF_MAC_TABLE )
-
-#define MAIN_MBSSID                 0
-#define FIRST_MBSSID                1
-
-#define MAX_BEACON_SIZE				512
-/* If the MAX_MBSSID_NUM is larger than 6, */
-/* it shall reserve some WCID space(wcid 222~253) for beacon frames. */
-/* -    these wcid 238~253 are reserved for beacon#6(ra6). */
-/* -    these wcid 222~237 are reserved for beacon#7(ra7). */
-#if defined(MAX_MBSSID_NUM) && (MAX_MBSSID_NUM == 8)
-#define HW_RESERVED_WCID	222
-#elif defined(MAX_MBSSID_NUM) && (MAX_MBSSID_NUM == 7)
-#define HW_RESERVED_WCID	238
-#else
-#define HW_RESERVED_WCID	255
-#endif
-
-/* Then dedicate wcid of DFS and Carrier-Sense. */
-#define DFS_CTS_WCID 		(HW_RESERVED_WCID - 1)
-#define CS_CTS_WCID 		(HW_RESERVED_WCID - 2)
-#define LAST_SPECIFIC_WCID	(HW_RESERVED_WCID - 2)
-
-/* If MAX_MBSSID_NUM is 8, the maximum available wcid for the associated STA is 211. */
-/* If MAX_MBSSID_NUM is 7, the maximum available wcid for the associated STA is 228. */
-#define MAX_AVAILABLE_CLIENT_WCID	(LAST_SPECIFIC_WCID - MAX_MBSSID_NUM - 1)
-
-/* TX need WCID to find Cipher Key */
-/* these wcid 212 ~ 219 are reserved for bc/mc packets if MAX_MBSSID_NUM is 8. */
-#define GET_GroupKey_WCID(__wcid, __bssidx) \
-	{										\
-		__wcid = LAST_SPECIFIC_WCID - (MAX_MBSSID_NUM) + __bssidx;	\
-	}
-
-#define IsGroupKeyWCID(__wcid) (((__wcid) < LAST_SPECIFIC_WCID) && ((__wcid) >= (LAST_SPECIFIC_WCID - (MAX_MBSSID_NUM))))
-
-/* definition to support multiple BSSID */
-#define BSS0                            0
-#define BSS1                            1
-#define BSS2                            2
-#define BSS3                            3
-#define BSS4                            4
-#define BSS5                            5
-#define BSS6                            6
-#define BSS7                            7
-
-/*============================================================ */
-/* Length definitions */
-#define PEER_KEY_NO                     2
-#define MAC_ADDR_LEN                    6
-#define TIMESTAMP_LEN                   8
-#define MAX_LEN_OF_SUPPORTED_RATES      MAX_LENGTH_OF_SUPPORT_RATES	/* 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54 */
-#define MAX_LEN_OF_KEY                  32	/* 32 octets == 256 bits, Redefine for WPA */
-#define MAX_NUM_OF_CHANNELS             MAX_NUM_OF_CHS	/* 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination */
-#define MAX_NUM_OF_11JCHANNELS             20	/* 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination */
-#define MAX_LEN_OF_SSID                 32
-#define CIPHER_TEXT_LEN                 128
-#define HASH_TABLE_SIZE                 256
-#define MAX_VIE_LEN                     1024	/* New for WPA cipher suite variable IE sizes. */
-#define MAX_SUPPORT_MCS             32
-#define MAX_NUM_OF_BBP_LATCH             140
-
-/*============================================================ */
-/* ASIC WCID Table definition. */
-/*============================================================ */
-#define BSSID_WCID		1	/* in infra mode, always put bssid with this WCID */
-#define MCAST_WCID	0x0
-#define BSS0Mcast_WCID	0x0
-#define BSS1Mcast_WCID	0xf8
-#define BSS2Mcast_WCID	0xf9
-#define BSS3Mcast_WCID	0xfa
-#define BSS4Mcast_WCID	0xfb
-#define BSS5Mcast_WCID	0xfc
-#define BSS6Mcast_WCID	0xfd
-#define BSS7Mcast_WCID	0xfe
-#define RESERVED_WCID		0xff
-
-#define MAX_NUM_OF_ACL_LIST				MAX_NUMBER_OF_ACL
-
-#define MAX_LEN_OF_MAC_TABLE            MAX_NUMBER_OF_MAC	/* if MAX_MBSSID_NUM is 8, this value can't be larger than 211 */
-
-#if MAX_LEN_OF_MAC_TABLE>MAX_AVAILABLE_CLIENT_WCID
-#error MAX_LEN_OF_MAC_TABLE can not be larger than MAX_AVAILABLE_CLIENT_WCID!
-#endif
-
-#define MAX_NUM_OF_WDS_LINK_PERBSSID	            3
-#define MAX_NUM_OF_WDS_LINK	            (MAX_NUM_OF_WDS_LINK_PERBSSID*MAX_MBSSID_NUM)
-#define MAX_NUM_OF_EVENT                MAX_NUMBER_OF_EVENT
-#define WDS_LINK_START_WCID				(MAX_LEN_OF_MAC_TABLE-1)
-
-#define NUM_OF_TID			8
-#define MAX_AID_BA                    4
-#define MAX_LEN_OF_BA_REC_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)	/*   (NUM_OF_TID*MAX_AID_BA + 32)        //Block ACK recipient */
-#define MAX_LEN_OF_BA_ORI_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)	/*   (NUM_OF_TID*MAX_AID_BA + 32)   // Block ACK originator */
-#define MAX_LEN_OF_BSS_TABLE             64
-#define MAX_REORDERING_MPDU_NUM			 512
-
-/* key related definitions */
-#define SHARE_KEY_NUM                   4
-#define MAX_LEN_OF_SHARE_KEY            16	/* byte count */
-#define MAX_LEN_OF_PEER_KEY             16	/* byte count */
-#define PAIRWISE_KEY_NUM                64	/* in MAC ASIC pairwise key table */
-#define GROUP_KEY_NUM                   4
-#define PMK_LEN                         32
-#define WDS_PAIRWISE_KEY_OFFSET         60	/* WDS links uses pairwise key#60 ~ 63 in ASIC pairwise key table */
-#define	PMKID_NO                        4	/* Number of PMKID saved supported */
-#define MAX_LEN_OF_MLME_BUFFER          2048
-
-/* power status related definitions */
-#define PWR_ACTIVE                      0
-#define PWR_SAVE                        1
-#define PWR_MMPS                        2	/*MIMO power save */
-
-/* Auth and Assoc mode related definitions */
-#define AUTH_MODE_OPEN                  0x00
-#define AUTH_MODE_KEY                   0x01
-
-/* BSS Type definitions */
-#define BSS_ADHOC                       0	/* = Ndis802_11IBSS */
-#define BSS_INFRA                       1	/* = Ndis802_11Infrastructure */
-#define BSS_ANY                         2	/* = Ndis802_11AutoUnknown */
-#define BSS_MONITOR			            3	/* = Ndis802_11Monitor */
-
-/* Reason code definitions */
-#define REASON_RESERVED                 0
-#define REASON_UNSPECIFY                1
-#define REASON_NO_longER_VALID          2
-#define REASON_DEAUTH_STA_LEAVING       3
-#define REASON_DISASSOC_INACTIVE        4
-#define REASON_DISASSPC_AP_UNABLE       5
-#define REASON_CLS2ERR                  6
-#define REASON_CLS3ERR                  7
-#define REASON_DISASSOC_STA_LEAVING     8
-#define REASON_STA_REQ_ASSOC_NOT_AUTH   9
-#define REASON_INVALID_IE               13
-#define REASON_MIC_FAILURE              14
-#define REASON_4_WAY_TIMEOUT            15
-#define REASON_GROUP_KEY_HS_TIMEOUT     16
-#define REASON_IE_DIFFERENT             17
-#define REASON_MCIPHER_NOT_VALID        18
-#define REASON_UCIPHER_NOT_VALID        19
-#define REASON_AKMP_NOT_VALID           20
-#define REASON_UNSUPPORT_RSNE_VER       21
-#define REASON_INVALID_RSNE_CAP         22
-#define REASON_8021X_AUTH_FAIL          23
-#define REASON_CIPHER_SUITE_REJECTED    24
-#define REASON_DECLINED                 37
-
-#define REASON_QOS_UNSPECIFY              32
-#define REASON_QOS_LACK_BANDWIDTH         33
-#define REASON_POOR_CHANNEL_CONDITION     34
-#define REASON_QOS_OUTSIDE_TXOP_LIMITION  35
-#define REASON_QOS_QSTA_LEAVING_QBSS      36
-#define REASON_QOS_UNWANTED_MECHANISM     37
-#define REASON_QOS_MECH_SETUP_REQUIRED    38
-#define REASON_QOS_REQUEST_TIMEOUT        39
-#define REASON_QOS_CIPHER_NOT_SUPPORT     45
-
-/* Status code definitions */
-#define MLME_SUCCESS                    0
-#define MLME_UNSPECIFY_FAIL             1
-#define MLME_CANNOT_SUPPORT_CAP         10
-#define MLME_REASSOC_DENY_ASSOC_EXIST   11
-#define MLME_ASSOC_DENY_OUT_SCOPE       12
-#define MLME_ALG_NOT_SUPPORT            13
-#define MLME_SEQ_NR_OUT_OF_SEQUENCE     14
-#define MLME_REJ_CHALLENGE_FAILURE      15
-#define MLME_REJ_TIMEOUT                  16
-#define MLME_ASSOC_REJ_UNABLE_HANDLE_STA  17
-#define MLME_ASSOC_REJ_DATA_RATE          18
-
-#define MLME_ASSOC_REJ_NO_EXT_RATE        22
-#define MLME_ASSOC_REJ_NO_EXT_RATE_PBCC   23
-#define MLME_ASSOC_REJ_NO_CCK_OFDM        24
-
-#define MLME_QOS_UNSPECIFY                32
-#define MLME_REQUEST_DECLINED             37
-#define MLME_REQUEST_WITH_INVALID_PARAM   38
-#define MLME_INVALID_GROUP_CIPHER	  41
-#define MLME_INVALID_PAIRWISE_CIPHER	  42
-#define MLME_INVALID_AKMP			  43
-#define MLME_DLS_NOT_ALLOW_IN_QBSS        48
-#define MLME_DEST_STA_NOT_IN_QBSS         49
-#define MLME_DEST_STA_IS_NOT_A_QSTA       50
-
-#define MLME_INVALID_FORMAT             0x51
-#define MLME_FAIL_NO_RESOURCE           0x52
-#define MLME_STATE_MACHINE_REJECT       0x53
-#define MLME_MAC_TABLE_FAIL             0x54
-
-/* IE code */
-#define IE_SSID                         0
-#define IE_SUPP_RATES                   1
-#define IE_FH_PARM                      2
-#define IE_DS_PARM                      3
-#define IE_CF_PARM                      4
-#define IE_TIM                          5
-#define IE_IBSS_PARM                    6
-#define IE_COUNTRY                      7	/* 802.11d */
-#define IE_802_11D_REQUEST              10	/* 802.11d */
-#define IE_QBSS_LOAD                    11	/* 802.11e d9 */
-#define IE_EDCA_PARAMETER               12	/* 802.11e d9 */
-#define IE_TSPEC                        13	/* 802.11e d9 */
-#define IE_TCLAS                        14	/* 802.11e d9 */
-#define IE_SCHEDULE                     15	/* 802.11e d9 */
-#define IE_CHALLENGE_TEXT               16
-#define IE_POWER_CONSTRAint             32	/* 802.11h d3.3 */
-#define IE_POWER_CAPABILITY             33	/* 802.11h d3.3 */
-#define IE_TPC_REQUEST                  34	/* 802.11h d3.3 */
-#define IE_TPC_REPORT                   35	/* 802.11h d3.3 */
-#define IE_SUPP_CHANNELS                36	/* 802.11h d3.3 */
-#define IE_CHANNEL_SWITCH_ANNOUNCEMENT  37	/* 802.11h d3.3 */
-#define IE_MEASUREMENT_REQUEST          38	/* 802.11h d3.3 */
-#define IE_MEASUREMENT_REPORT           39	/* 802.11h d3.3 */
-#define IE_QUIET                        40	/* 802.11h d3.3 */
-#define IE_IBSS_DFS                     41	/* 802.11h d3.3 */
-#define IE_ERP                          42	/* 802.11g */
-#define IE_TS_DELAY                     43	/* 802.11e d9 */
-#define IE_TCLAS_PROCESSING             44	/* 802.11e d9 */
-#define IE_QOS_CAPABILITY               46	/* 802.11e d6 */
-#define IE_HT_CAP                       45	/* 802.11n d1. HT CAPABILITY. ELEMENT ID TBD */
-#define IE_AP_CHANNEL_REPORT			51	/* 802.11k d6 */
-#define IE_HT_CAP2                         52	/* 802.11n d1. HT CAPABILITY. ELEMENT ID TBD */
-#define IE_RSN                          48	/* 802.11i d3.0 */
-#define IE_WPA2                         48	/* WPA2 */
-#define IE_EXT_SUPP_RATES               50	/* 802.11g */
-#define IE_SUPP_REG_CLASS               59	/* 802.11y. Supported regulatory classes. */
-#define IE_EXT_CHANNEL_SWITCH_ANNOUNCEMENT	60	/* 802.11n */
-#define IE_ADD_HT                         61	/* 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD */
-#define IE_ADD_HT2                        53	/* 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD */
-
-/* For 802.11n D3.03 */
-/*#define IE_NEW_EXT_CHA_OFFSET             62    // 802.11n d1. New extension channel offset element */
-#define IE_SECONDARY_CH_OFFSET		62	/* 802.11n D3.03        Secondary Channel Offset element */
-#define IE_WAPI							68	/* WAPI information element */
-#define IE_2040_BSS_COEXIST               72	/* 802.11n D3.0.3 */
-#define IE_2040_BSS_INTOLERANT_REPORT     73	/* 802.11n D3.03 */
-#define IE_OVERLAPBSS_SCAN_PARM           74	/* 802.11n D3.03 */
-#define IE_EXT_CAPABILITY                127	/* 802.11n D3.03 */
-
-#define IE_WPA                          221	/* WPA */
-#define IE_VENDOR_SPECIFIC              221	/* Wifi WMM (WME) */
-
-#define OUI_BROADCOM_HT              51	/* */
-#define OUI_BROADCOM_HTADD              52	/* */
-#define OUI_PREN_HT_CAP              51	/* */
-#define OUI_PREN_ADD_HT              52	/* */
-
-/* CCX information */
-#define IE_AIRONET_CKIP                 133	/* CCX1.0 ID 85H for CKIP */
-#define IE_AP_TX_POWER                  150	/* CCX 2.0 for AP transmit power */
-#define IE_MEASUREMENT_CAPABILITY       221	/* CCX 2.0 */
-#define IE_CCX_V2                       221
-#define IE_AIRONET_IPADDRESS            149	/* CCX ID 95H for IP Address */
-#define IE_AIRONET_CCKMREASSOC          156	/* CCX ID 9CH for CCKM Reassociation Request element */
-#define CKIP_NEGOTIATION_LENGTH         30
-#define AIRONET_IPADDRESS_LENGTH        10
-#define AIRONET_CCKMREASSOC_LENGTH      24
-
-/* ======================================================== */
-/* MLME state machine definition */
-/* ======================================================== */
-
-/* STA MLME state mahcines */
-#define ASSOC_STATE_MACHINE             1
-#define AUTH_STATE_MACHINE              2
-#define AUTH_RSP_STATE_MACHINE          3
-#define SYNC_STATE_MACHINE              4
-#define MLME_CNTL_STATE_MACHINE         5
-#define WPA_PSK_STATE_MACHINE           6
-/*#define LEAP_STATE_MACHINE              7 */
-#define AIRONET_STATE_MACHINE           8
-#define ACTION_STATE_MACHINE           9
-
-/* AP MLME state machines */
-#define AP_ASSOC_STATE_MACHINE          11
-#define AP_AUTH_STATE_MACHINE           12
-#define AP_SYNC_STATE_MACHINE           14
-#define AP_CNTL_STATE_MACHINE           15
-#define WSC_STATE_MACHINE            17
-#define WSC_UPNP_STATE_MACHINE		    18
-
-#define WPA_STATE_MACHINE			23
-
-/* */
-/* STA's CONTROL/CONNECT state machine: states, events, total function # */
-/* */
-#define CNTL_IDLE                       0
-#define CNTL_WAIT_DISASSOC              1
-#define CNTL_WAIT_JOIN                  2
-#define CNTL_WAIT_REASSOC               3
-#define CNTL_WAIT_START                 4
-#define CNTL_WAIT_AUTH                  5
-#define CNTL_WAIT_ASSOC                 6
-#define CNTL_WAIT_AUTH2                 7
-#define CNTL_WAIT_OID_LIST_SCAN         8
-#define CNTL_WAIT_OID_DISASSOC          9
-#ifdef RTMP_MAC_USB
-#define CNTL_WAIT_SCAN_FOR_CONNECT      10
-#endif /* RTMP_MAC_USB // */
-
-#define MT2_ASSOC_CONF                  34
-#define MT2_AUTH_CONF                   35
-#define MT2_DEAUTH_CONF                 36
-#define MT2_DISASSOC_CONF               37
-#define MT2_REASSOC_CONF                38
-#define MT2_PWR_MGMT_CONF               39
-#define MT2_JOIN_CONF                   40
-#define MT2_SCAN_CONF                   41
-#define MT2_START_CONF                  42
-#define MT2_GET_CONF                    43
-#define MT2_SET_CONF                    44
-#define MT2_RESET_CONF                  45
-#define MT2_FT_OTD_CONF					46
-#define MT2_MLME_ROAMING_REQ            52
-
-#define CNTL_FUNC_SIZE                  1
-
-/* */
-/* STA's ASSOC state machine: states, events, total function # */
-/* */
-#define ASSOC_IDLE                      0
-#define ASSOC_WAIT_RSP                  1
-#define REASSOC_WAIT_RSP                2
-#define DISASSOC_WAIT_RSP               3
-#define MAX_ASSOC_STATE                 4
-
-#define ASSOC_MACHINE_BASE              0
-#define MT2_MLME_ASSOC_REQ              0
-#define MT2_MLME_REASSOC_REQ            1
-#define MT2_MLME_DISASSOC_REQ           2
-#define MT2_PEER_DISASSOC_REQ           3
-#define MT2_PEER_ASSOC_REQ              4
-#define MT2_PEER_ASSOC_RSP              5
-#define MT2_PEER_REASSOC_REQ            6
-#define MT2_PEER_REASSOC_RSP            7
-#define MT2_DISASSOC_TIMEOUT            8
-#define MT2_ASSOC_TIMEOUT               9
-#define MT2_REASSOC_TIMEOUT             10
-#define MAX_ASSOC_MSG                   11
-
-#define ASSOC_FUNC_SIZE                 (MAX_ASSOC_STATE * MAX_ASSOC_MSG)
-
-/* */
-/* ACT state machine: states, events, total function # */
-/* */
-#define ACT_IDLE                      0
-#define MAX_ACT_STATE                 1
-
-#define ACT_MACHINE_BASE              0
-
-/*Those PEER_xx_CATE number is based on real Categary value in IEEE spec. Please do not modify it by your self. */
-/*Category */
-#define MT2_PEER_SPECTRUM_CATE              0
-#define MT2_PEER_QOS_CATE              1
-#define MT2_PEER_DLS_CATE             2
-#define MT2_PEER_BA_CATE             3
-#define MT2_PEER_PUBLIC_CATE             4
-#define MT2_PEER_RM_CATE             5
-/* "FT_CATEGORY_BSS_TRANSITION equal to 6" is defined file of "dot11r_ft.h" */
-#define MT2_PEER_HT_CATE             7	/*      7.4.7 */
-#define MAX_PEER_CATE_MSG                   7
-
-#define MT2_MLME_ADD_BA_CATE             8
-#define MT2_MLME_ORI_DELBA_CATE             9
-#define MT2_MLME_REC_DELBA_CATE             10
-#define MT2_MLME_QOS_CATE              11
-#define MT2_MLME_DLS_CATE             12
-#define MT2_ACT_INVALID             13
-#define MAX_ACT_MSG                   14
-
-/*Category field */
-#define CATEGORY_SPECTRUM		0
-#define CATEGORY_QOS			1
-#define CATEGORY_DLS			2
-#define CATEGORY_BA			3
-#define CATEGORY_PUBLIC		4
-#define CATEGORY_RM			5
-#define CATEGORY_HT			7
-
-/* DLS Action frame definition */
-#define ACTION_DLS_REQUEST			0
-#define ACTION_DLS_RESPONSE			1
-#define ACTION_DLS_TEARDOWN			2
-
-/*Spectrum  Action field value 802.11h 7.4.1 */
-#define SPEC_MRQ	0	/* Request */
-#define SPEC_MRP	1	/*Report */
-#define SPEC_TPCRQ	2
-#define SPEC_TPCRP	3
-#define SPEC_CHANNEL_SWITCH	4
-
-/*BA  Action field value */
-#define ADDBA_REQ	0
-#define ADDBA_RESP	1
-#define DELBA   2
-
-/*Public's  Action field value in Public Category.  Some in 802.11y and some in 11n */
-#define ACTION_BSS_2040_COEXIST				0	/* 11n */
-#define ACTION_DSE_ENABLEMENT					1	/* 11y D9.0 */
-#define ACTION_DSE_DEENABLEMENT				2	/* 11y D9.0 */
-#define ACTION_DSE_REG_LOCATION_ANNOUNCE	3	/* 11y D9.0 */
-#define ACTION_EXT_CH_SWITCH_ANNOUNCE		4	/* 11y D9.0 */
-#define ACTION_DSE_MEASUREMENT_REQ			5	/* 11y D9.0 */
-#define ACTION_DSE_MEASUREMENT_REPORT		6	/* 11y D9.0 */
-#define ACTION_MEASUREMENT_PILOT_ACTION		7	/* 11y D9.0 */
-#define ACTION_DSE_POWER_CONSTRAINT			8	/* 11y D9.0 */
-
-/*HT  Action field value */
-#define NOTIFY_BW_ACTION				0
-#define SMPS_ACTION						1
-#define PSMP_ACTION   					2
-#define SETPCO_ACTION					3
-#define MIMO_CHA_MEASURE_ACTION			4
-#define MIMO_N_BEACONFORM				5
-#define MIMO_BEACONFORM					6
-#define ANTENNA_SELECT					7
-#define HT_INFO_EXCHANGE				8
-
-#define ACT_FUNC_SIZE                 (MAX_ACT_STATE * MAX_ACT_MSG)
-/* */
-/* STA's AUTHENTICATION state machine: states, events, total function # */
-/* */
-#define AUTH_REQ_IDLE                   0
-#define AUTH_WAIT_SEQ2                  1
-#define AUTH_WAIT_SEQ4                  2
-#define MAX_AUTH_STATE                  3
-
-#define AUTH_MACHINE_BASE               0
-#define MT2_MLME_AUTH_REQ               0
-#define MT2_PEER_AUTH_EVEN              1
-#define MT2_AUTH_TIMEOUT                2
-#define MAX_AUTH_MSG                    3
-
-#define AUTH_FUNC_SIZE                  (MAX_AUTH_STATE * MAX_AUTH_MSG)
-
-/* */
-/* STA's AUTH_RSP state machine: states, events, total function # */
-/* */
-#define AUTH_RSP_IDLE                   0
-#define AUTH_RSP_WAIT_CHAL              1
-#define MAX_AUTH_RSP_STATE              2
-
-#define AUTH_RSP_MACHINE_BASE           0
-#define MT2_AUTH_CHALLENGE_TIMEOUT      0
-#define MT2_PEER_AUTH_ODD               1
-#define MT2_PEER_DEAUTH                 2
-#define MAX_AUTH_RSP_MSG                3
-
-#define AUTH_RSP_FUNC_SIZE              (MAX_AUTH_RSP_STATE * MAX_AUTH_RSP_MSG)
-
-/* */
-/* STA's SYNC state machine: states, events, total function # */
-/* */
-#define SYNC_IDLE                       0	/* merge NO_BSS,IBSS_IDLE,IBSS_ACTIVE and BSS in to 1 state */
-#define JOIN_WAIT_BEACON                1
-#define SCAN_LISTEN                     2
-#define MAX_SYNC_STATE                  3
-
-#define SYNC_MACHINE_BASE               0
-#define MT2_MLME_SCAN_REQ               0
-#define MT2_MLME_JOIN_REQ               1
-#define MT2_MLME_START_REQ              2
-#define MT2_PEER_BEACON                 3
-#define MT2_PEER_PROBE_RSP              4
-#define MT2_PEER_ATIM                   5
-#define MT2_SCAN_TIMEOUT                6
-#define MT2_BEACON_TIMEOUT              7
-#define MT2_ATIM_TIMEOUT                8
-#define MT2_PEER_PROBE_REQ              9
-#define MAX_SYNC_MSG                    10
-
-#define SYNC_FUNC_SIZE                  (MAX_SYNC_STATE * MAX_SYNC_MSG)
-
-/*Messages for the DLS state machine */
-#define DLS_IDLE						0
-#define MAX_DLS_STATE					1
-
-#define DLS_MACHINE_BASE				0
-#define MT2_MLME_DLS_REQ			    0
-#define MT2_PEER_DLS_REQ			    1
-#define MT2_PEER_DLS_RSP			    2
-#define MT2_MLME_DLS_TEAR_DOWN		    3
-#define MT2_PEER_DLS_TEAR_DOWN		    4
-#define MAX_DLS_MSG				        5
-
-#define DLS_FUNC_SIZE					(MAX_DLS_STATE * MAX_DLS_MSG)
-
-/* */
-/* WSC State machine: states, events, total function # */
-/* */
-
-/* */
-/* AP's CONTROL/CONNECT state machine: states, events, total function # */
-/* */
-#define AP_CNTL_FUNC_SIZE               1
-
-/* */
-/* AP's ASSOC state machine: states, events, total function # */
-/* */
-#define AP_ASSOC_IDLE                   0
-#define AP_MAX_ASSOC_STATE              1
-
-#define AP_ASSOC_MACHINE_BASE           0
-#define APMT2_MLME_DISASSOC_REQ         0
-#define APMT2_PEER_DISASSOC_REQ         1
-#define APMT2_PEER_ASSOC_REQ            2
-#define APMT2_PEER_REASSOC_REQ          3
-#define APMT2_CLS3ERR                   4
-#define AP_MAX_ASSOC_MSG                5
-
-#define AP_ASSOC_FUNC_SIZE              (AP_MAX_ASSOC_STATE * AP_MAX_ASSOC_MSG)
-
-/* */
-/* AP's AUTHENTICATION state machine: states, events, total function # */
-/* */
-#define AP_AUTH_REQ_IDLE                0
-#define AP_MAX_AUTH_STATE               1
-
-#define AP_AUTH_MACHINE_BASE            0
-#define APMT2_MLME_DEAUTH_REQ           0
-#define APMT2_CLS2ERR                   1
-#define APMT2_PEER_DEAUTH               2
-#define APMT2_PEER_AUTH_REQ				3
-#define APMT2_PEER_AUTH_CONFIRM			4
-#define AP_MAX_AUTH_MSG                 5
-
-#define AP_AUTH_FUNC_SIZE               (AP_MAX_AUTH_STATE * AP_MAX_AUTH_MSG)
-
-/* */
-/* AP's SYNC state machine: states, events, total function # */
-/* */
-#define AP_SYNC_IDLE                    0
-#define AP_SCAN_LISTEN					1
-#define AP_MAX_SYNC_STATE               2
-
-#define AP_SYNC_MACHINE_BASE            0
-#define APMT2_PEER_PROBE_REQ            0
-#define APMT2_PEER_BEACON               1
-#define APMT2_MLME_SCAN_REQ				2
-#define APMT2_PEER_PROBE_RSP			3
-#define APMT2_SCAN_TIMEOUT				4
-#define APMT2_MLME_SCAN_CNCL			5
-#define AP_MAX_SYNC_MSG                 6
-
-#define AP_SYNC_FUNC_SIZE               (AP_MAX_SYNC_STATE * AP_MAX_SYNC_MSG)
-
-/* */
-/* Common WPA state machine: states, events, total function # */
-/* */
-#define WPA_PTK                      0
-#define MAX_WPA_PTK_STATE            1
-
-#define WPA_MACHINE_BASE             0
-#define MT2_EAPPacket                0
-#define MT2_EAPOLStart               1
-#define MT2_EAPOLLogoff              2
-#define MT2_EAPOLKey                 3
-#define MT2_EAPOLASFAlert            4
-#define MAX_WPA_MSG                  5
-
-#define WPA_FUNC_SIZE                (MAX_WPA_PTK_STATE * MAX_WPA_MSG)
-
-/* ============================================================================= */
-
-/* value domain of 802.11 header FC.Tyte, which is b3..b2 of the 1st-byte of MAC header */
-#define BTYPE_MGMT                  0
-#define BTYPE_CNTL                  1
-#define BTYPE_DATA                  2
-
-/* value domain of 802.11 MGMT frame's FC.subtype, which is b7..4 of the 1st-byte of MAC header */
-#define SUBTYPE_ASSOC_REQ           0
-#define SUBTYPE_ASSOC_RSP           1
-#define SUBTYPE_REASSOC_REQ         2
-#define SUBTYPE_REASSOC_RSP         3
-#define SUBTYPE_PROBE_REQ           4
-#define SUBTYPE_PROBE_RSP           5
-#define SUBTYPE_BEACON              8
-#define SUBTYPE_ATIM                9
-#define SUBTYPE_DISASSOC            10
-#define SUBTYPE_AUTH                11
-#define SUBTYPE_DEAUTH              12
-#define SUBTYPE_ACTION              13
-#define SUBTYPE_ACTION_NO_ACK              14
-
-/* value domain of 802.11 CNTL frame's FC.subtype, which is b7..4 of the 1st-byte of MAC header */
-#define SUBTYPE_WRAPPER       	7
-#define SUBTYPE_BLOCK_ACK_REQ       8
-#define SUBTYPE_BLOCK_ACK           9
-#define SUBTYPE_PS_POLL             10
-#define SUBTYPE_RTS                 11
-#define SUBTYPE_CTS                 12
-#define SUBTYPE_ACK                 13
-#define SUBTYPE_CFEND               14
-#define SUBTYPE_CFEND_CFACK         15
-
-/* value domain of 802.11 DATA frame's FC.subtype, which is b7..4 of the 1st-byte of MAC header */
-#define SUBTYPE_DATA                0
-#define SUBTYPE_DATA_CFACK          1
-#define SUBTYPE_DATA_CFPOLL         2
-#define SUBTYPE_DATA_CFACK_CFPOLL   3
-#define SUBTYPE_NULL_FUNC           4
-#define SUBTYPE_CFACK               5
-#define SUBTYPE_CFPOLL              6
-#define SUBTYPE_CFACK_CFPOLL        7
-#define SUBTYPE_QDATA               8
-#define SUBTYPE_QDATA_CFACK         9
-#define SUBTYPE_QDATA_CFPOLL        10
-#define SUBTYPE_QDATA_CFACK_CFPOLL  11
-#define SUBTYPE_QOS_NULL            12
-#define SUBTYPE_QOS_CFACK           13
-#define SUBTYPE_QOS_CFPOLL          14
-#define SUBTYPE_QOS_CFACK_CFPOLL    15
-
-/* ACK policy of QOS Control field bit 6:5 */
-#define NORMAL_ACK                  0x00	/* b6:5 = 00 */
-#define NO_ACK                      0x20	/* b6:5 = 01 */
-#define NO_EXPLICIT_ACK             0x40	/* b6:5 = 10 */
-#define BLOCK_ACK                   0x60	/* b6:5 = 11 */
-
-/* */
-/* rtmp_data.c uses this definition */
-/* */
-#define LENGTH_802_11               24
-#define LENGTH_802_11_AND_H         30
-#define LENGTH_802_11_CRC_H         34
-#define LENGTH_802_11_CRC           28
-#define LENGTH_802_11_WITH_ADDR4    30
-#define LENGTH_802_3                14
-#define LENGTH_802_3_TYPE           2
-#define LENGTH_802_1_H              8
-#define LENGTH_EAPOL_H              4
-#define LENGTH_WMMQOS_H				2
-#define LENGTH_CRC                  4
-#define MAX_SEQ_NUMBER              0x0fff
-#define LENGTH_802_3_NO_TYPE		12
-#define LENGTH_802_1Q				4	/* VLAN related */
-
-/* STA_CSR4.field.TxResult */
-#define TX_RESULT_SUCCESS           0
-#define TX_RESULT_ZERO_LENGTH       1
-#define TX_RESULT_UNDER_RUN         2
-#define TX_RESULT_OHY_ERROR         4
-#define TX_RESULT_RETRY_FAIL        6
-
-/* All PHY rate summary in TXD */
-/* Preamble MODE in TxD */
-#define MODE_CCK	0
-#define MODE_OFDM   1
-#define MODE_HTMIX	2
-#define MODE_HTGREENFIELD	3
-
-/* MCS for CCK.  BW.SGI.STBC are reserved */
-#define MCS_longP_RATE_1                      0	/* long preamble CCK 1Mbps */
-#define MCS_longP_RATE_2                      1	/* long preamble CCK 1Mbps */
-#define MCS_longP_RATE_5_5                    2
-#define MCS_longP_RATE_11                     3
-#define MCS_SHORTP_RATE_1                      4	/* long preamble CCK 1Mbps. short is forbidden in 1Mbps */
-#define MCS_SHORTP_RATE_2                      5	/* short preamble CCK 2Mbps */
-#define MCS_SHORTP_RATE_5_5                    6
-#define MCS_SHORTP_RATE_11                     7
-/* To send duplicate legacy OFDM. set BW=BW_40.  SGI.STBC are reserved */
-#define MCS_RATE_6                      0	/* legacy OFDM */
-#define MCS_RATE_9                      1	/* OFDM */
-#define MCS_RATE_12                     2	/* OFDM */
-#define MCS_RATE_18                     3	/* OFDM */
-#define MCS_RATE_24                     4	/* OFDM */
-#define MCS_RATE_36                     5	/* OFDM */
-#define MCS_RATE_48                     6	/* OFDM */
-#define MCS_RATE_54                     7	/* OFDM */
-/* HT */
-#define MCS_0		0	/* 1S */
-#define MCS_1		1
-#define MCS_2		2
-#define MCS_3		3
-#define MCS_4		4
-#define MCS_5		5
-#define MCS_6		6
-#define MCS_7		7
-#define MCS_8		8	/* 2S */
-#define MCS_9		9
-#define MCS_10		10
-#define MCS_11		11
-#define MCS_12		12
-#define MCS_13		13
-#define MCS_14		14
-#define MCS_15		15
-#define MCS_16		16	/* 3*3 */
-#define MCS_17		17
-#define MCS_18		18
-#define MCS_19		19
-#define MCS_20		20
-#define MCS_21		21
-#define MCS_22		22
-#define MCS_23		23
-#define MCS_32		32
-#define MCS_AUTO		33
-
-/* OID_HTPHYMODE */
-/* MODE */
-#define HTMODE_MM	0
-#define HTMODE_GF	1
-
-/* Fixed Tx MODE - HT, CCK or OFDM */
-#define FIXED_TXMODE_HT		0
-#define FIXED_TXMODE_CCK	1
-#define FIXED_TXMODE_OFDM 	2
-/* BW */
-#define BW_20		BAND_WIDTH_20
-#define BW_40		BAND_WIDTH_40
-#define BW_BOTH		BAND_WIDTH_BOTH
-#define BW_10		BAND_WIDTH_10	/* 802.11j has 10MHz. This definition is for internal usage. doesn't fill in the IE or other field. */
-
-/* SHORTGI */
-#define GI_400		GAP_INTERVAL_400	/* only support in HT mode */
-#define GI_BOTH		GAP_INTERVAL_BOTH
-#define GI_800		GAP_INTERVAL_800
-/* STBC */
-#define STBC_NONE	0
-#define STBC_USE	1	/* limited use in rt2860b phy */
-#define RXSTBC_ONE	1	/* rx support of one spatial stream */
-#define RXSTBC_TWO	2	/* rx support of 1 and 2 spatial stream */
-#define RXSTBC_THR	3	/* rx support of 1~3 spatial stream */
-/* MCS FEEDBACK */
-#define MCSFBK_NONE	0	/* not support mcs feedback / */
-#define MCSFBK_RSV	1	/* reserved */
-#define MCSFBK_UNSOLICIT	2	/* only support unsolict mcs feedback */
-#define MCSFBK_MRQ	3	/* response to both MRQ and unsolict mcs feedback */
-
-/* MIMO power safe */
-#define	MMPS_STATIC	0
-#define	MMPS_DYNAMIC		1
-#define   MMPS_RSV		2
-#define MMPS_ENABLE		3
-
-/* A-MSDU size */
-#define	AMSDU_0	0
-#define	AMSDU_1		1
-
-/* MCS use 7 bits */
-#define TXRATEMIMO		0x80
-#define TXRATEMCS		0x7F
-#define TXRATEOFDM		0x7F
-#define RATE_1                      0
-#define RATE_2                      1
-#define RATE_5_5                    2
-#define RATE_11                     3
-#define RATE_6                      4	/* OFDM */
-#define RATE_9                      5	/* OFDM */
-#define RATE_12                     6	/* OFDM */
-#define RATE_18                     7	/* OFDM */
-#define RATE_24                     8	/* OFDM */
-#define RATE_36                     9	/* OFDM */
-#define RATE_48                     10	/* OFDM */
-#define RATE_54                     11	/* OFDM */
-#define RATE_FIRST_OFDM_RATE        RATE_6
-#define RATE_LAST_OFDM_RATE        	RATE_54
-#define RATE_6_5                    12	/* HT mix */
-#define RATE_13                     13	/* HT mix */
-#define RATE_19_5                   14	/* HT mix */
-#define RATE_26                     15	/* HT mix */
-#define RATE_39                     16	/* HT mix */
-#define RATE_52                     17	/* HT mix */
-#define RATE_58_5                   18	/* HT mix */
-#define RATE_65                     19	/* HT mix */
-#define RATE_78                     20	/* HT mix */
-#define RATE_104                    21	/* HT mix */
-#define RATE_117                    22	/* HT mix */
-#define RATE_130                    23	/* HT mix */
-/*#define RATE_AUTO_SWITCH            255 // for StaCfg.FixedTxRate only */
-#define HTRATE_0                      12
-#define RATE_FIRST_MM_RATE        HTRATE_0
-#define RATE_FIRST_HT_RATE        HTRATE_0
-#define RATE_LAST_HT_RATE        HTRATE_0
-
-/* pTxWI->txop */
-#define IFS_HTTXOP                 0	/* The txop will be handles by ASIC. */
-#define IFS_PIFS                    1
-#define IFS_SIFS                    2
-#define IFS_BACKOFF                 3
-
-/* pTxD->RetryMode */
-#define long_RETRY                  1
-#define SHORT_RETRY                 0
-
-/* Country Region definition */
-#define REGION_MINIMUM_BG_BAND            0
-#define REGION_0_BG_BAND                  0	/* 1-11 */
-#define REGION_1_BG_BAND                  1	/* 1-13 */
-#define REGION_2_BG_BAND                  2	/* 10-11 */
-#define REGION_3_BG_BAND                  3	/* 10-13 */
-#define REGION_4_BG_BAND                  4	/* 14 */
-#define REGION_5_BG_BAND                  5	/* 1-14 */
-#define REGION_6_BG_BAND                  6	/* 3-9 */
-#define REGION_7_BG_BAND                  7	/* 5-13 */
-#define REGION_31_BG_BAND                 31	/* 5-13 */
-#define REGION_MAXIMUM_BG_BAND            7
-
-#define REGION_MINIMUM_A_BAND             0
-#define REGION_0_A_BAND                   0	/* 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165 */
-#define REGION_1_A_BAND                   1	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 */
-#define REGION_2_A_BAND                   2	/* 36, 40, 44, 48, 52, 56, 60, 64 */
-#define REGION_3_A_BAND                   3	/* 52, 56, 60, 64, 149, 153, 157, 161 */
-#define REGION_4_A_BAND                   4	/* 149, 153, 157, 161, 165 */
-#define REGION_5_A_BAND                   5	/* 149, 153, 157, 161 */
-#define REGION_6_A_BAND                   6	/* 36, 40, 44, 48 */
-#define REGION_7_A_BAND                   7	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173 */
-#define REGION_8_A_BAND                   8	/* 52, 56, 60, 64 */
-#define REGION_9_A_BAND                   9	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140, 149, 153, 157, 161, 165 */
-#define REGION_10_A_BAND                  10	/* 36, 40, 44, 48, 149, 153, 157, 161, 165 */
-#define REGION_11_A_BAND                  11	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153, 157, 161 */
-#define REGION_12_A_BAND                  12	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 */
-#define REGION_13_A_BAND                  13	/* 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161 */
-#define REGION_14_A_BAND                  14	/* 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165 */
-#define REGION_15_A_BAND                  15	/* 149, 153, 157, 161, 165, 169, 173 */
-#define REGION_MAXIMUM_A_BAND             15
-
-/* pTxD->CipherAlg */
-#define CIPHER_NONE                 0
-#define CIPHER_WEP64                1
-#define CIPHER_WEP128               2
-#define CIPHER_TKIP                 3
-#define CIPHER_AES                  4
-#define CIPHER_CKIP64               5
-#define CIPHER_CKIP128              6
-#define CIPHER_TKIP_NO_MIC          7	/* MIC appended by driver: not a valid value in hardware key table */
-#define CIPHER_SMS4					8
-
-/* LED Status. */
-#define LED_LINK_DOWN               0
-#define LED_LINK_UP                 1
-#define LED_RADIO_OFF               2
-#define LED_RADIO_ON                3
-#define LED_HALT                    4
-#define LED_WPS                     5
-#define LED_ON_SITE_SURVEY          6
-#define LED_POWER_UP                7
-
-/* value domain of pAd->LedCntl.LedMode and E2PROM */
-#define LED_MODE_DEFAULT            0
-#define LED_MODE_TWO_LED			1
-/*#define LED_MODE_SIGNAL_STREGTH               8  // EEPROM define =8 */
-#define LED_MODE_SIGNAL_STREGTH		0x40	/* EEPROM define = 64 */
-
-/* RC4 init value, used fro WEP & TKIP */
-#define PPPINITFCS32                0xffffffff	/* Initial FCS value */
-
-/* value domain of pAd->StaCfg.PortSecured. 802.1X controlled port definition */
-#define WPA_802_1X_PORT_SECURED     1
-#define WPA_802_1X_PORT_NOT_SECURED 2
-
-#define PAIRWISE_KEY                1
-#define GROUP_KEY                   2
-
-/*definition of DRS */
-#define MAX_STEP_OF_TX_RATE_SWITCH	32
-
-/* pre-allocated free NDIS PACKET/BUFFER poll for internal usage */
-#define MAX_NUM_OF_FREE_NDIS_PACKET 128
-
-/*Block ACK */
-#define MAX_TX_REORDERBUF   64
-#define MAX_RX_REORDERBUF   64
-#define DEFAULT_TX_TIMEOUT   30
-#define DEFAULT_RX_TIMEOUT   30
-
-/* definition of Recipient or Originator */
-#define I_RECIPIENT                  TRUE
-#define I_ORIGINATOR                   FALSE
-
-#define DEFAULT_BBP_TX_POWER        0
-#define DEFAULT_RF_TX_POWER         5
-
-#define MAX_INI_BUFFER_SIZE			4096
-#define MAX_PARAM_BUFFER_SIZE		(2048)	/* enough for ACL (18*64) */
-											/*18 : the length of Mac address acceptable format "01:02:03:04:05:06;") */
-											/*64 : MAX_NUM_OF_ACL_LIST */
-/* definition of pAd->OpMode */
-#define OPMODE_STA                  0
-#define OPMODE_AP                   1
-/*#define OPMODE_L3_BRG               2       // as AP and STA at the same time */
-
-/* ========================= AP rtmp_def.h =========================== */
-/* value domain for pAd->EventTab.Log[].Event */
-#define EVENT_RESET_ACCESS_POint    0	/* Log = "hh:mm:ss   Restart Access Point" */
-#define EVENT_ASSOCIATED            1	/* Log = "hh:mm:ss   STA 00:01:02:03:04:05 associated" */
-#define EVENT_DISASSOCIATED         2	/* Log = "hh:mm:ss   STA 00:01:02:03:04:05 left this BSS" */
-#define EVENT_AGED_OUT              3	/* Log = "hh:mm:ss   STA 00:01:02:03:04:05 was aged-out and removed from this BSS" */
-#define EVENT_COUNTER_M             4
-#define EVENT_INVALID_PSK           5
-#define EVENT_MAX_EVENT_TYPE        6
-/* ==== end of AP rtmp_def.h ============ */
-
-/* definition RSSI Number */
-#define RSSI_0					0
-#define RSSI_1					1
-#define RSSI_2					2
-
-/* definition of radar detection */
-#define RD_NORMAL_MODE				0	/* Not found radar signal */
-#define RD_SWITCHING_MODE			1	/* Found radar signal, and doing channel switch */
-#define RD_SILENCE_MODE				2	/* After channel switch, need to be silence a while to ensure radar not found */
-
-/*Driver defined cid for mapping status and command. */
-#define  SLEEPCID	0x11
-#define  WAKECID	0x22
-#define  QUERYPOWERCID	0x33
-#define  OWNERMCU	0x1
-#define  OWNERCPU	0x0
-
-/* MBSSID definition */
-#define ENTRY_NOT_FOUND             0xFF
-
-/* After Linux 2.6.9,
- * VLAN module use Private (from user) interface flags (netdevice->priv_flags).
- * #define IFF_802_1Q_VLAN 0x1         --    802.1Q VLAN device.  in if.h
- * ref to ip_sabotage_out() [ out->priv_flags & IFF_802_1Q_VLAN ] in br_netfilter.c
- *
- * For this reason, we MUST use EVEN value in priv_flags
- */
-#define INT_MAIN                    0x0100
-#define INT_MBSSID                  0x0200
-#define INT_WDS                     0x0300
-#define INT_APCLI                   0x0400
-#define INT_MESH                   	0x0500
-
-#define INF_MAIN_DEV_NAME		"wlan"
-#define INF_MBSSID_DEV_NAME		"ra"
-#define INF_WDS_DEV_NAME		"wds"
-#define INF_APCLI_DEV_NAME		"apcli"
-#define INF_MESH_DEV_NAME		"mesh"
-
-/* WEP Key TYPE */
-#define WEP_HEXADECIMAL_TYPE    0
-#define WEP_ASCII_TYPE          1
-
-/* WIRELESS EVENTS definition */
-/* Max number of char in custom event, refer to wireless_tools.28/wireless.20.h */
-#define IW_CUSTOM_MAX_LEN				  			255	/* In bytes */
-
-/* For system event - start */
-#define	IW_SYS_EVENT_FLAG_START                     0x0200
-#define	IW_ASSOC_EVENT_FLAG                         0x0200
-#define	IW_DISASSOC_EVENT_FLAG                      0x0201
-#define	IW_DEAUTH_EVENT_FLAG                      	0x0202
-#define	IW_AGEOUT_EVENT_FLAG                      	0x0203
-#define	IW_COUNTER_MEASURES_EVENT_FLAG              0x0204
-#define	IW_REPLAY_COUNTER_DIFF_EVENT_FLAG           0x0205
-#define	IW_RSNIE_DIFF_EVENT_FLAG           			0x0206
-#define	IW_MIC_DIFF_EVENT_FLAG           			0x0207
-#define IW_ICV_ERROR_EVENT_FLAG						0x0208
-#define IW_MIC_ERROR_EVENT_FLAG						0x0209
-#define IW_GROUP_HS_TIMEOUT_EVENT_FLAG				0x020A
-#define	IW_PAIRWISE_HS_TIMEOUT_EVENT_FLAG			0x020B
-#define IW_RSNIE_SANITY_FAIL_EVENT_FLAG				0x020C
-#define IW_SET_KEY_DONE_WPA1_EVENT_FLAG				0x020D
-#define IW_SET_KEY_DONE_WPA2_EVENT_FLAG				0x020E
-#define IW_STA_LINKUP_EVENT_FLAG					0x020F
-#define IW_STA_LINKDOWN_EVENT_FLAG					0x0210
-#define IW_SCAN_COMPLETED_EVENT_FLAG				0x0211
-#define IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG				0x0212
-/* if add new system event flag, please update the IW_SYS_EVENT_FLAG_END */
-#define	IW_SYS_EVENT_FLAG_END                       0x0212
-#define	IW_SYS_EVENT_TYPE_NUM						(IW_SYS_EVENT_FLAG_END - IW_SYS_EVENT_FLAG_START + 1)
-/* For system event - end */
-
-/* For spoof attack event - start */
-#define	IW_SPOOF_EVENT_FLAG_START                   0x0300
-#define IW_CONFLICT_SSID_EVENT_FLAG					0x0300
-#define IW_SPOOF_ASSOC_RESP_EVENT_FLAG				0x0301
-#define IW_SPOOF_REASSOC_RESP_EVENT_FLAG			0x0302
-#define IW_SPOOF_PROBE_RESP_EVENT_FLAG				0x0303
-#define IW_SPOOF_BEACON_EVENT_FLAG					0x0304
-#define IW_SPOOF_DISASSOC_EVENT_FLAG				0x0305
-#define IW_SPOOF_AUTH_EVENT_FLAG					0x0306
-#define IW_SPOOF_DEAUTH_EVENT_FLAG					0x0307
-#define IW_SPOOF_UNKNOWN_MGMT_EVENT_FLAG			0x0308
-#define IW_REPLAY_ATTACK_EVENT_FLAG					0x0309
-/* if add new spoof attack event flag, please update the IW_SPOOF_EVENT_FLAG_END */
-#define	IW_SPOOF_EVENT_FLAG_END                     0x0309
-#define	IW_SPOOF_EVENT_TYPE_NUM						(IW_SPOOF_EVENT_FLAG_END - IW_SPOOF_EVENT_FLAG_START + 1)
-/* For spoof attack event - end */
-
-/* For flooding attack event - start */
-#define	IW_FLOOD_EVENT_FLAG_START                   0x0400
-#define IW_FLOOD_AUTH_EVENT_FLAG					0x0400
-#define IW_FLOOD_ASSOC_REQ_EVENT_FLAG				0x0401
-#define IW_FLOOD_REASSOC_REQ_EVENT_FLAG				0x0402
-#define IW_FLOOD_PROBE_REQ_EVENT_FLAG				0x0403
-#define IW_FLOOD_DISASSOC_EVENT_FLAG				0x0404
-#define IW_FLOOD_DEAUTH_EVENT_FLAG					0x0405
-#define IW_FLOOD_EAP_REQ_EVENT_FLAG					0x0406
-/* if add new flooding attack event flag, please update the IW_FLOOD_EVENT_FLAG_END */
-#define	IW_FLOOD_EVENT_FLAG_END                   	0x0406
-#define	IW_FLOOD_EVENT_TYPE_NUM						(IW_FLOOD_EVENT_FLAG_END - IW_FLOOD_EVENT_FLAG_START + 1)
-/* For flooding attack - end */
-
-/* End - WIRELESS EVENTS definition */
-
-/* definition for DLS, kathy */
-#define	MAX_NUM_OF_INIT_DLS_ENTRY   1
-#define	MAX_NUM_OF_DLS_ENTRY        MAX_NUMBER_OF_DLS_ENTRY
-
-/*Block ACK, kathy */
-#define MAX_TX_REORDERBUF		64
-#define MAX_RX_REORDERBUF		64
-#define DEFAULT_TX_TIMEOUT		30
-#define DEFAULT_RX_TIMEOUT		30
-#define MAX_BARECI_SESSION		8
-
-#ifndef IW_ESSID_MAX_SIZE
-/* Maximum size of the ESSID and pAd->nickname strings */
-#define IW_ESSID_MAX_SIZE   		32
-#endif
-
-/* For AsicRadioOff/AsicRadioOn function */
-#define DOT11POWERSAVE		0
-#define GUIRADIO_OFF		1
-#define RTMP_HALT		    2
-#define GUI_IDLE_POWER_SAVE		3
-/* -- */
-
-/* definition for WpaSupport flag */
-#define WPA_SUPPLICANT_DISABLE				0
-#define WPA_SUPPLICANT_ENABLE				1
-#define	WPA_SUPPLICANT_ENABLE_WITH_WEB_UI	2
-
-/* Endian byte swapping codes */
-#define SWAP16(x) \
-    ((u16)( \
-    (((u16)(x) & (u16)0x00ffU) << 8) | \
-    (((u16)(x) & (u16)0xff00U) >> 8) ))
-
-#define SWAP32(x) \
-    ((u32)( \
-    (((u32)(x) & (u32)0x000000ffUL) << 24) | \
-    (((u32)(x) & (u32)0x0000ff00UL) <<  8) | \
-    (((u32)(x) & (u32)0x00ff0000UL) >>  8) | \
-    (((u32)(x) & (u32)0xff000000UL) >> 24) ))
-
-#define SWAP64(x) \
-    ((u64)( \
-    (u64)(((u64)(x) & (u64)0x00000000000000ffULL) << 56) | \
-    (u64)(((u64)(x) & (u64)0x000000000000ff00ULL) << 40) | \
-    (u64)(((u64)(x) & (u64)0x0000000000ff0000ULL) << 24) | \
-    (u64)(((u64)(x) & (u64)0x00000000ff000000ULL) <<  8) | \
-    (u64)(((u64)(x) & (u64)0x000000ff00000000ULL) >>  8) | \
-    (u64)(((u64)(x) & (u64)0x0000ff0000000000ULL) >> 24) | \
-    (u64)(((u64)(x) & (u64)0x00ff000000000000ULL) >> 40) | \
-    (u64)(((u64)(x) & (u64)0xff00000000000000ULL) >> 56) ))
-
-#define cpu2le64(x) ((u64)(x))
-#define le2cpu64(x) ((u64)(x))
-#define cpu2le32(x) ((u32)(x))
-#define le2cpu32(x) ((u32)(x))
-#define cpu2le16(x) ((u16)(x))
-#define le2cpu16(x) ((u16)(x))
-#define cpu2be64(x) SWAP64((x))
-#define be2cpu64(x) SWAP64((x))
-#define cpu2be32(x) SWAP32((x))
-#define be2cpu32(x) SWAP32((x))
-#define cpu2be16(x) SWAP16((x))
-#define be2cpu16(x) SWAP16((x))
-
-#define ABS(_x, _y) ((_x) > (_y)) ? ((_x) -(_y)) : ((_y) -(_x))
-
-#define A2Dec(_X, _p)				\
-{									\
-	u8 *p;						\
-	_X = 0;							\
-	p = _p;							\
-	while (((*p >= '0') && (*p <= '9')))		\
-	{												\
-		if ((*p >= '0') && (*p <= '9'))		\
-			_X = _X * 10 + *p - 48;					\
-		p++;										\
-	}												\
-}
-
-#define A2Hex(_X, _p)				\
-do{									\
-	char *__p;						\
-	(_X) = 0;							\
-	__p = (char *)(_p);							\
-	while (((*__p >= 'a') && (*__p <= 'f')) || ((*__p >= 'A') && (*__p <= 'F')) || ((*__p >= '0') && (*__p <= '9')))		\
-	{												\
-		if ((*__p >= 'a') && (*__p <= 'f'))				\
-			(_X) = (_X) * 16 + *__p - 87;					\
-		else if ((*__p >= 'A') && (*__p <= 'F'))		\
-			(_X) = (_X) * 16 + *__p - 55;					\
-		else if ((*__p >= '0') && (*__p <= '9'))		\
-			(_X) = (_X) * 16 + *__p - 48;					\
-		__p++;										\
-	}												\
-}while(0)
-
-#endif /* __RTMP_DEF_H__ */
diff --git a/drivers/staging/rt2860/rtmp_dot11.h b/drivers/staging/rt2860/rtmp_dot11.h
deleted file mode 100644
index 4f8abd7..0000000
--- a/drivers/staging/rt2860/rtmp_dot11.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifndef __DOT11_BASE_H__
-#define __DOT11_BASE_H__
-
-#include "rtmp_type.h"
-
-/* 4-byte HTC field.  maybe included in any frame except non-QOS data frame.  The Order bit must set 1. */
-struct PACKED rt_ht_control {
-	u32 MA:1;		/*management action payload exist in (QoS Null+HTC) */
-	u32 TRQ:1;		/*sounding request */
-	u32 MRQ:1;		/*MCS feedback. Request for a MCS feedback */
-	u32 MRSorASI:3;	/* MRQ Sequence identifier. unchanged during entire procedure. 0x000-0x110. */
-	u32 MFS:3;		/*SET to the received value of MRS. 0x111 for unsolicited MFB. */
-	u32 MFBorASC:7;	/*Link adaptation feedback containing recommended MCS. 0x7f for no feedback or not available */
-	u32 CalPos:2;	/* calibration position */
-	u32 CalSeq:2;	/*calibration sequence */
-	u32 FBKReq:2;	/*feedback request */
-	u32 CSISTEERING:2;	/*CSI/ STEERING */
-	u32 ZLFAnnouce:1;	/* ZLF announcement */
-	u32 rsv:5;		/*calibration sequence */
-	u32 ACConstraint:1;	/*feedback request */
-	u32 RDG:1;		/*RDG / More PPDU */
-};
-
-/* 2-byte QOS CONTROL field */
-struct PACKED rt_qos_control {
-	u16 TID:4;
-	u16 EOSP:1;
-	u16 AckPolicy:2;	/*0: normal ACK 1:No ACK 2:scheduled under MTBA/PSMP  3: BA */
-	u16 AMsduPresent:1;
-	u16 Txop_QueueSize:8;
-};
-
-/* 2-byte Frame control field */
-struct PACKED rt_frame_control {
-	u16 Ver:2;		/* Protocol version */
-	u16 Type:2;		/* MSDU type */
-	u16 SubType:4;	/* MSDU subtype */
-	u16 ToDs:1;		/* To DS indication */
-	u16 FrDs:1;		/* From DS indication */
-	u16 MoreFrag:1;	/* More fragment bit */
-	u16 Retry:1;		/* Retry status bit */
-	u16 PwrMgmt:1;	/* Power management bit */
-	u16 MoreData:1;	/* More data bit */
-	u16 Wep:1;		/* Wep data */
-	u16 Order:1;		/* Strict order expected */
-};
-
-struct PACKED rt_header_802_11 {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-	u8 Addr3[MAC_ADDR_LEN];
-	u16 Frag:4;
-	u16 Sequence:12;
-	u8 Octet[0];
-};
-
-struct PACKED rt_pspoll_frame {
-	struct rt_frame_control FC;
-	u16 Aid;
-	u8 Bssid[MAC_ADDR_LEN];
-	u8 Ta[MAC_ADDR_LEN];
-};
-
-struct PACKED rt_rts_frame {
-	struct rt_frame_control FC;
-	u16 Duration;
-	u8 Addr1[MAC_ADDR_LEN];
-	u8 Addr2[MAC_ADDR_LEN];
-};
-
-#endif /* __DOT11_BASE_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_iface.h b/drivers/staging/rt2860/rtmp_iface.h
deleted file mode 100644
index 808c055..0000000
--- a/drivers/staging/rt2860/rtmp_iface.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rt_iface.h
-
-    Abstract:
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __RTMP_IFACE_H__
-#define __RTMP_IFACE_H__
-
-#ifdef RTMP_PCI_SUPPORT
-#include "iface/rtmp_pci.h"
-#endif /* RTMP_PCI_SUPPORT // */
-#ifdef RTMP_USB_SUPPORT
-#include "iface/rtmp_usb.h"
-#endif /* RTMP_USB_SUPPORT // */
-
-struct rt_inf_pci_config {
-	unsigned long CSRBaseAddress;	/* PCI MMIO Base Address, all access will use */
-	unsigned int irq_num;
-};
-
-struct rt_inf_usb_config {
-	u8 BulkInEpAddr;	/* bulk-in endpoint address */
-	u8 BulkOutEpAddr[6];	/* bulk-out endpoint address */
-};
-
-struct rt_inf_rbus_config {
-	unsigned long csr_addr;
-	unsigned int irq;
-};
-
-typedef enum _RTMP_INF_TYPE_ {
-	RTMP_DEV_INF_UNKNOWN = 0,
-	RTMP_DEV_INF_PCI = 1,
-	RTMP_DEV_INF_USB = 2,
-	RTMP_DEV_INF_RBUS = 4,
-} RTMP_INF_TYPE;
-
-typedef union _RTMP_INF_CONFIG_ {
-	struct rt_inf_pci_config pciConfig;
-	struct rt_inf_usb_config usbConfig;
-	struct rt_inf_rbus_config rbusConfig;
-} RTMP_INF_CONFIG;
-
-#endif /* __RTMP_IFACE_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_mcu.h b/drivers/staging/rt2860/rtmp_mcu.h
deleted file mode 100644
index d0987e5..0000000
--- a/drivers/staging/rt2860/rtmp_mcu.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_mcu.h
-
-	Abstract:
-	Miniport header file for mcu related information
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-*/
-
-#ifndef __RTMP_MCU_H__
-#define __RTMP_MCU_H__
-
-int RtmpAsicEraseFirmware(struct rt_rtmp_adapter *pAd);
-
-int RtmpAsicLoadFirmware(struct rt_rtmp_adapter *pAd);
-
-int RtmpAsicSendCommandToMcu(struct rt_rtmp_adapter *pAd,
-			     u8 Command,
-			     u8 Token, u8 Arg0, u8 Arg1);
-
-#endif /* __RTMP_MCU_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_os.h b/drivers/staging/rt2860/rtmp_os.h
deleted file mode 100644
index 94c30c8..0000000
--- a/drivers/staging/rt2860/rtmp_os.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rtmp_os.h
-
-    Abstract:
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
- */
-
-#ifndef __RTMP_OS_H__
-#define __RTMP_OS_H__
-
-#ifdef LINUX
-#include "rt_linux.h"
-#endif /* LINUX // */
-
-/*
-	This data structure mainly strip some callback function defined in
-	"struct net_device" in kernel source "include/linux/netdevice.h".
-
-	The definition of this data structure may various depends on different
-	OS. Use it carefully.
-*/
-struct rt_rtmp_os_netdev_op_hook {
-	const struct net_device_ops *netdev_ops;
-	void *priv;
-	int priv_flags;
-	unsigned char devAddr[6];
-	unsigned char devName[16];
-	unsigned char needProtcted;
-};
-
-typedef enum _RTMP_TASK_STATUS_ {
-	RTMP_TASK_STAT_UNKNOWN = 0,
-	RTMP_TASK_STAT_INITED = 1,
-	RTMP_TASK_STAT_RUNNING = 2,
-	RTMP_TASK_STAT_STOPED = 4,
-} RTMP_TASK_STATUS;
-#define RTMP_TASK_CAN_DO_INSERT		(RTMP_TASK_STAT_INITED |RTMP_TASK_STAT_RUNNING)
-
-#define RTMP_OS_TASK_NAME_LEN	16
-struct rt_rtmp_os_task {
-	char taskName[RTMP_OS_TASK_NAME_LEN];
-	void *priv;
-	/*unsigned long         taskFlags; */
-	RTMP_TASK_STATUS taskStatus;
-#ifndef KTHREAD_SUPPORT
-	struct semaphore taskSema;
-	struct pid *taskPID;
-	struct completion taskComplete;
-#endif
-	unsigned char task_killed;
-#ifdef KTHREAD_SUPPORT
-	struct task_struct *kthread_task;
-	wait_queue_head_t kthread_q;
-	BOOLEAN kthread_running;
-#endif
-};
-
-int RtmpOSIRQRequest(struct net_device *pNetDev);
-int RtmpOSIRQRelease(struct net_device *pNetDev);
-
-#endif /* __RMTP_OS_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_timer.h b/drivers/staging/rt2860/rtmp_timer.h
deleted file mode 100644
index 15b6287..0000000
--- a/drivers/staging/rt2860/rtmp_timer.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	rtmp_timer.h
-
-    Abstract:
-	Ralink Wireless Driver timer related data structures and declarations 
-
-    Revision History:
-	Who          		When                 What
-	--------    ----------      ----------------------------------------------
-	Name          		Date                 Modification logs
-	Shiang Tu    		Aug-28-2008 	     init version
-	Justin P. Mattock	11/07/2010	     Fix a typo
-
-*/
-
-#ifndef __RTMP_TIMER_H__
-#define  __RTMP_TIMER_H__
-
-#include "rtmp_os.h"
-
-#define DECLARE_TIMER_FUNCTION(_func)			\
-	void rtmp_timer_##_func(unsigned long data)
-
-#define GET_TIMER_FUNCTION(_func)				\
-	rtmp_timer_##_func
-
-/* ----------------- Timer Related MARCO ---------------*/
-/* In some os or chipset, we have a lot of timer functions and will read/write register, */
-/* it's not allowed in Linux USB sub-system to do it ( because of sleep issue when */
-/* submit to ctrl pipe). So we need a wrapper function to take care it. */
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-typedef void(*RTMP_TIMER_TASK_HANDLE) (void *SystemSpecific1,
-				       void *FunctionContext,
-				       void *SystemSpecific2,
-				       void *SystemSpecific3);
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
-
-struct rt_ralink_timer {
-	struct timer_list TimerObj;	/* Ndis Timer object */
-	BOOLEAN Valid;		/* Set to True when call RTMPInitTimer */
-	BOOLEAN State;		/* True if timer cancelled */
-	BOOLEAN PeriodicType;	/* True if timer is periodic timer */
-	BOOLEAN Repeat;		/* True if periodic timer */
-	unsigned long TimerValue;	/* Timer value in milliseconds */
-	unsigned long cookie;		/* os specific object */
-#ifdef RTMP_TIMER_TASK_SUPPORT
-	RTMP_TIMER_TASK_HANDLE handle;
-	void *pAd;
-#endif				/* RTMP_TIMER_TASK_SUPPORT // */
-};
-
-#ifdef RTMP_TIMER_TASK_SUPPORT
-struct rt_rtmp_timer_task_entry {
-	struct rt_ralink_timer *pRaTimer;
-	struct rt_rtmp_timer_task_entry *pNext;
-};
-
-#define TIMER_QUEUE_SIZE_MAX	128
-struct rt_rtmp_timer_task_queue {
-	unsigned int status;
-	unsigned char *pTimerQPoll;
-	struct rt_rtmp_timer_task_entry *pQPollFreeList;
-	struct rt_rtmp_timer_task_entry *pQHead;
-	struct rt_rtmp_timer_task_entry *pQTail;
-};
-
-#define BUILD_TIMER_FUNCTION(_func)										\
-void rtmp_timer_##_func(unsigned long data)										\
-{																			\
-	struct rt_ralink_timer *_pTimer = (struct rt_ralink_timer *)data;				\
-	struct rt_rtmp_timer_task_entry *_pQNode;										\
-	struct rt_rtmp_adapter *_pAd;											\
-																			\
-	_pTimer->handle = _func;													\
-	_pAd = (struct rt_rtmp_adapter *)_pTimer->pAd;										\
-	_pQNode = RtmpTimerQInsert(_pAd, _pTimer);								\
-	if ((_pQNode == NULL) && (_pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT))	\
-		RTMP_OS_Add_Timer(&_pTimer->TimerObj, OS_HZ);							\
-}
-#else
-#define BUILD_TIMER_FUNCTION(_func)										\
-void rtmp_timer_##_func(unsigned long data)										\
-{																			\
-	struct rt_ralink_timer *pTimer = (struct rt_ralink_timer *)data;				\
-																			\
-	_func(NULL, (void *)pTimer->cookie, NULL, pTimer);							\
-	if (pTimer->Repeat)														\
-		RTMP_OS_Add_Timer(&pTimer->TimerObj, pTimer->TimerValue);			\
-}
-#endif /* RTMP_TIMER_TASK_SUPPORT // */
-
-DECLARE_TIMER_FUNCTION(MlmePeriodicExec);
-DECLARE_TIMER_FUNCTION(MlmeRssiReportExec);
-DECLARE_TIMER_FUNCTION(AsicRxAntEvalTimeout);
-DECLARE_TIMER_FUNCTION(APSDPeriodicExec);
-DECLARE_TIMER_FUNCTION(AsicRfTuningExec);
-#ifdef RTMP_MAC_USB
-DECLARE_TIMER_FUNCTION(BeaconUpdateExec);
-#endif /* RTMP_MAC_USB // */
-
-DECLARE_TIMER_FUNCTION(BeaconTimeout);
-DECLARE_TIMER_FUNCTION(ScanTimeout);
-DECLARE_TIMER_FUNCTION(AuthTimeout);
-DECLARE_TIMER_FUNCTION(AssocTimeout);
-DECLARE_TIMER_FUNCTION(ReassocTimeout);
-DECLARE_TIMER_FUNCTION(DisassocTimeout);
-DECLARE_TIMER_FUNCTION(LinkDownExec);
-DECLARE_TIMER_FUNCTION(StaQuickResponeForRateUpExec);
-DECLARE_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
-DECLARE_TIMER_FUNCTION(PsPollWakeExec);
-DECLARE_TIMER_FUNCTION(RadioOnExec);
-
-#ifdef RTMP_MAC_USB
-DECLARE_TIMER_FUNCTION(RtmpUsbStaAsicForceWakeupTimeout);
-#endif /* RTMP_MAC_USB // */
-
-#if defined(AP_LED) || defined(STA_LED)
-DECLARE_TIMER_FUNCTION(LedCtrlMain);
-#endif
-
-#endif /* __RTMP_TIMER_H__ // */
diff --git a/drivers/staging/rt2860/rtmp_type.h b/drivers/staging/rt2860/rtmp_type.h
deleted file mode 100644
index d9bb2d6..0000000
--- a/drivers/staging/rt2860/rtmp_type.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    rtmp_type.h
-
-    Abstract:
-
-    Revision History:
-    Who         When            What
-    --------    ----------      ----------------------------------------------
-    Name        Date            Modification logs
-    Paul Lin    1-2-2004
-*/
-#ifndef __RTMP_TYPE_H__
-#define __RTMP_TYPE_H__
-
-#include <linux/types.h>
-
-#define PACKED  __attribute__ ((packed))
-
-typedef unsigned char BOOLEAN;
-
-typedef union _LARGE_INTEGER {
-	struct {
-		u32 LowPart;
-		int HighPart;
-	} u;
-	long long QuadPart;
-} LARGE_INTEGER;
-
-/* */
-/* Register set pair for initialzation register set definition */
-/* */
-struct rt_rtmp_reg_pair {
-	unsigned long Register;
-	unsigned long Value;
-};
-
-struct rt_reg_pair {
-	u8 Register;
-	u8 Value;
-};
-
-/* */
-/* Register set pair for initialzation register set definition */
-/* */
-struct rt_rtmp_rf_regs {
-	u8 Channel;
-	unsigned long R1;
-	unsigned long R2;
-	unsigned long R3;
-	unsigned long R4;
-};
-
-struct rt_frequency_item {
-	u8 Channel;
-	u8 N;
-	u8 R;
-	u8 K;
-};
-
-#define STATUS_SUCCESS				0x00
-#define STATUS_UNSUCCESSFUL		0x01
-
-#endif /* __RTMP_TYPE_H__ // */
diff --git a/drivers/staging/rt2860/rtusb_io.h b/drivers/staging/rt2860/rtusb_io.h
deleted file mode 100644
index 64a2fe4..0000000
--- a/drivers/staging/rt2860/rtusb_io.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-*/
-
-#ifndef __RTUSB_IO_H__
-#define __RTUSB_IO_H__
-
-#include "rtmp_type.h"
-
-/* New for MeetingHouse Api support */
-#define CMDTHREAD_VENDOR_RESET                      0x0D730101	/* cmd */
-#define CMDTHREAD_VENDOR_UNPLUG                     0x0D730102	/* cmd */
-#define CMDTHREAD_VENDOR_SWITCH_FUNCTION            0x0D730103	/* cmd */
-#define CMDTHREAD_MULTI_WRITE_MAC                   0x0D730107	/* cmd */
-#define CMDTHREAD_MULTI_READ_MAC                    0x0D730108	/* cmd */
-#define CMDTHREAD_VENDOR_EEPROM_WRITE               0x0D73010A	/* cmd */
-#define CMDTHREAD_VENDOR_EEPROM_READ                0x0D73010B	/* cmd */
-#define CMDTHREAD_VENDOR_ENTER_TESTMODE             0x0D73010C	/* cmd */
-#define CMDTHREAD_VENDOR_EXIT_TESTMODE              0x0D73010D	/* cmd */
-#define CMDTHREAD_VENDOR_WRITE_BBP                  0x0D730119	/* cmd */
-#define CMDTHREAD_VENDOR_READ_BBP                   0x0D730118	/* cmd */
-#define CMDTHREAD_VENDOR_WRITE_RF                   0x0D73011A	/* cmd */
-#define CMDTHREAD_VENDOR_FLIP_IQ                    0x0D73011D	/* cmd */
-#define CMDTHREAD_RESET_BULK_OUT                    0x0D730210	/* cmd */
-#define CMDTHREAD_RESET_BULK_IN                     0x0D730211	/* cmd */
-#define CMDTHREAD_SET_PSM_BIT				0x0D730212	/* cmd */
-#define CMDTHREAD_SET_RADIO                         0x0D730214	/* cmd */
-#define CMDTHREAD_UPDATE_TX_RATE                    0x0D730216	/* cmd */
-#define CMDTHREAD_802_11_ADD_KEY_WEP                0x0D730218	/* cmd */
-#define CMDTHREAD_RESET_FROM_ERROR                  0x0D73021A	/* cmd */
-#define CMDTHREAD_LINK_DOWN                         0x0D73021B	/* cmd */
-#define CMDTHREAD_RESET_FROM_NDIS                   0x0D73021C	/* cmd */
-#define CMDTHREAD_CHECK_GPIO                        0x0D730215	/* cmd */
-#define CMDTHREAD_FORCE_WAKE_UP                     0x0D730222	/* cmd */
-#define CMDTHREAD_SET_BW                            0x0D730225	/* cmd */
-#define CMDTHREAD_SET_ASIC_WCID                     0x0D730226	/* cmd */
-#define CMDTHREAD_SET_ASIC_WCID_CIPHER              0x0D730227	/* cmd */
-#define CMDTHREAD_QKERIODIC_EXECUT                  0x0D73023D	/* cmd */
-#define RT_CMD_SET_KEY_TABLE                        0x0D730228	/* cmd */
-#define RT_CMD_SET_RX_WCID_TABLE                    0x0D730229	/* cmd */
-#define CMDTHREAD_SET_CLIENT_MAC_ENTRY              0x0D73023E	/* cmd */
-#define CMDTHREAD_SET_GROUP_KEY						0x0D73023F	/* cmd */
-#define CMDTHREAD_SET_PAIRWISE_KEY					0x0D730240	/* cmd */
-
-#define CMDTHREAD_802_11_QUERY_HARDWARE_REGISTER    0x0D710105	/* cmd */
-#define CMDTHREAD_802_11_SET_PHY_MODE               0x0D79010C	/* cmd */
-#define CMDTHREAD_802_11_SET_STA_CONFIG             0x0D790111	/* cmd */
-#define CMDTHREAD_802_11_SET_PREAMBLE               0x0D790101	/* cmd */
-#define CMDTHREAD_802_11_COUNTER_MEASURE			0x0D790102	/* cmd */
-/* add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
-#define CMDTHREAD_UPDATE_PROTECT					0x0D790103	/* cmd */
-/* end johnli */
-
-/*CMDTHREAD_MULTI_READ_MAC */
-/*CMDTHREAD_MULTI_WRITE_MAC */
-/*CMDTHREAD_VENDOR_EEPROM_READ */
-/*CMDTHREAD_VENDOR_EEPROM_WRITE */
-struct rt_cmdhandler_tlv {
-	u16 Offset;
-	u16 Length;
-	u8 DataFirst;
-};
-
-struct rt_cmdqelmt;
-
-struct rt_cmdqelmt {
-	u32 command;
-	void *buffer;
-	unsigned long bufferlength;
-	BOOLEAN CmdFromNdis;
-	BOOLEAN SetOperation;
-	struct rt_cmdqelmt *next;
-};
-
-struct rt_cmdq {
-	u32 size;
-	struct rt_cmdqelmt *head;
-	struct rt_cmdqelmt *tail;
-	u32 CmdQState;
-};
-
-#define EnqueueCmd(cmdq, cmdqelmt)		\
-{										\
-	if (cmdq->size == 0)				\
-		cmdq->head = cmdqelmt;			\
-	else								\
-		cmdq->tail->next = cmdqelmt;	\
-	cmdq->tail = cmdqelmt;				\
-	cmdqelmt->next = NULL;				\
-	cmdq->size++;						\
-}
-
-/******************************************************************************
-
-	USB Cmd to ASIC Related MACRO
-
-******************************************************************************/
-/* reset MAC of a station entry to 0xFFFFFFFFFFFF */
-#define RTMP_STA_ENTRY_MAC_RESET(pAd, Wcid)					\
-	{	struct rt_set_asic_wcid	SetAsicWcid;						\
-		SetAsicWcid.WCID = Wcid;								\
-		SetAsicWcid.SetTid = 0xffffffff;						\
-		SetAsicWcid.DeleteTid = 0xffffffff;						\
-		RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_SET_ASIC_WCID,	\
-				&SetAsicWcid, sizeof(struct rt_set_asic_wcid));	}
-
-/* add this entry into ASIC RX WCID search table */
-#define RTMP_STA_ENTRY_ADD(pAd, pEntry)							\
-	RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_SET_CLIENT_MAC_ENTRY,	\
-							pEntry, sizeof(struct rt_mac_table_entry));
-
-/* add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
-/* Set MAC register value according operation mode */
-#define RTMP_UPDATE_PROTECT(pAd)	\
-	RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_UPDATE_PROTECT, NULL, 0);
-/* end johnli */
-
-/* remove Pair-wise key material from ASIC */
-/* yet implement */
-#define RTMP_STA_ENTRY_KEY_DEL(pAd, BssIdx, Wcid)
-
-/* add Client security information into ASIC WCID table and IVEIV table */
-#define RTMP_STA_SECURITY_INFO_ADD(pAd, apidx, KeyID, pEntry)						\
-	{	RTMP_STA_ENTRY_MAC_RESET(pAd, pEntry->Aid);								\
-		if (pEntry->Aid >= 1) {														\
-			struct rt_set_asic_wcid_attri	SetAsicWcidAttri;								\
-			SetAsicWcidAttri.WCID = pEntry->Aid;									\
-			if ((pEntry->AuthMode <= Ndis802_11AuthModeAutoSwitch) &&				\
-				(pEntry->WepStatus == Ndis802_11Encryption1Enabled))				\
-			{																		\
-				SetAsicWcidAttri.Cipher = pAd->SharedKey[apidx][KeyID].CipherAlg;	\
-			}																		\
-			else if (pEntry->AuthMode == Ndis802_11AuthModeWPANone)					\
-			{																		\
-				SetAsicWcidAttri.Cipher = pAd->SharedKey[apidx][KeyID].CipherAlg;	\
-			}																		\
-			else SetAsicWcidAttri.Cipher = 0;										\
-            DBGPRINT(RT_DEBUG_TRACE, ("aid cipher = %ld\n",SetAsicWcidAttri.Cipher));       \
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_SET_ASIC_WCID_CIPHER,			\
-							&SetAsicWcidAttri, sizeof(struct rt_set_asic_wcid_attri)); } }
-
-/* Insert the BA bitmap to ASIC for the Wcid entry */
-#define RTMP_ADD_BA_SESSION_TO_ASIC(_pAd, _Aid, _TID)					\
-		do{																\
-			struct rt_set_asic_wcid	SetAsicWcid;							\
-			SetAsicWcid.WCID = (_Aid);									\
-			SetAsicWcid.SetTid = (0x10000<<(_TID));						\
-			SetAsicWcid.DeleteTid = 0xffffffff;							\
-			RTUSBEnqueueInternalCmd((_pAd), CMDTHREAD_SET_ASIC_WCID, &SetAsicWcid, sizeof(struct rt_set_asic_wcid));	\
-		}while(0)
-
-/* Remove the BA bitmap from ASIC for the Wcid entry */
-#define RTMP_DEL_BA_SESSION_FROM_ASIC(_pAd, _Wcid, _TID)				\
-		do{																\
-			struct rt_set_asic_wcid	SetAsicWcid;							\
-			SetAsicWcid.WCID = (_Wcid);									\
-			SetAsicWcid.SetTid = (0xffffffff);							\
-			SetAsicWcid.DeleteTid = (0x10000<<(_TID) );					\
-			RTUSBEnqueueInternalCmd((_pAd), CMDTHREAD_SET_ASIC_WCID, &SetAsicWcid, sizeof(struct rt_set_asic_wcid));	\
-		}while(0)
-
-#endif /* __RTUSB_IO_H__ // */
diff --git a/drivers/staging/rt2860/spectrum.h b/drivers/staging/rt2860/spectrum.h
deleted file mode 100644
index 4c325ba..0000000
--- a/drivers/staging/rt2860/spectrum.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
- */
-
-#ifndef __SPECTRUM_H__
-#define __SPECTRUM_H__
-
-#include "rtmp_type.h"
-#include "spectrum_def.h"
-
-char RTMP_GetTxPwr(struct rt_rtmp_adapter *pAd, IN HTTRANSMIT_SETTING HTTxMode);
-
-/*
-	==========================================================================
-	Description:
-		Prepare Measurement request action frame and enqueue it into
-		management queue waiting for transmission.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void MakeMeasurementReqFrame(struct rt_rtmp_adapter *pAd,
-			     u8 *pOutBuffer,
-			     unsigned long *pFrameLen,
-			     u8 TotalLen,
-			     u8 Category,
-			     u8 Action,
-			     u8 MeasureToken,
-			     u8 MeasureReqMode,
-			     u8 MeasureReqType,
-			     u8 NumOfRepetitions);
-
-/*
-	==========================================================================
-	Description:
-		Prepare Measurement report action frame and enqueue it into
-		management queue waiting for transmission.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueMeasurementRep(struct rt_rtmp_adapter *pAd,
-			   u8 *pDA,
-			   u8 DialogToken,
-			   u8 MeasureToken,
-			   u8 MeasureReqMode,
-			   u8 MeasureReqType,
-			   u8 ReportInfoLen, u8 *pReportInfo);
-
-/*
-	==========================================================================
-	Description:
-		Prepare TPC Request action frame and enqueue it into
-		management queue waiting for transmission.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueTPCReq(struct rt_rtmp_adapter *pAd, u8 *pDA, u8 DialogToken);
-
-/*
-	==========================================================================
-	Description:
-		Prepare TPC Report action frame and enqueue it into
-		management queue waiting for transmission.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueTPCRep(struct rt_rtmp_adapter *pAd,
-		   u8 *pDA,
-		   u8 DialogToken, u8 TxPwr, u8 LinkMargin);
-
-/*
-	==========================================================================
-	Description:
-		Prepare Channel Switch Announcement action frame and enqueue it into
-		management queue waiting for transmission.
-
-	Parametrs:
-		1. the destination mac address of the frame.
-		2. Channel switch announcement mode.
-		2. a New selected channel.
-
-	Return	: None.
-	==========================================================================
- */
-void EnqueueChSwAnn(struct rt_rtmp_adapter *pAd,
-		    u8 *pDA, u8 ChSwMode, u8 NewCh);
-
-/*
-	==========================================================================
-	Description:
-		Spectrun action frames Handler such as channel switch announcement,
-		measurement report, measurement request actions frames.
-
-	Parametrs:
-		Elme - MLME message containing the received frame
-
-	Return	: None.
-	==========================================================================
- */
-void PeerSpectrumAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem);
-
-/*
-	==========================================================================
-	Description:
-
-	Parametrs:
-
-	Return	: None.
-	==========================================================================
- */
-int Set_MeasureReq_Proc(struct rt_rtmp_adapter *pAd, char *arg);
-
-int Set_TpcReq_Proc(struct rt_rtmp_adapter *pAd, char *arg);
-
-int Set_PwrConstraint(struct rt_rtmp_adapter *pAd, char *arg);
-
-void MeasureReqTabInit(struct rt_rtmp_adapter *pAd);
-
-void MeasureReqTabExit(struct rt_rtmp_adapter *pAd);
-
-struct rt_measure_req_entry *MeasureReqLookUp(struct rt_rtmp_adapter *pAd, u8 DialogToken);
-
-struct rt_measure_req_entry *MeasureReqInsert(struct rt_rtmp_adapter *pAd, u8 DialogToken);
-
-void MeasureReqDelete(struct rt_rtmp_adapter *pAd, u8 DialogToken);
-
-void InsertChannelRepIE(struct rt_rtmp_adapter *pAd,
-			u8 *pFrameBuf,
-			unsigned long *pFrameLen,
-			char *pCountry, u8 RegulatoryClass);
-
-void InsertTpcReportIE(struct rt_rtmp_adapter *pAd,
-		       u8 *pFrameBuf,
-		       unsigned long *pFrameLen,
-		       u8 TxPwr, u8 LinkMargin);
-
-void InsertDialogToken(struct rt_rtmp_adapter *pAd,
-		       u8 *pFrameBuf,
-		       unsigned long *pFrameLen, u8 DialogToken);
-
-void TpcReqTabInit(struct rt_rtmp_adapter *pAd);
-
-void TpcReqTabExit(struct rt_rtmp_adapter *pAd);
-
-void NotifyChSwAnnToPeerAPs(struct rt_rtmp_adapter *pAd,
-			    u8 *pRA,
-			    u8 *pTA, u8 ChSwMode, u8 Channel);
-
-void RguClass_BuildBcnChList(struct rt_rtmp_adapter *pAd,
-			     u8 *pBuf, unsigned long *pBufLen);
-#endif /* __SPECTRUM_H__ // */
diff --git a/drivers/staging/rt2860/spectrum_def.h b/drivers/staging/rt2860/spectrum_def.h
deleted file mode 100644
index 8ffcfb0..0000000
--- a/drivers/staging/rt2860/spectrum_def.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-	spectrum_def.h
-
-    Abstract:
-    Handle association related requests either from WSTA or from local MLME
-
-    Revision History:
-    Who          When          What
-    ---------    ----------    ----------------------------------------------
-	Fonchi Wu    2008	  	   created for 802.11h
- */
-
-#ifndef __SPECTRUM_DEF_H__
-#define __SPECTRUM_DEF_H__
-
-#define MAX_MEASURE_REQ_TAB_SIZE		32
-#define MAX_HASH_MEASURE_REQ_TAB_SIZE	MAX_MEASURE_REQ_TAB_SIZE
-
-#define MAX_TPC_REQ_TAB_SIZE			32
-#define MAX_HASH_TPC_REQ_TAB_SIZE		MAX_TPC_REQ_TAB_SIZE
-
-#define MIN_RCV_PWR				100	/* Negative value ((dBm) */
-
-#define TPC_REQ_AGE_OUT			500	/* ms */
-#define MQ_REQ_AGE_OUT			500	/* ms */
-
-#define TPC_DIALOGTOKEN_HASH_INDEX(_DialogToken)	((_DialogToken) % MAX_HASH_TPC_REQ_TAB_SIZE)
-#define MQ_DIALOGTOKEN_HASH_INDEX(_DialogToken)		((_DialogToken) % MAX_MEASURE_REQ_TAB_SIZE)
-
-struct rt_measure_req_entry;
-
-struct rt_measure_req_entry {
-	struct rt_measure_req_entry *pNext;
-	unsigned long lastTime;
-	BOOLEAN Valid;
-	u8 DialogToken;
-	u8 MeasureDialogToken[3];	/* 0:basic measure, 1: CCA measure, 2: RPI_Histogram measure. */
-};
-
-struct rt_measure_req_tab {
-	u8 Size;
-	struct rt_measure_req_entry *Hash[MAX_HASH_MEASURE_REQ_TAB_SIZE];
-	struct rt_measure_req_entry Content[MAX_MEASURE_REQ_TAB_SIZE];
-};
-
-struct rt_tpc_req_entry;
-
-struct rt_tpc_req_entry {
-	struct rt_tpc_req_entry *pNext;
-	unsigned long lastTime;
-	BOOLEAN Valid;
-	u8 DialogToken;
-};
-
-struct rt_tpc_req_tab {
-	u8 Size;
-	struct rt_tpc_req_entry *Hash[MAX_HASH_TPC_REQ_TAB_SIZE];
-	struct rt_tpc_req_entry Content[MAX_TPC_REQ_TAB_SIZE];
-};
-
-/* The regulatory information */
-struct rt_dot11_channel_set {
-	u8 NumberOfChannels;
-	u8 MaxTxPwr;
-	u8 ChannelList[16];
-};
-
-struct rt_dot11_regulatory_information {
-	u8 RegulatoryClass;
-	struct rt_dot11_channel_set ChannelSet;
-};
-
-#define RM_TPC_REQ				0
-#define RM_MEASURE_REQ			1
-
-#define RM_BASIC				0
-#define RM_CCA					1
-#define RM_RPI_HISTOGRAM		2
-#define RM_CH_LOAD				3
-#define RM_NOISE_HISTOGRAM		4
-
-struct PACKED rt_tpc_report_info {
-	u8 TxPwr;
-	u8 LinkMargin;
-};
-
-struct PACKED rt_ch_sw_ann_info {
-	u8 ChSwMode;
-	u8 Channel;
-	u8 ChSwCnt;
-};
-
-typedef union PACKED _MEASURE_REQ_MODE {
-	struct PACKED {
-		u8 Parallel:1;
-		u8 Enable:1;
-		u8 Request:1;
-		u8 Report:1;
-		u8 DurationMandatory:1;
-		 u8:3;
-	} field;
-	u8 word;
-} MEASURE_REQ_MODE, *PMEASURE_REQ_MODE;
-
-struct PACKED rt_measure_req {
-	u8 ChNum;
-	u64 MeasureStartTime;
-	u16 MeasureDuration;
-};
-
-struct PACKED rt_measure_req_info {
-	u8 Token;
-	MEASURE_REQ_MODE ReqMode;
-	u8 ReqType;
-	u8 Oct[0];
-};
-
-typedef union PACKED _MEASURE_BASIC_REPORT_MAP {
-	struct PACKED {
-		u8 BSS:1;
-
-		u8 OfdmPreamble:1;
-		u8 UnidentifiedSignal:1;
-		u8 Radar:1;
-		u8 Unmeasure:1;
-		u8 Rev:3;
-	} field;
-	u8 word;
-} MEASURE_BASIC_REPORT_MAP, *PMEASURE_BASIC_REPORT_MAP;
-
-struct PACKED rt_measure_basic_report {
-	u8 ChNum;
-	u64 MeasureStartTime;
-	u16 MeasureDuration;
-	MEASURE_BASIC_REPORT_MAP Map;
-};
-
-struct PACKED rt_measure_cca_report {
-	u8 ChNum;
-	u64 MeasureStartTime;
-	u16 MeasureDuration;
-	u8 CCA_Busy_Fraction;
-};
-
-struct PACKED rt_measure_rpi_report {
-	u8 ChNum;
-	u64 MeasureStartTime;
-	u16 MeasureDuration;
-	u8 RPI_Density[8];
-};
-
-typedef union PACKED _MEASURE_REPORT_MODE {
-	struct PACKED {
-		u8 Late:1;
-		u8 Incapable:1;
-		u8 Refused:1;
-		u8 Rev:5;
-	} field;
-	u8 word;
-} MEASURE_REPORT_MODE, *PMEASURE_REPORT_MODE;
-
-struct PACKED rt_measure_report_info {
-	u8 Token;
-	u8 ReportMode;
-	u8 ReportType;
-	u8 Octect[0];
-};
-
-struct PACKED rt_quiet_info {
-	u8 QuietCnt;
-	u8 QuietPeriod;
-	u16 QuietDuration;
-	u16 QuietOffset;
-};
-
-#endif /* __SPECTRUM_DEF_H__ // */
diff --git a/drivers/staging/rt2860/sta/assoc.c b/drivers/staging/rt2860/sta/assoc.c
deleted file mode 100644
index 59e931c..0000000
--- a/drivers/staging/rt2860/sta/assoc.c
+++ /dev/null
@@ -1,1602 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	assoc.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John			2004-9-3		porting from RT2500
-	Justin P. Mattock	11/07/2010		Fix typos
-*/
-#include "../rt_config.h"
-
-u8 CipherWpaTemplate[] = {
-	0xdd,			/* WPA IE */
-	0x16,			/* Length */
-	0x00, 0x50, 0xf2, 0x01,	/* oui */
-	0x01, 0x00,		/* Version */
-	0x00, 0x50, 0xf2, 0x02,	/* Multicast */
-	0x01, 0x00,		/* Number of unicast */
-	0x00, 0x50, 0xf2, 0x02,	/* unicast */
-	0x01, 0x00,		/* number of authentication method */
-	0x00, 0x50, 0xf2, 0x01	/* authentication */
-};
-
-u8 CipherWpa2Template[] = {
-	0x30,			/* RSN IE */
-	0x14,			/* Length */
-	0x01, 0x00,		/* Version */
-	0x00, 0x0f, 0xac, 0x02,	/* group cipher, TKIP */
-	0x01, 0x00,		/* number of pairwise */
-	0x00, 0x0f, 0xac, 0x02,	/* unicast */
-	0x01, 0x00,		/* number of authentication method */
-	0x00, 0x0f, 0xac, 0x02,	/* authentication */
-	0x00, 0x00,		/* RSN capability */
-};
-
-u8 Ccx2IeInfo[] = { 0x00, 0x40, 0x96, 0x03, 0x02 };
-
-/*
-	==========================================================================
-	Description:
-		association state machine init, including state transition and timer init
-	Parameters:
-		S - pointer to the association state machine
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
- */
-void AssocStateMachineInit(struct rt_rtmp_adapter *pAd,
-			   struct rt_state_machine *S, OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(S, Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG,
-			 (STATE_MACHINE_FUNC) Drop, ASSOC_IDLE,
-			 ASSOC_MACHINE_BASE);
-
-	/* first column */
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ,
-			      (STATE_MACHINE_FUNC) MlmeAssocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ,
-			      (STATE_MACHINE_FUNC) MlmeReassocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC) MlmeDisassocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC) PeerDisassocAction);
-
-	/* second column */
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC)
-			      InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC) PeerDisassocAction);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
-			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
-	/* */
-	/* Patch 3Com AP MOde:3CRWE454G72 */
-	/* We send Assoc request frame to this AP, it always send Reassoc Rsp not Associate Rsp. */
-	/* */
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
-			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT,
-			      (STATE_MACHINE_FUNC) AssocTimeoutAction);
-
-	/* third column */
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC)
-			      InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC) PeerDisassocAction);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
-			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
-	/* */
-	/* Patch, AP doesn't send Reassociate Rsp frame to Station. */
-	/* */
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
-			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT,
-			      (STATE_MACHINE_FUNC) ReassocTimeoutAction);
-
-	/* fourth column */
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC)
-			      InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
-			      (STATE_MACHINE_FUNC) PeerDisassocAction);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT,
-			      (STATE_MACHINE_FUNC) DisassocTimeoutAction);
-
-	/* initialize the timer */
-	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer,
-		      GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer,
-		      GET_TIMER_FUNCTION(ReassocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer,
-		      GET_TIMER_FUNCTION(DisassocTimeout), pAd, FALSE);
-}
-
-/*
-	==========================================================================
-	Description:
-		Association timeout procedure. After association timeout, this function
-		will be called and it will put a message into the MLME queue
-	Parameters:
-		Standard timer parameters
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AssocTimeout(void *SystemSpecific1,
-		  void *FunctionContext,
-		  void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
-	RTMP_MLME_HANDLER(pAd);
-}
-
-/*
-	==========================================================================
-	Description:
-		Reassociation timeout procedure. After reassociation timeout, this
-		function will be called and put a message into the MLME queue
-	Parameters:
-		Standard timer parameters
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void ReassocTimeout(void *SystemSpecific1,
-		    void *FunctionContext,
-		    void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
-	RTMP_MLME_HANDLER(pAd);
-}
-
-/*
-	==========================================================================
-	Description:
-		Disassociation timeout procedure. After disassociation timeout, this
-		function will be called and put a message into the MLME queue
-	Parameters:
-		Standard timer parameters
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void DisassocTimeout(void *SystemSpecific1,
-		     void *FunctionContext,
-		     void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
-	RTMP_MLME_HANDLER(pAd);
-}
-
-/*
-	==========================================================================
-	Description:
-		mlme assoc req handling procedure
-	Parameters:
-		Adapter - Adapter pointer
-		Elem - MLME Queue Element
-	Pre:
-		the station has been authenticated and the following information is stored in the config
-			-# SSID
-			-# supported rates and their length
-			-# listen interval (Adapter->StaCfg.default_listen_count)
-			-# Transmit power  (Adapter->StaCfg.tx_power)
-	Post  :
-		-# An association request frame is generated and sent to the air
-		-# Association timer starts
-		-# Association state -> ASSOC_WAIT_RSP
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void MlmeAssocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 ApAddr[6];
-	struct rt_header_802_11 AssocHdr;
-	u8 WmeIe[9] =
-	    { IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01,
-       0x00 };
-	u16 ListenIntv;
-	unsigned long Timeout;
-	u16 CapabilityInfo;
-	BOOLEAN TimerCancelled;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	unsigned long tmp;
-	u16 VarIesOffset;
-	u16 Status;
-
-	/* Block all authentication request during WPA block period */
-	if (pAd->StaCfg.bBlockAssoc == TRUE) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - Block Assoc request during WPA block period!\n"));
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2,
-			    &Status);
-	}
-	/* check sanity first */
-	else if (MlmeAssocReqSanity
-		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
-		  &Timeout, &ListenIntv)) {
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
-		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
-
-		/* Get an unused nonpaged memory */
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ASSOC - MlmeAssocReqAction() allocate memory failed \n"));
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_ASSOC_CONF, 2, &Status);
-			return;
-		}
-		/* Add by James 03/06/27 */
-		pAd->StaCfg.AssocInfo.Length =
-		    sizeof(struct rt_ndis_802_11_association_information);
-		/* Association don't need to report MAC address */
-		pAd->StaCfg.AssocInfo.AvailableRequestFixedIEs =
-		    NDIS_802_11_AI_REQFI_CAPABILITIES |
-		    NDIS_802_11_AI_REQFI_LISTENINTERVAL;
-		pAd->StaCfg.AssocInfo.RequestFixedIEs.Capabilities =
-		    CapabilityInfo;
-		pAd->StaCfg.AssocInfo.RequestFixedIEs.ListenInterval =
-		    ListenIntv;
-		/* Only reassociate need this */
-		/*COPY_MAC_ADDR(pAd->StaCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr); */
-		pAd->StaCfg.AssocInfo.OffsetRequestIEs =
-		    sizeof(struct rt_ndis_802_11_association_information);
-
-		NdisZeroMemory(pAd->StaCfg.ReqVarIEs, MAX_VIE_LEN);
-		/* First add SSID */
-		VarIesOffset = 0;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SsidIe,
-			       1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
-			       &pAd->MlmeAux.SsidLen, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
-			       pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-		VarIesOffset += pAd->MlmeAux.SsidLen;
-
-		/* Second add Supported rates */
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SupRateIe,
-			       1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
-			       &pAd->MlmeAux.SupRateLen, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
-			       pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
-		VarIesOffset += pAd->MlmeAux.SupRateLen;
-		/* End Add by James */
-
-		if ((pAd->CommonCfg.Channel > 14) &&
-		    (pAd->CommonCfg.bIEEE80211H == TRUE))
-			CapabilityInfo |= 0x0100;
-
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Send ASSOC request...\n"));
-		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr,
-				 ApAddr);
-
-		/* Build basic frame first */
-		MakeOutgoingFrame(pOutBuffer, &FrameLen,
-				  sizeof(struct rt_header_802_11), &AssocHdr,
-				  2, &CapabilityInfo,
-				  2, &ListenIntv,
-				  1, &SsidIe,
-				  1, &pAd->MlmeAux.SsidLen,
-				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid,
-				  1, &SupRateIe,
-				  1, &pAd->MlmeAux.SupRateLen,
-				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
-				  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0) {
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-					  1, &ExtRateIe,
-					  1, &pAd->MlmeAux.ExtRateLen,
-					  pAd->MlmeAux.ExtRateLen,
-					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
-			FrameLen += tmp;
-		}
-		/* HT */
-		if ((pAd->MlmeAux.HtCapabilityLen > 0)
-		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
-			unsigned long TmpLen;
-			u8 HtLen;
-			u8 BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
-			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
-				HtLen = SIZE_HT_CAP_IE + 4;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 1, &WpaIe, 1, &HtLen,
-						  4, &BROADCOM[0],
-						  pAd->MlmeAux.HtCapabilityLen,
-						  &pAd->MlmeAux.HtCapability,
-						  END_OF_ARGS);
-			} else {
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 1, &HtCapIe, 1,
-						  &pAd->MlmeAux.HtCapabilityLen,
-						  pAd->MlmeAux.HtCapabilityLen,
-						  &pAd->MlmeAux.HtCapability,
-						  END_OF_ARGS);
-			}
-			FrameLen += TmpLen;
-		}
-		/* add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION */
-		/* Case I: (Aggregation + Piggy-Back) */
-		/* 1. user enable aggregation, AND */
-		/* 2. Mac support piggy-back */
-		/* 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON */
-		/* Case II: (Aggregation) */
-		/* 1. user enable aggregation, AND */
-		/* 2. AP annouces it's AGGREGATION-capable in BEACON */
-		if (pAd->CommonCfg.bAggregationCapable) {
-			if ((pAd->CommonCfg.bPiggyBackCapable)
-			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
-				unsigned long TmpLen;
-				u8 RalinkIe[9] =
-				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
-			    0x03, 0x00, 0x00, 0x00 };
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 9, RalinkIe,
-						  END_OF_ARGS);
-				FrameLen += TmpLen;
-			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
-				unsigned long TmpLen;
-				u8 RalinkIe[9] =
-				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
-			    0x01, 0x00, 0x00, 0x00 };
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 9, RalinkIe,
-						  END_OF_ARGS);
-				FrameLen += TmpLen;
-			}
-		} else {
-			unsigned long TmpLen;
-			u8 RalinkIe[9] =
-			    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x06,
-		    0x00, 0x00, 0x00 };
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &TmpLen, 9,
-					  RalinkIe, END_OF_ARGS);
-			FrameLen += TmpLen;
-		}
-
-		if (pAd->MlmeAux.APEdcaParm.bValid) {
-			if (pAd->CommonCfg.bAPSDCapable
-			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
-				struct rt_qbss_sta_info_parm QosInfo;
-
-				NdisZeroMemory(&QosInfo,
-					       sizeof(struct rt_qbss_sta_info_parm));
-				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
-				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
-				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
-				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
-				QosInfo.MaxSPLength =
-				    pAd->CommonCfg.MaxSPLength;
-				WmeIe[8] |= *(u8 *)& QosInfo;
-			} else {
-				/* The Parameter Set Count is set to 0 in the association request frames */
-				/* WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f); */
-			}
-
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-					  9, &WmeIe[0], END_OF_ARGS);
-			FrameLen += tmp;
-		}
-		/* */
-		/* Let WPA(#221) Element ID on the end of this association frame. */
-		/* Otherwise some AP will fail on parsing Element ID and set status fail on Assoc Rsp. */
-		/* For example: Put Vendor Specific IE on the front of WPA IE. */
-		/* This happens on AP (Model No:Linksys WRK54G) */
-		/* */
-		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
-		    )
-		    ) {
-			u8 RSNIe = IE_WPA;
-
-			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-			    || (pAd->StaCfg.AuthMode ==
-				Ndis802_11AuthModeWPA2)) {
-				RSNIe = IE_WPA2;
-			}
-
-			if ((pAd->StaCfg.WpaSupplicantUP !=
-			     WPA_SUPPLICANT_ENABLE)
-			    && (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE))
-				RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode,
-					      pAd->StaCfg.WepStatus, BSS0);
-
-			/* Check for WPA PMK cache list */
-			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) {
-				int idx;
-				BOOLEAN FoundPMK = FALSE;
-				/* Search chched PMKID, append it if existed */
-				for (idx = 0; idx < PMKID_NO; idx++) {
-					if (NdisEqualMemory
-					    (ApAddr,
-					     &pAd->StaCfg.SavedPMK[idx].BSSID,
-					     6)) {
-						FoundPMK = TRUE;
-						break;
-					}
-				}
-				if (FoundPMK) {
-					/* Set PMK number */
-					*(u16 *)& pAd->StaCfg.RSN_IE[pAd->
-									StaCfg.
-									RSNIE_Len]
-					    = 1;
-					NdisMoveMemory(&pAd->StaCfg.
-						       RSN_IE[pAd->StaCfg.
-							      RSNIE_Len + 2],
-						       &pAd->StaCfg.
-						       SavedPMK[idx].PMKID, 16);
-					pAd->StaCfg.RSNIE_Len += 18;
-				}
-			}
-
-			if ((pAd->StaCfg.WpaSupplicantUP ==
-			     WPA_SUPPLICANT_ENABLE)
-			    && (pAd->StaCfg.bRSN_IE_FromWpaSupplicant ==
-				TRUE)) {
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-						  pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSN_IE,
-						  END_OF_ARGS);
-			} else {
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-						  1, &RSNIe,
-						  1, &pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSN_IE,
-						  END_OF_ARGS);
-			}
-
-			FrameLen += tmp;
-
-			if ((pAd->StaCfg.WpaSupplicantUP !=
-			     WPA_SUPPLICANT_ENABLE)
-			    || (pAd->StaCfg.bRSN_IE_FromWpaSupplicant ==
-				FALSE)) {
-				/* Append Variable IE */
-				NdisMoveMemory(pAd->StaCfg.ReqVarIEs +
-					       VarIesOffset, &RSNIe, 1);
-				VarIesOffset += 1;
-				NdisMoveMemory(pAd->StaCfg.ReqVarIEs +
-					       VarIesOffset,
-					       &pAd->StaCfg.RSNIE_Len, 1);
-				VarIesOffset += 1;
-			}
-			NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
-				       pAd->StaCfg.RSN_IE,
-				       pAd->StaCfg.RSNIE_Len);
-			VarIesOffset += pAd->StaCfg.RSNIE_Len;
-
-			/* Set Variable IEs Length */
-			pAd->StaCfg.ReqVarIELen = VarIesOffset;
-		}
-
-		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer);
-
-		RTMPSetTimer(&pAd->MlmeAux.AssocTimer, Timeout);
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - MlmeAssocReqAction() sanity check failed. BUG!\n"));
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2,
-			    &Status);
-	}
-
-}
-
-/*
-	==========================================================================
-	Description:
-		mlme reassoc req handling procedure
-	Parameters:
-		Elem -
-	Pre:
-		-# SSID  (Adapter->StaCfg.ssid[])
-		-# BSSID (AP address, Adapter->StaCfg.bssid)
-		-# Supported rates (Adapter->StaCfg.supported_rates[])
-		-# Supported rates length (Adapter->StaCfg.supported_rates_len)
-		-# Tx power (Adapter->StaCfg.tx_power)
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void MlmeReassocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 ApAddr[6];
-	struct rt_header_802_11 ReassocHdr;
-	u8 WmeIe[9] =
-	    { IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01,
-       0x00 };
-	u16 CapabilityInfo, ListenIntv;
-	unsigned long Timeout;
-	unsigned long FrameLen = 0;
-	BOOLEAN TimerCancelled;
-	int NStatus;
-	unsigned long tmp;
-	u8 *pOutBuffer = NULL;
-	u16 Status;
-
-	/* Block all authentication request during WPA block period */
-	if (pAd->StaCfg.bBlockAssoc == TRUE) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - Block ReAssoc request during WPA block period!\n"));
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2,
-			    &Status);
-	}
-	/* the parameters are the same as the association */
-	else if (MlmeAssocReqSanity
-		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
-		  &Timeout, &ListenIntv)) {
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &TimerCancelled);
-
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ASSOC - MlmeReassocReqAction() allocate memory failed \n"));
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_REASSOC_CONF, 2, &Status);
-			return;
-		}
-
-		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
-
-		/* make frame, use bssid as the AP address?? */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - Send RE-ASSOC request...\n"));
-		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0,
-				 ApAddr, ApAddr);
-		MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(struct rt_header_802_11),
-				  &ReassocHdr, 2, &CapabilityInfo, 2,
-				  &ListenIntv, MAC_ADDR_LEN, ApAddr, 1, &SsidIe,
-				  1, &pAd->MlmeAux.SsidLen,
-				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid, 1,
-				  &SupRateIe, 1, &pAd->MlmeAux.SupRateLen,
-				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
-				  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0) {
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-					  1, &ExtRateIe,
-					  1, &pAd->MlmeAux.ExtRateLen,
-					  pAd->MlmeAux.ExtRateLen,
-					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
-			FrameLen += tmp;
-		}
-
-		if (pAd->MlmeAux.APEdcaParm.bValid) {
-			if (pAd->CommonCfg.bAPSDCapable
-			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
-				struct rt_qbss_sta_info_parm QosInfo;
-
-				NdisZeroMemory(&QosInfo,
-					       sizeof(struct rt_qbss_sta_info_parm));
-				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
-				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
-				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
-				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
-				QosInfo.MaxSPLength =
-				    pAd->CommonCfg.MaxSPLength;
-				WmeIe[8] |= *(u8 *)& QosInfo;
-			}
-
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-					  9, &WmeIe[0], END_OF_ARGS);
-			FrameLen += tmp;
-		}
-		/* HT */
-		if ((pAd->MlmeAux.HtCapabilityLen > 0)
-		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
-			unsigned long TmpLen;
-			u8 HtLen;
-			u8 BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
-			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
-				HtLen = SIZE_HT_CAP_IE + 4;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 1, &WpaIe, 1, &HtLen,
-						  4, &BROADCOM[0],
-						  pAd->MlmeAux.HtCapabilityLen,
-						  &pAd->MlmeAux.HtCapability,
-						  END_OF_ARGS);
-			} else {
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 1, &HtCapIe, 1,
-						  &pAd->MlmeAux.HtCapabilityLen,
-						  pAd->MlmeAux.HtCapabilityLen,
-						  &pAd->MlmeAux.HtCapability,
-						  END_OF_ARGS);
-			}
-			FrameLen += TmpLen;
-		}
-		/* add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION */
-		/* Case I: (Aggregation + Piggy-Back) */
-		/* 1. user enable aggregation, AND */
-		/* 2. Mac support piggy-back */
-		/* 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON */
-		/* Case II: (Aggregation) */
-		/* 1. user enable aggregation, AND */
-		/* 2. AP annouces it's AGGREGATION-capable in BEACON */
-		if (pAd->CommonCfg.bAggregationCapable) {
-			if ((pAd->CommonCfg.bPiggyBackCapable)
-			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
-				unsigned long TmpLen;
-				u8 RalinkIe[9] =
-				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
-			    0x03, 0x00, 0x00, 0x00 };
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 9, RalinkIe,
-						  END_OF_ARGS);
-				FrameLen += TmpLen;
-			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
-				unsigned long TmpLen;
-				u8 RalinkIe[9] =
-				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
-			    0x01, 0x00, 0x00, 0x00 };
-				MakeOutgoingFrame(pOutBuffer + FrameLen,
-						  &TmpLen, 9, RalinkIe,
-						  END_OF_ARGS);
-				FrameLen += TmpLen;
-			}
-		} else {
-			unsigned long TmpLen;
-			u8 RalinkIe[9] =
-			    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x04,
-		    0x00, 0x00, 0x00 };
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &TmpLen, 9,
-					  RalinkIe, END_OF_ARGS);
-			FrameLen += TmpLen;
-		}
-
-		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer);
-
-		RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout);	/* in mSec */
-		pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - MlmeReassocReqAction() sanity check failed. BUG!\n"));
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2,
-			    &Status);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		Upper layer issues disassoc request
-	Parameters:
-		Elem -
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
- */
-void MlmeDisassocReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_disassoc_req *pDisassocReq;
-	struct rt_header_802_11 DisassocHdr;
-	struct rt_header_802_11 * pDisassocHdr;
-	u8 *pOutBuffer = NULL;
-	unsigned long FrameLen = 0;
-	int NStatus;
-	BOOLEAN TimerCancelled;
-	unsigned long Timeout = 500;
-	u16 Status;
-
-	/* skip sanity check */
-	pDisassocReq = (struct rt_mlme_disassoc_req *)(Elem->Msg);
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - MlmeDisassocReqAction() allocate memory failed\n"));
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_FAIL_NO_RESOURCE;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
-			    &Status);
-		return;
-	}
-
-	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &TimerCancelled);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		("ASSOC - Send DISASSOC request[BSSID::%pM (Reason=%d)\n",
-			pDisassocReq->Addr, pDisassocReq->Reason));
-	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);	/* patch peap ttls switching issue */
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  sizeof(struct rt_header_802_11), &DisassocHdr,
-			  2, &pDisassocReq->Reason, END_OF_ARGS);
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-
-	/* To patch Instance and Buffalo(N) AP */
-	/* Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine */
-	/* Therefore, we send both of them. */
-	pDisassocHdr = (struct rt_header_802_11 *) pOutBuffer;
-	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	pAd->StaCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
-	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pDisassocReq->Addr);
-
-	RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout);	/* in mSec */
-	pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
-
-	RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
-
-}
-
-/*
-	==========================================================================
-	Description:
-		peer sends assoc rsp back
-	Parameters:
-		Elme - MLME message containing the received frame
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void PeerAssocRspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 CapabilityInfo, Status, Aid;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-	u8 Addr2[MAC_ADDR_LEN];
-	BOOLEAN TimerCancelled;
-	u8 CkipFlag;
-	struct rt_edca_parm EdcaParm;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 HtCapabilityLen = 0;
-	u8 AddHtInfoLen;
-	u8 NewExtChannelOffset = 0xff;
-
-	if (PeerAssocRspSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status,
-	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
-	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
-	     &EdcaParm, &CkipFlag)) {
-		/* The frame is for me ? */
-		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerAssocRspAction():ASSOC - receive ASSOC_RSP to me (status=%d)\n",
-				  Status));
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerAssocRspAction():MacTable [%d].AMsduSize = %d. ClientStatusFlags = 0x%lx \n",
-				  Elem->Wcid,
-				  pAd->MacTab.Content[BSSID_WCID].AMsduSize,
-				  pAd->MacTab.Content[BSSID_WCID].
-				  ClientStatusFlags));
-			RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,
-					&TimerCancelled);
-
-			if (Status == MLME_SUCCESS) {
-				u8 MaxSupportedRateIn500Kbps = 0;
-				u8 idx;
-
-				/* supported rates array may not be sorted. sort it and find the maximum rate */
-				for (idx = 0; idx < SupRateLen; idx++) {
-					if (MaxSupportedRateIn500Kbps <
-					    (SupRate[idx] & 0x7f))
-						MaxSupportedRateIn500Kbps =
-						    SupRate[idx] & 0x7f;
-				}
-
-				for (idx = 0; idx < ExtRateLen; idx++) {
-					if (MaxSupportedRateIn500Kbps <
-					    (ExtRate[idx] & 0x7f))
-						MaxSupportedRateIn500Kbps =
-						    ExtRate[idx] & 0x7f;
-				}
-				/* go to procedure listed on page 376 */
-				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
-					      SupRate, SupRateLen, ExtRate,
-					      ExtRateLen, &EdcaParm,
-					      &HtCapability, HtCapabilityLen,
-					      &AddHtInfo);
-
-				StaAddMacTableEntry(pAd,
-						    &pAd->MacTab.
-						    Content[BSSID_WCID],
-						    MaxSupportedRateIn500Kbps,
-						    &HtCapability,
-						    HtCapabilityLen, &AddHtInfo,
-						    AddHtInfoLen,
-						    CapabilityInfo);
-			}
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_ASSOC_CONF, 2, &Status);
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - PeerAssocRspAction() sanity check fail\n"));
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		peer sends reassoc rsp
-	Parametrs:
-		Elem - MLME message cntaining the received frame
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void PeerReassocRspAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 CapabilityInfo;
-	u16 Status;
-	u16 Aid;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-	u8 Addr2[MAC_ADDR_LEN];
-	u8 CkipFlag;
-	BOOLEAN TimerCancelled;
-	struct rt_edca_parm EdcaParm;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 HtCapabilityLen;
-	u8 AddHtInfoLen;
-	u8 NewExtChannelOffset = 0xff;
-
-	if (PeerAssocRspSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status,
-	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
-	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
-	     &EdcaParm, &CkipFlag)) {
-		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))	/* The frame is for me ? */
-		{
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("ASSOC - receive REASSOC_RSP to me (status=%d)\n",
-				  Status));
-			RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,
-					&TimerCancelled);
-
-			if (Status == MLME_SUCCESS) {
-				/* go to procedure listed on page 376 */
-				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
-					      SupRate, SupRateLen, ExtRate,
-					      ExtRateLen, &EdcaParm,
-					      &HtCapability, HtCapabilityLen,
-					      &AddHtInfo);
-
-				{
-					wext_notify_event_assoc(pAd);
-					RtmpOSWrielessEventSend(pAd, SIOCGIWAP,
-								-1,
-								&pAd->MlmeAux.
-								Bssid[0], NULL,
-								0);
-				}
-
-			}
-			/* CkipFlag is no use for reassociate */
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-				    MT2_REASSOC_CONF, 2, &Status);
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - PeerReassocRspAction() sanity check fail\n"));
-	}
-
-}
-
-/*
-	==========================================================================
-	Description:
-		procedures on IEEE 802.11/1999 p.376
-	Parametrs:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AssocPostProc(struct rt_rtmp_adapter *pAd, u8 *pAddr2, u16 CapabilityInfo, u16 Aid, u8 SupRate[], u8 SupRateLen, u8 ExtRate[], u8 ExtRateLen, struct rt_edca_parm *pEdcaParm, struct rt_ht_capability_ie * pHtCapability, u8 HtCapabilityLen, struct rt_add_ht_info_ie * pAddHtInfo)	/* AP might use this additional ht info IE */
-{
-	unsigned long Idx;
-
-	pAd->MlmeAux.BssType = BSS_INFRA;
-	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
-	pAd->MlmeAux.Aid = Aid;
-	pAd->MlmeAux.CapabilityInfo =
-	    CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
-
-	/* Some HT AP might lost WMM IE. We add WMM ourselves. because HT requires QoS on. */
-	if ((HtCapabilityLen > 0) && (pEdcaParm->bValid == FALSE)) {
-		pEdcaParm->bValid = TRUE;
-		pEdcaParm->Aifsn[0] = 3;
-		pEdcaParm->Aifsn[1] = 7;
-		pEdcaParm->Aifsn[2] = 2;
-		pEdcaParm->Aifsn[3] = 2;
-
-		pEdcaParm->Cwmin[0] = 4;
-		pEdcaParm->Cwmin[1] = 4;
-		pEdcaParm->Cwmin[2] = 3;
-		pEdcaParm->Cwmin[3] = 2;
-
-		pEdcaParm->Cwmax[0] = 10;
-		pEdcaParm->Cwmax[1] = 10;
-		pEdcaParm->Cwmax[2] = 4;
-		pEdcaParm->Cwmax[3] = 3;
-
-		pEdcaParm->Txop[0] = 0;
-		pEdcaParm->Txop[1] = 0;
-		pEdcaParm->Txop[2] = 96;
-		pEdcaParm->Txop[3] = 48;
-
-	}
-
-	NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(struct rt_edca_parm));
-
-	/* filter out un-supported rates */
-	pAd->MlmeAux.SupRateLen = SupRateLen;
-	NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
-	RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
-
-	/* filter out un-supported rates */
-	pAd->MlmeAux.ExtRateLen = ExtRateLen;
-	NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
-	RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
-
-	if (HtCapabilityLen > 0) {
-		RTMPCheckHt(pAd, BSSID_WCID, pHtCapability, pAddHtInfo);
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AssocPostProc===>  AP.AMsduSize = %d. ClientStatusFlags = 0x%lx \n",
-		  pAd->MacTab.Content[BSSID_WCID].AMsduSize,
-		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AssocPostProc===>    (Mmps=%d, AmsduSize=%d, )\n",
-		  pAd->MacTab.Content[BSSID_WCID].MmpsMode,
-		  pAd->MacTab.Content[BSSID_WCID].AMsduSize));
-
-	/* Set New WPA information */
-	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
-	if (Idx == BSS_NOT_FOUND) {
-		DBGPRINT_ERR("ASSOC - Can't find BSS after receiving Assoc response\n");
-	} else {
-		/* Init variable */
-		pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = 0;
-		NdisZeroMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE,
-			       MAX_LEN_OF_RSNIE);
-
-		/* Store appropriate RSN_IE for WPA SM negotiation later */
-		if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
-		    && (pAd->ScanTab.BssEntry[Idx].VarIELen != 0)) {
-			u8 *pVIE;
-			u16 len;
-			struct rt_eid * pEid;
-
-			pVIE = pAd->ScanTab.BssEntry[Idx].VarIEs;
-			len = pAd->ScanTab.BssEntry[Idx].VarIELen;
-			/*KH need to check again */
-			/* Don't allow to go to sleep mode if authmode is WPA-related. */
-			/*This can make Authentication process more smoothly. */
-			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-
-			while (len > 0) {
-				pEid = (struct rt_eid *) pVIE;
-				/* For WPA/WPAPSK */
-				if ((pEid->Eid == IE_WPA)
-				    &&
-				    (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
-				    && (pAd->StaCfg.AuthMode ==
-					Ndis802_11AuthModeWPA
-					|| pAd->StaCfg.AuthMode ==
-					Ndis802_11AuthModeWPAPSK)) {
-					NdisMoveMemory(pAd->MacTab.
-						       Content[BSSID_WCID].
-						       RSN_IE, pVIE,
-						       (pEid->Len + 2));
-					pAd->MacTab.Content[BSSID_WCID].
-					    RSNIE_Len = (pEid->Len + 2);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("AssocPostProc===> Store RSN_IE for WPA SM negotiation \n"));
-				}
-				/* For WPA2/WPA2PSK */
-				else if ((pEid->Eid == IE_RSN)
-					 &&
-					 (NdisEqualMemory
-					  (pEid->Octet + 2, RSN_OUI, 3))
-					 && (pAd->StaCfg.AuthMode ==
-					     Ndis802_11AuthModeWPA2
-					     || pAd->StaCfg.AuthMode ==
-					     Ndis802_11AuthModeWPA2PSK)) {
-					NdisMoveMemory(pAd->MacTab.
-						       Content[BSSID_WCID].
-						       RSN_IE, pVIE,
-						       (pEid->Len + 2));
-					pAd->MacTab.Content[BSSID_WCID].
-					    RSNIE_Len = (pEid->Len + 2);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("AssocPostProc===> Store RSN_IE for WPA2 SM negotiation \n"));
-				}
-
-				pVIE += (pEid->Len + 2);
-				len -= (pEid->Len + 2);
-			}
-
-		}
-
-		if (pAd->MacTab.Content[BSSID_WCID].RSNIE_Len == 0) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("AssocPostProc===> no RSN_IE \n"));
-		} else {
-			hex_dump("RSN_IE",
-				 pAd->MacTab.Content[BSSID_WCID].RSN_IE,
-				 pAd->MacTab.Content[BSSID_WCID].RSNIE_Len);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		left part of IEEE 802.11/1999 p.374
-	Parameters:
-		Elem - MLME message containing the received frame
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void PeerDisassocAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Addr2[MAC_ADDR_LEN];
-	u16 Reason;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerDisassocAction()\n"));
-	if (PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - PeerDisassocAction() Reason = %d\n",
-			  Reason));
-		if (INFRA_ON(pAd)
-		    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, Addr2)) {
-
-			if (pAd->CommonCfg.bWirelessEvent) {
-				RTMPSendWirelessEvent(pAd,
-						      IW_DISASSOC_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-			}
-
-			LinkDown(pAd, TRUE);
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
-						0);
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("ASSOC - PeerDisassocAction() sanity check fail\n"));
-	}
-
-}
-
-/*
-	==========================================================================
-	Description:
-		what the state machine will do after assoc timeout
-	Parameters:
-		Elme -
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void AssocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - AssocTimeoutAction\n"));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_REJ_TIMEOUT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-		what the state machine will do after reassoc timeout
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void ReassocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - ReassocTimeoutAction\n"));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_REJ_TIMEOUT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-		what the state machine will do after disassoc timeout
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void DisassocTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - DisassocTimeoutAction\n"));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_SUCCESS;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
-		    &Status);
-}
-
-void InvalidStateWhenAssoc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("ASSOC - InvalidStateWhenAssoc(state=%ld), reset ASSOC state machine\n",
-		  pAd->Mlme.AssocMachine.CurrState));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
-}
-
-void InvalidStateWhenReassoc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("ASSOC - InvalidStateWhenReassoc(state=%ld), reset ASSOC state machine\n",
-		  pAd->Mlme.AssocMachine.CurrState));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
-}
-
-void InvalidStateWhenDisassociate(struct rt_rtmp_adapter *pAd,
-				  struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("ASSOC - InvalidStateWhenDisassoc(state=%ld), reset ASSOC state machine\n",
-		  pAd->Mlme.AssocMachine.CurrState));
-	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
-		    &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-		right part of IEEE 802.11/1999 page 374
-	Note:
-		This event should never cause ASSOC state machine perform state
-		transition, and has no relationship with CNTL machine. So we separate
-		this routine as a service outside of ASSOC state transition table.
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void Cls3errAction(struct rt_rtmp_adapter *pAd, u8 *pAddr)
-{
-	struct rt_header_802_11 DisassocHdr;
-	struct rt_header_802_11 * pDisassocHdr;
-	u8 *pOutBuffer = NULL;
-	unsigned long FrameLen = 0;
-	int NStatus;
-	u16 Reason = REASON_CLS3ERR;
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS)
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("ASSOC - Class 3 Error, Send DISASSOC frame\n"));
-	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->CommonCfg.Bssid);	/* patch peap ttls switching issue */
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  sizeof(struct rt_header_802_11), &DisassocHdr,
-			  2, &Reason, END_OF_ARGS);
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-
-	/* To patch Instance and Buffalo(N) AP */
-	/* Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine */
-	/* Therefore, we send both of them. */
-	pDisassocHdr = (struct rt_header_802_11 *) pOutBuffer;
-	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	pAd->StaCfg.DisassocReason = REASON_CLS3ERR;
-	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pAddr);
-}
-
-int wext_notify_event_assoc(struct rt_rtmp_adapter *pAd)
-{
-	char custom[IW_CUSTOM_MAX] = { 0 };
-
-	if (pAd->StaCfg.ReqVarIELen <= IW_CUSTOM_MAX) {
-		NdisMoveMemory(custom, pAd->StaCfg.ReqVarIEs,
-			       pAd->StaCfg.ReqVarIELen);
-		RtmpOSWrielessEventSend(pAd, IWEVASSOCREQIE, -1, NULL, custom,
-					pAd->StaCfg.ReqVarIELen);
-	} else
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("pAd->StaCfg.ReqVarIELen > MAX_CUSTOM_LEN\n"));
-
-	return 0;
-
-}
-
-BOOLEAN StaAddMacTableEntry(struct rt_rtmp_adapter *pAd,
-			    struct rt_mac_table_entry *pEntry,
-			    u8 MaxSupportedRateIn500Kbps,
-			    struct rt_ht_capability_ie * pHtCapability,
-			    u8 HtCapabilityLen,
-			    struct rt_add_ht_info_ie * pAddHtInfo,
-			    u8 AddHtInfoLen, u16 CapabilityInfo)
-{
-	u8 MaxSupportedRate = RATE_11;
-
-	if (ADHOC_ON(pAd))
-		CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE);
-
-	switch (MaxSupportedRateIn500Kbps) {
-	case 108:
-		MaxSupportedRate = RATE_54;
-		break;
-	case 96:
-		MaxSupportedRate = RATE_48;
-		break;
-	case 72:
-		MaxSupportedRate = RATE_36;
-		break;
-	case 48:
-		MaxSupportedRate = RATE_24;
-		break;
-	case 36:
-		MaxSupportedRate = RATE_18;
-		break;
-	case 24:
-		MaxSupportedRate = RATE_12;
-		break;
-	case 18:
-		MaxSupportedRate = RATE_9;
-		break;
-	case 12:
-		MaxSupportedRate = RATE_6;
-		break;
-	case 22:
-		MaxSupportedRate = RATE_11;
-		break;
-	case 11:
-		MaxSupportedRate = RATE_5_5;
-		break;
-	case 4:
-		MaxSupportedRate = RATE_2;
-		break;
-	case 2:
-		MaxSupportedRate = RATE_1;
-		break;
-	default:
-		MaxSupportedRate = RATE_11;
-		break;
-	}
-
-	if ((pAd->CommonCfg.PhyMode == PHY_11G)
-	    && (MaxSupportedRate < RATE_FIRST_OFDM_RATE))
-		return FALSE;
-
-	/* 11n only */
-	if (((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
-	     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))
-	    && (HtCapabilityLen == 0))
-		return FALSE;
-
-	if (!pEntry)
-		return FALSE;
-
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-	if (pEntry) {
-		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
-		if ((MaxSupportedRate < RATE_FIRST_OFDM_RATE) ||
-		    (pAd->CommonCfg.PhyMode == PHY_11B)) {
-			pEntry->RateLen = 4;
-			if (MaxSupportedRate >= RATE_FIRST_OFDM_RATE)
-				MaxSupportedRate = RATE_11;
-		} else
-			pEntry->RateLen = 12;
-
-		pEntry->MaxHTPhyMode.word = 0;
-		pEntry->MinHTPhyMode.word = 0;
-		pEntry->HTPhyMode.word = 0;
-		pEntry->MaxSupportedRate = MaxSupportedRate;
-		if (pEntry->MaxSupportedRate < RATE_FIRST_OFDM_RATE) {
-			pEntry->MaxHTPhyMode.field.MODE = MODE_CCK;
-			pEntry->MaxHTPhyMode.field.MCS =
-			    pEntry->MaxSupportedRate;
-			pEntry->MinHTPhyMode.field.MODE = MODE_CCK;
-			pEntry->MinHTPhyMode.field.MCS =
-			    pEntry->MaxSupportedRate;
-			pEntry->HTPhyMode.field.MODE = MODE_CCK;
-			pEntry->HTPhyMode.field.MCS = pEntry->MaxSupportedRate;
-		} else {
-			pEntry->MaxHTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->MaxHTPhyMode.field.MCS =
-			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
-			pEntry->MinHTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->MinHTPhyMode.field.MCS =
-			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
-			pEntry->HTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->HTPhyMode.field.MCS =
-			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
-		}
-		pEntry->CapabilityInfo = CapabilityInfo;
-		CLIENT_STATUS_CLEAR_FLAG(pEntry,
-					 fCLIENT_STATUS_AGGREGATION_CAPABLE);
-		CLIENT_STATUS_CLEAR_FLAG(pEntry,
-					 fCLIENT_STATUS_PIGGYBACK_CAPABLE);
-	}
-
-	NdisZeroMemory(&pEntry->HTCapability, sizeof(pEntry->HTCapability));
-	/* If this Entry supports 802.11n, upgrade to HT rate. */
-	if ((HtCapabilityLen != 0)
-	    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
-		u8 j, bitmask;	/*k,bitmask; */
-		char i;
-
-		if (ADHOC_ON(pAd))
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_WMM_CAPABLE);
-		if ((pHtCapability->HtCapInfo.GF)
-		    && (pAd->CommonCfg.DesiredHtPhy.GF)) {
-			pEntry->MaxHTPhyMode.field.MODE = MODE_HTGREENFIELD;
-		} else {
-			pEntry->MaxHTPhyMode.field.MODE = MODE_HTMIX;
-			pAd->MacTab.fAnyStationNonGF = TRUE;
-			pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
-		}
-
-		if ((pHtCapability->HtCapInfo.ChannelWidth) &&
-		    (pAd->CommonCfg.DesiredHtPhy.ChannelWidth) &&
-		    ((pAd->StaCfg.BssType == BSS_INFRA)
-		     || ((pAd->StaCfg.BssType == BSS_ADHOC)
-			 && (pAddHtInfo->AddHtInfo.ExtChanOffset ==
-			     pAd->CommonCfg.AddHTInfo.AddHtInfo.
-			     ExtChanOffset)))) {
-			pEntry->MaxHTPhyMode.field.BW = BW_40;
-			pEntry->MaxHTPhyMode.field.ShortGI =
-			    ((pAd->CommonCfg.DesiredHtPhy.
-			      ShortGIfor40) & (pHtCapability->HtCapInfo.
-					       ShortGIfor40));
-		} else {
-			pEntry->MaxHTPhyMode.field.BW = BW_20;
-			pEntry->MaxHTPhyMode.field.ShortGI =
-			    ((pAd->CommonCfg.DesiredHtPhy.
-			      ShortGIfor20) & (pHtCapability->HtCapInfo.
-					       ShortGIfor20));
-			pAd->MacTab.fAnyStation20Only = TRUE;
-		}
-
-		/* 3*3 */
-		if (pAd->MACVersion >= RALINK_2883_VERSION
-		    && pAd->MACVersion < RALINK_3070_VERSION)
-			pEntry->MaxHTPhyMode.field.TxBF =
-			    pAd->CommonCfg.RegTransmitSetting.field.TxBF;
-
-		/* find max fixed rate */
-		for (i = 23; i >= 0; i--)	/* 3*3 */
-		{
-			j = i / 8;
-			bitmask = (1 << (i - (j * 8)));
-			if ((pAd->StaCfg.DesiredHtPhyInfo.MCSSet[j] & bitmask)
-			    && (pHtCapability->MCSSet[j] & bitmask)) {
-				pEntry->MaxHTPhyMode.field.MCS = i;
-				break;
-			}
-			if (i == 0)
-				break;
-		}
-
-		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) {
-			if (pAd->StaCfg.DesiredTransmitSetting.field.MCS == 32) {
-				/* Fix MCS as HT Duplicated Mode */
-				pEntry->MaxHTPhyMode.field.BW = 1;
-				pEntry->MaxHTPhyMode.field.MODE = MODE_HTMIX;
-				pEntry->MaxHTPhyMode.field.STBC = 0;
-				pEntry->MaxHTPhyMode.field.ShortGI = 0;
-				pEntry->MaxHTPhyMode.field.MCS = 32;
-			} else if (pEntry->MaxHTPhyMode.field.MCS >
-				   pAd->StaCfg.HTPhyMode.field.MCS) {
-				/* STA supports fixed MCS */
-				pEntry->MaxHTPhyMode.field.MCS =
-				    pAd->StaCfg.HTPhyMode.field.MCS;
-			}
-		}
-
-		pEntry->MaxHTPhyMode.field.STBC =
-		    (pHtCapability->HtCapInfo.
-		     RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
-		pEntry->MpduDensity = pHtCapability->HtCapParm.MpduDensity;
-		pEntry->MaxRAmpduFactor =
-		    pHtCapability->HtCapParm.MaxRAmpduFactor;
-		pEntry->MmpsMode = (u8)pHtCapability->HtCapInfo.MimoPs;
-		pEntry->AMsduSize = (u8)pHtCapability->HtCapInfo.AMsduSize;
-		pEntry->HTPhyMode.word = pEntry->MaxHTPhyMode.word;
-
-		if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable
-		    && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_AMSDU_INUSED);
-		if (pHtCapability->HtCapInfo.ShortGIfor20)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_SGI20_CAPABLE);
-		if (pHtCapability->HtCapInfo.ShortGIfor40)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_SGI40_CAPABLE);
-		if (pHtCapability->HtCapInfo.TxSTBC)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_TxSTBC_CAPABLE);
-		if (pHtCapability->HtCapInfo.RxSTBC)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_RxSTBC_CAPABLE);
-		if (pHtCapability->ExtHtCapInfo.PlusHTC)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_HTC_CAPABLE);
-		if (pAd->CommonCfg.bRdg
-		    && pHtCapability->ExtHtCapInfo.RDGSupport)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_RDG_CAPABLE);
-		if (pHtCapability->ExtHtCapInfo.MCSFeedback == 0x03)
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_MCSFEEDBACK_CAPABLE);
-		NdisMoveMemory(&pEntry->HTCapability, pHtCapability,
-			       HtCapabilityLen);
-	} else {
-		pAd->MacTab.fAnyStationIsLegacy = TRUE;
-	}
-
-	pEntry->HTPhyMode.word = pEntry->MaxHTPhyMode.word;
-	pEntry->CurrTxRate = pEntry->MaxSupportedRate;
-
-	/* Set asic auto fall back */
-	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
-		u8 *pTable;
-		u8 TableSize = 0;
-
-		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
-				      &pEntry->CurrTxRateIndex);
-		pEntry->bAutoTxRateSwitch = TRUE;
-	} else {
-		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
-		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
-		pEntry->bAutoTxRateSwitch = FALSE;
-
-		/* If the legacy mode is set, overwrite the transmit setting of this entry. */
-		RTMPUpdateLegacyTxSetting((u8)pAd->StaCfg.
-					  DesiredTransmitSetting.field.
-					  FixedTxMode, pEntry);
-	}
-
-	pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
-	pEntry->Sst = SST_ASSOC;
-	pEntry->AuthState = AS_AUTH_OPEN;
-	pEntry->AuthMode = pAd->StaCfg.AuthMode;
-	pEntry->WepStatus = pAd->StaCfg.WepStatus;
-
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-
-	{
-		union iwreq_data wrqu;
-		wext_notify_event_assoc(pAd);
-
-		memcpy(wrqu.ap_addr.sa_data, pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
-		wireless_send_event(pAd->net_dev, SIOCGIWAP, &wrqu, NULL);
-
-	}
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/sta/auth.c b/drivers/staging/rt2860/sta/auth.c
deleted file mode 100644
index 23ea00b..0000000
--- a/drivers/staging/rt2860/sta/auth.c
+++ /dev/null
@@ -1,517 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	auth.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John			2004-9-3		porting from RT2500
-	Justin P. Mattock	11/07/2010		Fix typos
-*/
-#include "../rt_config.h"
-
-/*
-    ==========================================================================
-    Description:
-        authenticate state machine init, including state transition and timer init
-    Parameters:
-        Sm - pointer to the auth state machine
-    Note:
-        The state machine looks like this
-
-                        AUTH_REQ_IDLE           AUTH_WAIT_SEQ2                   AUTH_WAIT_SEQ4
-    MT2_MLME_AUTH_REQ   mlme_auth_req_action    invalid_state_when_auth          invalid_state_when_auth
-    MT2_PEER_AUTH_EVEN  drop                    peer_auth_even_at_seq2_action    peer_auth_even_at_seq4_action
-    MT2_AUTH_TIMEOUT    Drop                    auth_timeout_action              auth_timeout_action
-
-	IRQL = PASSIVE_LEVEL
-
-    ==========================================================================
- */
-
-void AuthStateMachineInit(struct rt_rtmp_adapter *pAd,
-			  struct rt_state_machine *Sm, OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(Sm, Trans, MAX_AUTH_STATE, MAX_AUTH_MSG,
-			 (STATE_MACHINE_FUNC) Drop, AUTH_REQ_IDLE,
-			 AUTH_MACHINE_BASE);
-
-	/* the first column */
-	StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ,
-			      (STATE_MACHINE_FUNC) MlmeAuthReqAction);
-
-	/* the second column */
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN,
-			      (STATE_MACHINE_FUNC) PeerAuthRspAtSeq2Action);
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT,
-			      (STATE_MACHINE_FUNC) AuthTimeoutAction);
-
-	/* the third column */
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN,
-			      (STATE_MACHINE_FUNC) PeerAuthRspAtSeq4Action);
-	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_AUTH_TIMEOUT,
-			      (STATE_MACHINE_FUNC) AuthTimeoutAction);
-
-	RTMPInitTimer(pAd, &pAd->MlmeAux.AuthTimer,
-		      GET_TIMER_FUNCTION(AuthTimeout), pAd, FALSE);
-}
-
-/*
-    ==========================================================================
-    Description:
-        function to be executed at timer thread when auth timer expires
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void AuthTimeout(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeout\n"));
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG
-	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-		return;
-
-	/* send a de-auth to reset AP's state machine (Patch AP-Dir635) */
-	if (pAd->Mlme.AuthMachine.CurrState == AUTH_WAIT_SEQ2)
-		Cls2errAction(pAd, pAd->MlmeAux.Bssid);
-
-	MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_AUTH_TIMEOUT, 0, NULL);
-	RTMP_MLME_HANDLER(pAd);
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void MlmeAuthReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	if (AUTH_ReqSend
-	    (pAd, Elem, &pAd->MlmeAux.AuthTimer, "AUTH", 1, NULL, 0))
-		pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
-	else {
-		u16 Status;
-
-		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2,
-			    &Status);
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void PeerAuthRspAtSeq2Action(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Addr2[MAC_ADDR_LEN];
-	u16 Seq, Status, RemoteStatus, Alg;
-	u8 ChlgText[CIPHER_TEXT_LEN];
-	u8 CyperChlgText[CIPHER_TEXT_LEN + 8 + 8];
-	u8 Element[2];
-	struct rt_header_802_11 AuthHdr;
-	BOOLEAN TimerCancelled;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	u16 Status2;
-
-	if (PeerAuthSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status,
-	     (char *)ChlgText)) {
-		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 2) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("AUTH - Receive AUTH_RSP seq#2 to me (Alg=%d, Status=%d)\n",
-				  Alg, Status));
-			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
-					&TimerCancelled);
-
-			if (Status == MLME_SUCCESS) {
-				/* Authentication Mode "LEAP" has allow for CCX 1.X */
-				if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen) {
-					pAd->Mlme.AuthMachine.CurrState =
-					    AUTH_REQ_IDLE;
-					MlmeEnqueue(pAd,
-						    MLME_CNTL_STATE_MACHINE,
-						    MT2_AUTH_CONF, 2, &Status);
-				} else {
-					/* 2. shared key, need to be challenged */
-					Seq++;
-					RemoteStatus = MLME_SUCCESS;
-
-					/* Get an unused nonpaged memory */
-					NStatus =
-					    MlmeAllocateMemory(pAd,
-							       &pOutBuffer);
-					if (NStatus != NDIS_STATUS_SUCCESS) {
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("AUTH - PeerAuthRspAtSeq2Action() allocate memory fail\n"));
-						pAd->Mlme.AuthMachine.
-						    CurrState = AUTH_REQ_IDLE;
-						Status2 = MLME_FAIL_NO_RESOURCE;
-						MlmeEnqueue(pAd,
-							    MLME_CNTL_STATE_MACHINE,
-							    MT2_AUTH_CONF, 2,
-							    &Status2);
-						return;
-					}
-
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("AUTH - Send AUTH request seq#3...\n"));
-					MgtMacHeaderInit(pAd, &AuthHdr,
-							 SUBTYPE_AUTH, 0, Addr2,
-							 pAd->MlmeAux.Bssid);
-					AuthHdr.FC.Wep = 1;
-					/* Encrypt challenge text & auth information */
-					RTMPInitWepEngine(pAd,
-							  pAd->
-							  SharedKey[BSS0][pAd->
-									  StaCfg.
-									  DefaultKeyId].
-							  Key,
-							  pAd->StaCfg.
-							  DefaultKeyId,
-							  pAd->
-							  SharedKey[BSS0][pAd->
-									  StaCfg.
-									  DefaultKeyId].
-							  KeyLen,
-							  CyperChlgText);
-
-					Alg = cpu2le16(*(u16 *) & Alg);
-					Seq = cpu2le16(*(u16 *) & Seq);
-					RemoteStatus =
-					    cpu2le16(*(u16 *) &
-						     RemoteStatus);
-
-					RTMPEncryptData(pAd, (u8 *)& Alg,
-							CyperChlgText + 4, 2);
-					RTMPEncryptData(pAd, (u8 *)& Seq,
-							CyperChlgText + 6, 2);
-					RTMPEncryptData(pAd,
-							(u8 *)& RemoteStatus,
-							CyperChlgText + 8, 2);
-					Element[0] = 16;
-					Element[1] = 128;
-					RTMPEncryptData(pAd, Element,
-							CyperChlgText + 10, 2);
-					RTMPEncryptData(pAd, ChlgText,
-							CyperChlgText + 12,
-							128);
-					RTMPSetICV(pAd, CyperChlgText + 140);
-					MakeOutgoingFrame(pOutBuffer, &FrameLen,
-							  sizeof(struct rt_header_802_11),
-							  &AuthHdr,
-							  CIPHER_TEXT_LEN + 16,
-							  CyperChlgText,
-							  END_OF_ARGS);
-					MiniportMMRequest(pAd, 0, pOutBuffer,
-							  FrameLen);
-					MlmeFreeMemory(pAd, pOutBuffer);
-
-					RTMPSetTimer(&pAd->MlmeAux.AuthTimer,
-						     AUTH_TIMEOUT);
-					pAd->Mlme.AuthMachine.CurrState =
-					    AUTH_WAIT_SEQ4;
-				}
-			} else {
-				pAd->StaCfg.AuthFailReason = Status;
-				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
-				pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-				MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
-					    MT2_AUTH_CONF, 2, &Status);
-			}
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AUTH - PeerAuthSanity() sanity check fail\n"));
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void PeerAuthRspAtSeq4Action(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Addr2[MAC_ADDR_LEN];
-	u16 Alg, Seq, Status;
-	char ChlgText[CIPHER_TEXT_LEN];
-	BOOLEAN TimerCancelled;
-
-	if (PeerAuthSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status,
-	     ChlgText)) {
-		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 4) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("AUTH - Receive AUTH_RSP seq#4 to me\n"));
-			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
-					&TimerCancelled);
-
-			if (Status != MLME_SUCCESS) {
-				pAd->StaCfg.AuthFailReason = Status;
-				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
-			}
-
-			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF,
-				    2, &Status);
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AUTH - PeerAuthRspAtSeq4Action() sanity check fail\n"));
-	}
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void MlmeDeauthReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_deauth_req *pInfo;
-	struct rt_header_802_11 DeauthHdr;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	u16 Status;
-
-	pInfo = (struct rt_mlme_deauth_req *)Elem->Msg;
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AUTH - MlmeDeauthReqAction() allocate memory fail\n"));
-		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-		Status = MLME_FAIL_NO_RESOURCE;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2,
-			    &Status);
-		return;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AUTH - Send DE-AUTH request (Reason=%d)...\n",
-		  pInfo->Reason));
-	MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pInfo->Addr,
-			 pAd->MlmeAux.Bssid);
-	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(struct rt_header_802_11),
-			  &DeauthHdr, 2, &pInfo->Reason, END_OF_ARGS);
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	pAd->StaCfg.DeauthReason = pInfo->Reason;
-	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pInfo->Addr);
-	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-	Status = MLME_SUCCESS;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
-
-	/* send wireless event - for deauthentication */
-	if (pAd->CommonCfg.bWirelessEvent)
-		RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
-				      pAd->MacTab.Content[BSSID_WCID].Addr,
-				      BSS0, 0);
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void AuthTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeoutAction\n"));
-	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-	Status = MLME_REJ_TIMEOUT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void InvalidStateWhenAuth(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AUTH - InvalidStateWhenAuth (state=%ld), reset AUTH state machine\n",
-		  pAd->Mlme.AuthMachine.CurrState));
-	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-}
-
-/*
-    ==========================================================================
-    Description:
-        Some STA/AP
-    Note:
-        This action should never trigger AUTH state transition, therefore we
-        separate it from AUTH state machine, and make it as a standalone service
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-void Cls2errAction(struct rt_rtmp_adapter *pAd, u8 *pAddr)
-{
-	struct rt_header_802_11 DeauthHdr;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	u16 Reason = REASON_CLS2ERR;
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NStatus != NDIS_STATUS_SUCCESS)
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AUTH - Class 2 error, Send DEAUTH frame...\n"));
-	MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pAddr,
-			 pAd->MlmeAux.Bssid);
-	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(struct rt_header_802_11),
-			  &DeauthHdr, 2, &Reason, END_OF_ARGS);
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-
-	pAd->StaCfg.DeauthReason = Reason;
-	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pAddr);
-}
-
-BOOLEAN AUTH_ReqSend(struct rt_rtmp_adapter *pAd,
-		     struct rt_mlme_queue_elem *pElem,
-		     struct rt_ralink_timer *pAuthTimer,
-		     char *pSMName,
-		     u16 SeqNo,
-		     u8 *pNewElement, unsigned long ElementLen)
-{
-	u16 Alg, Seq, Status;
-	u8 Addr[6];
-	unsigned long Timeout;
-	struct rt_header_802_11 AuthHdr;
-	BOOLEAN TimerCancelled;
-	int NStatus;
-	u8 *pOutBuffer = NULL;
-	unsigned long FrameLen = 0, tmp = 0;
-
-	/* Block all authentication request during WPA block period */
-	if (pAd->StaCfg.bBlockAssoc == TRUE) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s - Block Auth request during WPA block period!\n",
-			  pSMName));
-		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2,
-			    &Status);
-	} else
-	    if (MlmeAuthReqSanity
-		(pAd, pElem->Msg, pElem->MsgLen, Addr, &Timeout, &Alg)) {
-		/* reset timer */
-		RTMPCancelTimer(pAuthTimer, &TimerCancelled);
-
-		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, Addr);
-		pAd->MlmeAux.Alg = Alg;
-		Seq = SeqNo;
-		Status = MLME_SUCCESS;
-
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-		if (NStatus != NDIS_STATUS_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s - MlmeAuthReqAction(Alg:%d) allocate memory failed\n",
-				  pSMName, Alg));
-			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF,
-				    2, &Status);
-			return FALSE;
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s - Send AUTH request seq#1 (Alg=%d)...\n", pSMName,
-			  Alg));
-		MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr,
-				 pAd->MlmeAux.Bssid);
-		MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(struct rt_header_802_11),
-				  &AuthHdr, 2, &Alg, 2, &Seq, 2, &Status,
-				  END_OF_ARGS);
-
-		if (pNewElement && ElementLen) {
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-					  ElementLen, pNewElement, END_OF_ARGS);
-			FrameLen += tmp;
-		}
-
-		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer);
-
-		RTMPSetTimer(pAuthTimer, Timeout);
-		return TRUE;
-	} else {
-		DBGPRINT_ERR("%s - MlmeAuthReqAction() sanity check failed\n", pSMName);
-		return FALSE;
-	}
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/sta/auth_rsp.c b/drivers/staging/rt2860/sta/auth_rsp.c
deleted file mode 100644
index 5b018b7..0000000
--- a/drivers/staging/rt2860/sta/auth_rsp.c
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	auth_rsp.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John		2004-10-1		copy from RT2560
-*/
-#include "../rt_config.h"
-
-/*
-    ==========================================================================
-    Description:
-        authentication state machine init procedure
-    Parameters:
-        Sm - the state machine
-
-	IRQL = PASSIVE_LEVEL
-
-    ==========================================================================
- */
-void AuthRspStateMachineInit(struct rt_rtmp_adapter *pAd,
-			     struct rt_state_machine *Sm,
-			     IN STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(Sm, Trans, MAX_AUTH_RSP_STATE, MAX_AUTH_RSP_MSG,
-			 (STATE_MACHINE_FUNC) Drop, AUTH_RSP_IDLE,
-			 AUTH_RSP_MACHINE_BASE);
-
-	/* column 1 */
-	StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH,
-			      (STATE_MACHINE_FUNC) PeerDeauthAction);
-
-	/* column 2 */
-	StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH,
-			      (STATE_MACHINE_FUNC) PeerDeauthAction);
-
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
-*/
-void PeerAuthSimpleRspGenAndSend(struct rt_rtmp_adapter *pAd,
-				 struct rt_header_802_11 * pHdr80211,
-				 u16 Alg,
-				 u16 Seq,
-				 u16 Reason, u16 Status)
-{
-	struct rt_header_802_11 AuthHdr;
-	unsigned long FrameLen = 0;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-
-	if (Reason != MLME_SUCCESS) {
-		DBGPRINT(RT_DEBUG_TRACE, ("Peer AUTH fail...\n"));
-		return;
-	}
-	/*Get an unused nonpaged memory */
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-	if (NStatus != NDIS_STATUS_SUCCESS)
-		return;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("Send AUTH response (seq#2)...\n"));
-	MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, pHdr80211->Addr2,
-			 pAd->MlmeAux.Bssid);
-	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(struct rt_header_802_11),
-			  &AuthHdr, 2, &Alg, 2, &Seq, 2, &Reason, END_OF_ARGS);
-	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
-*/
-void PeerDeauthAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Addr2[MAC_ADDR_LEN];
-	u16 Reason;
-
-	if (PeerDeauthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason)) {
-		if (INFRA_ON(pAd)
-		    && MAC_ADDR_EQUAL(Addr2, pAd->CommonCfg.Bssid)
-		    ) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("AUTH_RSP - receive DE-AUTH from our AP (Reason=%d)\n",
-				  Reason));
-
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
-						0);
-
-			/* send wireless event - for deauthentication */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-
-			LinkDown(pAd, TRUE);
-		}
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("AUTH_RSP - PeerDeauthAction() sanity check fail\n"));
-	}
-}
diff --git a/drivers/staging/rt2860/sta/connect.c b/drivers/staging/rt2860/sta/connect.c
deleted file mode 100644
index 4996258..0000000
--- a/drivers/staging/rt2860/sta/connect.c
+++ /dev/null
@@ -1,2613 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	connect.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John			2004-08-08		Major modification from RT2560
-	Justin P. Mattock	11/07/2010		Fix typos
-*/
-#include "../rt_config.h"
-
-u8 CipherSuiteWpaNoneTkip[] = {
-	0x00, 0x50, 0xf2, 0x01,	/* oui */
-	0x01, 0x00,		/* Version */
-	0x00, 0x50, 0xf2, 0x02,	/* Multicast */
-	0x01, 0x00,		/* Number of unicast */
-	0x00, 0x50, 0xf2, 0x02,	/* unicast */
-	0x01, 0x00,		/* number of authentication method */
-	0x00, 0x50, 0xf2, 0x00	/* authentication */
-};
-
-u8 CipherSuiteWpaNoneTkipLen =
-    (sizeof(CipherSuiteWpaNoneTkip) / sizeof(u8));
-
-u8 CipherSuiteWpaNoneAes[] = {
-	0x00, 0x50, 0xf2, 0x01,	/* oui */
-	0x01, 0x00,		/* Version */
-	0x00, 0x50, 0xf2, 0x04,	/* Multicast */
-	0x01, 0x00,		/* Number of unicast */
-	0x00, 0x50, 0xf2, 0x04,	/* unicast */
-	0x01, 0x00,		/* number of authentication method */
-	0x00, 0x50, 0xf2, 0x00	/* authentication */
-};
-
-u8 CipherSuiteWpaNoneAesLen =
-    (sizeof(CipherSuiteWpaNoneAes) / sizeof(u8));
-
-/* The following MACRO is called after 1. starting an new IBSS, 2. successfully JOIN an IBSS, */
-/* or 3. successfully ASSOCIATE to a BSS, 4. successfully RE_ASSOCIATE to a BSS */
-/* All settings successfuly negotiated firing MLME state machines become final settings */
-/* and are copied to pAd->StaActive */
-#define COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd)                                 \
-{                                                                                       \
-	NdisZeroMemory((_pAd)->CommonCfg.Ssid, MAX_LEN_OF_SSID);							\
-	(_pAd)->CommonCfg.SsidLen = (_pAd)->MlmeAux.SsidLen;                                \
-	NdisMoveMemory((_pAd)->CommonCfg.Ssid, (_pAd)->MlmeAux.Ssid, (_pAd)->MlmeAux.SsidLen); \
-	COPY_MAC_ADDR((_pAd)->CommonCfg.Bssid, (_pAd)->MlmeAux.Bssid);                      \
-	(_pAd)->CommonCfg.Channel = (_pAd)->MlmeAux.Channel;                                \
-	(_pAd)->CommonCfg.CentralChannel = (_pAd)->MlmeAux.CentralChannel;                  \
-	(_pAd)->StaActive.Aid = (_pAd)->MlmeAux.Aid;                                        \
-	(_pAd)->StaActive.AtimWin = (_pAd)->MlmeAux.AtimWin;                                \
-	(_pAd)->StaActive.CapabilityInfo = (_pAd)->MlmeAux.CapabilityInfo;                  \
-	(_pAd)->CommonCfg.BeaconPeriod = (_pAd)->MlmeAux.BeaconPeriod;                      \
-	(_pAd)->StaActive.CfpMaxDuration = (_pAd)->MlmeAux.CfpMaxDuration;                  \
-	(_pAd)->StaActive.CfpPeriod = (_pAd)->MlmeAux.CfpPeriod;                            \
-	(_pAd)->StaActive.SupRateLen = (_pAd)->MlmeAux.SupRateLen;                          \
-	NdisMoveMemory((_pAd)->StaActive.SupRate, (_pAd)->MlmeAux.SupRate, (_pAd)->MlmeAux.SupRateLen);\
-	(_pAd)->StaActive.ExtRateLen = (_pAd)->MlmeAux.ExtRateLen;                          \
-	NdisMoveMemory((_pAd)->StaActive.ExtRate, (_pAd)->MlmeAux.ExtRate, (_pAd)->MlmeAux.ExtRateLen);\
-	NdisMoveMemory(&(_pAd)->CommonCfg.APEdcaParm, &(_pAd)->MlmeAux.APEdcaParm, sizeof(struct rt_edca_parm));\
-	NdisMoveMemory(&(_pAd)->CommonCfg.APQosCapability, &(_pAd)->MlmeAux.APQosCapability, sizeof(struct rt_qos_capability_parm));\
-	NdisMoveMemory(&(_pAd)->CommonCfg.APQbssLoad, &(_pAd)->MlmeAux.APQbssLoad, sizeof(struct rt_qbss_load_parm));\
-	COPY_MAC_ADDR((_pAd)->MacTab.Content[BSSID_WCID].Addr, (_pAd)->MlmeAux.Bssid);      \
-	(_pAd)->MacTab.Content[BSSID_WCID].Aid = (_pAd)->MlmeAux.Aid;                       \
-	(_pAd)->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = (_pAd)->StaCfg.PairCipher;\
-	COPY_MAC_ADDR((_pAd)->MacTab.Content[BSSID_WCID].PairwiseKey.BssId, (_pAd)->MlmeAux.Bssid);\
-	(_pAd)->MacTab.Content[BSSID_WCID].RateLen = (_pAd)->StaActive.SupRateLen + (_pAd)->StaActive.ExtRateLen;\
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = PASSIVE_LEVEL
-
-	==========================================================================
-*/
-void MlmeCntlInit(struct rt_rtmp_adapter *pAd,
-		  struct rt_state_machine *S, OUT STATE_MACHINE_FUNC Trans[])
-{
-	/* Control state machine differs from other state machines, the interface */
-	/* follows the standard interface */
-	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void MlmeCntlMachinePerformAction(struct rt_rtmp_adapter *pAd,
-				  struct rt_state_machine *S,
-				  struct rt_mlme_queue_elem *Elem)
-{
-	switch (pAd->Mlme.CntlMachine.CurrState) {
-	case CNTL_IDLE:
-		CntlIdleProc(pAd, Elem);
-		break;
-	case CNTL_WAIT_DISASSOC:
-		CntlWaitDisassocProc(pAd, Elem);
-		break;
-	case CNTL_WAIT_JOIN:
-		CntlWaitJoinProc(pAd, Elem);
-		break;
-
-		/* CNTL_WAIT_REASSOC is the only state in CNTL machine that does */
-		/* not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)". */
-		/* Therefore not protected by NDIS's "only one outstanding OID request" */
-		/* rule. Which means NDIS may SET OID in the middle of ROAMing attempts. */
-		/* Current approach is to block new SET request at RTMPSetInformation() */
-		/* when CntlMachine.CurrState is not CNTL_IDLE */
-	case CNTL_WAIT_REASSOC:
-		CntlWaitReassocProc(pAd, Elem);
-		break;
-
-	case CNTL_WAIT_START:
-		CntlWaitStartProc(pAd, Elem);
-		break;
-	case CNTL_WAIT_AUTH:
-		CntlWaitAuthProc(pAd, Elem);
-		break;
-	case CNTL_WAIT_AUTH2:
-		CntlWaitAuthProc2(pAd, Elem);
-		break;
-	case CNTL_WAIT_ASSOC:
-		CntlWaitAssocProc(pAd, Elem);
-		break;
-
-	case CNTL_WAIT_OID_LIST_SCAN:
-		if (Elem->MsgType == MT2_SCAN_CONF) {
-			/* Resume TxRing after SCANING complete. We hope the out-of-service time */
-			/* won't be too long to let upper layer time-out the waiting frames */
-			RTMPResumeMsduTransmission(pAd);
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-
-			/* */
-			/* Set LED status to previous status. */
-			/* */
-			if (pAd->bLedOnScanning) {
-				pAd->bLedOnScanning = FALSE;
-				RTMPSetLED(pAd, pAd->LedStatus);
-			}
-		}
-		break;
-
-	case CNTL_WAIT_OID_DISASSOC:
-		if (Elem->MsgType == MT2_DISASSOC_CONF) {
-			LinkDown(pAd, FALSE);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-		}
-		break;
-#ifdef RTMP_MAC_USB
-		/* */
-		/* This state is for that we want to connect to an AP but */
-		/* it didn't find on BSS List table. So we need to scan the air first, */
-		/* after that we can try to connect to the desired AP if available. */
-		/* */
-	case CNTL_WAIT_SCAN_FOR_CONNECT:
-		if (Elem->MsgType == MT2_SCAN_CONF) {
-			/* Resume TxRing after SCANING complete. We hope the out-of-service time */
-			/* won't be too long to let upper layer time-out the waiting frames */
-			RTMPResumeMsduTransmission(pAd);
-#ifdef CCX_SUPPORT
-			if (pAd->StaCfg.CCXReqType != MSRN_TYPE_UNUSED) {
-				/* Cisco scan request is finished, prepare beacon report */
-				MlmeEnqueue(pAd, AIRONET_STATE_MACHINE,
-					    MT2_AIRONET_SCAN_DONE, 0, NULL);
-			}
-#endif /* CCX_SUPPORT // */
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-
-			/* */
-			/* Check if we can connect to. */
-			/* */
-			BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
-					 (char *) pAd->MlmeAux.
-					 AutoReconnectSsid,
-					 pAd->MlmeAux.AutoReconnectSsidLen);
-			if (pAd->MlmeAux.SsidBssTab.BssNr > 0) {
-				MlmeAutoReconnectLastSSID(pAd);
-			}
-		}
-		break;
-#endif /* RTMP_MAC_USB // */
-	default:
-		DBGPRINT_ERR("ERROR! CNTL - Illegal message type(=%ld)", Elem->MsgType);
-		break;
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlIdleProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_disassoc_req DisassocReq;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-		return;
-
-	switch (Elem->MsgType) {
-	case OID_802_11_SSID:
-		CntlOidSsidProc(pAd, Elem);
-		break;
-
-	case OID_802_11_BSSID:
-		CntlOidRTBssidProc(pAd, Elem);
-		break;
-
-	case OID_802_11_BSSID_LIST_SCAN:
-		CntlOidScanProc(pAd, Elem);
-		break;
-
-	case OID_802_11_DISASSOCIATE:
-		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
-				 REASON_DISASSOC_STA_LEAVING);
-		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-			    sizeof(struct rt_mlme_disassoc_req), &DisassocReq);
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
-
-		if (pAd->StaCfg.WpaSupplicantUP !=
-		    WPA_SUPPLICANT_ENABLE_WITH_WEB_UI) {
-			/* Set the AutoReconnectSsid to prevent it reconnect to old SSID */
-			/* Since calling this indicate user don't want to connect to that SSID anymore. */
-			pAd->MlmeAux.AutoReconnectSsidLen = 32;
-			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
-				       pAd->MlmeAux.AutoReconnectSsidLen);
-		}
-		break;
-
-	case MT2_MLME_ROAMING_REQ:
-		CntlMlmeRoamingProc(pAd, Elem);
-		break;
-
-	case OID_802_11_MIC_FAILURE_REPORT_FRAME:
-		WpaMicFailureReportFrame(pAd, Elem);
-		break;
-
-	default:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - Illegal message in CntlIdleProc(MsgType=%ld)\n",
-			  Elem->MsgType));
-		break;
-	}
-}
-
-void CntlOidScanProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_scan_req ScanReq;
-	unsigned long BssIdx = BSS_NOT_FOUND;
-	struct rt_bss_entry CurrBss;
-
-	/* record current BSS if network is connected. */
-	/* 2003-2-13 do not include current IBSS if this is the only STA in this IBSS. */
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-		BssIdx =
-		    BssSsidTableSearch(&pAd->ScanTab, pAd->CommonCfg.Bssid,
-				       (u8 *)pAd->CommonCfg.Ssid,
-				       pAd->CommonCfg.SsidLen,
-				       pAd->CommonCfg.Channel);
-		if (BssIdx != BSS_NOT_FOUND) {
-			NdisMoveMemory(&CurrBss, &pAd->ScanTab.BssEntry[BssIdx],
-				       sizeof(struct rt_bss_entry));
-		}
-	}
-	/* clean up previous SCAN result, add current BSS back to table if any */
-	BssTableInit(&pAd->ScanTab);
-	if (BssIdx != BSS_NOT_FOUND) {
-		/* DDK Note: If the NIC is associated with a particular BSSID and SSID */
-		/*    that are not contained in the list of BSSIDs generated by this scan, the */
-		/*    BSSID description of the currently associated BSSID and SSID should be */
-		/*    appended to the list of BSSIDs in the NIC's database. */
-		/* To ensure this, we append this BSS as the first entry in SCAN result */
-		NdisMoveMemory(&pAd->ScanTab.BssEntry[0], &CurrBss,
-			       sizeof(struct rt_bss_entry));
-		pAd->ScanTab.BssNr = 1;
-	}
-
-	ScanParmFill(pAd, &ScanReq, (char *)Elem->Msg, Elem->MsgLen, BSS_ANY,
-		     SCAN_ACTIVE);
-	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
-		    sizeof(struct rt_mlme_scan_req), &ScanReq);
-	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
-}
-
-/*
-	==========================================================================
-	Description:
-		Before calling this routine, user desired SSID should already been
-		recorded in CommonCfg.Ssid[]
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlOidSsidProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_ndis_802_11_ssid * pOidSsid = (struct rt_ndis_802_11_ssid *) Elem->Msg;
-	struct rt_mlme_disassoc_req DisassocReq;
-	unsigned long Now;
-
-	/* Step 1. record the desired user settings to MlmeAux */
-	NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
-	NdisMoveMemory(pAd->MlmeAux.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
-	pAd->MlmeAux.SsidLen = (u8)pOidSsid->SsidLength;
-	NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
-	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
-
-	pAd->StaCfg.bAutoConnectByBssid = FALSE;
-
-	/* */
-	/* Update Reconnect Ssid, that user desired to connect. */
-	/* */
-	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
-	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid,
-		       pAd->MlmeAux.SsidLen);
-	pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
-
-	/* step 2. find all matching BSS in the lastest SCAN result (inBssTab) */
-	/*    & log them into MlmeAux.SsidBssTab for later-on iteration. Sort by RSSI order */
-	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
-			 (char *)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("CntlOidSsidProc():CNTL - %d BSS of %d BSS match the desire (%d)SSID - %s\n",
-		  pAd->MlmeAux.SsidBssTab.BssNr, pAd->ScanTab.BssNr,
-		  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid));
-	NdisGetSystemUpTime(&Now);
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
-	    (pAd->CommonCfg.SsidLen ==
-	     pAd->MlmeAux.SsidBssTab.BssEntry[0].SsidLen)
-	    && NdisEqualMemory(pAd->CommonCfg.Ssid,
-			       pAd->MlmeAux.SsidBssTab.BssEntry[0].Ssid,
-			       pAd->CommonCfg.SsidLen)
-	    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid,
-			      pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid)) {
-		/* Case 1. already connected with an AP who has the desired SSID */
-		/*         with highest RSSI */
-
-		/* Add checking Mode "LEAP" for CCX 1.0 */
-		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-		    ) &&
-		    (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
-			/* case 1.1 For WPA, WPA-PSK, if the 1x port is not secured, we have to redo */
-			/*          connection process */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
-			DisassocParmFill(pAd, &DisassocReq,
-					 pAd->CommonCfg.Bssid,
-					 REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-				    MT2_MLME_DISASSOC_REQ,
-				    sizeof(struct rt_mlme_disassoc_req),
-				    &DisassocReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		} else if (pAd->bConfigChanged == TRUE) {
-			/* case 1.2 Important Config has changed, we have to reconnect to the same AP */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():CNTL - disassociate with current AP Because config changed...\n"));
-			DisassocParmFill(pAd, &DisassocReq,
-					 pAd->CommonCfg.Bssid,
-					 REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-				    MT2_MLME_DISASSOC_REQ,
-				    sizeof(struct rt_mlme_disassoc_req),
-				    &DisassocReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		} else {
-			/* case 1.3. already connected to the SSID with highest RSSI. */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():CNTL - already with this BSSID. ignore this SET_SSID request\n"));
-			/* */
-			/* (HCT 12.1) 1c_wlan_mediaevents required */
-			/* media connect events are indicated when associating with the same AP */
-			/* */
-			if (INFRA_ON(pAd)) {
-				/* */
-				/* Since MediaState already is NdisMediaStateConnected */
-				/* We just indicate the connect event again to meet the WHQL required. */
-				/* */
-				pAd->IndicateMediaState =
-				    NdisMediaStateConnected;
-				RTMP_IndicateMediaState(pAd);
-				pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information to link is up */
-			}
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1,
-						&pAd->MlmeAux.Bssid[0], NULL,
-						0);
-		}
-	} else if (INFRA_ON(pAd)) {
-		/* */
-		/* For RT61 */
-		/* [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: ) */
-		/* RT61 may lost SSID, and not connect to NDTEST_WEP_AP2 and will connect to NDTEST_WEP_AP2 by Autoreconnect */
-		/* But media status is connected, so the SSID not report correctly. */
-		/* */
-		if (!SSID_EQUAL
-		    (pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen,
-		     pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)) {
-			/* */
-			/* Different SSID means not Roaming case, so we let LinkDown() to Indicate a disconnect event. */
-			/* */
-			pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
-		}
-		/* case 2. active INFRA association existent */
-		/*    roaming is done within miniport driver, nothing to do with configuration */
-		/*    utility. so upon a new SET(OID_802_11_SSID) is received, we just */
-		/*    disassociate with the current associated AP, */
-		/*    then perform a new association with this new SSID, no matter the */
-		/*    new/old SSID are the same or not. */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
-		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
-				 REASON_DISASSOC_STA_LEAVING);
-		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-			    sizeof(struct rt_mlme_disassoc_req), &DisassocReq);
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-	} else {
-		if (ADHOC_ON(pAd)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():CNTL - drop current ADHOC\n"));
-			LinkDown(pAd, FALSE);
-			OPSTATUS_CLEAR_FLAG(pAd,
-					    fOP_STATUS_MEDIA_STATE_CONNECTED);
-			pAd->IndicateMediaState = NdisMediaStateDisconnected;
-			RTMP_IndicateMediaState(pAd);
-			pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
-		}
-
-		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0) &&
-		    (pAd->StaCfg.bAutoReconnect == TRUE) &&
-		    (pAd->MlmeAux.BssType == BSS_INFRA) &&
-		    (MlmeValidateSSID(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)
-		     == TRUE)
-		    ) {
-			struct rt_mlme_scan_req ScanReq;
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CntlOidSsidProc():CNTL - No matching BSS, start a new scan\n"));
-			ScanParmFill(pAd, &ScanReq, (char *)pAd->MlmeAux.Ssid,
-				     pAd->MlmeAux.SsidLen, BSS_ANY,
-				     SCAN_ACTIVE);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
-				    sizeof(struct rt_mlme_scan_req), &ScanReq);
-			pAd->Mlme.CntlMachine.CurrState =
-			    CNTL_WAIT_OID_LIST_SCAN;
-			/* Reset Missed scan number */
-			pAd->StaCfg.LastScanTime = Now;
-		} else {
-			pAd->MlmeAux.BssIdx = 0;
-			IterateOnBssTab(pAd);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlOidRTBssidProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	unsigned long BssIdx;
-	u8 *pOidBssid = (u8 *)Elem->Msg;
-	struct rt_mlme_disassoc_req DisassocReq;
-	struct rt_mlme_join_req JoinReq;
-
-	/* record user desired settings */
-	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pOidBssid);
-	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
-
-	/* find the desired BSS in the latest SCAN result table */
-	BssIdx = BssTableSearch(&pAd->ScanTab, pOidBssid, pAd->MlmeAux.Channel);
-	if (BssIdx == BSS_NOT_FOUND) {
-		struct rt_mlme_scan_req ScanReq;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n"));
-		/*pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE; */
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - BSSID not found. start a new scan\n"));
-		ScanParmFill(pAd, &ScanReq, (char *)pAd->MlmeAux.Ssid,
-			     pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
-			    sizeof(struct rt_mlme_scan_req), &ScanReq);
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
-		/* Reset Missed scan number */
-		NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
-		return;
-	}
-	/* */
-	/* Update Reconnect Ssid, that user desired to connect. */
-	/* */
-	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
-	pAd->MlmeAux.AutoReconnectSsidLen =
-	    pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid,
-		       pAd->ScanTab.BssEntry[BssIdx].Ssid,
-		       pAd->ScanTab.BssEntry[BssIdx].SsidLen);
-
-	/* copy the matched BSS entry from ScanTab to MlmeAux.SsidBssTab. Why? */
-	/* Because we need this entry to become the JOIN target in later on SYNC state machine */
-	pAd->MlmeAux.BssIdx = 0;
-	pAd->MlmeAux.SsidBssTab.BssNr = 1;
-	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0],
-		       &pAd->ScanTab.BssEntry[BssIdx], sizeof(struct rt_bss_entry));
-
-	/* Add SSID into MlmeAux for site survey joining hidden SSID */
-	pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid,
-		       pAd->MlmeAux.SsidLen);
-
-	{
-		if (INFRA_ON(pAd)) {
-			/* disassoc from current AP first */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - disassociate with current AP ...\n"));
-			DisassocParmFill(pAd, &DisassocReq,
-					 pAd->CommonCfg.Bssid,
-					 REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-				    MT2_MLME_DISASSOC_REQ,
-				    sizeof(struct rt_mlme_disassoc_req),
-				    &DisassocReq);
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		} else {
-			if (ADHOC_ON(pAd)) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("CNTL - drop current ADHOC\n"));
-				LinkDown(pAd, FALSE);
-				OPSTATUS_CLEAR_FLAG(pAd,
-						    fOP_STATUS_MEDIA_STATE_CONNECTED);
-				pAd->IndicateMediaState =
-				    NdisMediaStateDisconnected;
-				RTMP_IndicateMediaState(pAd);
-				pAd->ExtraInfo = GENERAL_LINK_DOWN;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
-			}
-			/* Change the wepstatus to original wepstatus */
-			pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
-			pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
-			pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
-
-			/* Check cipher suite, AP must have more secured cipher than station setting */
-			/* Set the Pairwise and Group cipher to match the intended AP setting */
-			/* We can only connect to AP with less secured cipher setting */
-			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
-			    || (pAd->StaCfg.AuthMode ==
-				Ndis802_11AuthModeWPAPSK)) {
-				pAd->StaCfg.GroupCipher =
-				    pAd->ScanTab.BssEntry[BssIdx].WPA.
-				    GroupCipher;
-
-				if (pAd->StaCfg.WepStatus ==
-				    pAd->ScanTab.BssEntry[BssIdx].WPA.
-				    PairCipher)
-					pAd->StaCfg.PairCipher =
-					    pAd->ScanTab.BssEntry[BssIdx].WPA.
-					    PairCipher;
-				else if (pAd->ScanTab.BssEntry[BssIdx].WPA.
-					 PairCipherAux != Ndis802_11WEPDisabled)
-					pAd->StaCfg.PairCipher =
-					    pAd->ScanTab.BssEntry[BssIdx].WPA.
-					    PairCipherAux;
-				else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
-					pAd->StaCfg.PairCipher =
-					    Ndis802_11Encryption2Enabled;
-			} else
-			    if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
-				|| (pAd->StaCfg.AuthMode ==
-				    Ndis802_11AuthModeWPA2PSK)) {
-				pAd->StaCfg.GroupCipher =
-				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
-				    GroupCipher;
-
-				if (pAd->StaCfg.WepStatus ==
-				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
-				    PairCipher)
-					pAd->StaCfg.PairCipher =
-					    pAd->ScanTab.BssEntry[BssIdx].WPA2.
-					    PairCipher;
-				else if (pAd->ScanTab.BssEntry[BssIdx].WPA2.
-					 PairCipherAux != Ndis802_11WEPDisabled)
-					pAd->StaCfg.PairCipher =
-					    pAd->ScanTab.BssEntry[BssIdx].WPA2.
-					    PairCipherAux;
-				else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
-					pAd->StaCfg.PairCipher =
-					    Ndis802_11Encryption2Enabled;
-
-				/* RSN capability */
-				pAd->StaCfg.RsnCapability =
-				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
-				    RsnCapability;
-			}
-			/* Set Mix cipher flag */
-			pAd->StaCfg.bMixCipher =
-			    (pAd->StaCfg.PairCipher ==
-			     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
-			/*if (pAd->StaCfg.bMixCipher == TRUE)
-			   {
-			   // If mix cipher, re-build RSNIE
-			   RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
-			   } */
-			/* No active association, join the BSS immediately */
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - joining %pM ...\n",
-					pOidBssid));
-
-			JoinParmFill(pAd, &JoinReq, pAd->MlmeAux.BssIdx);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ,
-				    sizeof(struct rt_mlme_join_req), &JoinReq);
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
-		}
-	}
-}
-
-/* Roaming is the only external request triggering CNTL state machine */
-/* despite of other "SET OID" operation. All "SET OID" related operations */
-/* happen in sequence, because no other SET OID will be sent to this device */
-/* until the the previous SET operation is complete (successful o failed). */
-/* So, how do we quarantee this ROAMING request won't corrupt other "SET OID"? */
-/* or been corrupted by other "SET OID"? */
-/* */
-/* IRQL = DISPATCH_LEVEL */
-void CntlMlmeRoamingProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 BBPValue = 0;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Roaming in MlmeAux.RoamTab...\n"));
-
-	{
-		/*Let BBP register at 20MHz to do (fast) roaming. */
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-		BBPValue &= (~0x18);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-
-		NdisMoveMemory(&pAd->MlmeAux.SsidBssTab, &pAd->MlmeAux.RoamTab,
-			       sizeof(pAd->MlmeAux.RoamTab));
-		pAd->MlmeAux.SsidBssTab.BssNr = pAd->MlmeAux.RoamTab.BssNr;
-
-		BssTableSortByRssi(&pAd->MlmeAux.SsidBssTab);
-		pAd->MlmeAux.BssIdx = 0;
-		IterateOnBssTab(pAd);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitDisassocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	struct rt_mlme_start_req StartReq;
-
-	if (Elem->MsgType == MT2_DISASSOC_CONF) {
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Dis-associate successful\n"));
-
-		if (pAd->CommonCfg.bWirelessEvent) {
-			RTMPSendWirelessEvent(pAd, IW_DISASSOC_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		}
-
-		LinkDown(pAd, FALSE);
-
-		/* case 1. no matching BSS, and user wants ADHOC, so we just start a new one */
-		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0)
-		    && (pAd->StaCfg.BssType == BSS_ADHOC)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - No matching BSS, start a new ADHOC (Ssid=%s)...\n",
-				  pAd->MlmeAux.Ssid));
-			StartParmFill(pAd, &StartReq, (char *)pAd->MlmeAux.Ssid,
-				      pAd->MlmeAux.SsidLen);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
-				    sizeof(struct rt_mlme_start_req), &StartReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
-		}
-		/* case 2. try each matched BSS */
-		else {
-			pAd->MlmeAux.BssIdx = 0;
-
-			IterateOnBssTab(pAd);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitJoinProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Reason;
-	struct rt_mlme_auth_req AuthReq;
-
-	if (Elem->MsgType == MT2_JOIN_CONF) {
-		NdisMoveMemory(&Reason, Elem->Msg, sizeof(u16));
-		if (Reason == MLME_SUCCESS) {
-			/* 1. joined an IBSS, we are pretty much done here */
-			if (pAd->MlmeAux.BssType == BSS_ADHOC) {
-				/* */
-				/* 5G bands rules of Japan: */
-				/* Ad hoc must be disabled in W53(ch52,56,60,64) channels. */
-				/* */
-				if ((pAd->CommonCfg.bIEEE80211H == 1) &&
-				    RadarChannelCheck(pAd,
-						      pAd->CommonCfg.Channel)
-				    ) {
-					pAd->Mlme.CntlMachine.CurrState =
-					    CNTL_IDLE;
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("CNTL - Channel=%d, Join adhoc on W53(52,56,60,64) Channels are not accepted\n",
-						  pAd->CommonCfg.Channel));
-					return;
-				}
-
-				LinkUp(pAd, BSS_ADHOC);
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-				DBGPRINT(RT_DEBUG_TRACE,
-					("CNTL - join the IBSS = %pM ...\n",
-						pAd->CommonCfg.Bssid));
-
-				pAd->IndicateMediaState =
-				    NdisMediaStateConnected;
-				pAd->ExtraInfo = GENERAL_LINK_UP;
-			}
-			/* 2. joined a new INFRA network, start from authentication */
-			else {
-				{
-					/* either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first */
-					if ((pAd->StaCfg.AuthMode ==
-					     Ndis802_11AuthModeShared)
-					    || (pAd->StaCfg.AuthMode ==
-						Ndis802_11AuthModeAutoSwitch)) {
-						AuthParmFill(pAd, &AuthReq,
-							     pAd->MlmeAux.Bssid,
-							     AUTH_MODE_KEY);
-					} else {
-						AuthParmFill(pAd, &AuthReq,
-							     pAd->MlmeAux.Bssid,
-							     AUTH_MODE_OPEN);
-					}
-					MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
-						    MT2_MLME_AUTH_REQ,
-						    sizeof
-						    (struct rt_mlme_auth_req),
-						    &AuthReq);
-				}
-
-				pAd->Mlme.CntlMachine.CurrState =
-				    CNTL_WAIT_AUTH;
-			}
-		} else {
-			/* 3. failed, try next BSS */
-			pAd->MlmeAux.BssIdx++;
-			IterateOnBssTab(pAd);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitStartProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Result;
-
-	if (Elem->MsgType == MT2_START_CONF) {
-		NdisMoveMemory(&Result, Elem->Msg, sizeof(u16));
-		if (Result == MLME_SUCCESS) {
-			/* */
-			/* 5G bands rules of Japan: */
-			/* Ad hoc must be disabled in W53(ch52,56,60,64) channels. */
-			/* */
-			if ((pAd->CommonCfg.bIEEE80211H == 1) &&
-			    RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
-			    ) {
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("CNTL - Channel=%d, Start adhoc on W53(52,56,60,64) Channels are not accepted\n",
-					  pAd->CommonCfg.Channel));
-				return;
-			}
-			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.
-				       MCSSet[0], 16);
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
-				N_ChannelCheck(pAd);
-				SetCommonHT(pAd);
-				NdisMoveMemory(&pAd->MlmeAux.AddHtInfo,
-					       &pAd->CommonCfg.AddHTInfo,
-					       sizeof(struct rt_add_ht_info_ie));
-				RTMPCheckHt(pAd, BSSID_WCID,
-					    &pAd->CommonCfg.HtCapability,
-					    &pAd->CommonCfg.AddHTInfo);
-				pAd->StaActive.SupportedPhyInfo.bHtEnable =
-				    TRUE;
-				NdisMoveMemory(&pAd->StaActive.SupportedPhyInfo.
-					       MCSSet[0],
-					       &pAd->CommonCfg.HtCapability.
-					       MCSSet[0], 16);
-				COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG
-				    (pAd);
-
-				if ((pAd->CommonCfg.HtCapability.HtCapInfo.
-				     ChannelWidth == BW_40)
-				    && (pAd->CommonCfg.AddHTInfo.AddHtInfo.
-					ExtChanOffset == EXTCHA_ABOVE)) {
-					pAd->MlmeAux.CentralChannel =
-					    pAd->CommonCfg.Channel + 2;
-				} else
-				    if ((pAd->CommonCfg.HtCapability.HtCapInfo.
-					 ChannelWidth == BW_40)
-					&& (pAd->CommonCfg.AddHTInfo.AddHtInfo.
-					    ExtChanOffset == EXTCHA_BELOW)) {
-					pAd->MlmeAux.CentralChannel =
-					    pAd->CommonCfg.Channel - 2;
-				}
-			} else {
-				pAd->StaActive.SupportedPhyInfo.bHtEnable =
-				    FALSE;
-			}
-			LinkUp(pAd, BSS_ADHOC);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			/* Before send beacon, driver need do radar detection */
-			if ((pAd->CommonCfg.Channel > 14)
-			    && (pAd->CommonCfg.bIEEE80211H == 1)
-			    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
-				pAd->CommonCfg.RadarDetect.RDMode =
-				    RD_SILENCE_MODE;
-				pAd->CommonCfg.RadarDetect.RDCount = 0;
-			}
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				("CNTL - start a new IBSS = %pM ...\n",
-					pAd->CommonCfg.Bssid));
-		} else {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - Start IBSS fail. BUG!\n"));
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitAuthProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Reason;
-	struct rt_mlme_assoc_req AssocReq;
-	struct rt_mlme_auth_req AuthReq;
-
-	if (Elem->MsgType == MT2_AUTH_CONF) {
-		NdisMoveMemory(&Reason, Elem->Msg, sizeof(u16));
-		if (Reason == MLME_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH OK\n"));
-			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
-				      pAd->MlmeAux.CapabilityInfo,
-				      ASSOC_TIMEOUT,
-				      pAd->StaCfg.DefaultListenCount);
-
-			{
-				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-					    MT2_MLME_ASSOC_REQ,
-					    sizeof(struct rt_mlme_assoc_req),
-					    &AssocReq);
-
-				pAd->Mlme.CntlMachine.CurrState =
-				    CNTL_WAIT_ASSOC;
-			}
-		} else {
-			/* This fail may because of the AP already keep us in its MAC table without */
-			/* ageing-out. The previous authentication attempt must have let it remove us. */
-			/* so try Authentication again may help. For D-Link DWL-900AP+ compatibility. */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - AUTH FAIL, try again...\n"));
-
-			{
-				if ((pAd->StaCfg.AuthMode ==
-				     Ndis802_11AuthModeShared)
-				    || (pAd->StaCfg.AuthMode ==
-					Ndis802_11AuthModeAutoSwitch)) {
-					/* either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first */
-					AuthParmFill(pAd, &AuthReq,
-						     pAd->MlmeAux.Bssid,
-						     AUTH_MODE_KEY);
-				} else {
-					AuthParmFill(pAd, &AuthReq,
-						     pAd->MlmeAux.Bssid,
-						     AUTH_MODE_OPEN);
-				}
-				MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
-					    MT2_MLME_AUTH_REQ,
-					    sizeof(struct rt_mlme_auth_req),
-					    &AuthReq);
-
-			}
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitAuthProc2(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Reason;
-	struct rt_mlme_assoc_req AssocReq;
-	struct rt_mlme_auth_req AuthReq;
-
-	if (Elem->MsgType == MT2_AUTH_CONF) {
-		NdisMoveMemory(&Reason, Elem->Msg, sizeof(u16));
-		if (Reason == MLME_SUCCESS) {
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH OK\n"));
-			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
-				      pAd->MlmeAux.CapabilityInfo,
-				      ASSOC_TIMEOUT,
-				      pAd->StaCfg.DefaultListenCount);
-			{
-				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
-					    MT2_MLME_ASSOC_REQ,
-					    sizeof(struct rt_mlme_assoc_req),
-					    &AssocReq);
-
-				pAd->Mlme.CntlMachine.CurrState =
-				    CNTL_WAIT_ASSOC;
-			}
-		} else {
-			if ((pAd->StaCfg.AuthMode ==
-			     Ndis802_11AuthModeAutoSwitch)
-			    && (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared)) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("CNTL - AUTH FAIL, try OPEN system...\n"));
-				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid,
-					     Ndis802_11AuthModeOpen);
-				MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
-					    MT2_MLME_AUTH_REQ,
-					    sizeof(struct rt_mlme_auth_req),
-					    &AuthReq);
-
-				pAd->Mlme.CntlMachine.CurrState =
-				    CNTL_WAIT_AUTH2;
-			} else {
-				/* not success, try next BSS */
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("CNTL - AUTH FAIL, give up; try next BSS\n"));
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;	/*??????? */
-				pAd->MlmeAux.BssIdx++;
-				IterateOnBssTab(pAd);
-			}
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitAssocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Reason;
-
-	if (Elem->MsgType == MT2_ASSOC_CONF) {
-		NdisMoveMemory(&Reason, Elem->Msg, sizeof(u16));
-		if (Reason == MLME_SUCCESS) {
-			if (pAd->CommonCfg.bWirelessEvent) {
-				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-			}
-
-			LinkUp(pAd, BSS_INFRA);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - Association successful on BSS #%ld\n",
-				  pAd->MlmeAux.BssIdx));
-		} else {
-			/* not success, try next BSS */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - Association fails on BSS #%ld\n",
-				  pAd->MlmeAux.BssIdx));
-			pAd->MlmeAux.BssIdx++;
-			IterateOnBssTab(pAd);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void CntlWaitReassocProc(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Result;
-
-	if (Elem->MsgType == MT2_REASSOC_CONF) {
-		NdisMoveMemory(&Result, Elem->Msg, sizeof(u16));
-		if (Result == MLME_SUCCESS) {
-			/* send wireless event - for association */
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-
-			/* */
-			/* NDIS requires a new Link UP indication but no Link Down for RE-ASSOC */
-			/* */
-			LinkUp(pAd, BSS_INFRA);
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - Re-assocition successful on BSS #%ld\n",
-				  pAd->MlmeAux.RoamIdx));
-		} else {
-			/* reassoc failed, try to pick next BSS in the BSS Table */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - Re-assocition fails on BSS #%ld\n",
-				  pAd->MlmeAux.RoamIdx));
-			{
-				pAd->MlmeAux.RoamIdx++;
-				IterateOnBssTab2(pAd);
-			}
-		}
-	}
-}
-
-void AdhocTurnOnQos(struct rt_rtmp_adapter *pAd)
-{
-#define AC0_DEF_TXOP		0
-#define AC1_DEF_TXOP		0
-#define AC2_DEF_TXOP		94
-#define AC3_DEF_TXOP		47
-
-	/* Turn on QOs if use HT rate. */
-	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
-		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
-		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
-		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
-		pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
-		pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
-
-		pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
-		pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
-
-		pAd->CommonCfg.APEdcaParm.Cwmax[0] = 10;
-		pAd->CommonCfg.APEdcaParm.Cwmax[1] = 6;
-		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
-		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
-
-		pAd->CommonCfg.APEdcaParm.Txop[0] = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[1] = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[2] = AC2_DEF_TXOP;
-		pAd->CommonCfg.APEdcaParm.Txop[3] = AC3_DEF_TXOP;
-	}
-	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void LinkUp(struct rt_rtmp_adapter *pAd, u8 BssType)
-{
-	unsigned long Now;
-	u32 Data;
-	BOOLEAN Cancelled;
-	u8 Value = 0, idx = 0, HashIdx = 0;
-	struct rt_mac_table_entry *pEntry = NULL, *pCurrEntry = NULL;
-
-	/* Init ChannelQuality to prevent DEAD_CQI at initial LinkUp */
-	pAd->Mlme.ChannelQuality = 50;
-
-	pEntry = MacTableLookup(pAd, pAd->CommonCfg.Bssid);
-	if (pEntry) {
-		MacTableDeleteEntry(pAd, pEntry->Aid, pEntry->Addr);
-		pEntry = NULL;
-	}
-
-	pEntry = &pAd->MacTab.Content[BSSID_WCID];
-
-	/* */
-	/* ASSOC - DisassocTimeoutAction */
-	/* CNTL - Dis-associate successful */
-	/* ! LINK DOWN ! */
-	/* [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: ) */
-	/* */
-	/* To prevent DisassocTimeoutAction to call Link down after we link up, */
-	/* cancel the DisassocTimer no matter what it start or not. */
-	/* */
-	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
-
-	COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
-
-	COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
-
-#ifdef RTMP_MAC_PCI
-	/* Before power save before link up function, We will force use 1R. */
-	/* So after link up, check Rx antenna # again. */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-	if (pAd->Antenna.field.RxPath == 3) {
-		Value |= (0x10);
-	} else if (pAd->Antenna.field.RxPath == 2) {
-		Value |= (0x8);
-	} else if (pAd->Antenna.field.RxPath == 1) {
-		Value |= (0x0);
-	}
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-	pAd->StaCfg.BBPR3 = Value;
-#endif /* RTMP_MAC_PCI // */
-
-	if (BssType == BSS_ADHOC) {
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_ADHOC_ON);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
-
-		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-			AdhocTurnOnQos(pAd);
-
-		DBGPRINT(RT_DEBUG_TRACE, ("Adhoc LINK UP!\n"));
-	} else {
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_INFRA_ON);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
-
-		DBGPRINT(RT_DEBUG_TRACE, ("Infra LINK UP!\n"));
-	}
-
-	/* 3*3 */
-	/* reset Tx beamforming bit */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
-	Value &= (~0x01);
-	Value |= pAd->CommonCfg.RegTransmitSetting.field.TxBF;
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
-
-	/* Change to AP channel */
-	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
-	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
-		/* Must use 40MHz. */
-		pAd->CommonCfg.BBPCurrentBW = BW_40;
-		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
-		Value &= (~0x18);
-		Value |= 0x10;
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
-
-		/*  RX : control channel at lower */
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-		Value &= (~0x20);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RTMP_MAC_PCI
-		pAd->StaCfg.BBPR3 = Value;
-#endif /* RTMP_MAC_PCI // */
-
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
-		Data &= 0xfffffffe;
-		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Data);
-
-		if (pAd->MACVersion == 0x28600100) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x1A);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x0A);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x16);
-			DBGPRINT(RT_DEBUG_TRACE, ("rt2860C !\n"));
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("40MHz Lower LINK UP! Control Channel at Below. Central = %d \n",
-			  pAd->CommonCfg.CentralChannel));
-	} else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
-		   && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
-		       BW_40)) {
-		/* Must use 40MHz. */
-		pAd->CommonCfg.BBPCurrentBW = BW_40;
-		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
-		Value &= (~0x18);
-		Value |= 0x10;
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
-
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
-		Data |= 0x1;
-		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Data);
-
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-		Value |= (0x20);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RTMP_MAC_PCI
-		pAd->StaCfg.BBPR3 = Value;
-#endif /* RTMP_MAC_PCI // */
-
-		if (pAd->MACVersion == 0x28600100) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x1A);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x0A);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x16);
-			DBGPRINT(RT_DEBUG_TRACE, ("rt2860C !\n"));
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("40MHz Upper LINK UP! Control Channel at UpperCentral = %d \n",
-			  pAd->CommonCfg.CentralChannel));
-	} else {
-		pAd->CommonCfg.BBPCurrentBW = BW_20;
-		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
-		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
-		Value &= (~0x18);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
-
-		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
-		Data &= 0xfffffffe;
-		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Data);
-
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-		Value &= (~0x20);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RTMP_MAC_PCI
-		pAd->StaCfg.BBPR3 = Value;
-#endif /* RTMP_MAC_PCI // */
-
-		if (pAd->MACVersion == 0x28600100) {
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x08);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x11);
-			DBGPRINT(RT_DEBUG_TRACE, ("rt2860C !\n"));
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE, ("20MHz LINK UP!\n"));
-	}
-
-	RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
-
-	/* */
-	/* Save BBP_R66 value, it will be used in RTUSBResumeMsduTransmission */
-	/* */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
-				    &pAd->BbpTuning.R66CurrentValue);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("LINK UP! (BssType=%d, AID=%d, ssid=%s, Channel=%d, CentralChannel = %d)\n",
-		  BssType, pAd->StaActive.Aid, pAd->CommonCfg.Ssid,
-		  pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("LINK UP! (Density =%d, )\n",
-		  pAd->MacTab.Content[BSSID_WCID].MpduDensity));
-
-	AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
-
-	AsicSetSlotTime(pAd, TRUE);
-	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
-
-	/* Call this for RTS protection for legacy rate, we will always enable RTS threshold, but normally it will not hit */
-	AsicUpdateProtect(pAd, 0, (OFDMSETPROTECT | CCKSETPROTECT), TRUE,
-			  FALSE);
-
-	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)) {
-		/* Update HT protection for based on AP's operating mode. */
-		if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1) {
-			AsicUpdateProtect(pAd,
-					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					  OperaionMode, ALLN_SETPROTECT, FALSE,
-					  TRUE);
-		} else
-			AsicUpdateProtect(pAd,
-					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					  OperaionMode, ALLN_SETPROTECT, FALSE,
-					  FALSE);
-	}
-
-	NdisZeroMemory(&pAd->DrsCounters, sizeof(struct rt_counter_drs));
-
-	NdisGetSystemUpTime(&Now);
-	pAd->StaCfg.LastBeaconRxTime = Now;	/* last RX timestamp */
-
-	if ((pAd->CommonCfg.TxPreamble != Rt802_11PreambleLong) &&
-	    CAP_IS_SHORT_PREAMBLE_ON(pAd->StaActive.CapabilityInfo)) {
-		MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
-	}
-
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
-
-	if (pAd->CommonCfg.RadarDetect.RDMode == RD_SILENCE_MODE) {
-	}
-	pAd->CommonCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
-
-	if (BssType == BSS_ADHOC) {
-		MakeIbssBeacon(pAd);
-		if ((pAd->CommonCfg.Channel > 14)
-		    && (pAd->CommonCfg.bIEEE80211H == 1)
-		    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
-			;	/*Do nothing */
-		} else {
-			AsicEnableIbssSync(pAd);
-		}
-
-		/* In ad hoc mode, use MAC table from index 1. */
-		/* p.s ASIC use all 0xff as termination of WCID table search.To prevent it's 0xff-ff-ff-ff-ff-ff, Write 0 here. */
-		RTMP_IO_WRITE32(pAd, MAC_WCID_BASE, 0x00);
-		RTMP_IO_WRITE32(pAd, 0x1808, 0x00);
-
-		/* If WEP is enabled, add key material and cipherAlg into Asic */
-		/* Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000) */
-
-		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) {
-			u8 *Key;
-			u8 CipherAlg;
-
-			for (idx = 0; idx < SHARE_KEY_NUM; idx++) {
-				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
-				Key = pAd->SharedKey[BSS0][idx].Key;
-
-				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
-					/* Set key material and cipherAlg to Asic */
-					AsicAddSharedKeyEntry(pAd, BSS0, idx,
-							      CipherAlg, Key,
-							      NULL, NULL);
-
-					if (idx == pAd->StaCfg.DefaultKeyId) {
-						/* Update WCID attribute table and IVEIV table for this group key table */
-						RTMPAddWcidAttributeEntry(pAd,
-									  BSS0,
-									  idx,
-									  CipherAlg,
-									  NULL);
-					}
-				}
-
-			}
-		}
-		/* If WPANone is enabled, add key material and cipherAlg into Asic */
-		/* Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000) */
-		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
-			pAd->StaCfg.DefaultKeyId = 0;	/* always be zero */
-
-			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
-				       sizeof(struct rt_cipher_key));
-			pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key,
-				       pAd->StaCfg.PMK, LEN_TKIP_EK);
-
-			if (pAd->StaCfg.PairCipher ==
-			    Ndis802_11Encryption2Enabled) {
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
-					       &pAd->StaCfg.PMK[16],
-					       LEN_TKIP_RXMICK);
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
-					       &pAd->StaCfg.PMK[16],
-					       LEN_TKIP_TXMICK);
-			}
-			/* Decide its ChiperAlg */
-			if (pAd->StaCfg.PairCipher ==
-			    Ndis802_11Encryption2Enabled)
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-			else if (pAd->StaCfg.PairCipher ==
-				 Ndis802_11Encryption3Enabled)
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-			else {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Unknow Cipher (=%d), set Cipher to AES\n",
-					  pAd->StaCfg.PairCipher));
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-			}
-
-			/* Set key material and cipherAlg to Asic */
-			AsicAddSharedKeyEntry(pAd,
-					      BSS0,
-					      0,
-					      pAd->SharedKey[BSS0][0].CipherAlg,
-					      pAd->SharedKey[BSS0][0].Key,
-					      pAd->SharedKey[BSS0][0].TxMic,
-					      pAd->SharedKey[BSS0][0].RxMic);
-
-			/* Update WCID attribute table and IVEIV table for this group key table */
-			RTMPAddWcidAttributeEntry(pAd, BSS0, 0,
-						  pAd->SharedKey[BSS0][0].
-						  CipherAlg, NULL);
-
-		}
-
-	} else			/* BSS_INFRA */
-	{
-		/* Check the new SSID with last SSID */
-		while (Cancelled == TRUE) {
-			if (pAd->CommonCfg.LastSsidLen ==
-			    pAd->CommonCfg.SsidLen) {
-				if (RTMPCompareMemory
-				    (pAd->CommonCfg.LastSsid,
-				     pAd->CommonCfg.Ssid,
-				     pAd->CommonCfg.LastSsidLen) == 0) {
-					/* Link to the old one no linkdown is required. */
-					break;
-				}
-			}
-			/* Send link down event before set to link up */
-			pAd->IndicateMediaState = NdisMediaStateDisconnected;
-			RTMP_IndicateMediaState(pAd);
-			pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("NDIS_STATUS_MEDIA_DISCONNECT Event AA!\n"));
-			break;
-		}
-
-		/* */
-		/* On WPA mode, Remove All Keys if not connect to the last BSSID */
-		/* Key will be set after 4-way handshake. */
-		/* */
-		if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-			unsigned long IV;
-
-			/* Remove all WPA keys */
-			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-			RTMPWPARemoveAllKeys(pAd);
-			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-			pAd->StaCfg.PrivacyFilter =
-			    Ndis802_11PrivFilter8021xWEP;
-
-			/* Fixed connection failed with Range Maximizer - 515 AP (Marvell Chip) when security is WPAPSK/TKIP */
-			/* If IV related values are too large in GroupMsg2, AP would ignore this message. */
-			IV = 1;
-			IV |= (pAd->StaCfg.DefaultKeyId << 30);
-			AsicUpdateWCIDIVEIV(pAd, BSSID_WCID, IV, 0);
-		}
-		/* NOTE: */
-		/* the decision of using "short slot time" or not may change dynamically due to */
-		/* new STA association to the AP. so we have to decide that upon parsing BEACON, not here */
-
-		/* NOTE: */
-		/* the decision to use "RTC/CTS" or "CTS-to-self" protection or not may change dynamically */
-		/* due to new STA association to the AP. so we have to decide that upon parsing BEACON, not here */
-
-		ComposePsPoll(pAd);
-		ComposeNullFrame(pAd);
-
-		AsicEnableBssSync(pAd);
-
-		/* Add BSSID to WCID search table */
-		AsicUpdateRxWCIDTable(pAd, BSSID_WCID, pAd->CommonCfg.Bssid);
-
-		/* If WEP is enabled, add pairwise and shared key */
-		if (((pAd->StaCfg.WpaSupplicantUP) &&
-		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
-		     (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) ||
-		    ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) &&
-		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled))) {
-			u8 *Key;
-			u8 CipherAlg;
-
-			for (idx = 0; idx < SHARE_KEY_NUM; idx++) {
-				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
-				Key = pAd->SharedKey[BSS0][idx].Key;
-
-				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
-					/* Set key material and cipherAlg to Asic */
-					AsicAddSharedKeyEntry(pAd, BSS0, idx,
-							      CipherAlg, Key,
-							      NULL, NULL);
-
-					if (idx == pAd->StaCfg.DefaultKeyId) {
-						/* Assign group key info */
-						RTMPAddWcidAttributeEntry(pAd,
-									  BSS0,
-									  idx,
-									  CipherAlg,
-									  NULL);
-
-						pEntry->Aid = BSSID_WCID;
-						/* Assign pairwise key info */
-						RTMPAddWcidAttributeEntry(pAd,
-									  BSS0,
-									  idx,
-									  CipherAlg,
-									  pEntry);
-					}
-				}
-			}
-		}
-		/* only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode */
-		/* should wait until at least 2 active nodes in this BSSID. */
-		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-
-		/* For GUI ++ */
-		if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA) {
-			pAd->IndicateMediaState = NdisMediaStateConnected;
-			pAd->ExtraInfo = GENERAL_LINK_UP;
-			RTMP_IndicateMediaState(pAd);
-		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-			   (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-		{
-			if (pAd->StaCfg.WpaSupplicantUP ==
-			    WPA_SUPPLICANT_DISABLE)
-				RTMPSetTimer(&pAd->Mlme.LinkDownTimer,
-					     LINK_DOWN_TIMEOUT);
-		}
-		/* -- */
-
-		/* Add BSSID in my MAC Table. */
-		NdisAcquireSpinLock(&pAd->MacTabLock);
-		/* add this MAC entry into HASH table */
-		if (pEntry) {
-			HashIdx = MAC_ADDR_HASH_INDEX(pAd->CommonCfg.Bssid);
-			if (pAd->MacTab.Hash[HashIdx] == NULL) {
-				pAd->MacTab.Hash[HashIdx] = pEntry;
-			} else {
-				pCurrEntry = pAd->MacTab.Hash[HashIdx];
-				while (pCurrEntry->pNext != NULL) {
-					pCurrEntry = pCurrEntry->pNext;
-				}
-				pCurrEntry->pNext = pEntry;
-			}
-		}
-		RTMPMoveMemory(pEntry->Addr, pAd->CommonCfg.Bssid,
-			       MAC_ADDR_LEN);
-		pEntry->Aid = BSSID_WCID;
-		pEntry->pAd = pAd;
-		pEntry->ValidAsCLI = TRUE;	/*Although this is bssid..still set ValidAsCl */
-		pAd->MacTab.Size = 1;	/* infra mode always set MACtab size =1. */
-		pEntry->Sst = SST_ASSOC;
-		pEntry->AuthState = SST_ASSOC;
-		pEntry->AuthMode = pAd->StaCfg.AuthMode;
-		pEntry->WepStatus = pAd->StaCfg.WepStatus;
-		if (pEntry->AuthMode < Ndis802_11AuthModeWPA) {
-			pEntry->WpaState = AS_NOTUSE;
-			pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-		} else {
-			pEntry->WpaState = AS_PTKSTART;
-			pEntry->PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
-		}
-		NdisReleaseSpinLock(&pAd->MacTabLock);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("LINK UP!  ClientStatusFlags=%lx)\n",
-			  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-
-		MlmeUpdateTxRates(pAd, TRUE, BSS0);
-		MlmeUpdateHtTxRates(pAd, BSS0);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("LINK UP! (StaActive.bHtEnable =%d, )\n",
-			  pAd->StaActive.SupportedPhyInfo.bHtEnable));
-
-		if (pAd->CommonCfg.bAggregationCapable) {
-			if ((pAd->CommonCfg.bPiggyBackCapable)
-			    && (pAd->MlmeAux.APRalinkIe & 0x00000003) == 3) {
-				OPSTATUS_SET_FLAG(pAd,
-						  fOP_STATUS_PIGGYBACK_INUSED);
-				OPSTATUS_SET_FLAG(pAd,
-						  fOP_STATUS_AGGREGATION_INUSED);
-				CLIENT_STATUS_SET_FLAG(pEntry,
-						       fCLIENT_STATUS_AGGREGATION_CAPABLE);
-				CLIENT_STATUS_SET_FLAG(pEntry,
-						       fCLIENT_STATUS_PIGGYBACK_CAPABLE);
-				RTMPSetPiggyBack(pAd, TRUE);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Turn on Piggy-Back\n"));
-			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
-				OPSTATUS_SET_FLAG(pAd,
-						  fOP_STATUS_AGGREGATION_INUSED);
-				CLIENT_STATUS_SET_FLAG(pEntry,
-						       fCLIENT_STATUS_AGGREGATION_CAPABLE);
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Ralink Aggregation\n"));
-			}
-		}
-
-		if (pAd->MlmeAux.APRalinkIe != 0x0) {
-			if (CLIENT_STATUS_TEST_FLAG
-			    (pEntry, fCLIENT_STATUS_RDG_CAPABLE)) {
-				AsicEnableRDG(pAd);
-			}
-			OPSTATUS_SET_FLAG(pAd, fCLIENT_STATUS_RALINK_CHIPSET);
-			CLIENT_STATUS_SET_FLAG(pEntry,
-					       fCLIENT_STATUS_RALINK_CHIPSET);
-		} else {
-			OPSTATUS_CLEAR_FLAG(pAd, fCLIENT_STATUS_RALINK_CHIPSET);
-			CLIENT_STATUS_CLEAR_FLAG(pEntry,
-						 fCLIENT_STATUS_RALINK_CHIPSET);
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("NDIS_STATUS_MEDIA_CONNECT Event B!.BACapability = %x. ClientStatusFlags = %lx\n",
-		  pAd->CommonCfg.BACapability.word,
-		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-
-	/* Set LED */
-	RTMPSetLED(pAd, LED_LINK_UP);
-
-	pAd->Mlme.PeriodicRound = 0;
-	pAd->Mlme.OneSecPeriodicRound = 0;
-	pAd->bConfigChanged = FALSE;	/* Reset config flag */
-	pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information after link is up */
-
-	/* Set basic auto fall back */
-	{
-		u8 *pTable;
-		u8 TableSize = 0;
-
-		MlmeSelectTxRateTable(pAd, &pAd->MacTab.Content[BSSID_WCID],
-				      &pTable, &TableSize,
-				      &pAd->CommonCfg.TxRateIndex);
-		AsicUpdateAutoFallBackTable(pAd, pTable);
-	}
-
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-	pEntry->HTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
-	pEntry->MaxHTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
-	if (pAd->StaCfg.bAutoTxRateSwitch == FALSE) {
-		pEntry->bAutoTxRateSwitch = FALSE;
-
-		if (pEntry->HTPhyMode.field.MCS == 32)
-			pEntry->HTPhyMode.field.ShortGI = GI_800;
-
-		if ((pEntry->HTPhyMode.field.MCS > MCS_7)
-		    || (pEntry->HTPhyMode.field.MCS == 32))
-			pEntry->HTPhyMode.field.STBC = STBC_NONE;
-
-		/* If the legacy mode is set, overwrite the transmit setting of this entry. */
-		if (pEntry->HTPhyMode.field.MODE <= MODE_OFDM)
-			RTMPUpdateLegacyTxSetting((u8)pAd->StaCfg.
-						  DesiredTransmitSetting.field.
-						  FixedTxMode, pEntry);
-	} else
-		pEntry->bAutoTxRateSwitch = TRUE;
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-
-	/*  Let Link Status Page display first initial rate. */
-	pAd->LastTxRate = (u16)(pEntry->HTPhyMode.word);
-	/* Select DAC according to HT or Legacy */
-	if (pAd->StaActive.SupportedPhyInfo.MCSSet[0] != 0x00) {
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &Value);
-		Value &= (~0x18);
-		if (pAd->Antenna.field.TxPath == 2) {
-			Value |= 0x10;
-		}
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, Value);
-	} else {
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &Value);
-		Value &= (~0x18);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, Value);
-	}
-
-	if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
-	} else if (pEntry->MaxRAmpduFactor == 0) {
-		/* If HT AP doesn't support MaxRAmpduFactor = 1, we need to set max PSDU to 0. */
-		/* Because our Init value is 1 at MACRegTable. */
-		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x0fff);
-	}
-	/* Patch for Marvel AP to gain high throughput */
-	/* Need to set as following, */
-	/* 1. Set txop in register-EDCA_AC0_CFG as 0x60 */
-	/* 2. Set EnTXWriteBackDDONE in register-WPDMA_GLO_CFG as zero */
-	/* 3. PBF_MAX_PCNT as 0x1F3FBF9F */
-	/* 4. kick per two packets when dequeue */
-	/* */
-	/* Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable */
-	/* */
-	/* if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is. */
-	if (!((pAd->CommonCfg.RxStream == 1) && (pAd->CommonCfg.TxStream == 1))
-	    && (pAd->StaCfg.bForceTxBurst == FALSE)
-	    &&
-	    (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
-	      && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
-	     || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
-		 && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE)))) {
-		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data &= 0xFFFFFF00;
-		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
-
-		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3F7F9F);
-		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 1\n"));
-	} else if (pAd->CommonCfg.bEnableTxBurst) {
-		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data &= 0xFFFFFF00;
-		Data |= 0x60;
-		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
-		pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = TRUE;
-
-		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3FBF9F);
-		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 2\n"));
-	} else {
-		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data &= 0xFFFFFF00;
-		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
-
-		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3F7F9F);
-		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 3\n"));
-	}
-
-	/* Re-check to turn on TX burst or not. */
-	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE)
-	    && ((STA_WEP_ON(pAd)) || (STA_TKIP_ON(pAd)))) {
-		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = TRUE;
-		if (pAd->CommonCfg.bEnableTxBurst) {
-			u32 MACValue = 0;
-			/* Force disable  TXOP value in this case. The same action in MLMEUpdateProtect too. */
-			/* I didn't change PBF_MAX_PCNT setting. */
-			RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &MACValue);
-			MACValue &= 0xFFFFFF00;
-			RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, MACValue);
-			pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
-		}
-	} else {
-		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = FALSE;
-	}
-
-	pAd->CommonCfg.IOTestParm.bLastAtheros = FALSE;
-	COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("pAd->bNextDisableRxBA= %d \n",
-		  pAd->CommonCfg.IOTestParm.bNextDisableRxBA));
-	/* BSSID add in one MAC entry too.  Because in Tx, ASIC need to check Cipher and IV/EIV, BAbitmap */
-	/* Pther information in MACTab.Content[BSSID_WCID] is not necessary for driver. */
-	/* Note: As STA, The MACTab.Content[BSSID_WCID]. PairwiseKey and Shared Key for BSS0 are the same. */
-
-	if (pAd->StaCfg.WepStatus <= Ndis802_11WEPDisabled) {
-		if (pAd->StaCfg.WpaSupplicantUP &&
-		    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
-		    (pAd->StaCfg.IEEE8021X == TRUE)) ;
-		else {
-			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-			pAd->StaCfg.PrivacyFilter =
-			    Ndis802_11PrivFilterAcceptAll;
-		}
-	}
-
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-	pEntry->PortSecured = pAd->StaCfg.PortSecured;
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-
-	/* */
-	/* Patch Atheros AP TX will breakdown issue. */
-	/* AP Model: DLink DWL-8200AP */
-	/* */
-	if (INFRA_ON(pAd) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)
-	    && STA_TKIP_ON(pAd)) {
-		RTMP_IO_WRITE32(pAd, RX_PARSER_CFG, 0x01);
-	} else {
-		RTMP_IO_WRITE32(pAd, RX_PARSER_CFG, 0x00);
-	}
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
-}
-
-/*
-	==========================================================================
-
-	Routine	Description:
-		Disconnect current BSSID
-
-	Arguments:
-		pAd				- Pointer to our adapter
-		IsReqFromAP		- Request from AP
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		We need more information to know it's this requst from AP.
-		If yes! we need to do extra handling, for example, remove the WPA key.
-		Otherwise on 4-way handshaking will fail, since the WPA key didn't get
-		removed while auto reconnect.
-		Disconnect request from AP, it means we will start afresh 4-way handshaking
-		on WPA mode.
-
-	==========================================================================
-*/
-void LinkDown(struct rt_rtmp_adapter *pAd, IN BOOLEAN IsReqFromAP)
-{
-	u8 i, ByteValue = 0;
-
-	/* Do nothing if monitor mode is on */
-	if (MONITOR_ON(pAd))
-		return;
-
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
-	/* Comment the codes, because the line 2291 call the same function. */
-	/* RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled); */
-	/* Not allowed go to sleep within the linkdown function. */
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-
-	if (pAd->CommonCfg.bWirelessEvent) {
-		RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG,
-				      pAd->MacTab.Content[BSSID_WCID].Addr,
-				      BSS0, 0);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("LINK DOWN!\n"));
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
-
-#ifdef RTMP_MAC_PCI
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-		BOOLEAN Cancelled;
-		pAd->Mlme.bPsPollTimerRunning = FALSE;
-		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
-	}
-
-	pAd->bPCIclkOff = FALSE;
-#endif /* RTMP_MAC_PCI // */
-
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
-	    || RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)
-	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)) {
-		AUTO_WAKEUP_STRUC AutoWakeupCfg;
-		AsicForceWakeup(pAd, TRUE);
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-	}
-#ifdef RTMP_MAC_PCI
-	pAd->bPCIclkOff = FALSE;
-#endif /* RTMP_MAC_PCI // */
-
-	if (ADHOC_ON(pAd))	/* Adhoc mode link down */
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("LINK DOWN 1!\n"));
-
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-		pAd->IndicateMediaState = NdisMediaStateDisconnected;
-		RTMP_IndicateMediaState(pAd);
-		pAd->ExtraInfo = GENERAL_LINK_DOWN;
-		BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
-				    pAd->CommonCfg.Channel);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 (" MacTab.Size=%d !\n", pAd->MacTab.Size));
-	} else			/* Infra structure mode */
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("LINK DOWN 2!\n"));
-
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-
-		/* Saved last SSID for linkup comparison */
-		pAd->CommonCfg.LastSsidLen = pAd->CommonCfg.SsidLen;
-		NdisMoveMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid,
-			       pAd->CommonCfg.LastSsidLen);
-		COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
-		if (pAd->MlmeAux.CurrReqIsFromNdis == TRUE) {
-			pAd->IndicateMediaState = NdisMediaStateDisconnected;
-			RTMP_IndicateMediaState(pAd);
-			pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("NDIS_STATUS_MEDIA_DISCONNECT Event A!\n"));
-			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
-		} else {
-			/* */
-			/* If disassociation request is from NDIS, then we don't need to delete BSSID from entry. */
-			/* Otherwise lost beacon or receive De-Authentication from AP, */
-			/* then we should delete BSSID from BssTable. */
-			/* If we don't delete from entry, roaming will fail. */
-			/* */
-			BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
-					    pAd->CommonCfg.Channel);
-		}
-
-		/* restore back to - */
-		/*      1. long slot (20 us) or short slot (9 us) time */
-		/*      2. turn on/off RTS/CTS and/or CTS-to-self protection */
-		/*      3. short preamble */
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
-
-	}
-
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
-		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE)
-			MacTableDeleteEntry(pAd, pAd->MacTab.Content[i].Aid,
-					    pAd->MacTab.Content[i].Addr);
-	}
-
-	AsicSetSlotTime(pAd, TRUE);	/*FALSE); */
-	AsicSetEdcaParm(pAd, NULL);
-
-	/* Set LED */
-	RTMPSetLED(pAd, LED_LINK_DOWN);
-	pAd->LedIndicatorStrength = 0xF0;
-	RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, firmware has not done it. */
-
-	AsicDisableSync(pAd);
-
-	pAd->Mlme.PeriodicRound = 0;
-	pAd->Mlme.OneSecPeriodicRound = 0;
-
-	if (pAd->StaCfg.BssType == BSS_INFRA) {
-		/* Remove StaCfg Information after link down */
-		NdisZeroMemory(pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
-		NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
-		pAd->CommonCfg.SsidLen = 0;
-	}
-
-	NdisZeroMemory(&pAd->MlmeAux.HtCapability, sizeof(struct rt_ht_capability_ie));
-	NdisZeroMemory(&pAd->MlmeAux.AddHtInfo, sizeof(struct rt_add_ht_info_ie));
-	pAd->MlmeAux.HtCapabilityLen = 0;
-	pAd->MlmeAux.NewExtChannelOffset = 0xff;
-
-	/* Reset WPA-PSK state. Only reset when supplicant enabled */
-	if (pAd->StaCfg.WpaState != SS_NOTUSE) {
-		pAd->StaCfg.WpaState = SS_START;
-		/* Clear Replay counter */
-		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
-
-	}
-	/* */
-	/* if link down come from AP, we need to remove all WPA keys on WPA mode. */
-	/* otherwise will cause 4-way handshaking failed, since the WPA key not empty. */
-	/* */
-	if ((IsReqFromAP) && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)) {
-		/* Remove all WPA keys */
-		RTMPWPARemoveAllKeys(pAd);
-	}
-	/* 802.1x port control */
-
-	/* Prevent clear PortSecured here with static WEP */
-	/* NetworkManger set security policy first then set SSID to connect AP. */
-	if (pAd->StaCfg.WpaSupplicantUP &&
-	    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
-	    (pAd->StaCfg.IEEE8021X == FALSE)) {
-		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-	} else {
-		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
-	}
-
-	NdisAcquireSpinLock(&pAd->MacTabLock);
-	NdisZeroMemory(&pAd->MacTab, sizeof(struct rt_mac_table));
-	pAd->MacTab.Content[BSSID_WCID].PortSecured = pAd->StaCfg.PortSecured;
-	NdisReleaseSpinLock(&pAd->MacTabLock);
-
-	pAd->StaCfg.MicErrCnt = 0;
-
-	pAd->IndicateMediaState = NdisMediaStateDisconnected;
-	/* Update extra information to link is up */
-	pAd->ExtraInfo = GENERAL_LINK_DOWN;
-
-	pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
-
-#ifdef RTMP_MAC_USB
-	pAd->bUsbTxBulkAggre = FALSE;
-#endif /* RTMP_MAC_USB // */
-
-	/* Clean association information */
-	NdisZeroMemory(&pAd->StaCfg.AssocInfo,
-		       sizeof(struct rt_ndis_802_11_association_information));
-	pAd->StaCfg.AssocInfo.Length =
-	    sizeof(struct rt_ndis_802_11_association_information);
-	pAd->StaCfg.ReqVarIELen = 0;
-	pAd->StaCfg.ResVarIELen = 0;
-
-	/* */
-	/* Reset RSSI value after link down */
-	/* */
-	pAd->StaCfg.RssiSample.AvgRssi0 = 0;
-	pAd->StaCfg.RssiSample.AvgRssi0X8 = 0;
-	pAd->StaCfg.RssiSample.AvgRssi1 = 0;
-	pAd->StaCfg.RssiSample.AvgRssi1X8 = 0;
-	pAd->StaCfg.RssiSample.AvgRssi2 = 0;
-	pAd->StaCfg.RssiSample.AvgRssi2X8 = 0;
-
-	/* Restore MlmeRate */
-	pAd->CommonCfg.MlmeRate = pAd->CommonCfg.BasicMlmeRate;
-	pAd->CommonCfg.RtsRate = pAd->CommonCfg.BasicMlmeRate;
-
-	/* */
-	/* After Link down, reset piggy-back setting in ASIC. Disable RDG. */
-	/* */
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
-		pAd->CommonCfg.BBPCurrentBW = BW_20;
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &ByteValue);
-		ByteValue &= (~0x18);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, ByteValue);
-	}
-	/* Reset DAC */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &ByteValue);
-	ByteValue &= (~0x18);
-	if (pAd->Antenna.field.TxPath == 2) {
-		ByteValue |= 0x10;
-	}
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, ByteValue);
-
-	RTMPSetPiggyBack(pAd, FALSE);
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_PIGGYBACK_INUSED);
-
-	pAd->CommonCfg.BACapability.word = pAd->CommonCfg.REGBACapability.word;
-
-	/* Restore all settings in the following. */
-	AsicUpdateProtect(pAd, 0,
-			  (ALLN_SETPROTECT | CCKSETPROTECT | OFDMSETPROTECT),
-			  TRUE, FALSE);
-	AsicDisableRDG(pAd);
-	pAd->CommonCfg.IOTestParm.bCurrentAtheros = FALSE;
-	pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
-
-	RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x1fff);
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-
-/* Allow go to sleep after linkdown steps. */
-	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-
-	RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
-
-#ifdef RT30xx
-	if ((IS_RT30xx(pAd) || IS_RT3090(pAd) || IS_RT3390(pAd))
-	    && (pAd->Antenna.field.RxPath > 1 || pAd->Antenna.field.TxPath > 1)) {
-		RTMP_ASIC_MMPS_DISABLE(pAd);
-	}
-#endif /* RT30xx // */
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void IterateOnBssTab(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_mlme_start_req StartReq;
-	struct rt_mlme_join_req JoinReq;
-	unsigned long BssIdx;
-
-	/* Change the wepstatus to original wepstatus */
-	pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
-	pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
-	pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
-
-	BssIdx = pAd->MlmeAux.BssIdx;
-	if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr) {
-		/* Check cipher suite, AP must have more secured cipher than station setting */
-		/* Set the Pairwise and Group cipher to match the intended AP setting */
-		/* We can only connect to AP with less secured cipher setting */
-		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
-		    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
-			pAd->StaCfg.GroupCipher =
-			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
-			    GroupCipher;
-
-			if (pAd->StaCfg.WepStatus ==
-			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
-			    PairCipher)
-				pAd->StaCfg.PairCipher =
-				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
-				    WPA.PairCipher;
-			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
-				 PairCipherAux != Ndis802_11WEPDisabled)
-				pAd->StaCfg.PairCipher =
-				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
-				    WPA.PairCipherAux;
-			else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
-				pAd->StaCfg.PairCipher =
-				    Ndis802_11Encryption2Enabled;
-		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
-			   || (pAd->StaCfg.AuthMode ==
-			       Ndis802_11AuthModeWPA2PSK)) {
-			pAd->StaCfg.GroupCipher =
-			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
-			    GroupCipher;
-
-			if (pAd->StaCfg.WepStatus ==
-			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
-			    PairCipher)
-				pAd->StaCfg.PairCipher =
-				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
-				    WPA2.PairCipher;
-			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
-				 PairCipherAux != Ndis802_11WEPDisabled)
-				pAd->StaCfg.PairCipher =
-				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
-				    WPA2.PairCipherAux;
-			else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
-				pAd->StaCfg.PairCipher =
-				    Ndis802_11Encryption2Enabled;
-
-			/* RSN capability */
-			pAd->StaCfg.RsnCapability =
-			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
-			    RsnCapability;
-		}
-		/* Set Mix cipher flag */
-		pAd->StaCfg.bMixCipher =
-		    (pAd->StaCfg.PairCipher ==
-		     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
-		/*if (pAd->StaCfg.bMixCipher == TRUE)
-		   {
-		   // If mix cipher, re-build RSNIE
-		   RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
-		   } */
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - iterate BSS %ld of %d\n", BssIdx,
-			  pAd->MlmeAux.SsidBssTab.BssNr));
-		JoinParmFill(pAd, &JoinReq, BssIdx);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ,
-			    sizeof(struct rt_mlme_join_req), &JoinReq);
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
-	} else if (pAd->StaCfg.BssType == BSS_ADHOC) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",
-			  pAd->MlmeAux.Ssid));
-		StartParmFill(pAd, &StartReq, (char *)pAd->MlmeAux.Ssid,
-			      pAd->MlmeAux.SsidLen);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
-			    sizeof(struct rt_mlme_start_req), &StartReq);
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
-	} else			/* no more BSS */
-	{
-
-		{
-			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",
-				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
-		}
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-	}
-}
-
-/* for re-association only */
-/* IRQL = DISPATCH_LEVEL */
-void IterateOnBssTab2(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_mlme_assoc_req ReassocReq;
-	unsigned long BssIdx;
-	struct rt_bss_entry *pBss;
-
-	BssIdx = pAd->MlmeAux.RoamIdx;
-	pBss = &pAd->MlmeAux.RoamTab.BssEntry[BssIdx];
-
-	if (BssIdx < pAd->MlmeAux.RoamTab.BssNr) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("CNTL - iterate BSS %ld of %d\n", BssIdx,
-			  pAd->MlmeAux.RoamTab.BssNr));
-
-		AsicSwitchChannel(pAd, pBss->Channel, FALSE);
-		AsicLockChannel(pAd, pBss->Channel);
-
-		/* reassociate message has the same structure as associate message */
-		AssocParmFill(pAd, &ReassocReq, pBss->Bssid,
-			      pBss->CapabilityInfo, ASSOC_TIMEOUT,
-			      pAd->StaCfg.DefaultListenCount);
-		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_REASSOC_REQ,
-			    sizeof(struct rt_mlme_assoc_req), &ReassocReq);
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
-	} else			/* no more BSS */
-	{
-
-		{
-			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",
-				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
-		}
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void JoinParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_join_req *JoinReq, unsigned long BssIdx)
-{
-	JoinReq->BssIdx = BssIdx;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void ScanParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_scan_req *ScanReq,
-		  char Ssid[],
-		  u8 SsidLen, u8 BssType, u8 ScanType)
-{
-	NdisZeroMemory(ScanReq->Ssid, MAX_LEN_OF_SSID);
-	ScanReq->SsidLen = SsidLen;
-	NdisMoveMemory(ScanReq->Ssid, Ssid, SsidLen);
-	ScanReq->BssType = BssType;
-	ScanReq->ScanType = ScanType;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void StartParmFill(struct rt_rtmp_adapter *pAd,
-		   struct rt_mlme_start_req *StartReq,
-		   char Ssid[], u8 SsidLen)
-{
-	ASSERT(SsidLen <= MAX_LEN_OF_SSID);
-	NdisMoveMemory(StartReq->Ssid, Ssid, SsidLen);
-	StartReq->SsidLen = SsidLen;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-void AuthParmFill(struct rt_rtmp_adapter *pAd,
-		  struct rt_mlme_auth_req *AuthReq,
-		  u8 *pAddr, u16 Alg)
-{
-	COPY_MAC_ADDR(AuthReq->Addr, pAddr);
-	AuthReq->Alg = Alg;
-	AuthReq->Timeout = AUTH_TIMEOUT;
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-#ifdef RTMP_MAC_PCI
-void ComposePsPoll(struct rt_rtmp_adapter *pAd)
-{
-	NdisZeroMemory(&pAd->PsPollFrame, sizeof(struct rt_pspoll_frame));
-	pAd->PsPollFrame.FC.Type = BTYPE_CNTL;
-	pAd->PsPollFrame.FC.SubType = SUBTYPE_PS_POLL;
-	pAd->PsPollFrame.Aid = pAd->StaActive.Aid | 0xC000;
-	COPY_MAC_ADDR(pAd->PsPollFrame.Bssid, pAd->CommonCfg.Bssid);
-	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void ComposeNullFrame(struct rt_rtmp_adapter *pAd)
-{
-	NdisZeroMemory(&pAd->NullFrame, sizeof(struct rt_header_802_11));
-	pAd->NullFrame.FC.Type = BTYPE_DATA;
-	pAd->NullFrame.FC.SubType = SUBTYPE_NULL_FUNC;
-	pAd->NullFrame.FC.ToDs = 1;
-	COPY_MAC_ADDR(pAd->NullFrame.Addr1, pAd->CommonCfg.Bssid);
-	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
-	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
-}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-void MlmeCntlConfirm(struct rt_rtmp_adapter *pAd, unsigned long MsgType, u16 Msg)
-{
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MsgType, sizeof(u16),
-		    &Msg);
-}
-
-void ComposePsPoll(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi * pTxWI;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("ComposePsPoll\n"));
-	NdisZeroMemory(&pAd->PsPollFrame, sizeof(struct rt_pspoll_frame));
-
-	pAd->PsPollFrame.FC.PwrMgmt = 0;
-	pAd->PsPollFrame.FC.Type = BTYPE_CNTL;
-	pAd->PsPollFrame.FC.SubType = SUBTYPE_PS_POLL;
-	pAd->PsPollFrame.Aid = pAd->StaActive.Aid | 0xC000;
-	COPY_MAC_ADDR(pAd->PsPollFrame.Bssid, pAd->CommonCfg.Bssid);
-	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
-
-	RTMPZeroMemory(&pAd->PsPollContext.TransferBuffer->field.
-		       WirelessPacket[0], 100);
-	pTxInfo =
-	    (struct rt_txinfo *)& pAd->PsPollContext.TransferBuffer->field.
-	    WirelessPacket[0];
-	RTMPWriteTxInfo(pAd, pTxInfo,
-			(u16)(sizeof(struct rt_pspoll_frame) + TXWI_SIZE), TRUE,
-			EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
-	pTxWI =
-	    (struct rt_txwi *) & pAd->PsPollContext.TransferBuffer->field.
-	    WirelessPacket[TXINFO_SIZE];
-	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0,
-		      BSSID_WCID, (sizeof(struct rt_pspoll_frame)), 0, 0,
-		      (u8)pAd->CommonCfg.MlmeTransmit.field.MCS,
-		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	RTMPMoveMemory(&pAd->PsPollContext.TransferBuffer->field.
-		       WirelessPacket[TXWI_SIZE + TXINFO_SIZE],
-		       &pAd->PsPollFrame, sizeof(struct rt_pspoll_frame));
-	/* Append 4 extra zero bytes. */
-	pAd->PsPollContext.BulkOutSize =
-	    TXINFO_SIZE + TXWI_SIZE + sizeof(struct rt_pspoll_frame) + 4;
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void ComposeNullFrame(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_txinfo *pTxInfo;
-	struct rt_txwi * pTxWI;
-
-	NdisZeroMemory(&pAd->NullFrame, sizeof(struct rt_header_802_11));
-	pAd->NullFrame.FC.Type = BTYPE_DATA;
-	pAd->NullFrame.FC.SubType = SUBTYPE_NULL_FUNC;
-	pAd->NullFrame.FC.ToDs = 1;
-	COPY_MAC_ADDR(pAd->NullFrame.Addr1, pAd->CommonCfg.Bssid);
-	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
-	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
-	RTMPZeroMemory(&pAd->NullContext.TransferBuffer->field.
-		       WirelessPacket[0], 100);
-	pTxInfo =
-	    (struct rt_txinfo *)& pAd->NullContext.TransferBuffer->field.
-	    WirelessPacket[0];
-	RTMPWriteTxInfo(pAd, pTxInfo,
-			(u16)(sizeof(struct rt_header_802_11) + TXWI_SIZE), TRUE,
-			EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
-	pTxWI =
-	    (struct rt_txwi *) & pAd->NullContext.TransferBuffer->field.
-	    WirelessPacket[TXINFO_SIZE];
-	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0,
-		      BSSID_WCID, (sizeof(struct rt_header_802_11)), 0, 0,
-		      (u8)pAd->CommonCfg.MlmeTransmit.field.MCS,
-		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	RTMPMoveMemory(&pAd->NullContext.TransferBuffer->field.
-		       WirelessPacket[TXWI_SIZE + TXINFO_SIZE], &pAd->NullFrame,
-		       sizeof(struct rt_header_802_11));
-	pAd->NullContext.BulkOutSize =
-	    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
-}
-#endif /* RTMP_MAC_USB // */
-
-/*
-	==========================================================================
-	Description:
-		Pre-build a BEACON frame in the shared memory
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
-*/
-unsigned long MakeIbssBeacon(struct rt_rtmp_adapter *pAd)
-{
-	u8 DsLen = 1, IbssLen = 2;
-	u8 LocalErpIe[3] = { IE_ERP, 1, 0x04 };
-	struct rt_header_802_11 BcnHdr;
-	u16 CapabilityInfo;
-	LARGE_INTEGER FakeTimestamp;
-	unsigned long FrameLen = 0;
-	struct rt_txwi * pTxWI = &pAd->BeaconTxWI;
-	u8 *pBeaconFrame = pAd->BeaconBuf;
-	BOOLEAN Privacy;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen = 0;
-	u8 ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 ExtRateLen = 0;
-	u8 RSNIe = IE_WPA;
-
-	if ((pAd->CommonCfg.PhyMode == PHY_11B)
-	    && (pAd->CommonCfg.Channel <= 14)) {
-		SupRate[0] = 0x82;	/* 1 mbps */
-		SupRate[1] = 0x84;	/* 2 mbps */
-		SupRate[2] = 0x8b;	/* 5.5 mbps */
-		SupRate[3] = 0x96;	/* 11 mbps */
-		SupRateLen = 4;
-		ExtRateLen = 0;
-	} else if (pAd->CommonCfg.Channel > 14) {
-		SupRate[0] = 0x8C;	/* 6 mbps, in units of 0.5 Mbps, basic rate */
-		SupRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
-		SupRate[2] = 0x98;	/* 12 mbps, in units of 0.5 Mbps, basic rate */
-		SupRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
-		SupRate[4] = 0xb0;	/* 24 mbps, in units of 0.5 Mbps, basic rate */
-		SupRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
-		SupRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
-		SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
-		SupRateLen = 8;
-		ExtRateLen = 0;
-
-		/* */
-		/* Also Update MlmeRate & RtsRate for G only & A only */
-		/* */
-		pAd->CommonCfg.MlmeRate = RATE_6;
-		pAd->CommonCfg.RtsRate = RATE_6;
-		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-		pAd->CommonCfg.MlmeTransmit.field.MCS =
-		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
-		    MODE_OFDM;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
-		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-	} else {
-		SupRate[0] = 0x82;	/* 1 mbps */
-		SupRate[1] = 0x84;	/* 2 mbps */
-		SupRate[2] = 0x8b;	/* 5.5 mbps */
-		SupRate[3] = 0x96;	/* 11 mbps */
-		SupRateLen = 4;
-
-		ExtRate[0] = 0x0C;	/* 6 mbps, in units of 0.5 Mbps, */
-		ExtRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
-		ExtRate[2] = 0x18;	/* 12 mbps, in units of 0.5 Mbps, */
-		ExtRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
-		ExtRate[4] = 0x30;	/* 24 mbps, in units of 0.5 Mbps, */
-		ExtRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
-		ExtRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
-		ExtRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
-		ExtRateLen = 8;
-	}
-
-	pAd->StaActive.SupRateLen = SupRateLen;
-	NdisMoveMemory(pAd->StaActive.SupRate, SupRate, SupRateLen);
-	pAd->StaActive.ExtRateLen = ExtRateLen;
-	NdisMoveMemory(pAd->StaActive.ExtRate, ExtRate, ExtRateLen);
-
-	/* compose IBSS beacon frame */
-	MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, BROADCAST_ADDR,
-			 pAd->CommonCfg.Bssid);
-	Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
-	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
-	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
-	CapabilityInfo =
-	    CAP_GENERATE(0, 1, Privacy,
-			 (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort),
-			 0, 0);
-
-	MakeOutgoingFrame(pBeaconFrame, &FrameLen,
-			  sizeof(struct rt_header_802_11), &BcnHdr,
-			  TIMESTAMP_LEN, &FakeTimestamp,
-			  2, &pAd->CommonCfg.BeaconPeriod,
-			  2, &CapabilityInfo,
-			  1, &SsidIe,
-			  1, &pAd->CommonCfg.SsidLen,
-			  pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid,
-			  1, &SupRateIe,
-			  1, &SupRateLen,
-			  SupRateLen, SupRate,
-			  1, &DsIe,
-			  1, &DsLen,
-			  1, &pAd->CommonCfg.Channel,
-			  1, &IbssIe,
-			  1, &IbssLen, 2, &pAd->StaActive.AtimWin, END_OF_ARGS);
-
-	/* add ERP_IE and EXT_RAE IE of in 802.11g */
-	if (ExtRateLen) {
-		unsigned long tmp;
-
-		MakeOutgoingFrame(pBeaconFrame + FrameLen, &tmp,
-				  3, LocalErpIe,
-				  1, &ExtRateIe,
-				  1, &ExtRateLen,
-				  ExtRateLen, ExtRate, END_OF_ARGS);
-		FrameLen += tmp;
-	}
-	/* If adhoc secruity is set for WPA-None, append the cipher suite IE */
-	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
-		unsigned long tmp;
-		RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus,
-			      BSS0);
-
-		MakeOutgoingFrame(pBeaconFrame + FrameLen, &tmp,
-				  1, &RSNIe,
-				  1, &pAd->StaCfg.RSNIE_Len,
-				  pAd->StaCfg.RSNIE_Len, pAd->StaCfg.RSN_IE,
-				  END_OF_ARGS);
-		FrameLen += tmp;
-	}
-
-	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
-		unsigned long TmpLen;
-		u8 HtLen, HtLen1;
-
-		/* add HT Capability IE */
-		HtLen = sizeof(pAd->CommonCfg.HtCapability);
-		HtLen1 = sizeof(pAd->CommonCfg.AddHTInfo);
-
-		MakeOutgoingFrame(pBeaconFrame + FrameLen, &TmpLen,
-				  1, &HtCapIe,
-				  1, &HtLen,
-				  HtLen, &pAd->CommonCfg.HtCapability,
-				  1, &AddHtInfoIe,
-				  1, &HtLen1,
-				  HtLen1, &pAd->CommonCfg.AddHTInfo,
-				  END_OF_ARGS);
-
-		FrameLen += TmpLen;
-	}
-	/*beacon use reserved WCID 0xff */
-	if (pAd->CommonCfg.Channel > 14) {
-		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
-			      TRUE, 0, 0xff, FrameLen, PID_MGMT, PID_BEACON,
-			      RATE_1, IFS_HTTXOP, FALSE,
-			      &pAd->CommonCfg.MlmeTransmit);
-	} else {
-		/* Set to use 1Mbps for Adhoc beacon. */
-		HTTRANSMIT_SETTING Transmit;
-		Transmit.word = 0;
-		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
-			      TRUE, 0, 0xff, FrameLen, PID_MGMT, PID_BEACON,
-			      RATE_1, IFS_HTTXOP, FALSE, &Transmit);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("MakeIbssBeacon (len=%ld), SupRateLen=%d, ExtRateLen=%d, Channel=%d, PhyMode=%d\n",
-		  FrameLen, SupRateLen, ExtRateLen, pAd->CommonCfg.Channel,
-		  pAd->CommonCfg.PhyMode));
-	return FrameLen;
-}
diff --git a/drivers/staging/rt2860/sta/rtmp_data.c b/drivers/staging/rt2860/sta/rtmp_data.c
deleted file mode 100644
index e82c6b6..0000000
--- a/drivers/staging/rt2860/sta/rtmp_data.c
+++ /dev/null
@@ -1,2552 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtmp_data.c
-
-	Abstract:
-	Data path subroutines
-
-	Revision History:
-	Who 	  		When		What
-	Justin P. Mattock	11/07/2010	Fix typos
-	--------	----------		----------------------------------------------
-*/
-#include "../rt_config.h"
-#include <linux/kernel.h>
-
-void STARxEAPOLFrameIndicate(struct rt_rtmp_adapter *pAd,
-			     struct rt_mac_table_entry *pEntry,
-			     struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
-	struct rt_rxwi * pRxWI = pRxBlk->pRxWI;
-	u8 *pTmpBuf;
-
-	if (pAd->StaCfg.WpaSupplicantUP) {
-		/* All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon) */
-		/* TBD : process fragmented EAPol frames */
-		{
-			/* In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable */
-			if (pAd->StaCfg.IEEE8021X == TRUE &&
-			    (EAP_CODE_SUCCESS ==
-			     WpaCheckEapCode(pAd, pRxBlk->pData,
-					     pRxBlk->DataSize,
-					     LENGTH_802_1_H))) {
-				u8 *Key;
-				u8 CipherAlg;
-				int idx = 0;
-
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("Receive EAP-SUCCESS Packet\n"));
-				/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-				STA_PORT_SECURED(pAd);
-
-				if (pAd->StaCfg.IEEE8021x_required_keys ==
-				    FALSE) {
-					idx = pAd->StaCfg.DesireSharedKeyId;
-					CipherAlg =
-					    pAd->StaCfg.DesireSharedKey[idx].
-					    CipherAlg;
-					Key =
-					    pAd->StaCfg.DesireSharedKey[idx].
-					    Key;
-
-					if (pAd->StaCfg.DesireSharedKey[idx].
-					    KeyLen > 0) {
-#ifdef RTMP_MAC_PCI
-						struct rt_mac_table_entry *pEntry =
-						    &pAd->MacTab.
-						    Content[BSSID_WCID];
-
-						/* Set key material and cipherAlg to Asic */
-						AsicAddSharedKeyEntry(pAd, BSS0,
-								      idx,
-								      CipherAlg,
-								      Key, NULL,
-								      NULL);
-
-						/* Assign group key info */
-						RTMPAddWcidAttributeEntry(pAd,
-									  BSS0,
-									  idx,
-									  CipherAlg,
-									  NULL);
-
-						/* Assign pairwise key info */
-						RTMPAddWcidAttributeEntry(pAd,
-									  BSS0,
-									  idx,
-									  CipherAlg,
-									  pEntry);
-
-						pAd->IndicateMediaState =
-						    NdisMediaStateConnected;
-						pAd->ExtraInfo =
-						    GENERAL_LINK_UP;
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-						union {
-							char buf[sizeof
-								 (struct rt_ndis_802_11_wep)
-								 +
-								 MAX_LEN_OF_KEY
-								 - 1];
-							struct rt_ndis_802_11_wep keyinfo;
-						}
-						WepKey;
-						int len;
-
-						NdisZeroMemory(&WepKey,
-							       sizeof(WepKey));
-						len =
-						    pAd->StaCfg.
-						    DesireSharedKey[idx].KeyLen;
-
-						NdisMoveMemory(WepKey.keyinfo.
-							       KeyMaterial,
-							       pAd->StaCfg.
-							       DesireSharedKey
-							       [idx].Key,
-							       pAd->StaCfg.
-							       DesireSharedKey
-							       [idx].KeyLen);
-
-						WepKey.keyinfo.KeyIndex =
-						    0x80000000 + idx;
-						WepKey.keyinfo.KeyLength = len;
-						pAd->SharedKey[BSS0][idx].
-						    KeyLen =
-						    (u8)(len <= 5 ? 5 : 13);
-
-						pAd->IndicateMediaState =
-						    NdisMediaStateConnected;
-						pAd->ExtraInfo =
-						    GENERAL_LINK_UP;
-						/* need to enqueue cmd to thread */
-						RTUSBEnqueueCmdFromNdis(pAd,
-									OID_802_11_ADD_WEP,
-									TRUE,
-									&WepKey,
-									sizeof
-									(WepKey.
-									 keyinfo)
-									+ len -
-									1);
-#endif /* RTMP_MAC_USB // */
-						/* For Preventing ShardKey Table is cleared by remove key procedure. */
-						pAd->SharedKey[BSS0][idx].
-						    CipherAlg = CipherAlg;
-						pAd->SharedKey[BSS0][idx].
-						    KeyLen =
-						    pAd->StaCfg.
-						    DesireSharedKey[idx].KeyLen;
-						NdisMoveMemory(pAd->
-							       SharedKey[BSS0]
-							       [idx].Key,
-							       pAd->StaCfg.
-							       DesireSharedKey
-							       [idx].Key,
-							       pAd->StaCfg.
-							       DesireSharedKey
-							       [idx].KeyLen);
-					}
-				}
-			}
-
-			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
-			return;
-		}
-	} else {
-		/* Special DATA frame that has to pass to MLME */
-		/*       1. Cisco Aironet frames for CCX2. We need pass it to MLME for special process */
-		/*       2. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process */
-		{
-			pTmpBuf = pRxBlk->pData - LENGTH_802_11;
-			NdisMoveMemory(pTmpBuf, pRxBlk->pHeader, LENGTH_802_11);
-			REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID,
-						  pTmpBuf,
-						  pRxBlk->DataSize +
-						  LENGTH_802_11, pRxWI->RSSI0,
-						  pRxWI->RSSI1, pRxWI->RSSI2,
-						  pRxD->PlcpSignal);
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("report EAPOL/AIRONET DATA to MLME (len=%d) !\n",
-				      pRxBlk->DataSize));
-		}
-	}
-
-	RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
-	return;
-
-}
-
-void STARxDataFrameAnnounce(struct rt_rtmp_adapter *pAd,
-			    struct rt_mac_table_entry *pEntry,
-			    struct rt_rx_blk *pRxBlk, u8 FromWhichBSSID)
-{
-
-	/* non-EAP frame */
-	if (!RTMPCheckWPAframe
-	    (pAd, pEntry, pRxBlk->pData, pRxBlk->DataSize, FromWhichBSSID)) {
-
-		{
-			/* drop all non-EAP DATA frame before */
-			/* this client's Port-Access-Control is secured */
-			if (pRxBlk->pHeader->FC.Wep) {
-				/* unsupported cipher suite */
-				if (pAd->StaCfg.WepStatus ==
-				    Ndis802_11EncryptionDisabled) {
-					/* release packet */
-					RELEASE_NDIS_PACKET(pAd,
-							    pRxBlk->pRxPacket,
-							    NDIS_STATUS_FAILURE);
-					return;
-				}
-			} else {
-				/* encryption in-use but receive a non-EAPOL clear text frame, drop it */
-				if ((pAd->StaCfg.WepStatus !=
-				     Ndis802_11EncryptionDisabled)
-				    && (pAd->StaCfg.PortSecured ==
-					WPA_802_1X_PORT_NOT_SECURED)) {
-					/* release packet */
-					RELEASE_NDIS_PACKET(pAd,
-							    pRxBlk->pRxPacket,
-							    NDIS_STATUS_FAILURE);
-					return;
-				}
-			}
-		}
-		RX_BLK_CLEAR_FLAG(pRxBlk, fRX_EAP);
-		if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_ARALINK)) {
-			/* Normal legacy, AMPDU or AMSDU */
-			CmmRxnonRalinkFrameIndicate(pAd, pRxBlk,
-						    FromWhichBSSID);
-
-		} else {
-			/* ARALINK */
-			CmmRxRalinkFrameIndicate(pAd, pEntry, pRxBlk,
-						 FromWhichBSSID);
-		}
-	} else {
-		RX_BLK_SET_FLAG(pRxBlk, fRX_EAP);
-
-		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU)
-		    && (pAd->CommonCfg.bDisableReordering == 0)) {
-			Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-		} else {
-			/* Determine the destination of the EAP frame */
-			/* to WPA state machine or upper layer */
-			STARxEAPOLFrameIndicate(pAd, pEntry, pRxBlk,
-						FromWhichBSSID);
-		}
-	}
-}
-
-/* For TKIP frame, calculate the MIC value */
-BOOLEAN STACheckTkipMICValue(struct rt_rtmp_adapter *pAd,
-			     struct rt_mac_table_entry *pEntry, struct rt_rx_blk *pRxBlk)
-{
-	struct rt_header_802_11 * pHeader = pRxBlk->pHeader;
-	u8 *pData = pRxBlk->pData;
-	u16 DataSize = pRxBlk->DataSize;
-	u8 UserPriority = pRxBlk->UserPriority;
-	struct rt_cipher_key *pWpaKey;
-	u8 *pDA, *pSA;
-
-	pWpaKey = &pAd->SharedKey[BSS0][pRxBlk->pRxWI->KeyIndex];
-
-	pDA = pHeader->Addr1;
-	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_INFRA)) {
-		pSA = pHeader->Addr3;
-	} else {
-		pSA = pHeader->Addr2;
-	}
-
-	if (RTMPTkipCompareMICValue(pAd,
-				    pData,
-				    pDA,
-				    pSA,
-				    pWpaKey->RxMic,
-				    UserPriority, DataSize) == FALSE) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error 2\n"));
-
-		if (pAd->StaCfg.WpaSupplicantUP) {
-			WpaSendMicFailureToWpaSupplicant(pAd,
-							 (pWpaKey->Type ==
-							  PAIRWISEKEY) ? TRUE :
-							 FALSE);
-		} else {
-			RTMPReportMicError(pAd, pWpaKey);
-		}
-
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
-				    NDIS_STATUS_FAILURE);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/* */
-/* All Rx routines use struct rt_rx_blk structure to hande rx events */
-/* It is very important to build pRxBlk attributes */
-/*  1. pHeader pointer to 802.11 Header */
-/*  2. pData pointer to payload including LLC (just skip Header) */
-/*  3. set payload size including LLC to DataSize */
-/*  4. set some flags with RX_BLK_SET_FLAG() */
-/* */
-void STAHandleRxDataFrame(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk)
-{
-	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
-	struct rt_rxwi * pRxWI = pRxBlk->pRxWI;
-	struct rt_header_802_11 * pHeader = pRxBlk->pHeader;
-	void *pRxPacket = pRxBlk->pRxPacket;
-	BOOLEAN bFragment = FALSE;
-	struct rt_mac_table_entry *pEntry = NULL;
-	u8 FromWhichBSSID = BSS0;
-	u8 UserPriority = 0;
-
-	{
-		/* before LINK UP, all DATA frames are rejected */
-		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-			/* release packet */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-			return;
-		}
-		/* Drop not my BSS frames */
-		if (pRxD->MyBss == 0) {
-			{
-				/* release packet */
-				RELEASE_NDIS_PACKET(pAd, pRxPacket,
-						    NDIS_STATUS_FAILURE);
-				return;
-			}
-		}
-
-		pAd->RalinkCounters.RxCountSinceLastNULL++;
-		if (pAd->CommonCfg.bAPSDCapable
-		    && pAd->CommonCfg.APEdcaParm.bAPSDCapable
-		    && (pHeader->FC.SubType & 0x08)) {
-			u8 *pData;
-			DBGPRINT(RT_DEBUG_INFO, ("bAPSDCapable\n"));
-
-			/* Qos bit 4 */
-			pData = (u8 *)pHeader + LENGTH_802_11;
-			if ((*pData >> 4) & 0x01) {
-				DBGPRINT(RT_DEBUG_INFO,
-					 ("RxDone- Rcv EOSP frame, driver may fall into sleep\n"));
-				pAd->CommonCfg.bInServicePeriod = FALSE;
-
-				/* Force driver to fall into sleep mode when rcv EOSP frame */
-				if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-					u16 TbttNumToNextWakeUp;
-					u16 NextDtim =
-					    pAd->StaCfg.DtimPeriod;
-					unsigned long Now;
-
-					NdisGetSystemUpTime(&Now);
-					NextDtim -=
-					    (u16)(Now -
-						      pAd->StaCfg.
-						      LastBeaconRxTime) /
-					    pAd->CommonCfg.BeaconPeriod;
-
-					TbttNumToNextWakeUp =
-					    pAd->StaCfg.DefaultListenCount;
-					if (OPSTATUS_TEST_FLAG
-					    (pAd, fOP_STATUS_RECEIVE_DTIM)
-					    && (TbttNumToNextWakeUp > NextDtim))
-						TbttNumToNextWakeUp = NextDtim;
-
-					RTMP_SET_PSM_BIT(pAd, PWR_SAVE);
-					/* if WMM-APSD is failed, try to disable following line */
-					AsicSleepThenAutoWakeup(pAd,
-								TbttNumToNextWakeUp);
-				}
-			}
-
-			if ((pHeader->FC.MoreData)
-			    && (pAd->CommonCfg.bInServicePeriod)) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("Sending another trigger frame when More Data bit is set to 1\n"));
-			}
-		}
-		/* Drop NULL, CF-ACK(no data), CF-POLL(no data), and CF-ACK+CF-POLL(no data) data frame */
-		if ((pHeader->FC.SubType & 0x04))	/* bit 2 : no DATA */
-		{
-			/* release packet */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-			return;
-		}
-		/* Drop not my BSS frame (we can not only check the MyBss bit in RxD) */
-
-		if (INFRA_ON(pAd)) {
-			/* Infrastructure mode, check address 2 for BSSID */
-			if (!RTMPEqualMemory
-			    (&pHeader->Addr2, &pAd->CommonCfg.Bssid, 6)) {
-				/* Receive frame not my BSSID */
-				/* release packet */
-				RELEASE_NDIS_PACKET(pAd, pRxPacket,
-						    NDIS_STATUS_FAILURE);
-				return;
-			}
-		} else		/* Ad-Hoc mode or Not associated */
-		{
-			/* Ad-Hoc mode, check address 3 for BSSID */
-			if (!RTMPEqualMemory
-			    (&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6)) {
-				/* Receive frame not my BSSID */
-				/* release packet */
-				RELEASE_NDIS_PACKET(pAd, pRxPacket,
-						    NDIS_STATUS_FAILURE);
-				return;
-			}
-		}
-
-		/* */
-		/* find pEntry */
-		/* */
-		if (pRxWI->WirelessCliID < MAX_LEN_OF_MAC_TABLE) {
-			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
-		} else {
-			/* 1. release packet if infra mode */
-			/* 2. new a pEntry if ad-hoc mode */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-			return;
-		}
-
-		/* infra or ad-hoc */
-		if (INFRA_ON(pAd)) {
-			RX_BLK_SET_FLAG(pRxBlk, fRX_INFRA);
-			ASSERT(pRxWI->WirelessCliID == BSSID_WCID);
-		}
-		/* check Atheros Client */
-		if ((pEntry->bIAmBadAtheros == FALSE) && (pRxD->AMPDU == 1)
-		    && (pHeader->FC.Retry)) {
-			pEntry->bIAmBadAtheros = TRUE;
-			pAd->CommonCfg.IOTestParm.bCurrentAtheros = TRUE;
-			pAd->CommonCfg.IOTestParm.bLastAtheros = TRUE;
-			if (!STA_AES_ON(pAd)) {
-				AsicUpdateProtect(pAd, 8, ALLN_SETPROTECT, TRUE,
-						  FALSE);
-			}
-		}
-	}
-
-	pRxBlk->pData = (u8 *) pHeader;
-
-	/* */
-	/* update RxBlk->pData, DataSize */
-	/* 802.11 Header, QOS, HTC, Hw Padding */
-	/* */
-
-	/* 1. skip 802.11 HEADER */
-	{
-		pRxBlk->pData += LENGTH_802_11;
-		pRxBlk->DataSize -= LENGTH_802_11;
-	}
-
-	/* 2. QOS */
-	if (pHeader->FC.SubType & 0x08) {
-		RX_BLK_SET_FLAG(pRxBlk, fRX_QOS);
-		UserPriority = *(pRxBlk->pData) & 0x0f;
-		/* bit 7 in QoS Control field signals the HT A-MSDU format */
-		if ((*pRxBlk->pData) & 0x80) {
-			RX_BLK_SET_FLAG(pRxBlk, fRX_AMSDU);
-		}
-		/* skip QOS contorl field */
-		pRxBlk->pData += 2;
-		pRxBlk->DataSize -= 2;
-	}
-	pRxBlk->UserPriority = UserPriority;
-
-	/* check if need to resend PS Poll when received packet with MoreData = 1 */
-	if ((pAd->StaCfg.Psm == PWR_SAVE) && (pHeader->FC.MoreData == 1)) {
-		if ((((UserPriority == 0) || (UserPriority == 3)) &&
-		     pAd->CommonCfg.bAPSDAC_BE == 0) ||
-		    (((UserPriority == 1) || (UserPriority == 2)) &&
-		     pAd->CommonCfg.bAPSDAC_BK == 0) ||
-		    (((UserPriority == 4) || (UserPriority == 5)) &&
-		     pAd->CommonCfg.bAPSDAC_VI == 0) ||
-		    (((UserPriority == 6) || (UserPriority == 7)) &&
-		     pAd->CommonCfg.bAPSDAC_VO == 0)) {
-			/* non-UAPSD delivery-enabled AC */
-			RTMP_PS_POLL_ENQUEUE(pAd);
-		}
-	}
-	/* 3. Order bit: A-Ralink or HTC+ */
-	if (pHeader->FC.Order) {
-#ifdef AGGREGATION_SUPPORT
-		if ((pRxWI->PHYMODE <= MODE_OFDM)
-		    && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)))
-		{
-			RX_BLK_SET_FLAG(pRxBlk, fRX_ARALINK);
-		} else
-#endif /* AGGREGATION_SUPPORT // */
-		{
-			RX_BLK_SET_FLAG(pRxBlk, fRX_HTC);
-			/* skip HTC contorl field */
-			pRxBlk->pData += 4;
-			pRxBlk->DataSize -= 4;
-		}
-	}
-	/* 4. skip HW padding */
-	if (pRxD->L2PAD) {
-		/* just move pData pointer */
-		/* because DataSize excluding HW padding */
-		RX_BLK_SET_FLAG(pRxBlk, fRX_PAD);
-		pRxBlk->pData += 2;
-	}
-
-	if (pRxD->BA) {
-		RX_BLK_SET_FLAG(pRxBlk, fRX_AMPDU);
-	}
-	/* */
-	/* Case I  Process Broadcast & Multicast data frame */
-	/* */
-	if (pRxD->Bcast || pRxD->Mcast) {
-		INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
-
-		/* Drop Mcast/Bcast frame with fragment bit on */
-		if (pHeader->FC.MoreFrag) {
-			/* release packet */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-			return;
-		}
-		/* Filter out Bcast frame which AP relayed for us */
-		if (pHeader->FC.FrDs
-		    && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress)) {
-			/* release packet */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-			return;
-		}
-
-		Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
-		return;
-	} else if (pRxD->U2M) {
-		pAd->LastRxRate =
-		    (u16)((pRxWI->MCS) + (pRxWI->BW << 7) +
-			      (pRxWI->ShortGI << 8) + (pRxWI->PHYMODE << 14));
-
-		if (ADHOC_ON(pAd)) {
-			pEntry = MacTableLookup(pAd, pHeader->Addr2);
-			if (pEntry)
-				Update_Rssi_Sample(pAd, &pEntry->RssiSample,
-						   pRxWI);
-		}
-
-		Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
-
-		pAd->StaCfg.LastSNR0 = (u8)(pRxWI->SNR0);
-		pAd->StaCfg.LastSNR1 = (u8)(pRxWI->SNR1);
-
-		pAd->RalinkCounters.OneSecRxOkDataCnt++;
-
-		if (!((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == 0))) {
-			/* re-assemble the fragmented packets */
-			/* return complete frame (pRxPacket) or NULL */
-			bFragment = TRUE;
-			pRxPacket = RTMPDeFragmentDataFrame(pAd, pRxBlk);
-		}
-
-		if (pRxPacket) {
-			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
-
-			/* process complete frame */
-			if (bFragment && (pRxD->Decrypted)
-			    && (pEntry->WepStatus ==
-				Ndis802_11Encryption2Enabled)) {
-				/* Minus MIC length */
-				pRxBlk->DataSize -= 8;
-
-				/* For TKIP frame, calculate the MIC value */
-				if (STACheckTkipMICValue(pAd, pEntry, pRxBlk) ==
-				    FALSE) {
-					return;
-				}
-			}
-
-			STARxDataFrameAnnounce(pAd, pEntry, pRxBlk,
-					       FromWhichBSSID);
-			return;
-		} else {
-			/* just return */
-			/* because RTMPDeFragmentDataFrame() will release rx packet, */
-			/* if packet is fragmented */
-			return;
-		}
-	}
-
-	ASSERT(0);
-	/* release packet */
-	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
-}
-
-void STAHandleRxMgmtFrame(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk)
-{
-	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
-	struct rt_rxwi * pRxWI = pRxBlk->pRxWI;
-	struct rt_header_802_11 * pHeader = pRxBlk->pHeader;
-	void *pRxPacket = pRxBlk->pRxPacket;
-
-	do {
-
-		/* check if need to resend PS Poll when received packet with MoreData = 1 */
-		if ((pAd->StaCfg.Psm == PWR_SAVE)
-		    && (pHeader->FC.MoreData == 1)) {
-			/* for UAPSD, all management frames will be VO priority */
-			if (pAd->CommonCfg.bAPSDAC_VO == 0) {
-				/* non-UAPSD delivery-enabled AC */
-				RTMP_PS_POLL_ENQUEUE(pAd);
-			}
-		}
-
-		/* TODO: if MoreData == 0, station can go to sleep */
-
-		/* We should collect RSSI not only U2M data but also my beacon */
-		if ((pHeader->FC.SubType == SUBTYPE_BEACON)
-		    && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2))
-		    && (pAd->RxAnt.EvaluatePeriod == 0)) {
-			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
-
-			pAd->StaCfg.LastSNR0 = (u8)(pRxWI->SNR0);
-			pAd->StaCfg.LastSNR1 = (u8)(pRxWI->SNR1);
-		}
-
-		/* First check the size, it MUST not exceed the mlme queue size */
-		if (pRxWI->MPDUtotalByteCount > MGMT_DMA_BUFFER_SIZE) {
-			DBGPRINT_ERR("STAHandleRxMgmtFrame: frame too large, size = %d \n", pRxWI->MPDUtotalByteCount);
-			break;
-		}
-
-		REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID, pHeader,
-					  pRxWI->MPDUtotalByteCount,
-					  pRxWI->RSSI0, pRxWI->RSSI1,
-					  pRxWI->RSSI2, pRxD->PlcpSignal);
-	} while (FALSE);
-
-	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_SUCCESS);
-}
-
-void STAHandleRxControlFrame(struct rt_rtmp_adapter *pAd, struct rt_rx_blk *pRxBlk)
-{
-	struct rt_rxwi * pRxWI = pRxBlk->pRxWI;
-	struct rt_header_802_11 * pHeader = pRxBlk->pHeader;
-	void *pRxPacket = pRxBlk->pRxPacket;
-
-	switch (pHeader->FC.SubType) {
-	case SUBTYPE_BLOCK_ACK_REQ:
-		{
-			CntlEnqueueForRecv(pAd, pRxWI->WirelessCliID,
-					   (pRxWI->MPDUtotalByteCount),
-					   (struct rt_frame_ba_req *) pHeader);
-		}
-		break;
-	case SUBTYPE_BLOCK_ACK:
-	case SUBTYPE_ACK:
-	default:
-		break;
-	}
-
-	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process RxDone interrupt, running in DPC level
-
-	Arguments:
-		pAd Pointer to our adapter
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-		This routine has to maintain Rx ring read pointer.
-		Need to consider QOS DATA format when converting to 802.3
-	========================================================================
-*/
-BOOLEAN STARxDoneInterruptHandle(struct rt_rtmp_adapter *pAd, IN BOOLEAN argc)
-{
-	int Status;
-	u32 RxProcessed, RxPending;
-	BOOLEAN bReschedule = FALSE;
-	PRT28XX_RXD_STRUC pRxD;
-	u8 *pData;
-	struct rt_rxwi * pRxWI;
-	void *pRxPacket;
-	struct rt_header_802_11 * pHeader;
-	struct rt_rx_blk RxCell;
-
-	RxProcessed = RxPending = 0;
-
-	/* process whole rx ring */
-	while (1) {
-
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF |
-				   fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				   fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				   fRTMP_ADAPTER_NIC_NOT_EXIST) ||
-		    !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
-			break;
-		}
-#ifdef RTMP_MAC_PCI
-		if (RxProcessed++ > MAX_RX_PROCESS_CNT) {
-			/* need to reschedule rx handle */
-			bReschedule = TRUE;
-			break;
-		}
-#endif /* RTMP_MAC_PCI // */
-
-		RxProcessed++;	/* test */
-
-		/* 1. allocate a new data packet into rx ring to replace received packet */
-		/*    then processing the received packet */
-		/* 2. the callee must take charge of release of packet */
-		/* 3. As far as driver is concerned , */
-		/*    the rx packet must */
-		/*      a. be indicated to upper layer or */
-		/*      b. be released if it is discarded */
-		pRxPacket =
-		    GetPacketFromRxRing(pAd, &(RxCell.RxD), &bReschedule,
-					&RxPending);
-		if (pRxPacket == NULL) {
-			/* no more packet to process */
-			break;
-		}
-		/* get rx ring descriptor */
-		pRxD = &(RxCell.RxD);
-		/* get rx data buffer */
-		pData = GET_OS_PKT_DATAPTR(pRxPacket);
-		pRxWI = (struct rt_rxwi *) pData;
-		pHeader = (struct rt_header_802_11 *) (pData + RXWI_SIZE);
-
-		/* build RxCell */
-		RxCell.pRxWI = pRxWI;
-		RxCell.pHeader = pHeader;
-		RxCell.pRxPacket = pRxPacket;
-		RxCell.pData = (u8 *) pHeader;
-		RxCell.DataSize = pRxWI->MPDUtotalByteCount;
-		RxCell.Flags = 0;
-
-		/* Increase Total receive byte counter after real data received no mater any error or not */
-		pAd->RalinkCounters.ReceivedByteCount +=
-		    pRxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.OneSecReceivedByteCount +=
-		    pRxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.RxCount++;
-
-		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
-
-		if (pRxWI->MPDUtotalByteCount < 14)
-			Status = NDIS_STATUS_FAILURE;
-
-		if (MONITOR_ON(pAd)) {
-			send_monitor_packets(pAd, &RxCell);
-			break;
-		}
-
-		/* STARxDoneInterruptHandle() is called in rtusb_bulk.c */
-
-		/* Check for all RxD errors */
-		Status = RTMPCheckRxError(pAd, pHeader, pRxWI, pRxD);
-
-		/* Handle the received frame */
-		if (Status == NDIS_STATUS_SUCCESS) {
-			switch (pHeader->FC.Type) {
-				/* CASE I, receive a DATA frame */
-			case BTYPE_DATA:
-				{
-					/* process DATA frame */
-					STAHandleRxDataFrame(pAd, &RxCell);
-				}
-				break;
-				/* CASE II, receive a MGMT frame */
-			case BTYPE_MGMT:
-				{
-					STAHandleRxMgmtFrame(pAd, &RxCell);
-				}
-				break;
-				/* CASE III. receive a CNTL frame */
-			case BTYPE_CNTL:
-				{
-					STAHandleRxControlFrame(pAd, &RxCell);
-				}
-				break;
-				/* discard other type */
-			default:
-				RELEASE_NDIS_PACKET(pAd, pRxPacket,
-						    NDIS_STATUS_FAILURE);
-				break;
-			}
-		} else {
-			pAd->Counters8023.RxErrors++;
-			/* discard this frame */
-			RELEASE_NDIS_PACKET(pAd, pRxPacket,
-					    NDIS_STATUS_FAILURE);
-		}
-	}
-
-	return bReschedule;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	Arguments:
-		pAd 	Pointer to our adapter
-
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-void RTMPHandleTwakeupInterrupt(struct rt_rtmp_adapter *pAd)
-{
-	AsicForceWakeup(pAd, FALSE);
-}
-
-/*
-========================================================================
-Routine Description:
-    Early checking and OS-depened parsing for Tx packet send to our STA driver.
-
-Arguments:
-    void *	MiniportAdapterContext	Pointer refer to the device handle, i.e., the pAd.
-	void **	ppPacketArray			The packet array need to do transmission.
-	u32			NumberOfPackets			Number of packet in packet array.
-
-Return Value:
-	NONE
-
-Note:
-	This function does early checking and classification for send-out packet.
-	You only can put OS-depened & STA related code in here.
-========================================================================
-*/
-void STASendPackets(void *MiniportAdapterContext,
-		    void **ppPacketArray, u32 NumberOfPackets)
-{
-	u32 Index;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)MiniportAdapterContext;
-	void *pPacket;
-	BOOLEAN allowToSend = FALSE;
-
-	for (Index = 0; Index < NumberOfPackets; Index++) {
-		pPacket = ppPacketArray[Index];
-
-		do {
-			if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)
-			    || RTMP_TEST_FLAG(pAd,
-					      fRTMP_ADAPTER_HALT_IN_PROGRESS)
-			    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) {
-				/* Drop send request since hardware is in reset state */
-				break;
-			} else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd)) {
-				/* Drop send request since there are no physical connection yet */
-				break;
-			} else {
-				/* Record that orignal packet source is from NDIS layer,so that */
-				/* later on driver knows how to release this NDIS PACKET */
-				RTMP_SET_PACKET_WCID(pPacket, 0);	/* this field is useless when in STA mode */
-				RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-				NDIS_SET_PACKET_STATUS(pPacket,
-						       NDIS_STATUS_PENDING);
-				pAd->RalinkCounters.PendingNdisPacketCount++;
-
-				allowToSend = TRUE;
-			}
-		} while (FALSE);
-
-		if (allowToSend == TRUE)
-			STASendPacket(pAd, pPacket);
-		else
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-	}
-
-	/* Dequeue outgoing frames from TxSwQueue[] and process it */
-	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-
-}
-
-/*
-========================================================================
-Routine Description:
-	This routine is used to do packet parsing and classification for Tx packet
-	to STA device, and it will en-queue packets to our TxSwQueue depends on AC
-	class.
-
-Arguments:
-	pAd    		Pointer to our adapter
-	pPacket 	Pointer to send packet
-
-Return Value:
-	NDIS_STATUS_SUCCESS			If success to queue the packet into TxSwQueue.
-	NDIS_STATUS_FAILURE			If failed to do en-queue.
-
-Note:
-	You only can put OS-indepened & STA related code in here.
-========================================================================
-*/
-int STASendPacket(struct rt_rtmp_adapter *pAd, void *pPacket)
-{
-	struct rt_packet_info PacketInfo;
-	u8 *pSrcBufVA;
-	u32 SrcBufLen;
-	u32 AllowFragSize;
-	u8 NumberOfFrag;
-	u8 RTSRequired;
-	u8 QueIdx, UserPriority;
-	struct rt_mac_table_entry *pEntry = NULL;
-	unsigned int IrqFlags;
-	u8 FlgIsIP = 0;
-	u8 Rate;
-
-	/* Prepare packet information structure for buffer descriptor */
-	/* chained within a single NDIS packet. */
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
-
-	if (pSrcBufVA == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("STASendPacket --> pSrcBufVA == NULL !SrcBufLen=%x\n",
-			  SrcBufLen));
-		/* Resource is low, system did not allocate virtual address */
-		/* return NDIS_STATUS_FAILURE directly to upper layer */
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		return NDIS_STATUS_FAILURE;
-	}
-
-	if (SrcBufLen < 14) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("STASendPacket --> Ndis Packet buffer error!\n"));
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		return (NDIS_STATUS_FAILURE);
-	}
-	/* In HT rate adhoc mode, A-MPDU is often used. So need to lookup BA Table and MAC Entry. */
-	/* Note multicast packets in adhoc also use BSSID_WCID index. */
-	{
-		if (INFRA_ON(pAd)) {
-			{
-				pEntry = &pAd->MacTab.Content[BSSID_WCID];
-				RTMP_SET_PACKET_WCID(pPacket, BSSID_WCID);
-				Rate = pAd->CommonCfg.TxRate;
-			}
-		} else if (ADHOC_ON(pAd)) {
-			if (*pSrcBufVA & 0x01) {
-				RTMP_SET_PACKET_WCID(pPacket, MCAST_WCID);
-				pEntry = &pAd->MacTab.Content[MCAST_WCID];
-			} else {
-				pEntry = MacTableLookup(pAd, pSrcBufVA);
-			}
-			Rate = pAd->CommonCfg.TxRate;
-		}
-	}
-
-	if (!pEntry) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			("STASendPacket->Cannot find pEntry(%pM) in MacTab!\n",
-				pSrcBufVA));
-		/* Resource is low, system did not allocate virtual address */
-		/* return NDIS_STATUS_FAILURE directly to upper layer */
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		return NDIS_STATUS_FAILURE;
-	}
-
-	if (ADHOC_ON(pAd)
-	    ) {
-		RTMP_SET_PACKET_WCID(pPacket, (u8)pEntry->Aid);
-	}
-	/* */
-	/* Check the Ethernet Frame type of this packet, and set the RTMP_SET_PACKET_SPECIFIC flags. */
-	/*              Here we set the PACKET_SPECIFIC flags(LLC, VLAN, DHCP/ARP, EAPOL). */
-	RTMPCheckEtherType(pAd, pPacket);
-
-	/* */
-	/* WPA 802.1x secured port control - drop all non-802.1x frame before port secured */
-	/* */
-	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-	     || (pAd->StaCfg.IEEE8021X == TRUE)
-	    )
-	    && ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
-		|| (pAd->StaCfg.MicErrCnt >= 2))
-	    && (RTMP_GET_PACKET_EAPOL(pPacket) == FALSE)
-	    ) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("STASendPacket --> Drop packet before port secured!\n"));
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-
-		return (NDIS_STATUS_FAILURE);
-	}
-
-	/* STEP 1. Decide number of fragments required to deliver this MSDU. */
-	/*         The estimation here is not very accurate because difficult to */
-	/*         take encryption overhead into consideration here. The result */
-	/*         "NumberOfFrag" is then just used to pre-check if enough free */
-	/*         TXD are available to hold this MSDU. */
-
-	if (*pSrcBufVA & 0x01)	/* fragmentation not allowed on multicast & broadcast */
-		NumberOfFrag = 1;
-	else if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED))
-		NumberOfFrag = 1;	/* Aggregation overwhelms fragmentation */
-	else if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED))
-		NumberOfFrag = 1;	/* Aggregation overwhelms fragmentation */
-	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX)
-		 || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
-		NumberOfFrag = 1;	/* MIMO RATE overwhelms fragmentation */
-	else {
-		/* The calculated "NumberOfFrag" is a rough estimation because of various */
-		/* encryption/encapsulation overhead not taken into consideration. This number is just */
-		/* used to make sure enough free TXD are available before fragmentation takes place. */
-		/* In case the actual required number of fragments of an NDIS packet */
-		/* excceeds "NumberOfFrag"caculated here and not enough free TXD available, the */
-		/* last fragment (i.e. last MPDU) will be dropped in RTMPHardTransmit() due to out of */
-		/* resource, and the NDIS packet will be indicated NDIS_STATUS_FAILURE. This should */
-		/* rarely happen and the penalty is just like a TX RETRY fail. Affordable. */
-
-		AllowFragSize =
-		    (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 -
-		    LENGTH_CRC;
-		NumberOfFrag =
-		    ((PacketInfo.TotalPacketLength - LENGTH_802_3 +
-		      LENGTH_802_1_H) / AllowFragSize) + 1;
-		/* To get accurate number of fragmentation, Minus 1 if the size just match to allowable fragment size */
-		if (((PacketInfo.TotalPacketLength - LENGTH_802_3 +
-		      LENGTH_802_1_H) % AllowFragSize) == 0) {
-			NumberOfFrag--;
-		}
-	}
-
-	/* Save fragment number to Ndis packet reserved field */
-	RTMP_SET_PACKET_FRAGMENTS(pPacket, NumberOfFrag);
-
-	/* STEP 2. Check the requirement of RTS: */
-	/*         If multiple fragment required, RTS is required only for the first fragment */
-	/*         if the fragment size is larger than RTS threshold */
-	/*     For RT28xx, Let ASIC send RTS/CTS */
-	/*      RTMP_SET_PACKET_RTS(pPacket, 0); */
-	if (NumberOfFrag > 1)
-		RTSRequired =
-		    (pAd->CommonCfg.FragmentThreshold >
-		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
-	else
-		RTSRequired =
-		    (PacketInfo.TotalPacketLength >
-		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
-
-	/* Save RTS requirement to Ndis packet reserved field */
-	RTMP_SET_PACKET_RTS(pPacket, RTSRequired);
-	RTMP_SET_PACKET_TXRATE(pPacket, pAd->CommonCfg.TxRate);
-
-	/* */
-	/* STEP 3. Traffic classification. outcome = <UserPriority, QueIdx> */
-	/* */
-	UserPriority = 0;
-	QueIdx = QID_AC_BE;
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) &&
-	    CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE)) {
-		u16 Protocol;
-		u8 LlcSnapLen = 0, Byte0, Byte1;
-		do {
-			/* get Ethernet protocol field */
-			Protocol =
-			    (u16)((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
-			if (Protocol <= 1500) {
-				/* get Ethernet protocol field from LLC/SNAP */
-				if (Sniff2BytesFromNdisBuffer
-				    (PacketInfo.pFirstBuffer, LENGTH_802_3 + 6,
-				     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
-					break;
-
-				Protocol = (u16)((Byte0 << 8) + Byte1);
-				LlcSnapLen = 8;
-			}
-			/* always AC_BE for non-IP packet */
-			if (Protocol != 0x0800)
-				break;
-
-			/* get IP header */
-			if (Sniff2BytesFromNdisBuffer
-			    (PacketInfo.pFirstBuffer, LENGTH_802_3 + LlcSnapLen,
-			     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
-				break;
-
-			/* return AC_BE if packet is not IPv4 */
-			if ((Byte0 & 0xf0) != 0x40)
-				break;
-
-			FlgIsIP = 1;
-			UserPriority = (Byte1 & 0xe0) >> 5;
-			QueIdx = MapUserPriorityToAccessCategory[UserPriority];
-
-			/* TODO: have to check ACM bit. apply TSPEC if ACM is ON */
-			/* TODO: downgrade UP & QueIdx before passing ACM */
-			/*
-			   Under WMM ACM control, we dont need to check the bit;
-			   Or when a TSPEC is built for VO but we will change to issue
-			   BA session for BE here, so we will not use BA to send VO packets.
-			 */
-			if (pAd->CommonCfg.APEdcaParm.bACM[QueIdx]) {
-				UserPriority = 0;
-				QueIdx = QID_AC_BE;
-			}
-		} while (FALSE);
-	}
-
-	RTMP_SET_PACKET_UP(pPacket, UserPriority);
-
-	/* Make sure SendTxWait queue resource won't be used by other threads */
-	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-	if (pAd->TxSwQueue[QueIdx].Number >= MAX_PACKETS_IN_QUEUE) {
-		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-
-		return NDIS_STATUS_FAILURE;
-	} else {
-		InsertTailQueueAc(pAd, pEntry, &pAd->TxSwQueue[QueIdx],
-				  PACKET_TO_QUEUE_ENTRY(pPacket));
-	}
-	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-
-	if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE) &&
-	    IS_HT_STA(pEntry)) {
-		/*struct rt_mac_table_entry *pMacEntry = &pAd->MacTab.Content[BSSID_WCID]; */
-		if (((pEntry->TXBAbitmap & (1 << UserPriority)) == 0) &&
-		    ((pEntry->BADeclineBitmap & (1 << UserPriority)) == 0) &&
-		    (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
-		    /* For IOT compatibility, if */
-		    /* 1. It is Ralink chip or */
-		    /* 2. It is OPEN or AES mode, */
-		    /* then BA session can be bulit. */
-		    && ((pEntry->ValidAsCLI && pAd->MlmeAux.APRalinkIe != 0x0)
-			|| (pEntry->WepStatus != Ndis802_11WEPEnabled
-			    && pEntry->WepStatus !=
-			    Ndis802_11Encryption2Enabled))
-		    ) {
-			BAOriSessionSetUp(pAd, pEntry, UserPriority, 0, 10,
-					  FALSE);
-		}
-	}
-
-	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;	/* TODO: for debug only. to be removed */
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		This subroutine will scan through relative ring descriptor to find
-		out available free ring descriptor and compare with request size.
-
-	Arguments:
-		pAd Pointer to our adapter
-		QueIdx		Selected TX Ring
-
-	Return Value:
-		NDIS_STATUS_FAILURE 	Not enough free descriptor
-		NDIS_STATUS_SUCCESS 	Enough free descriptor
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-#ifdef RTMP_MAC_PCI
-int RTMPFreeTXDRequest(struct rt_rtmp_adapter *pAd,
-			       u8 QueIdx,
-			       u8 NumberRequired, u8 *FreeNumberIs)
-{
-	unsigned long FreeNumber = 0;
-	int Status = NDIS_STATUS_FAILURE;
-
-	switch (QueIdx) {
-	case QID_AC_BK:
-	case QID_AC_BE:
-	case QID_AC_VI:
-	case QID_AC_VO:
-		if (pAd->TxRing[QueIdx].TxSwFreeIdx >
-		    pAd->TxRing[QueIdx].TxCpuIdx)
-			FreeNumber =
-			    pAd->TxRing[QueIdx].TxSwFreeIdx -
-			    pAd->TxRing[QueIdx].TxCpuIdx - 1;
-		else
-			FreeNumber =
-			    pAd->TxRing[QueIdx].TxSwFreeIdx + TX_RING_SIZE -
-			    pAd->TxRing[QueIdx].TxCpuIdx - 1;
-
-		if (FreeNumber >= NumberRequired)
-			Status = NDIS_STATUS_SUCCESS;
-		break;
-
-	case QID_MGMT:
-		if (pAd->MgmtRing.TxSwFreeIdx > pAd->MgmtRing.TxCpuIdx)
-			FreeNumber =
-			    pAd->MgmtRing.TxSwFreeIdx - pAd->MgmtRing.TxCpuIdx -
-			    1;
-		else
-			FreeNumber =
-			    pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE -
-			    pAd->MgmtRing.TxCpuIdx - 1;
-
-		if (FreeNumber >= NumberRequired)
-			Status = NDIS_STATUS_SUCCESS;
-		break;
-
-	default:
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
-		break;
-	}
-	*FreeNumberIs = (u8)FreeNumber;
-
-	return (Status);
-}
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-/*
-	Actually, this function used to check if the TxHardware Queue still has frame need to send.
-	If no frame need to send, go to sleep, else, still wake up.
-*/
-int RTMPFreeTXDRequest(struct rt_rtmp_adapter *pAd,
-			       u8 QueIdx,
-			       u8 NumberRequired, u8 *FreeNumberIs)
-{
-	/*unsigned long         FreeNumber = 0; */
-	int Status = NDIS_STATUS_FAILURE;
-	unsigned long IrqFlags;
-	struct rt_ht_tx_context *pHTTXContext;
-
-	switch (QueIdx) {
-	case QID_AC_BK:
-	case QID_AC_BE:
-	case QID_AC_VI:
-	case QID_AC_VO:
-		{
-			pHTTXContext = &pAd->TxContext[QueIdx];
-			RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx],
-				      IrqFlags);
-			if ((pHTTXContext->CurWritePosition !=
-			     pHTTXContext->ENextBulkOutPosition)
-			    || (pHTTXContext->IRPPending == TRUE)) {
-				Status = NDIS_STATUS_FAILURE;
-			} else {
-				Status = NDIS_STATUS_SUCCESS;
-			}
-			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
-					IrqFlags);
-		}
-		break;
-	case QID_MGMT:
-		if (pAd->MgmtRing.TxSwFreeIdx != MGMT_RING_SIZE)
-			Status = NDIS_STATUS_FAILURE;
-		else
-			Status = NDIS_STATUS_SUCCESS;
-		break;
-	default:
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
-		break;
-	}
-
-	return (Status);
-}
-#endif /* RTMP_MAC_USB // */
-
-void RTMPSendDisassociationFrame(struct rt_rtmp_adapter *pAd)
-{
-}
-
-void RTMPSendNullFrame(struct rt_rtmp_adapter *pAd,
-		       u8 TxRate, IN BOOLEAN bQosNull)
-{
-	u8 NullFrame[48];
-	unsigned long Length;
-	struct rt_header_802_11 * pHeader_802_11;
-
-	/* WPA 802.1x secured port control */
-	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-	     || (pAd->StaCfg.IEEE8021X == TRUE)
-	    ) && (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
-		return;
-	}
-
-	NdisZeroMemory(NullFrame, 48);
-	Length = sizeof(struct rt_header_802_11);
-
-	pHeader_802_11 = (struct rt_header_802_11 *) NullFrame;
-
-	pHeader_802_11->FC.Type = BTYPE_DATA;
-	pHeader_802_11->FC.SubType = SUBTYPE_NULL_FUNC;
-	pHeader_802_11->FC.ToDs = 1;
-	COPY_MAC_ADDR(pHeader_802_11->Addr1, pAd->CommonCfg.Bssid);
-	COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
-	COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->CommonCfg.Bssid);
-
-	if (pAd->CommonCfg.bAPSDForcePowerSave) {
-		pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
-	} else {
-		pHeader_802_11->FC.PwrMgmt =
-		    (pAd->StaCfg.Psm == PWR_SAVE) ? 1 : 0;
-	}
-	pHeader_802_11->Duration =
-	    pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
-
-	pAd->Sequence++;
-	pHeader_802_11->Sequence = pAd->Sequence;
-
-	/* Prepare QosNull function frame */
-	if (bQosNull) {
-		pHeader_802_11->FC.SubType = SUBTYPE_QOS_NULL;
-
-		/* copy QOS control bytes */
-		NullFrame[Length] = 0;
-		NullFrame[Length + 1] = 0;
-		Length += 2;	/* if pad with 2 bytes for alignment, APSD will fail */
-	}
-
-	HAL_KickOutNullFrameTx(pAd, 0, NullFrame, Length);
-
-}
-
-/* IRQL = DISPATCH_LEVEL */
-void RTMPSendRTSFrame(struct rt_rtmp_adapter *pAd,
-		      u8 *pDA,
-		      IN unsigned int NextMpduSize,
-		      u8 TxRate,
-		      u8 RTSRate,
-		      u16 AckDuration, u8 QueIdx, u8 FrameGap)
-{
-}
-
-/* -------------------------------------------------------- */
-/*  FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM */
-/*              Find the WPA key, either Group or Pairwise Key */
-/*              LEAP + TKIP also use WPA key. */
-/* -------------------------------------------------------- */
-/* Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst */
-/* In Cisco CCX 2.0 Leap Authentication */
-/*                 WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey */
-/*                 Instead of the SharedKey, SharedKey Length may be Zero. */
-void STAFindCipherAlgorithm(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	NDIS_802_11_ENCRYPTION_STATUS Cipher;	/* To indicate cipher used for this packet */
-	u8 CipherAlg = CIPHER_NONE;	/* cipher alogrithm */
-	u8 KeyIdx = 0xff;
-	u8 *pSrcBufVA;
-	struct rt_cipher_key *pKey = NULL;
-
-	pSrcBufVA = GET_OS_PKT_DATAPTR(pTxBlk->pPacket);
-
-	{
-		/* Select Cipher */
-		if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))
-			Cipher = pAd->StaCfg.GroupCipher;	/* Cipher for Multicast or Broadcast */
-		else
-			Cipher = pAd->StaCfg.PairCipher;	/* Cipher for Unicast */
-
-		if (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket)) {
-			ASSERT(pAd->SharedKey[BSS0][0].CipherAlg <=
-			       CIPHER_CKIP128);
-
-			/* 4-way handshaking frame must be clear */
-			if (!(TX_BLK_TEST_FLAG(pTxBlk, fTX_bClearEAPFrame))
-			    && (pAd->SharedKey[BSS0][0].CipherAlg)
-			    && (pAd->SharedKey[BSS0][0].KeyLen)) {
-				CipherAlg = pAd->SharedKey[BSS0][0].CipherAlg;
-				KeyIdx = 0;
-			}
-		} else if (Cipher == Ndis802_11Encryption1Enabled) {
-			KeyIdx = pAd->StaCfg.DefaultKeyId;
-		} else if ((Cipher == Ndis802_11Encryption2Enabled) ||
-			   (Cipher == Ndis802_11Encryption3Enabled)) {
-			if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))	/* multicast */
-				KeyIdx = pAd->StaCfg.DefaultKeyId;
-			else if (pAd->SharedKey[BSS0][0].KeyLen)
-				KeyIdx = 0;
-			else
-				KeyIdx = pAd->StaCfg.DefaultKeyId;
-		}
-
-		if (KeyIdx == 0xff)
-			CipherAlg = CIPHER_NONE;
-		else if ((Cipher == Ndis802_11EncryptionDisabled)
-			 || (pAd->SharedKey[BSS0][KeyIdx].KeyLen == 0))
-			CipherAlg = CIPHER_NONE;
-		else if (pAd->StaCfg.WpaSupplicantUP &&
-			 (Cipher == Ndis802_11Encryption1Enabled) &&
-			 (pAd->StaCfg.IEEE8021X == TRUE) &&
-			 (pAd->StaCfg.PortSecured ==
-			  WPA_802_1X_PORT_NOT_SECURED))
-			CipherAlg = CIPHER_NONE;
-		else {
-			/*Header_802_11.FC.Wep = 1; */
-			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
-			pKey = &pAd->SharedKey[BSS0][KeyIdx];
-		}
-	}
-
-	pTxBlk->CipherAlg = CipherAlg;
-	pTxBlk->pKey = pKey;
-}
-
-void STABuildCommon802_11Header(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	struct rt_header_802_11 *pHeader_802_11;
-
-	/* */
-	/* MAKE A COMMON 802.11 HEADER */
-	/* */
-
-	/* normal wlan header size : 24 octets */
-	pTxBlk->MpduHeaderLen = sizeof(struct rt_header_802_11);
-
-	pHeader_802_11 =
-	    (struct rt_header_802_11 *) & pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-
-	NdisZeroMemory(pHeader_802_11, sizeof(struct rt_header_802_11));
-
-	pHeader_802_11->FC.FrDs = 0;
-	pHeader_802_11->FC.Type = BTYPE_DATA;
-	pHeader_802_11->FC.SubType =
-	    ((TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) ? SUBTYPE_QDATA :
-	     SUBTYPE_DATA);
-
-	if (pTxBlk->pMacEntry) {
-		if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bForceNonQoS)) {
-			pHeader_802_11->Sequence =
-			    pTxBlk->pMacEntry->NonQosDataSeq;
-			pTxBlk->pMacEntry->NonQosDataSeq =
-			    (pTxBlk->pMacEntry->NonQosDataSeq + 1) & MAXSEQ;
-		} else {
-			{
-				pHeader_802_11->Sequence =
-				    pTxBlk->pMacEntry->TxSeq[pTxBlk->
-							     UserPriority];
-				pTxBlk->pMacEntry->TxSeq[pTxBlk->UserPriority] =
-				    (pTxBlk->pMacEntry->
-				     TxSeq[pTxBlk->UserPriority] + 1) & MAXSEQ;
-			}
-		}
-	} else {
-		pHeader_802_11->Sequence = pAd->Sequence;
-		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	/* next sequence */
-	}
-
-	pHeader_802_11->Frag = 0;
-
-	pHeader_802_11->FC.MoreData = TX_BLK_TEST_FLAG(pTxBlk, fTX_bMoreData);
-
-	{
-		if (INFRA_ON(pAd)) {
-			{
-				COPY_MAC_ADDR(pHeader_802_11->Addr1,
-					      pAd->CommonCfg.Bssid);
-				COPY_MAC_ADDR(pHeader_802_11->Addr2,
-					      pAd->CurrentAddress);
-				COPY_MAC_ADDR(pHeader_802_11->Addr3,
-					      pTxBlk->pSrcBufHeader);
-				pHeader_802_11->FC.ToDs = 1;
-			}
-		} else if (ADHOC_ON(pAd)) {
-			COPY_MAC_ADDR(pHeader_802_11->Addr1,
-				      pTxBlk->pSrcBufHeader);
-			COPY_MAC_ADDR(pHeader_802_11->Addr2,
-				      pAd->CurrentAddress);
-			COPY_MAC_ADDR(pHeader_802_11->Addr3,
-				      pAd->CommonCfg.Bssid);
-			pHeader_802_11->FC.ToDs = 0;
-		}
-	}
-
-	if (pTxBlk->CipherAlg != CIPHER_NONE)
-		pHeader_802_11->FC.Wep = 1;
-
-	/* ----------------------------------------------------------------- */
-	/* STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later. */
-	/* ----------------------------------------------------------------- */
-	if (pAd->CommonCfg.bAPSDForcePowerSave)
-		pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
-	else
-		pHeader_802_11->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
-}
-
-void STABuildCache802_11Header(struct rt_rtmp_adapter *pAd,
-			       struct rt_tx_blk *pTxBlk, u8 * pHeader)
-{
-	struct rt_mac_table_entry *pMacEntry;
-	struct rt_header_802_11 * pHeader80211;
-
-	pHeader80211 = (struct rt_header_802_11 *) pHeader;
-	pMacEntry = pTxBlk->pMacEntry;
-
-	/* */
-	/* Update the cached 802.11 HEADER */
-	/* */
-
-	/* normal wlan header size : 24 octets */
-	pTxBlk->MpduHeaderLen = sizeof(struct rt_header_802_11);
-
-	/* More Bit */
-	pHeader80211->FC.MoreData = TX_BLK_TEST_FLAG(pTxBlk, fTX_bMoreData);
-
-	/* Sequence */
-	pHeader80211->Sequence = pMacEntry->TxSeq[pTxBlk->UserPriority];
-	pMacEntry->TxSeq[pTxBlk->UserPriority] =
-	    (pMacEntry->TxSeq[pTxBlk->UserPriority] + 1) & MAXSEQ;
-
-	{
-		/* Check if the frame can be sent through DLS direct link interface */
-		/* If packet can be sent through DLS, then force aggregation disable. (Hard to determine peer STA's capability) */
-
-		/* The addr3 of normal packet send from DS is Dest Mac address. */
-		if (ADHOC_ON(pAd))
-			COPY_MAC_ADDR(pHeader80211->Addr3,
-				      pAd->CommonCfg.Bssid);
-		else
-			COPY_MAC_ADDR(pHeader80211->Addr3,
-				      pTxBlk->pSrcBufHeader);
-	}
-
-	/* ----------------------------------------------------------------- */
-	/* STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later. */
-	/* ----------------------------------------------------------------- */
-	if (pAd->CommonCfg.bAPSDForcePowerSave)
-		pHeader80211->FC.PwrMgmt = PWR_SAVE;
-	else
-		pHeader80211->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
-}
-
-static inline u8 *STA_Build_ARalink_Frame_Header(struct rt_rtmp_adapter *pAd,
-						    struct rt_tx_blk *pTxBlk)
-{
-	u8 *pHeaderBufPtr;
-	struct rt_header_802_11 *pHeader_802_11;
-	void *pNextPacket;
-	u32 nextBufLen;
-	struct rt_queue_entry *pQEntry;
-
-	STAFindCipherAlgorithm(pAd, pTxBlk);
-	STABuildCommon802_11Header(pAd, pTxBlk);
-
-	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-	pHeader_802_11 = (struct rt_header_802_11 *) pHeaderBufPtr;
-
-	/* steal "order" bit to mark "aggregation" */
-	pHeader_802_11->FC.Order = 1;
-
-	/* skip common header */
-	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
-
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		/* */
-		/* build QOS Control bytes */
-		/* */
-		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
-
-		*(pHeaderBufPtr + 1) = 0;
-		pHeaderBufPtr += 2;
-		pTxBlk->MpduHeaderLen += 2;
-	}
-	/* padding at front of LLC header. LLC header should at 4-bytes alignment. */
-	pTxBlk->HdrPadLen = (unsigned long)pHeaderBufPtr;
-	pHeaderBufPtr = (u8 *)ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (unsigned long)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-	/* For RA Aggregation, */
-	/* put the 2nd MSDU length(extra 2-byte field) after struct rt_qos_control in little endian format */
-	pQEntry = pTxBlk->TxPacketList.Head;
-	pNextPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-	nextBufLen = GET_OS_PKT_LEN(pNextPacket);
-	if (RTMP_GET_PACKET_VLAN(pNextPacket))
-		nextBufLen -= LENGTH_802_1Q;
-
-	*pHeaderBufPtr = (u8)nextBufLen & 0xff;
-	*(pHeaderBufPtr + 1) = (u8)(nextBufLen >> 8);
-
-	pHeaderBufPtr += 2;
-	pTxBlk->MpduHeaderLen += 2;
-
-	return pHeaderBufPtr;
-
-}
-
-static inline u8 *STA_Build_AMSDU_Frame_Header(struct rt_rtmp_adapter *pAd,
-						  struct rt_tx_blk *pTxBlk)
-{
-	u8 *pHeaderBufPtr;	/*, pSaveBufPtr; */
-	struct rt_header_802_11 *pHeader_802_11;
-
-	STAFindCipherAlgorithm(pAd, pTxBlk);
-	STABuildCommon802_11Header(pAd, pTxBlk);
-
-	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-	pHeader_802_11 = (struct rt_header_802_11 *) pHeaderBufPtr;
-
-	/* skip common header */
-	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
-
-	/* */
-	/* build QOS Control bytes */
-	/* */
-	*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
-
-	/* */
-	/* A-MSDU packet */
-	/* */
-	*pHeaderBufPtr |= 0x80;
-
-	*(pHeaderBufPtr + 1) = 0;
-	pHeaderBufPtr += 2;
-	pTxBlk->MpduHeaderLen += 2;
-
-	/*pSaveBufPtr = pHeaderBufPtr; */
-
-	/* */
-	/* padding at front of LLC header */
-	/* LLC header should locate at 4-octets aligment */
-	/* */
-	/* @@@ MpduHeaderLen excluding padding @@@ */
-	/* */
-	pTxBlk->HdrPadLen = (unsigned long)pHeaderBufPtr;
-	pHeaderBufPtr = (u8 *)ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (unsigned long)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-	return pHeaderBufPtr;
-
-}
-
-void STA_AMPDU_Frame_Tx(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	struct rt_header_802_11 *pHeader_802_11;
-	u8 *pHeaderBufPtr;
-	u16 FreeNumber;
-	struct rt_mac_table_entry *pMacEntry;
-	BOOLEAN bVLANPkt;
-	struct rt_queue_entry *pQEntry;
-
-	ASSERT(pTxBlk);
-
-	while (pTxBlk->TxPacketList.Head) {
-		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
-					    NDIS_STATUS_FAILURE);
-			continue;
-		}
-
-		bVLANPkt =
-		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
-
-		pMacEntry = pTxBlk->pMacEntry;
-		if (pMacEntry->isCached) {
-			/* NOTE: Please make sure the size of pMacEntry->CachedBuf[] is smaller than pTxBlk->HeaderBuf[]! */
-			NdisMoveMemory((u8 *)& pTxBlk->
-				       HeaderBuf[TXINFO_SIZE],
-				       (u8 *)& pMacEntry->CachedBuf[0],
-				       TXWI_SIZE + sizeof(struct rt_header_802_11));
-			pHeaderBufPtr =
-			    (u8 *)(&pTxBlk->
-				      HeaderBuf[TXINFO_SIZE + TXWI_SIZE]);
-			STABuildCache802_11Header(pAd, pTxBlk, pHeaderBufPtr);
-		} else {
-			STAFindCipherAlgorithm(pAd, pTxBlk);
-			STABuildCommon802_11Header(pAd, pTxBlk);
-
-			pHeaderBufPtr =
-			    &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-		}
-
-		pHeader_802_11 = (struct rt_header_802_11 *) pHeaderBufPtr;
-
-		/* skip common header */
-		pHeaderBufPtr += pTxBlk->MpduHeaderLen;
-
-		/* */
-		/* build QOS Control bytes */
-		/* */
-		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
-		*(pHeaderBufPtr + 1) = 0;
-		pHeaderBufPtr += 2;
-		pTxBlk->MpduHeaderLen += 2;
-
-		/* */
-		/* build HTC+ */
-		/* HTC control filed following QoS field */
-		/* */
-		if ((pAd->CommonCfg.bRdg == TRUE)
-		    && CLIENT_STATUS_TEST_FLAG(pTxBlk->pMacEntry,
-					       fCLIENT_STATUS_RDG_CAPABLE)) {
-			if (pMacEntry->isCached == FALSE) {
-				/* mark HTC bit */
-				pHeader_802_11->FC.Order = 1;
-
-				NdisZeroMemory(pHeaderBufPtr, 4);
-				*(pHeaderBufPtr + 3) |= 0x80;
-			}
-			pHeaderBufPtr += 4;
-			pTxBlk->MpduHeaderLen += 4;
-		}
-		/*pTxBlk->MpduHeaderLen = pHeaderBufPtr - pTxBlk->HeaderBuf - TXWI_SIZE - TXINFO_SIZE; */
-		ASSERT(pTxBlk->MpduHeaderLen >= 24);
-
-		/* skip 802.3 header */
-		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen -= LENGTH_802_3;
-
-		/* skip vlan tag */
-		if (bVLANPkt) {
-			pTxBlk->pSrcBufData += LENGTH_802_1Q;
-			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
-		}
-		/* */
-		/* padding at front of LLC header */
-		/* LLC header should locate at 4-octets aligment */
-		/* */
-		/* @@@ MpduHeaderLen excluding padding @@@ */
-		/* */
-		pTxBlk->HdrPadLen = (unsigned long)pHeaderBufPtr;
-		pHeaderBufPtr = (u8 *)ROUND_UP(pHeaderBufPtr, 4);
-		pTxBlk->HdrPadLen = (unsigned long)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-		{
-
-			/* */
-			/* Insert LLC-SNAP encapsulation - 8 octets */
-			/* */
-			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
-							    pSrcBufData - 2,
-							    pTxBlk->
-							    pExtraLlcSnapEncap);
-			if (pTxBlk->pExtraLlcSnapEncap) {
-				NdisMoveMemory(pHeaderBufPtr,
-					       pTxBlk->pExtraLlcSnapEncap, 6);
-				pHeaderBufPtr += 6;
-				/* get 2 octets (TypeofLen) */
-				NdisMoveMemory(pHeaderBufPtr,
-					       pTxBlk->pSrcBufData - 2, 2);
-				pHeaderBufPtr += 2;
-				pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
-			}
-
-		}
-
-		if (pMacEntry->isCached) {
-			RTMPWriteTxWI_Cache(pAd,
-					    (struct rt_txwi *) (&pTxBlk->
-							   HeaderBuf
-							   [TXINFO_SIZE]),
-					    pTxBlk);
-		} else {
-			RTMPWriteTxWI_Data(pAd,
-					   (struct rt_txwi *) (&pTxBlk->
-							  HeaderBuf
-							  [TXINFO_SIZE]),
-					   pTxBlk);
-
-			NdisZeroMemory((u8 *)(&pMacEntry->CachedBuf[0]),
-				       sizeof(pMacEntry->CachedBuf));
-			NdisMoveMemory((u8 *)(&pMacEntry->CachedBuf[0]),
-				       (u8 *)(&pTxBlk->
-						 HeaderBuf[TXINFO_SIZE]),
-				       (pHeaderBufPtr -
-					(u8 *)(&pTxBlk->
-						  HeaderBuf[TXINFO_SIZE])));
-			pMacEntry->isCached = TRUE;
-		}
-
-		/* calculate Transmitted AMPDU count and ByteCount */
-		{
-			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.
-			    LowPart++;
-			pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.
-			    QuadPart += pTxBlk->SrcBufLen;
-		}
-
-		/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
-
-		HAL_WriteTxResource(pAd, pTxBlk, TRUE, &FreeNumber);
-
-		/* */
-		/* Kick out Tx */
-		/* */
-		if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-			HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
-
-		pAd->RalinkCounters.KickTxCount++;
-		pAd->RalinkCounters.OneSecTxDoneCount++;
-	}
-
-}
-
-void STA_AMSDU_Frame_Tx(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	u8 *pHeaderBufPtr;
-	u16 FreeNumber;
-	u16 subFramePayloadLen = 0;	/* AMSDU Subframe length without AMSDU-Header / Padding. */
-	u16 totalMPDUSize = 0;
-	u8 *subFrameHeader;
-	u8 padding = 0;
-	u16 FirstTx = 0, LastTxIdx = 0;
-	BOOLEAN bVLANPkt;
-	int frameNum = 0;
-	struct rt_queue_entry *pQEntry;
-
-	ASSERT(pTxBlk);
-
-	ASSERT((pTxBlk->TxPacketList.Number > 1));
-
-	while (pTxBlk->TxPacketList.Head) {
-		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
-					    NDIS_STATUS_FAILURE);
-			continue;
-		}
-
-		bVLANPkt =
-		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
-
-		/* skip 802.3 header */
-		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen -= LENGTH_802_3;
-
-		/* skip vlan tag */
-		if (bVLANPkt) {
-			pTxBlk->pSrcBufData += LENGTH_802_1Q;
-			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
-		}
-
-		if (frameNum == 0) {
-			pHeaderBufPtr =
-			    STA_Build_AMSDU_Frame_Header(pAd, pTxBlk);
-
-			/* NOTE: TxWI->MPDUtotalByteCount will be updated after final frame was handled. */
-			RTMPWriteTxWI_Data(pAd,
-					   (struct rt_txwi *) (&pTxBlk->
-							  HeaderBuf
-							  [TXINFO_SIZE]),
-					   pTxBlk);
-		} else {
-			pHeaderBufPtr = &pTxBlk->HeaderBuf[0];
-			padding =
-			    ROUND_UP(LENGTH_AMSDU_SUBFRAMEHEAD +
-				     subFramePayloadLen,
-				     4) - (LENGTH_AMSDU_SUBFRAMEHEAD +
-					   subFramePayloadLen);
-			NdisZeroMemory(pHeaderBufPtr,
-				       padding + LENGTH_AMSDU_SUBFRAMEHEAD);
-			pHeaderBufPtr += padding;
-			pTxBlk->MpduHeaderLen = padding;
-		}
-
-		/* */
-		/* A-MSDU subframe */
-		/*   DA(6)+SA(6)+Length(2) + LLC/SNAP Encap */
-		/* */
-		subFrameHeader = pHeaderBufPtr;
-		subFramePayloadLen = pTxBlk->SrcBufLen;
-
-		NdisMoveMemory(subFrameHeader, pTxBlk->pSrcBufHeader, 12);
-
-		pHeaderBufPtr += LENGTH_AMSDU_SUBFRAMEHEAD;
-		pTxBlk->MpduHeaderLen += LENGTH_AMSDU_SUBFRAMEHEAD;
-
-		/* */
-		/* Insert LLC-SNAP encapsulation - 8 octets */
-		/* */
-		EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData - 2,
-						    pTxBlk->pExtraLlcSnapEncap);
-
-		subFramePayloadLen = pTxBlk->SrcBufLen;
-
-		if (pTxBlk->pExtraLlcSnapEncap) {
-			NdisMoveMemory(pHeaderBufPtr,
-				       pTxBlk->pExtraLlcSnapEncap, 6);
-			pHeaderBufPtr += 6;
-			/* get 2 octets (TypeofLen) */
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
-				       2);
-			pHeaderBufPtr += 2;
-			pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
-			subFramePayloadLen += LENGTH_802_1_H;
-		}
-		/* update subFrame Length field */
-		subFrameHeader[12] = (subFramePayloadLen & 0xFF00) >> 8;
-		subFrameHeader[13] = subFramePayloadLen & 0xFF;
-
-		totalMPDUSize += pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
-
-		if (frameNum == 0)
-			FirstTx =
-			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
-						     &FreeNumber);
-		else
-			LastTxIdx =
-			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
-						     &FreeNumber);
-
-		frameNum++;
-
-		pAd->RalinkCounters.KickTxCount++;
-		pAd->RalinkCounters.OneSecTxDoneCount++;
-
-		/* calculate Transmitted AMSDU Count and ByteCount */
-		{
-			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart++;
-			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart +=
-			    totalMPDUSize;
-		}
-
-	}
-
-	HAL_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, FirstTx);
-	HAL_LastTxIdx(pAd, pTxBlk->QueIdx, LastTxIdx);
-
-	/* */
-	/* Kick out Tx */
-	/* */
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
-}
-
-void STA_Legacy_Frame_Tx(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	struct rt_header_802_11 *pHeader_802_11;
-	u8 *pHeaderBufPtr;
-	u16 FreeNumber;
-	BOOLEAN bVLANPkt;
-	struct rt_queue_entry *pQEntry;
-
-	ASSERT(pTxBlk);
-
-	pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-	pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
-		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	if (pTxBlk->TxFrameType == TX_MCAST_FRAME) {
-		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
-	}
-
-	if (RTMP_GET_PACKET_RTS(pTxBlk->pPacket))
-		TX_BLK_SET_FLAG(pTxBlk, fTX_bRtsRequired);
-	else
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bRtsRequired);
-
-	bVLANPkt = (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
-
-	if (pTxBlk->TxRate < pAd->CommonCfg.MinTxRate)
-		pTxBlk->TxRate = pAd->CommonCfg.MinTxRate;
-
-	STAFindCipherAlgorithm(pAd, pTxBlk);
-	STABuildCommon802_11Header(pAd, pTxBlk);
-
-	/* skip 802.3 header */
-	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-	pTxBlk->SrcBufLen -= LENGTH_802_3;
-
-	/* skip vlan tag */
-	if (bVLANPkt) {
-		pTxBlk->pSrcBufData += LENGTH_802_1Q;
-		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
-	}
-
-	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-	pHeader_802_11 = (struct rt_header_802_11 *) pHeaderBufPtr;
-
-	/* skip common header */
-	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
-
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		/* */
-		/* build QOS Control bytes */
-		/* */
-		*(pHeaderBufPtr) =
-		    ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.
-						      AckPolicy[pTxBlk->
-								QueIdx] << 5));
-		*(pHeaderBufPtr + 1) = 0;
-		pHeaderBufPtr += 2;
-		pTxBlk->MpduHeaderLen += 2;
-	}
-	/* The remaining content of MPDU header should locate at 4-octets alignment */
-	pTxBlk->HdrPadLen = (unsigned long)pHeaderBufPtr;
-	pHeaderBufPtr = (u8 *)ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (unsigned long)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-	{
-
-		/* */
-		/* Insert LLC-SNAP encapsulation - 8 octets */
-		/* */
-		/* */
-		/* if original Ethernet frame contains no LLC/SNAP, */
-		/* then an extra LLC/SNAP encap is required */
-		/* */
-		EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
-						   pTxBlk->pExtraLlcSnapEncap);
-		if (pTxBlk->pExtraLlcSnapEncap) {
-			u8 vlan_size;
-
-			NdisMoveMemory(pHeaderBufPtr,
-				       pTxBlk->pExtraLlcSnapEncap, 6);
-			pHeaderBufPtr += 6;
-			/* skip vlan tag */
-			vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
-			/* get 2 octets (TypeofLen) */
-			NdisMoveMemory(pHeaderBufPtr,
-				       pTxBlk->pSrcBufHeader + 12 + vlan_size,
-				       2);
-			pHeaderBufPtr += 2;
-			pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
-		}
-
-	}
-
-	/* */
-	/* prepare for TXWI */
-	/* use Wcid as Key Index */
-	/* */
-
-	RTMPWriteTxWI_Data(pAd, (struct rt_txwi *) (&pTxBlk->HeaderBuf[TXINFO_SIZE]),
-			   pTxBlk);
-
-	/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
-
-	HAL_WriteTxResource(pAd, pTxBlk, TRUE, &FreeNumber);
-
-	pAd->RalinkCounters.KickTxCount++;
-	pAd->RalinkCounters.OneSecTxDoneCount++;
-
-	/* */
-	/* Kick out Tx */
-	/* */
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
-}
-
-void STA_ARalink_Frame_Tx(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	u8 *pHeaderBufPtr;
-	u16 FreeNumber;
-	u16 totalMPDUSize = 0;
-	u16 FirstTx, LastTxIdx;
-	int frameNum = 0;
-	BOOLEAN bVLANPkt;
-	struct rt_queue_entry *pQEntry;
-
-	ASSERT(pTxBlk);
-
-	ASSERT((pTxBlk->TxPacketList.Number == 2));
-
-	FirstTx = LastTxIdx = 0;	/* Is it ok init they as 0? */
-	while (pTxBlk->TxPacketList.Head) {
-		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-
-		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
-					    NDIS_STATUS_FAILURE);
-			continue;
-		}
-
-		bVLANPkt =
-		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
-
-		/* skip 802.3 header */
-		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen -= LENGTH_802_3;
-
-		/* skip vlan tag */
-		if (bVLANPkt) {
-			pTxBlk->pSrcBufData += LENGTH_802_1Q;
-			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
-		}
-
-		if (frameNum == 0) {	/* For first frame, we need to create the 802.11 header + padding(optional) + RA-AGG-LEN + SNAP Header */
-
-			pHeaderBufPtr =
-			    STA_Build_ARalink_Frame_Header(pAd, pTxBlk);
-
-			/* It's ok write the TxWI here, because the TxWI->MPDUtotalByteCount */
-			/* will be updated after final frame was handled. */
-			RTMPWriteTxWI_Data(pAd,
-					   (struct rt_txwi *) (&pTxBlk->
-							  HeaderBuf
-							  [TXINFO_SIZE]),
-					   pTxBlk);
-
-			/* */
-			/* Insert LLC-SNAP encapsulation - 8 octets */
-			/* */
-			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
-							    pSrcBufData - 2,
-							    pTxBlk->
-							    pExtraLlcSnapEncap);
-
-			if (pTxBlk->pExtraLlcSnapEncap) {
-				NdisMoveMemory(pHeaderBufPtr,
-					       pTxBlk->pExtraLlcSnapEncap, 6);
-				pHeaderBufPtr += 6;
-				/* get 2 octets (TypeofLen) */
-				NdisMoveMemory(pHeaderBufPtr,
-					       pTxBlk->pSrcBufData - 2, 2);
-				pHeaderBufPtr += 2;
-				pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
-			}
-		} else {	/* For second aggregated frame, we need create the 802.3 header to headerBuf, because PCI will copy it to SDPtr0. */
-
-			pHeaderBufPtr = &pTxBlk->HeaderBuf[0];
-			pTxBlk->MpduHeaderLen = 0;
-
-			/* A-Ralink sub-sequent frame header is the same as 802.3 header. */
-			/*   DA(6)+SA(6)+FrameType(2) */
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader,
-				       12);
-			pHeaderBufPtr += 12;
-			/* get 2 octets (TypeofLen) */
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
-				       2);
-			pHeaderBufPtr += 2;
-			pTxBlk->MpduHeaderLen = LENGTH_ARALINK_SUBFRAMEHEAD;
-		}
-
-		totalMPDUSize += pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
-
-		/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
-		if (frameNum == 0)
-			FirstTx =
-			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
-						     &FreeNumber);
-		else
-			LastTxIdx =
-			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
-						     &FreeNumber);
-
-		frameNum++;
-
-		pAd->RalinkCounters.OneSecTxAggregationCount++;
-		pAd->RalinkCounters.KickTxCount++;
-		pAd->RalinkCounters.OneSecTxDoneCount++;
-
-	}
-
-	HAL_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, FirstTx);
-	HAL_LastTxIdx(pAd, pTxBlk->QueIdx, LastTxIdx);
-
-	/* */
-	/* Kick out Tx */
-	/* */
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
-
-}
-
-void STA_Fragment_Frame_Tx(struct rt_rtmp_adapter *pAd, struct rt_tx_blk *pTxBlk)
-{
-	struct rt_header_802_11 *pHeader_802_11;
-	u8 *pHeaderBufPtr;
-	u16 FreeNumber;
-	u8 fragNum = 0;
-	struct rt_packet_info PacketInfo;
-	u16 EncryptionOverhead = 0;
-	u32 FreeMpduSize, SrcRemainingBytes;
-	u16 AckDuration;
-	u32 NextMpduSize;
-	BOOLEAN bVLANPkt;
-	struct rt_queue_entry *pQEntry;
-	HTTRANSMIT_SETTING *pTransmit;
-
-	ASSERT(pTxBlk);
-
-	pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-	pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
-		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
-		return;
-	}
-
-	ASSERT(TX_BLK_TEST_FLAG(pTxBlk, fTX_bAllowFrag));
-	bVLANPkt = (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
-
-	STAFindCipherAlgorithm(pAd, pTxBlk);
-	STABuildCommon802_11Header(pAd, pTxBlk);
-
-	if (pTxBlk->CipherAlg == CIPHER_TKIP) {
-		pTxBlk->pPacket =
-		    duplicate_pkt_with_TKIP_MIC(pAd, pTxBlk->pPacket);
-		if (pTxBlk->pPacket == NULL)
-			return;
-		RTMP_QueryPacketInfo(pTxBlk->pPacket, &PacketInfo,
-				     &pTxBlk->pSrcBufHeader,
-				     &pTxBlk->SrcBufLen);
-	}
-	/* skip 802.3 header */
-	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-	pTxBlk->SrcBufLen -= LENGTH_802_3;
-
-	/* skip vlan tag */
-	if (bVLANPkt) {
-		pTxBlk->pSrcBufData += LENGTH_802_1Q;
-		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
-	}
-
-	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-	pHeader_802_11 = (struct rt_header_802_11 *) pHeaderBufPtr;
-
-	/* skip common header */
-	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
-
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		/* */
-		/* build QOS Control bytes */
-		/* */
-		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
-
-		*(pHeaderBufPtr + 1) = 0;
-		pHeaderBufPtr += 2;
-		pTxBlk->MpduHeaderLen += 2;
-	}
-	/* */
-	/* padding at front of LLC header */
-	/* LLC header should locate at 4-octets aligment */
-	/* */
-	pTxBlk->HdrPadLen = (unsigned long)pHeaderBufPtr;
-	pHeaderBufPtr = (u8 *)ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (unsigned long)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-	/* */
-	/* Insert LLC-SNAP encapsulation - 8 octets */
-	/* */
-	/* */
-	/* if original Ethernet frame contains no LLC/SNAP, */
-	/* then an extra LLC/SNAP encap is required */
-	/* */
-	EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
-					   pTxBlk->pExtraLlcSnapEncap);
-	if (pTxBlk->pExtraLlcSnapEncap) {
-		u8 vlan_size;
-
-		NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
-		pHeaderBufPtr += 6;
-		/* skip vlan tag */
-		vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
-		/* get 2 octets (TypeofLen) */
-		NdisMoveMemory(pHeaderBufPtr,
-			       pTxBlk->pSrcBufHeader + 12 + vlan_size, 2);
-		pHeaderBufPtr += 2;
-		pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
-	}
-
-	/* If TKIP is used and fragmentation is required. Driver has to */
-	/*      append TKIP MIC at tail of the scatter buffer */
-	/*      MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC */
-	if (pTxBlk->CipherAlg == CIPHER_TKIP) {
-		RTMPCalculateMICValue(pAd, pTxBlk->pPacket,
-				      pTxBlk->pExtraLlcSnapEncap, pTxBlk->pKey,
-				      0);
-
-		/* NOTE: DON'T refer the skb->len directly after following copy. Because the length is not adjusted */
-		/*                      to correct length, refer to pTxBlk->SrcBufLen for the packet length in following progress. */
-		NdisMoveMemory(pTxBlk->pSrcBufData + pTxBlk->SrcBufLen,
-			       &pAd->PrivateInfo.Tx.MIC[0], 8);
-		/*skb_put((RTPKT_TO_OSPKT(pTxBlk->pPacket))->tail, 8); */
-		pTxBlk->SrcBufLen += 8;
-		pTxBlk->TotalFrameLen += 8;
-		pTxBlk->CipherAlg = CIPHER_TKIP_NO_MIC;
-	}
-	/* */
-	/* calculate the overhead bytes that encryption algorithm may add. This */
-	/* affects the calculate of "duration" field */
-	/* */
-	if ((pTxBlk->CipherAlg == CIPHER_WEP64)
-	    || (pTxBlk->CipherAlg == CIPHER_WEP128))
-		EncryptionOverhead = 8;	/*WEP: IV[4] + ICV[4]; */
-	else if (pTxBlk->CipherAlg == CIPHER_TKIP_NO_MIC)
-		EncryptionOverhead = 12;	/*TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength */
-	else if (pTxBlk->CipherAlg == CIPHER_TKIP)
-		EncryptionOverhead = 20;	/*TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8] */
-	else if (pTxBlk->CipherAlg == CIPHER_AES)
-		EncryptionOverhead = 16;	/* AES: IV[4] + EIV[4] + MIC[8] */
-	else
-		EncryptionOverhead = 0;
-
-	pTransmit = pTxBlk->pTransmit;
-	/* Decide the TX rate */
-	if (pTransmit->field.MODE == MODE_CCK)
-		pTxBlk->TxRate = pTransmit->field.MCS;
-	else if (pTransmit->field.MODE == MODE_OFDM)
-		pTxBlk->TxRate = pTransmit->field.MCS + RATE_FIRST_OFDM_RATE;
-	else
-		pTxBlk->TxRate = RATE_6_5;
-
-	/* decide how much time an ACK/CTS frame will consume in the air */
-	if (pTxBlk->TxRate <= RATE_LAST_OFDM_RATE)
-		AckDuration =
-		    RTMPCalcDuration(pAd,
-				     pAd->CommonCfg.ExpectedACKRate[pTxBlk->
-								    TxRate],
-				     14);
-	else
-		AckDuration = RTMPCalcDuration(pAd, RATE_6_5, 14);
-
-	/* Init the total payload length of this frame. */
-	SrcRemainingBytes = pTxBlk->SrcBufLen;
-
-	pTxBlk->TotalFragNum = 0xff;
-
-	do {
-
-		FreeMpduSize = pAd->CommonCfg.FragmentThreshold - LENGTH_CRC;
-
-		FreeMpduSize -= pTxBlk->MpduHeaderLen;
-
-		if (SrcRemainingBytes <= FreeMpduSize) {	/* this is the last or only fragment */
-
-			pTxBlk->SrcBufLen = SrcRemainingBytes;
-
-			pHeader_802_11->FC.MoreFrag = 0;
-			pHeader_802_11->Duration =
-			    pAd->CommonCfg.Dsifs + AckDuration;
-
-			/* Indicate the lower layer that this's the last fragment. */
-			pTxBlk->TotalFragNum = fragNum;
-		} else {	/* more fragment is required */
-
-			pTxBlk->SrcBufLen = FreeMpduSize;
-
-			NextMpduSize =
-			    min(((u32)SrcRemainingBytes - pTxBlk->SrcBufLen),
-				((u32)pAd->CommonCfg.FragmentThreshold));
-			pHeader_802_11->FC.MoreFrag = 1;
-			pHeader_802_11->Duration =
-			    (3 * pAd->CommonCfg.Dsifs) + (2 * AckDuration) +
-			    RTMPCalcDuration(pAd, pTxBlk->TxRate,
-					     NextMpduSize + EncryptionOverhead);
-		}
-
-		if (fragNum == 0)
-			pTxBlk->FrameGap = IFS_HTTXOP;
-		else
-			pTxBlk->FrameGap = IFS_SIFS;
-
-		RTMPWriteTxWI_Data(pAd,
-				   (struct rt_txwi *) (&pTxBlk->
-						  HeaderBuf[TXINFO_SIZE]),
-				   pTxBlk);
-
-		HAL_WriteFragTxResource(pAd, pTxBlk, fragNum, &FreeNumber);
-
-		pAd->RalinkCounters.KickTxCount++;
-		pAd->RalinkCounters.OneSecTxDoneCount++;
-
-		/* Update the frame number, remaining size of the NDIS packet payload. */
-
-		/* space for 802.11 header. */
-		if (fragNum == 0 && pTxBlk->pExtraLlcSnapEncap)
-			pTxBlk->MpduHeaderLen -= LENGTH_802_1_H;
-
-		fragNum++;
-		SrcRemainingBytes -= pTxBlk->SrcBufLen;
-		pTxBlk->pSrcBufData += pTxBlk->SrcBufLen;
-
-		pHeader_802_11->Frag++;	/* increase Frag # */
-
-	} while (SrcRemainingBytes > 0);
-
-	/* */
-	/* Kick out Tx */
-	/* */
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
-}
-
-#define RELEASE_FRAMES_OF_TXBLK(_pAd, _pTxBlk, _pQEntry, _Status) 										\
-		while(_pTxBlk->TxPacketList.Head)														\
-		{																						\
-			_pQEntry = RemoveHeadQueue(&_pTxBlk->TxPacketList);									\
-			RELEASE_NDIS_PACKET(_pAd, QUEUE_ENTRY_TO_PACKET(_pQEntry), _Status);	\
-		}
-
-/*
-	========================================================================
-
-	Routine Description:
-		Copy frame from waiting queue into relative ring buffer and set
-	appropriate ASIC register to kick hardware encryption before really
-	sent out to air.
-
-	Arguments:
-		pAd 	Pointer to our adapter
-		void *	Pointer to outgoing Ndis frame
-		NumberOfFrag	Number of fragment required
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-int STAHardTransmit(struct rt_rtmp_adapter *pAd,
-			    struct rt_tx_blk *pTxBlk, u8 QueIdx)
-{
-	char *pPacket;
-	struct rt_queue_entry *pQEntry;
-
-	/* --------------------------------------------- */
-	/* STEP 0. DO SANITY CHECK AND SOME EARLY PREPARATION. */
-	/* --------------------------------------------- */
-	/* */
-	ASSERT(pTxBlk->TxPacketList.Number);
-	if (pTxBlk->TxPacketList.Head == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("pTxBlk->TotalFrameNum == %ld!\n",
-			  pTxBlk->TxPacketList.Number));
-		return NDIS_STATUS_FAILURE;
-	}
-
-	pPacket = QUEUE_ENTRY_TO_PACKET(pTxBlk->TxPacketList.Head);
-
-	/* ------------------------------------------------------------------ */
-	/* STEP 1. WAKE UP PHY */
-	/*              outgoing frame always wakeup PHY to prevent frame lost and */
-	/*              turn off PSM bit to improve performance */
-	/* ------------------------------------------------------------------ */
-	/* not to change PSM bit, just send this frame out? */
-	if ((pAd->StaCfg.Psm == PWR_SAVE)
-	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
-		DBGPRINT_RAW(RT_DEBUG_INFO, ("AsicForceWakeup At HardTx\n"));
-#ifdef RTMP_MAC_PCI
-		AsicForceWakeup(pAd, TRUE);
-#endif /* RTMP_MAC_PCI // */
-#ifdef RTMP_MAC_USB
-		RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_FORCE_WAKE_UP, NULL, 0);
-#endif /* RTMP_MAC_USB // */
-	}
-	/* It should not change PSM bit, when APSD turn on. */
-	if ((!
-	     (pAd->CommonCfg.bAPSDCapable
-	      && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
-	     && (pAd->CommonCfg.bAPSDForcePowerSave == FALSE))
-	    || (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket))
-	    || (RTMP_GET_PACKET_WAI(pTxBlk->pPacket))) {
-		if ((pAd->StaCfg.Psm == PWR_SAVE) &&
-		    (pAd->StaCfg.WindowsPowerMode ==
-		     Ndis802_11PowerModeFast_PSP))
-			RTMP_SET_PSM_BIT(pAd, PWR_ACTIVE);
-	}
-
-	switch (pTxBlk->TxFrameType) {
-	case TX_AMPDU_FRAME:
-		STA_AMPDU_Frame_Tx(pAd, pTxBlk);
-		break;
-	case TX_AMSDU_FRAME:
-		STA_AMSDU_Frame_Tx(pAd, pTxBlk);
-		break;
-	case TX_LEGACY_FRAME:
-		STA_Legacy_Frame_Tx(pAd, pTxBlk);
-		break;
-	case TX_MCAST_FRAME:
-		STA_Legacy_Frame_Tx(pAd, pTxBlk);
-		break;
-	case TX_RALINK_FRAME:
-		STA_ARalink_Frame_Tx(pAd, pTxBlk);
-		break;
-	case TX_FRAG_FRAME:
-		STA_Fragment_Frame_Tx(pAd, pTxBlk);
-		break;
-	default:
-		{
-			/* It should not happened! */
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("Send a packet was not classified! It should not happen!\n"));
-			while (pTxBlk->TxPacketList.Number) {
-				pQEntry =
-				    RemoveHeadQueue(&pTxBlk->TxPacketList);
-				pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-				if (pPacket)
-					RELEASE_NDIS_PACKET(pAd, pPacket,
-							    NDIS_STATUS_FAILURE);
-			}
-		}
-		break;
-	}
-
-	return (NDIS_STATUS_SUCCESS);
-
-}
-
-unsigned long HashBytesPolynomial(u8 * value, unsigned int len)
-{
-	unsigned char *word = value;
-	unsigned int ret = 0;
-	unsigned int i;
-
-	for (i = 0; i < len; i++) {
-		int mod = i % 32;
-		ret ^= (unsigned int)(word[i]) << mod;
-		ret ^= (unsigned int)(word[i]) >> (32 - mod);
-	}
-	return ret;
-}
-
-void Sta_Announce_or_Forward_802_3_Packet(struct rt_rtmp_adapter *pAd,
-					  void *pPacket,
-					  u8 FromWhichBSSID)
-{
-	if (TRUE) {
-		announce_802_3_packet(pAd, pPacket);
-	} else {
-		/* release packet */
-		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-	}
-}
diff --git a/drivers/staging/rt2860/sta/sanity.c b/drivers/staging/rt2860/sta/sanity.c
deleted file mode 100644
index 0c32604..0000000
--- a/drivers/staging/rt2860/sta/sanity.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	sanity.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John Chang  		2004-09-01      add WMM support
-	Justin P. Mattock	11/07/2010	Fix typos
-*/
-#include "../rt_config.h"
-
-extern u8 CISCO_OUI[];
-
-extern u8 WPA_OUI[];
-extern u8 RSN_OUI[];
-extern u8 WME_INFO_ELEM[];
-extern u8 WME_PARM_ELEM[];
-extern u8 Ccx2QosInfo[];
-extern u8 RALINK_OUI[];
-extern u8 BROADCOM_OUI[];
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
- */
-BOOLEAN MlmeStartReqSanity(struct rt_rtmp_adapter *pAd,
-			   void * Msg,
-			   unsigned long MsgLen,
-			   char Ssid[], u8 * pSsidLen)
-{
-	struct rt_mlme_start_req *Info;
-
-	Info = (struct rt_mlme_start_req *)(Msg);
-
-	if (Info->SsidLen > MAX_LEN_OF_SSID) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeStartReqSanity fail - wrong SSID length\n"));
-		return FALSE;
-	}
-
-	*pSsidLen = Info->SsidLen;
-	NdisMoveMemory(Ssid, Info->Ssid, *pSsidLen);
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-    IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerAssocRspSanity(struct rt_rtmp_adapter *pAd, void * pMsg, unsigned long MsgLen, u8 *pAddr2, u16 * pCapabilityInfo, u16 * pStatus, u16 * pAid, u8 SupRate[], u8 * pSupRateLen, u8 ExtRate[], u8 * pExtRateLen, struct rt_ht_capability_ie * pHtCapability, struct rt_add_ht_info_ie * pAddHtInfo,	/* AP might use this additional ht info IE */
-			   u8 * pHtCapabilityLen,
-			   u8 * pAddHtInfoLen,
-			   u8 * pNewExtChannelOffset,
-			   struct rt_edca_parm *pEdcaParm, u8 * pCkipFlag)
-{
-	char IeType, *Ptr;
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) pMsg;
-	struct rt_eid * pEid;
-	unsigned long Length = 0;
-
-	*pNewExtChannelOffset = 0xff;
-	*pHtCapabilityLen = 0;
-	*pAddHtInfoLen = 0;
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-	Ptr = (char *)pFrame->Octet;
-	Length += LENGTH_802_11;
-
-	NdisMoveMemory(pCapabilityInfo, &pFrame->Octet[0], 2);
-	Length += 2;
-	NdisMoveMemory(pStatus, &pFrame->Octet[2], 2);
-	Length += 2;
-	*pCkipFlag = 0;
-	*pExtRateLen = 0;
-	pEdcaParm->bValid = FALSE;
-
-	if (*pStatus != MLME_SUCCESS)
-		return TRUE;
-
-	NdisMoveMemory(pAid, &pFrame->Octet[4], 2);
-	Length += 2;
-
-	/* Aid already swapped byte order in RTMPFrameEndianChange() for big endian platform */
-	*pAid = (*pAid) & 0x3fff;	/* AID is low 14-bit */
-
-	/* -- get supported rates from payload and advance the pointer */
-	IeType = pFrame->Octet[6];
-	*pSupRateLen = pFrame->Octet[7];
-	if ((IeType != IE_SUPP_RATES)
-	    || (*pSupRateLen > MAX_LEN_OF_SUPPORTED_RATES)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PeerAssocRspSanity fail - wrong SupportedRates IE\n"));
-		return FALSE;
-	} else
-		NdisMoveMemory(SupRate, &pFrame->Octet[8], *pSupRateLen);
-
-	Length = Length + 2 + *pSupRateLen;
-
-	/* many AP implement proprietary IEs in non-standard order, we'd better */
-	/* tolerate mis-ordered IEs to get best compatibility */
-	pEid = (struct rt_eid *) & pFrame->Octet[8 + (*pSupRateLen)];
-
-	/* get variable fields from payload and advance the pointer */
-	while ((Length + 2 + pEid->Len) <= MsgLen) {
-		switch (pEid->Eid) {
-		case IE_EXT_SUPP_RATES:
-			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
-				NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
-				*pExtRateLen = pEid->Len;
-			}
-			break;
-
-		case IE_HT_CAP:
-		case IE_HT_CAP2:
-			if (pEid->Len >= SIZE_HT_CAP_IE)	/*Note: allow extension! */
-			{
-				NdisMoveMemory(pHtCapability, pEid->Octet,
-					       SIZE_HT_CAP_IE);
-
-				*(u16 *) (&pHtCapability->HtCapInfo) =
-				    cpu2le16(*(u16 *)
-					     (&pHtCapability->HtCapInfo));
-				*(u16 *) (&pHtCapability->ExtHtCapInfo) =
-				    cpu2le16(*(u16 *)
-					     (&pHtCapability->ExtHtCapInfo));
-
-				*pHtCapabilityLen = SIZE_HT_CAP_IE;
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerAssocRspSanity - wrong IE_HT_CAP. \n"));
-			}
-
-			break;
-		case IE_ADD_HT:
-		case IE_ADD_HT2:
-			if (pEid->Len >= sizeof(struct rt_add_ht_info_ie)) {
-				/* This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only */
-				/* copy first sizeof(struct rt_add_ht_info_ie) */
-				NdisMoveMemory(pAddHtInfo, pEid->Octet,
-					       sizeof(struct rt_add_ht_info_ie));
-
-				*(u16 *) (&pAddHtInfo->AddHtInfo2) =
-				    cpu2le16(*(u16 *)
-					     (&pAddHtInfo->AddHtInfo2));
-				*(u16 *) (&pAddHtInfo->AddHtInfo3) =
-				    cpu2le16(*(u16 *)
-					     (&pAddHtInfo->AddHtInfo3));
-
-				*pAddHtInfoLen = SIZE_ADD_HT_INFO_IE;
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerAssocRspSanity - wrong IE_ADD_HT. \n"));
-			}
-
-			break;
-		case IE_SECONDARY_CH_OFFSET:
-			if (pEid->Len == 1) {
-				*pNewExtChannelOffset = pEid->Octet[0];
-			} else {
-				DBGPRINT(RT_DEBUG_WARN,
-					 ("PeerAssocRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
-			}
-			break;
-
-		case IE_VENDOR_SPECIFIC:
-			/* handle WME PARAMTER ELEMENT */
-			if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6)
-			    && (pEid->Len == 24)) {
-				u8 *ptr;
-				int i;
-
-				/* parsing EDCA parameters */
-				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
-				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
-				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
-				/*pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80; */
-				pEdcaParm->EdcaUpdateCount =
-				    pEid->Octet[6] & 0x0f;
-				pEdcaParm->bAPSDCapable =
-				    (pEid->Octet[6] & 0x80) ? 1 : 0;
-				ptr = (u8 *)& pEid->Octet[8];
-				for (i = 0; i < 4; i++) {
-					u8 aci = (*ptr & 0x60) >> 5;	/* b5~6 is AC INDEX */
-					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	/* b5 is ACM */
-					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	/* b0~3 is AIFSN */
-					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	/* b0~4 is Cwmin */
-					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	/* b5~8 is Cwmax */
-					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	/* in unit of 32-us */
-					ptr += 4;	/* point to next AC */
-				}
-			}
-			break;
-		default:
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PeerAssocRspSanity - ignore unrecognized EID = %d\n",
-				  pEid->Eid));
-			break;
-		}
-
-		Length = Length + 2 + pEid->Len;
-		pEid = (struct rt_eid *) ((u8 *) pEid + 2 + pEid->Len);
-	}
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-        MLME message sanity check
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN PeerProbeReqSanity(struct rt_rtmp_adapter *pAd,
-			   void * Msg,
-			   unsigned long MsgLen,
-			   u8 *pAddr2,
-			   char Ssid[], u8 * pSsidLen)
-{
-	u8 Idx;
-	u8 RateLen;
-	char IeType;
-	struct rt_frame_802_11 * pFrame = (struct rt_frame_802_11 *) Msg;
-
-	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-
-	if ((pFrame->Octet[0] != IE_SSID)
-	    || (pFrame->Octet[1] > MAX_LEN_OF_SSID)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PeerProbeReqSanity fail - wrong SSID IE(Type=%d,Len=%d)\n",
-			  pFrame->Octet[0], pFrame->Octet[1]));
-		return FALSE;
-	}
-
-	*pSsidLen = pFrame->Octet[1];
-	NdisMoveMemory(Ssid, &pFrame->Octet[2], *pSsidLen);
-
-	Idx = *pSsidLen + 2;
-
-	/* -- get supported rates from payload and advance the pointer */
-	IeType = pFrame->Octet[Idx];
-	RateLen = pFrame->Octet[Idx + 1];
-	if (IeType != IE_SUPP_RATES) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("PeerProbeReqSanity fail - wrong SupportRates IE(Type=%d,Len=%d)\n",
-			  pFrame->Octet[Idx], pFrame->Octet[Idx + 1]));
-		return FALSE;
-	} else {
-		if ((pAd->CommonCfg.PhyMode == PHY_11G) && (RateLen < 8))
-			return (FALSE);
-	}
-
-	return TRUE;
-}
-
-/*
-    ==========================================================================
-    Description:
-
-	IRQL = DISPATCH_LEVEL
-
-    ==========================================================================
- */
-BOOLEAN GetTimBit(char * Ptr,
-		  u16 Aid,
-		  u8 * TimLen,
-		  u8 * BcastFlag,
-		  u8 * DtimCount,
-		  u8 * DtimPeriod, u8 * MessageToMe)
-{
-	u8 BitCntl, N1, N2, MyByte, MyBit;
-	char *IdxPtr;
-
-	IdxPtr = Ptr;
-
-	IdxPtr++;
-	*TimLen = *IdxPtr;
-
-	/* get DTIM Count from TIM element */
-	IdxPtr++;
-	*DtimCount = *IdxPtr;
-
-	/* get DTIM Period from TIM element */
-	IdxPtr++;
-	*DtimPeriod = *IdxPtr;
-
-	/* get Bitmap Control from TIM element */
-	IdxPtr++;
-	BitCntl = *IdxPtr;
-
-	if ((*DtimCount == 0) && (BitCntl & 0x01))
-		*BcastFlag = TRUE;
-	else
-		*BcastFlag = FALSE;
-
-	/* Parse Partial Virtual Bitmap from TIM element */
-	N1 = BitCntl & 0xfe;	/* N1 is the first bitmap byte# */
-	N2 = *TimLen - 4 + N1;	/* N2 is the last bitmap byte# */
-
-	if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
-		*MessageToMe = FALSE;
-	else {
-		MyByte = (Aid >> 3) - N1;	/* my byte position in the bitmap byte-stream */
-		MyBit = Aid % 16 - ((MyByte & 0x01) ? 8 : 0);
-
-		IdxPtr += (MyByte + 1);
-
-		/*if (*IdxPtr) */
-		/*    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr)); */
-
-		if (*IdxPtr & (0x01 << MyBit))
-			*MessageToMe = TRUE;
-		else
-			*MessageToMe = FALSE;
-	}
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/sta/sync.c b/drivers/staging/rt2860/sta/sync.c
deleted file mode 100644
index 7054ba1..0000000
--- a/drivers/staging/rt2860/sta/sync.c
+++ /dev/null
@@ -1,1968 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	sync.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John Chang		2004-09-01      	modified for rt2561/2661
-	Jan Lee			2006-08-01      	modified for rt2860 for 802.11n
-	Justin P. Mattock	11/07/2010		Fix typos
-*/
-#include "../rt_config.h"
-
-#define ADHOC_ENTRY_BEACON_LOST_TIME	(2*OS_HZ)	/* 2 sec */
-
-/*
-	==========================================================================
-	Description:
-		The sync state machine,
-	Parameters:
-		Sm - pointer to the state machine
-	Note:
-		the state machine looks like the following
-
-	==========================================================================
- */
-void SyncStateMachineInit(struct rt_rtmp_adapter *pAd,
-			  struct rt_state_machine *Sm, OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(Sm, Trans, MAX_SYNC_STATE, MAX_SYNC_MSG,
-			 (STATE_MACHINE_FUNC) Drop, SYNC_IDLE,
-			 SYNC_MACHINE_BASE);
-
-	/* column 1 */
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ,
-			      (STATE_MACHINE_FUNC) MlmeScanReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ,
-			      (STATE_MACHINE_FUNC) MlmeJoinReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_START_REQ,
-			      (STATE_MACHINE_FUNC) MlmeStartReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_BEACON,
-			      (STATE_MACHINE_FUNC) PeerBeacon);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ,
-			      (STATE_MACHINE_FUNC) PeerProbeReqAction);
-
-	/*column 2 */
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenJoin);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_START_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenStart);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_PEER_BEACON,
-			      (STATE_MACHINE_FUNC) PeerBeaconAtJoinAction);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT,
-			      (STATE_MACHINE_FUNC) BeaconTimeoutAtJoinAction);
-
-	/* column 3 */
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenJoin);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_START_REQ,
-			      (STATE_MACHINE_FUNC) InvalidStateWhenStart);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_BEACON,
-			      (STATE_MACHINE_FUNC) PeerBeaconAtScanAction);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_PROBE_RSP,
-			      (STATE_MACHINE_FUNC) PeerBeaconAtScanAction);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT,
-			      (STATE_MACHINE_FUNC) ScanTimeoutAction);
-
-	/* timer init */
-	RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer,
-		      GET_TIMER_FUNCTION(BeaconTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer,
-		      GET_TIMER_FUNCTION(ScanTimeout), pAd, FALSE);
-}
-
-/*
-	==========================================================================
-	Description:
-		Beacon timeout handler, executed in timer thread
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void BeaconTimeout(void *SystemSpecific1,
-		   void *FunctionContext,
-		   void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BeaconTimeout\n"));
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-		return;
-
-	if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
-	    ) {
-		u8 BBPValue = 0;
-		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-		BBPValue &= (~0x18);
-		BBPValue |= 0x10;
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",
-			  pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
-	}
-
-	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_BEACON_TIMEOUT, 0, NULL);
-	RTMP_MLME_HANDLER(pAd);
-}
-
-/*
-	==========================================================================
-	Description:
-		Scan timeout handler, executed in timer thread
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void ScanTimeout(void *SystemSpecific1,
-		 void *FunctionContext,
-		 void *SystemSpecific2, void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-
-	/* Do nothing if the driver is starting halt state. */
-	/* This might happen when timer already been fired before cancel timer with mlmehalt */
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-		return;
-
-	if (MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL)) {
-		RTMP_MLME_HANDLER(pAd);
-	} else {
-		/* To prevent SyncMachine.CurrState is SCAN_LISTEN forever. */
-		pAd->MlmeAux.Channel = 0;
-		ScanNextChannel(pAd);
-		if (pAd->CommonCfg.bWirelessEvent) {
-			RTMPSendWirelessEvent(pAd,
-					      IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG,
-					      pAd->MacTab.Content[BSSID_WCID].
-					      Addr, BSS0, 0);
-		}
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		MLME SCAN req state machine procedure
-	==========================================================================
- */
-void MlmeScanReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Ssid[MAX_LEN_OF_SSID], SsidLen, ScanType, BssType, BBPValue = 0;
-	BOOLEAN TimerCancelled;
-	unsigned long Now;
-	u16 Status;
-	struct rt_header_802_11 * pHdr80211;
-	u8 *pOutBuffer = NULL;
-	int NStatus;
-
-	/* Check the total scan tries for one single OID command */
-	/* If this is the CCX 2.0 Case, skip that! */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("SYNC - MlmeScanReqAction before Startup\n"));
-		return;
-	}
-	/* Increase the scan retry counters. */
-	pAd->StaCfg.ScanCnt++;
-
-#ifdef RTMP_MAC_PCI
-	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
-	    (IDLE_ON(pAd)) &&
-	    (pAd->StaCfg.bRadio == TRUE) &&
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
-		if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE) {
-			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00,
-					     0x02);
-			AsicCheckCommanOk(pAd, PowerWakeCID);
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("PSM - Issue Wake up command \n"));
-		} else {
-			RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-		}
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	/* first check the parameter sanity */
-	if (MlmeScanReqSanity(pAd,
-			      Elem->Msg,
-			      Elem->MsgLen,
-			      &BssType, (char *)Ssid, &SsidLen, &ScanType)) {
-
-		/* Check for channel load and noise hist request */
-		/* Suspend MSDU only at scan request, not the last two mentioned */
-		/* Suspend MSDU transmission here */
-		RTMPSuspendMsduTransmission(pAd);
-
-		/* */
-		/* To prevent data loss. */
-		/* Send a NULL data with turned PSM bit on to current associated AP before SCAN progress. */
-		/* And should send a NULL data with turned PSM bit off to AP, when scan progress done */
-		/* */
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-		    && (INFRA_ON(pAd))) {
-			NStatus = MlmeAllocateMemory(pAd, (void *)& pOutBuffer);
-			if (NStatus == NDIS_STATUS_SUCCESS) {
-				pHdr80211 = (struct rt_header_802_11 *) pOutBuffer;
-				MgtMacHeaderInit(pAd, pHdr80211,
-						 SUBTYPE_NULL_FUNC, 1,
-						 pAd->CommonCfg.Bssid,
-						 pAd->CommonCfg.Bssid);
-				pHdr80211->Duration = 0;
-				pHdr80211->FC.Type = BTYPE_DATA;
-				pHdr80211->FC.PwrMgmt = PWR_SAVE;
-
-				/* Send using priority queue */
-				MiniportMMRequest(pAd, 0, pOutBuffer,
-						  sizeof(struct rt_header_802_11));
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("MlmeScanReqAction -- Send PSM Data frame for off channel RM\n"));
-				MlmeFreeMemory(pAd, pOutBuffer);
-				RTMPusecDelay(5000);
-			}
-		}
-
-		NdisGetSystemUpTime(&Now);
-		pAd->StaCfg.LastScanTime = Now;
-		/* reset all the timers */
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
-
-		/* record desired BSS parameters */
-		pAd->MlmeAux.BssType = BssType;
-		pAd->MlmeAux.ScanType = ScanType;
-		pAd->MlmeAux.SsidLen = SsidLen;
-		NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
-		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
-
-		/* start from the first channel */
-		pAd->MlmeAux.Channel = FirstChannel(pAd);
-
-		/* Let BBP register at 20MHz to do scan */
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-		BBPValue &= (~0x18);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BBP R4 to 20MHz.l\n"));
-		ScanNextChannel(pAd);
-	} else {
-		DBGPRINT_ERR("SYNC - MlmeScanReqAction() sanity check fail\n");
-		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2,
-			    &Status);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		MLME JOIN req state machine procedure
-	==========================================================================
- */
-void MlmeJoinReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 BBPValue = 0;
-	struct rt_bss_entry *pBss;
-	BOOLEAN TimerCancelled;
-	struct rt_header_802_11 Hdr80211;
-	int NStatus;
-	unsigned long FrameLen = 0;
-	u8 *pOutBuffer = NULL;
-	u8 *pSupRate = NULL;
-	u8 SupRateLen;
-	u8 *pExtRate = NULL;
-	u8 ExtRateLen;
-	u8 ASupRate[] = { 0x8C, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6C };
-	u8 ASupRateLen = sizeof(ASupRate) / sizeof(u8);
-	struct rt_mlme_join_req *pInfo = (struct rt_mlme_join_req *)(Elem->Msg);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("SYNC - MlmeJoinReqAction(BSS #%ld)\n", pInfo->BssIdx));
-
-#ifdef RTMP_MAC_PCI
-	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
-	    (IDLE_ON(pAd)) &&
-	    (pAd->StaCfg.bRadio == TRUE) &&
-	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
-		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-	}
-#endif /* RTMP_MAC_PCI // */
-
-	/* reset all the timers */
-	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
-	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
-
-	pBss = &pAd->MlmeAux.SsidBssTab.BssEntry[pInfo->BssIdx];
-
-	/* record the desired SSID & BSSID we're waiting for */
-	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pBss->Bssid);
-
-	/* If AP's SSID is not hidden, it is OK for updating ssid to MlmeAux again. */
-	if (pBss->Hidden == 0) {
-		RTMPZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
-		NdisMoveMemory(pAd->MlmeAux.Ssid, pBss->Ssid, pBss->SsidLen);
-		pAd->MlmeAux.SsidLen = pBss->SsidLen;
-	}
-
-	pAd->MlmeAux.BssType = pBss->BssType;
-	pAd->MlmeAux.Channel = pBss->Channel;
-	pAd->MlmeAux.CentralChannel = pBss->CentralChannel;
-
-	/* Let BBP register at 20MHz to do scan */
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-	BBPValue &= (~0x18);
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BBP R4 to 20MHz.l\n"));
-
-	/* switch channel and waiting for beacon timer */
-	AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
-	AsicLockChannel(pAd, pAd->MlmeAux.Channel);
-	RTMPSetTimer(&pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
-
-	do {
-		if (((pAd->CommonCfg.bIEEE80211H == 1) &&
-		     (pAd->MlmeAux.Channel > 14) &&
-		     RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
-		    ) {
-			/* */
-			/* We can't send any Probe request frame to meet 802.11h. */
-			/* */
-			if (pBss->Hidden == 0)
-				break;
-		}
-		/* */
-		/* send probe request */
-		/* */
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-		if (NStatus == NDIS_STATUS_SUCCESS) {
-			if (pAd->MlmeAux.Channel <= 14) {
-				pSupRate = pAd->CommonCfg.SupRate;
-				SupRateLen = pAd->CommonCfg.SupRateLen;
-				pExtRate = pAd->CommonCfg.ExtRate;
-				ExtRateLen = pAd->CommonCfg.ExtRateLen;
-			} else {
-				/* */
-				/* Overwrite Support Rate, CCK rate are not allowed */
-				/* */
-				pSupRate = ASupRate;
-				SupRateLen = ASupRateLen;
-				ExtRateLen = 0;
-			}
-
-			if (pAd->MlmeAux.BssType == BSS_INFRA)
-				MgtMacHeaderInit(pAd, &Hdr80211,
-						 SUBTYPE_PROBE_REQ, 0,
-						 pAd->MlmeAux.Bssid,
-						 pAd->MlmeAux.Bssid);
-			else
-				MgtMacHeaderInit(pAd, &Hdr80211,
-						 SUBTYPE_PROBE_REQ, 0,
-						 BROADCAST_ADDR,
-						 BROADCAST_ADDR);
-
-			MakeOutgoingFrame(pOutBuffer, &FrameLen,
-					  sizeof(struct rt_header_802_11), &Hdr80211,
-					  1, &SsidIe,
-					  1, &pAd->MlmeAux.SsidLen,
-					  pAd->MlmeAux.SsidLen,
-					  pAd->MlmeAux.Ssid, 1, &SupRateIe, 1,
-					  &SupRateLen, SupRateLen, pSupRate,
-					  END_OF_ARGS);
-
-			if (ExtRateLen) {
-				unsigned long Tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &Tmp,
-						  1, &ExtRateIe,
-						  1, &ExtRateLen,
-						  ExtRateLen, pExtRate,
-						  END_OF_ARGS);
-				FrameLen += Tmp;
-			}
-
-			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-			MlmeFreeMemory(pAd, pOutBuffer);
-		}
-	} while (FALSE);
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		("SYNC - Switch to ch %d, Wait BEACON from %pM\n",
-			pBss->Channel, pBss->Bssid));
-
-	pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
-}
-
-/*
-	==========================================================================
-	Description:
-		MLME START Request state machine procedure, starting an IBSS
-	==========================================================================
- */
-void MlmeStartReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Ssid[MAX_LEN_OF_SSID], SsidLen;
-	BOOLEAN TimerCancelled;
-
-	/* New for WPA security suites */
-	u8 VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
-	struct rt_ndis_802_11_variable_ies *pVIE = NULL;
-	LARGE_INTEGER TimeStamp;
-	BOOLEAN Privacy;
-	u16 Status;
-
-	/* Init Variable IE structure */
-	pVIE = (struct rt_ndis_802_11_variable_ies *)VarIE;
-	pVIE->Length = 0;
-	TimeStamp.u.LowPart = 0;
-	TimeStamp.u.HighPart = 0;
-
-	if (MlmeStartReqSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, (char *)Ssid, &SsidLen)) {
-		/* reset all the timers */
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
-
-		/* */
-		/* Start a new IBSS. All IBSS parameters are decided now.... */
-		/* */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeStartReqAction - Start a new IBSS. All IBSS parameters are decided now.... \n"));
-		pAd->MlmeAux.BssType = BSS_ADHOC;
-		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
-		pAd->MlmeAux.SsidLen = SsidLen;
-
-		/* generate a radom number as BSSID */
-		MacAddrRandomBssid(pAd, pAd->MlmeAux.Bssid);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeStartReqAction - generate a radom number as BSSID \n"));
-
-		Privacy =
-		    (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
-		    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
-		    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
-		pAd->MlmeAux.CapabilityInfo =
-		    CAP_GENERATE(0, 1, Privacy,
-				 (pAd->CommonCfg.TxPreamble ==
-				  Rt802_11PreambleShort), 1, 0);
-		pAd->MlmeAux.BeaconPeriod = pAd->CommonCfg.BeaconPeriod;
-		pAd->MlmeAux.AtimWin = pAd->StaCfg.AtimWin;
-		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
-
-		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
-		pAd->MlmeAux.CentralChannel = pAd->CommonCfg.CentralChannel;
-
-		pAd->MlmeAux.SupRateLen = pAd->CommonCfg.SupRateLen;
-		NdisMoveMemory(pAd->MlmeAux.SupRate, pAd->CommonCfg.SupRate,
-			       MAX_LEN_OF_SUPPORTED_RATES);
-		RTMPCheckRates(pAd, pAd->MlmeAux.SupRate,
-			       &pAd->MlmeAux.SupRateLen);
-		pAd->MlmeAux.ExtRateLen = pAd->CommonCfg.ExtRateLen;
-		NdisMoveMemory(pAd->MlmeAux.ExtRate, pAd->CommonCfg.ExtRate,
-			       MAX_LEN_OF_SUPPORTED_RATES);
-		RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate,
-			       &pAd->MlmeAux.ExtRateLen);
-
-		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
-			RTMPUpdateHTIE(&pAd->CommonCfg.DesiredHtPhy,
-				       &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0],
-				       &pAd->MlmeAux.HtCapability,
-				       &pAd->MlmeAux.AddHtInfo);
-			pAd->MlmeAux.HtCapabilityLen = sizeof(struct rt_ht_capability_ie);
-			/* Not turn pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE here. */
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
-		} else {
-			pAd->MlmeAux.HtCapabilityLen = 0;
-			pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
-			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.
-				       MCSSet[0], 16);
-		}
-		/* temporarily not support QOS in IBSS */
-		NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(struct rt_edca_parm));
-		NdisZeroMemory(&pAd->MlmeAux.APQbssLoad,
-			       sizeof(struct rt_qbss_load_parm));
-		NdisZeroMemory(&pAd->MlmeAux.APQosCapability,
-			       sizeof(struct rt_qos_capability_parm));
-
-		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
-		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("SYNC - MlmeStartReqAction(ch= %d,sup rates= %d, ext rates=%d)\n",
-			  pAd->MlmeAux.Channel, pAd->MlmeAux.SupRateLen,
-			  pAd->MlmeAux.ExtRateLen));
-
-		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-		Status = MLME_SUCCESS;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2,
-			    &Status);
-	} else {
-		DBGPRINT_ERR("SYNC - MlmeStartReqAction() sanity check fail.\n");
-		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2,
-			    &Status);
-	}
-}
-
-/*
-	==========================================================================
-	Description:
-		peer sends beacon back when scanning
-	==========================================================================
- */
-void PeerBeaconAtScanAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	u8 Ssid[MAX_LEN_OF_SSID], BssType, Channel, NewChannel,
-	    SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe;
-	struct rt_cf_parm CfParm;
-	u16 BeaconPeriod, AtimWin, CapabilityInfo;
-	struct rt_frame_802_11 * pFrame;
-	LARGE_INTEGER TimeStamp;
-	u8 Erp;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES],
-	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen, ExtRateLen;
-	u16 LenVIE;
-	u8 CkipFlag;
-	u8 AironetCellPowerLimit;
-	struct rt_edca_parm EdcaParm;
-	struct rt_qbss_load_parm QbssLoad;
-	struct rt_qos_capability_parm QosCapability;
-	unsigned long RalinkIe;
-	u8 VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
-	struct rt_ndis_802_11_variable_ies *pVIE = NULL;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
-	u8 AddHtInfoLen;
-	u8 NewExtChannelOffset = 0xff;
-
-	/* NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00); */
-	pFrame = (struct rt_frame_802_11 *) Elem->Msg;
-	/* Init Variable IE structure */
-	pVIE = (struct rt_ndis_802_11_variable_ies *)VarIE;
-	pVIE->Length = 0;
-
-	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
-	RTMPZeroMemory(&AddHtInfo, sizeof(struct rt_add_ht_info_ie));
-
-	if (PeerBeaconAndProbeRspSanity(pAd,
-					Elem->Msg,
-					Elem->MsgLen,
-					Elem->Channel,
-					Addr2,
-					Bssid,
-					(char *)Ssid,
-					&SsidLen,
-					&BssType,
-					&BeaconPeriod,
-					&Channel,
-					&NewChannel,
-					&TimeStamp,
-					&CfParm,
-					&AtimWin,
-					&CapabilityInfo,
-					&Erp,
-					&DtimCount,
-					&DtimPeriod,
-					&BcastFlag,
-					&MessageToMe,
-					SupRate,
-					&SupRateLen,
-					ExtRate,
-					&ExtRateLen,
-					&CkipFlag,
-					&AironetCellPowerLimit,
-					&EdcaParm,
-					&QbssLoad,
-					&QosCapability,
-					&RalinkIe,
-					&HtCapabilityLen,
-					&PreNHtCapabilityLen,
-					&HtCapability,
-					&AddHtInfoLen,
-					&AddHtInfo,
-					&NewExtChannelOffset, &LenVIE, pVIE)) {
-		unsigned long Idx;
-		char Rssi = 0;
-
-		Idx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
-		if (Idx != BSS_NOT_FOUND)
-			Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
-
-		Rssi =
-		    RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
-				ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
-				ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
-
-		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
-			HtCapabilityLen = SIZE_HT_CAP_IE;
-
-		Idx =
-		    BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, (char *)Ssid,
-				     SsidLen, BssType, BeaconPeriod, &CfParm,
-				     AtimWin, CapabilityInfo, SupRate,
-				     SupRateLen, ExtRate, ExtRateLen,
-				     &HtCapability, &AddHtInfo, HtCapabilityLen,
-				     AddHtInfoLen, NewExtChannelOffset, Channel,
-				     Rssi, TimeStamp, CkipFlag, &EdcaParm,
-				     &QosCapability, &QbssLoad, LenVIE, pVIE);
-
-		if (Idx != BSS_NOT_FOUND) {
-			NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF,
-				       &Elem->Msg[24], 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0],
-				       &Elem->TimeStamp.u.LowPart, 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4],
-				       &Elem->TimeStamp.u.LowPart, 4);
-		}
-
-	}
-	/* sanity check fail, ignored */
-}
-
-/*
-	==========================================================================
-	Description:
-		When waiting joining the (I)BSS, beacon received from external
-	==========================================================================
- */
-void PeerBeaconAtJoinAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	u8 Ssid[MAX_LEN_OF_SSID], SsidLen, BssType, Channel, MessageToMe,
-	    DtimCount, DtimPeriod, BcastFlag, NewChannel;
-	LARGE_INTEGER TimeStamp;
-	u16 BeaconPeriod, AtimWin, CapabilityInfo;
-	struct rt_cf_parm Cf;
-	BOOLEAN TimerCancelled;
-	u8 Erp;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES],
-	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen, ExtRateLen;
-	u8 CkipFlag;
-	u16 LenVIE;
-	u8 AironetCellPowerLimit;
-	struct rt_edca_parm EdcaParm;
-	struct rt_qbss_load_parm QbssLoad;
-	struct rt_qos_capability_parm QosCapability;
-	u16 Status;
-	u8 VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
-	struct rt_ndis_802_11_variable_ies *pVIE = NULL;
-	unsigned long RalinkIe;
-	unsigned long Idx;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
-	u8 AddHtInfoLen;
-	u8 NewExtChannelOffset = 0xff;
-	u8 CentralChannel;
-	BOOLEAN bAllowNrate = FALSE;
-
-	/* Init Variable IE structure */
-	pVIE = (struct rt_ndis_802_11_variable_ies *)VarIE;
-	pVIE->Length = 0;
-	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
-	RTMPZeroMemory(&AddHtInfo, sizeof(struct rt_add_ht_info_ie));
-
-	if (PeerBeaconAndProbeRspSanity(pAd,
-					Elem->Msg,
-					Elem->MsgLen,
-					Elem->Channel,
-					Addr2,
-					Bssid,
-					(char *)Ssid,
-					&SsidLen,
-					&BssType,
-					&BeaconPeriod,
-					&Channel,
-					&NewChannel,
-					&TimeStamp,
-					&Cf,
-					&AtimWin,
-					&CapabilityInfo,
-					&Erp,
-					&DtimCount,
-					&DtimPeriod,
-					&BcastFlag,
-					&MessageToMe,
-					SupRate,
-					&SupRateLen,
-					ExtRate,
-					&ExtRateLen,
-					&CkipFlag,
-					&AironetCellPowerLimit,
-					&EdcaParm,
-					&QbssLoad,
-					&QosCapability,
-					&RalinkIe,
-					&HtCapabilityLen,
-					&PreNHtCapabilityLen,
-					&HtCapability,
-					&AddHtInfoLen,
-					&AddHtInfo,
-					&NewExtChannelOffset, &LenVIE, pVIE)) {
-		/* Disqualify 11b only adhoc when we are in 11g only adhoc mode */
-		if ((BssType == BSS_ADHOC)
-		    && (pAd->CommonCfg.PhyMode == PHY_11G)
-		    && ((SupRateLen + ExtRateLen) < 12))
-			return;
-
-		/* BEACON from desired BSS/IBSS found. We should be able to decide most */
-		/* BSS parameters here. */
-		/* Q. But what happen if this JOIN doesn't conclude a successful ASSOCIATION? */
-		/*    Do we need to recover back all parameters belonging to previous BSS? */
-		/* A. Should be not. There's no back-door recover to previous AP. It still needs */
-		/*    a new JOIN-AUTH-ASSOC sequence. */
-		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n",
-				  Channel));
-			RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,
-					&TimerCancelled);
-
-			/* Update RSSI to prevent No signal display when cards first initialized */
-			pAd->StaCfg.RssiSample.LastRssi0 =
-			    ConvertToRssi(pAd, Elem->Rssi0, RSSI_0);
-			pAd->StaCfg.RssiSample.LastRssi1 =
-			    ConvertToRssi(pAd, Elem->Rssi1, RSSI_1);
-			pAd->StaCfg.RssiSample.LastRssi2 =
-			    ConvertToRssi(pAd, Elem->Rssi2, RSSI_2);
-			pAd->StaCfg.RssiSample.AvgRssi0 =
-			    pAd->StaCfg.RssiSample.LastRssi0;
-			pAd->StaCfg.RssiSample.AvgRssi0X8 =
-			    pAd->StaCfg.RssiSample.AvgRssi0 << 3;
-			pAd->StaCfg.RssiSample.AvgRssi1 =
-			    pAd->StaCfg.RssiSample.LastRssi1;
-			pAd->StaCfg.RssiSample.AvgRssi1X8 =
-			    pAd->StaCfg.RssiSample.AvgRssi1 << 3;
-			pAd->StaCfg.RssiSample.AvgRssi2 =
-			    pAd->StaCfg.RssiSample.LastRssi2;
-			pAd->StaCfg.RssiSample.AvgRssi2X8 =
-			    pAd->StaCfg.RssiSample.AvgRssi2 << 3;
-
-			/* */
-			/* We need to check if SSID only set to any, then we can record the current SSID. */
-			/* Otherwise will cause hidden SSID association failed. */
-			/* */
-			if (pAd->MlmeAux.SsidLen == 0) {
-				NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid,
-					       SsidLen);
-				pAd->MlmeAux.SsidLen = SsidLen;
-			} else {
-				Idx =
-				    BssSsidTableSearch(&pAd->ScanTab, Bssid,
-						       pAd->MlmeAux.Ssid,
-						       pAd->MlmeAux.SsidLen,
-						       Channel);
-
-				if (Idx == BSS_NOT_FOUND) {
-					char Rssi = 0;
-					Rssi =
-					    RTMPMaxRssi(pAd,
-							ConvertToRssi(pAd,
-								      Elem->
-								      Rssi0,
-								      RSSI_0),
-							ConvertToRssi(pAd,
-								      Elem->
-								      Rssi1,
-								      RSSI_1),
-							ConvertToRssi(pAd,
-								      Elem->
-								      Rssi2,
-								      RSSI_2));
-					Idx =
-					    BssTableSetEntry(pAd, &pAd->ScanTab,
-							     Bssid,
-							     (char *) Ssid,
-							     SsidLen, BssType,
-							     BeaconPeriod, &Cf,
-							     AtimWin,
-							     CapabilityInfo,
-							     SupRate,
-							     SupRateLen,
-							     ExtRate,
-							     ExtRateLen,
-							     &HtCapability,
-							     &AddHtInfo,
-							     HtCapabilityLen,
-							     AddHtInfoLen,
-							     NewExtChannelOffset,
-							     Channel, Rssi,
-							     TimeStamp,
-							     CkipFlag,
-							     &EdcaParm,
-							     &QosCapability,
-							     &QbssLoad, LenVIE,
-							     pVIE);
-					if (Idx != BSS_NOT_FOUND) {
-						NdisMoveMemory(pAd->ScanTab.
-							       BssEntry[Idx].
-							       PTSF,
-							       &Elem->Msg[24],
-							       4);
-						NdisMoveMemory(&pAd->ScanTab.
-							       BssEntry[Idx].
-							       TTSF[0],
-							       &Elem->TimeStamp.
-							       u.LowPart, 4);
-						NdisMoveMemory(&pAd->ScanTab.
-							       BssEntry[Idx].
-							       TTSF[4],
-							       &Elem->TimeStamp.
-							       u.LowPart, 4);
-						CapabilityInfo =
-						    pAd->ScanTab.BssEntry[Idx].
-						    CapabilityInfo;
-					}
-				} else {
-					/* */
-					/* Multiple SSID case, used correct CapabilityInfo */
-					/* */
-					CapabilityInfo =
-					    pAd->ScanTab.BssEntry[Idx].
-					    CapabilityInfo;
-				}
-			}
-			NdisMoveMemory(pAd->MlmeAux.Bssid, Bssid, MAC_ADDR_LEN);
-			pAd->MlmeAux.CapabilityInfo =
-			    CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
-			pAd->MlmeAux.BssType = BssType;
-			pAd->MlmeAux.BeaconPeriod = BeaconPeriod;
-			pAd->MlmeAux.Channel = Channel;
-			pAd->MlmeAux.AtimWin = AtimWin;
-			pAd->MlmeAux.CfpPeriod = Cf.CfpPeriod;
-			pAd->MlmeAux.CfpMaxDuration = Cf.CfpMaxDuration;
-			pAd->MlmeAux.APRalinkIe = RalinkIe;
-
-			/* Copy AP's supported rate to MlmeAux for creating association request */
-			/* Also filter out not supported rate */
-			pAd->MlmeAux.SupRateLen = SupRateLen;
-			NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate,
-				       SupRateLen);
-			RTMPCheckRates(pAd, pAd->MlmeAux.SupRate,
-				       &pAd->MlmeAux.SupRateLen);
-			pAd->MlmeAux.ExtRateLen = ExtRateLen;
-			NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate,
-				       ExtRateLen);
-			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate,
-				       &pAd->MlmeAux.ExtRateLen);
-
-			NdisZeroMemory(pAd->StaActive.SupportedPhyInfo.MCSSet,
-				       16);
-
-			if (((pAd->StaCfg.WepStatus != Ndis802_11WEPEnabled)
-			     && (pAd->StaCfg.WepStatus !=
-				 Ndis802_11Encryption2Enabled))
-			    || (pAd->CommonCfg.HT_DisallowTKIP == FALSE)) {
-				bAllowNrate = TRUE;
-			}
-
-			pAd->MlmeAux.NewExtChannelOffset = NewExtChannelOffset;
-			pAd->MlmeAux.HtCapabilityLen = HtCapabilityLen;
-
-			RTMPZeroMemory(&pAd->MlmeAux.HtCapability,
-				       SIZE_HT_CAP_IE);
-			/* filter out un-supported ht rates */
-			if (((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
-			    && ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-				&& (bAllowNrate))) {
-				RTMPMoveMemory(&pAd->MlmeAux.AddHtInfo,
-					       &AddHtInfo, SIZE_ADD_HT_INFO_IE);
-
-				/* StaActive.SupportedHtPhy.MCSSet stores Peer AP's 11n Rx capability */
-				NdisMoveMemory(pAd->StaActive.SupportedPhyInfo.
-					       MCSSet, HtCapability.MCSSet, 16);
-				pAd->MlmeAux.NewExtChannelOffset =
-				    NewExtChannelOffset;
-				pAd->MlmeAux.HtCapabilityLen = SIZE_HT_CAP_IE;
-				pAd->StaActive.SupportedPhyInfo.bHtEnable =
-				    TRUE;
-				if (PreNHtCapabilityLen > 0)
-					pAd->StaActive.SupportedPhyInfo.
-					    bPreNHt = TRUE;
-				RTMPCheckHt(pAd, BSSID_WCID, &HtCapability,
-					    &AddHtInfo);
-				/* Copy AP Parameter to StaActive.  This is also in LinkUp. */
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("PeerBeaconAtJoinAction! (MpduDensity=%d, MaxRAmpduFactor=%d, BW=%d)\n",
-					  pAd->StaActive.SupportedHtPhy.
-					  MpduDensity,
-					  pAd->StaActive.SupportedHtPhy.
-					  MaxRAmpduFactor,
-					  HtCapability.HtCapInfo.ChannelWidth));
-
-				if (AddHtInfoLen > 0) {
-					CentralChannel = AddHtInfo.ControlChan;
-					/* Check again the Bandwidth capability of this AP. */
-					if ((AddHtInfo.ControlChan > 2)
-					    && (AddHtInfo.AddHtInfo.
-						ExtChanOffset == EXTCHA_BELOW)
-					    && (HtCapability.HtCapInfo.
-						ChannelWidth == BW_40)) {
-						CentralChannel =
-						    AddHtInfo.ControlChan - 2;
-					} else
-					    if ((AddHtInfo.AddHtInfo.
-						 ExtChanOffset == EXTCHA_ABOVE)
-						&& (HtCapability.HtCapInfo.
-						    ChannelWidth == BW_40)) {
-						CentralChannel =
-						    AddHtInfo.ControlChan + 2;
-					}
-					/* Check Error . */
-					if (pAd->MlmeAux.CentralChannel !=
-					    CentralChannel)
-						DBGPRINT(RT_DEBUG_ERROR,
-							 ("PeerBeaconAtJoinAction HT===>Beacon Central Channel = %d, Control Channel = %d. Mlmeaux CentralChannel = %d\n",
-							  CentralChannel,
-							  AddHtInfo.ControlChan,
-							  pAd->MlmeAux.
-							  CentralChannel));
-
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("PeerBeaconAtJoinAction HT===>Central Channel = %d, Control Channel = %d,  .\n",
-						  CentralChannel,
-						  AddHtInfo.ControlChan));
-
-				}
-
-			} else {
-				/* To prevent error, let legacy AP must have same CentralChannel and Channel. */
-				if ((HtCapabilityLen == 0)
-				    && (PreNHtCapabilityLen == 0))
-					pAd->MlmeAux.CentralChannel =
-					    pAd->MlmeAux.Channel;
-
-				pAd->StaActive.SupportedPhyInfo.bHtEnable =
-				    FALSE;
-				pAd->MlmeAux.NewExtChannelOffset = 0xff;
-				RTMPZeroMemory(&pAd->MlmeAux.HtCapability,
-					       SIZE_HT_CAP_IE);
-				pAd->MlmeAux.HtCapabilityLen = 0;
-				RTMPZeroMemory(&pAd->MlmeAux.AddHtInfo,
-					       SIZE_ADD_HT_INFO_IE);
-			}
-
-			RTMPUpdateMlmeRate(pAd);
-
-			/* copy QOS related information */
-			if ((pAd->CommonCfg.bWmmCapable)
-			    || (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-			    ) {
-				NdisMoveMemory(&pAd->MlmeAux.APEdcaParm,
-					       &EdcaParm, sizeof(struct rt_edca_parm));
-				NdisMoveMemory(&pAd->MlmeAux.APQbssLoad,
-					       &QbssLoad,
-					       sizeof(struct rt_qbss_load_parm));
-				NdisMoveMemory(&pAd->MlmeAux.APQosCapability,
-					       &QosCapability,
-					       sizeof(struct rt_qos_capability_parm));
-			} else {
-				NdisZeroMemory(&pAd->MlmeAux.APEdcaParm,
-					       sizeof(struct rt_edca_parm));
-				NdisZeroMemory(&pAd->MlmeAux.APQbssLoad,
-					       sizeof(struct rt_qbss_load_parm));
-				NdisZeroMemory(&pAd->MlmeAux.APQosCapability,
-					       sizeof(struct rt_qos_capability_parm));
-			}
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("SYNC - after JOIN, SupRateLen=%d, ExtRateLen=%d\n",
-				  pAd->MlmeAux.SupRateLen,
-				  pAd->MlmeAux.ExtRateLen));
-
-			if (AironetCellPowerLimit != 0xFF) {
-				/*We need to change our TxPower for CCX 2.0 AP Control of Client Transmit Power */
-				ChangeToCellPowerLimit(pAd,
-						       AironetCellPowerLimit);
-			} else	/*Used the default TX Power Percentage. */
-				pAd->CommonCfg.TxPowerPercentage =
-				    pAd->CommonCfg.TxPowerDefault;
-
-			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-			Status = MLME_SUCCESS;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF,
-				    2, &Status);
-		}
-		/* not to me BEACON, ignored */
-	}
-	/* sanity check fail, ignore this frame */
-}
-
-/*
-	==========================================================================
-	Description:
-		receive BEACON from peer
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void PeerBeacon(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	char Ssid[MAX_LEN_OF_SSID];
-	struct rt_cf_parm CfParm;
-	u8 SsidLen, MessageToMe = 0, BssType, Channel, NewChannel, index = 0;
-	u8 DtimCount = 0, DtimPeriod = 0, BcastFlag = 0;
-	u16 CapabilityInfo, AtimWin, BeaconPeriod;
-	LARGE_INTEGER TimeStamp;
-	u16 TbttNumToNextWakeUp;
-	u8 Erp;
-	u8 SupRate[MAX_LEN_OF_SUPPORTED_RATES],
-	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	u8 SupRateLen, ExtRateLen;
-	u8 CkipFlag;
-	u16 LenVIE;
-	u8 AironetCellPowerLimit;
-	struct rt_edca_parm EdcaParm;
-	struct rt_qbss_load_parm QbssLoad;
-	struct rt_qos_capability_parm QosCapability;
-	unsigned long RalinkIe;
-	/* New for WPA security suites */
-	u8 VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
-	struct rt_ndis_802_11_variable_ies *pVIE = NULL;
-	struct rt_ht_capability_ie HtCapability;
-	struct rt_add_ht_info_ie AddHtInfo;	/* AP might use this additional ht info IE */
-	u8 HtCapabilityLen, PreNHtCapabilityLen;
-	u8 AddHtInfoLen;
-	u8 NewExtChannelOffset = 0xff;
-
-	if (!(INFRA_ON(pAd) || ADHOC_ON(pAd)
-	    ))
-		return;
-
-	/* Init Variable IE structure */
-	pVIE = (struct rt_ndis_802_11_variable_ies *)VarIE;
-	pVIE->Length = 0;
-	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
-	RTMPZeroMemory(&AddHtInfo, sizeof(struct rt_add_ht_info_ie));
-
-	if (PeerBeaconAndProbeRspSanity(pAd,
-					Elem->Msg,
-					Elem->MsgLen,
-					Elem->Channel,
-					Addr2,
-					Bssid,
-					Ssid,
-					&SsidLen,
-					&BssType,
-					&BeaconPeriod,
-					&Channel,
-					&NewChannel,
-					&TimeStamp,
-					&CfParm,
-					&AtimWin,
-					&CapabilityInfo,
-					&Erp,
-					&DtimCount,
-					&DtimPeriod,
-					&BcastFlag,
-					&MessageToMe,
-					SupRate,
-					&SupRateLen,
-					ExtRate,
-					&ExtRateLen,
-					&CkipFlag,
-					&AironetCellPowerLimit,
-					&EdcaParm,
-					&QbssLoad,
-					&QosCapability,
-					&RalinkIe,
-					&HtCapabilityLen,
-					&PreNHtCapabilityLen,
-					&HtCapability,
-					&AddHtInfoLen,
-					&AddHtInfo,
-					&NewExtChannelOffset, &LenVIE, pVIE)) {
-		BOOLEAN is_my_bssid, is_my_ssid;
-		unsigned long Bssidx, Now;
-		struct rt_bss_entry *pBss;
-		char RealRssi =
-		    RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
-				ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
-				ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
-
-		is_my_bssid =
-		    MAC_ADDR_EQUAL(Bssid, pAd->CommonCfg.Bssid) ? TRUE : FALSE;
-		is_my_ssid =
-		    SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
-			       pAd->CommonCfg.SsidLen) ? TRUE : FALSE;
-
-		/* ignore BEACON not for my SSID */
-		if ((!is_my_ssid) && (!is_my_bssid))
-			return;
-
-		/* It means STA waits disassoc completely from this AP, ignores this beacon. */
-		if (pAd->Mlme.CntlMachine.CurrState == CNTL_WAIT_DISASSOC)
-			return;
-
-		/* Copy Control channel for this BSSID. */
-		if (AddHtInfoLen != 0)
-			Channel = AddHtInfo.ControlChan;
-
-		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
-			HtCapabilityLen = SIZE_HT_CAP_IE;
-
-		/* */
-		/* Housekeeping "SsidBssTab" table for later-on ROAMing usage. */
-		/* */
-		Bssidx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
-		if (Bssidx == BSS_NOT_FOUND) {
-			/* discover new AP of this network, create BSS entry */
-			Bssidx =
-			    BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid,
-					     SsidLen, BssType, BeaconPeriod,
-					     &CfParm, AtimWin, CapabilityInfo,
-					     SupRate, SupRateLen, ExtRate,
-					     ExtRateLen, &HtCapability,
-					     &AddHtInfo, HtCapabilityLen,
-					     AddHtInfoLen, NewExtChannelOffset,
-					     Channel, RealRssi, TimeStamp,
-					     CkipFlag, &EdcaParm,
-					     &QosCapability, &QbssLoad, LenVIE,
-					     pVIE);
-			if (Bssidx == BSS_NOT_FOUND)	/* return if BSS table full */
-				return;
-
-			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF,
-				       &Elem->Msg[24], 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[0],
-				       &Elem->TimeStamp.u.LowPart, 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[4],
-				       &Elem->TimeStamp.u.LowPart, 4);
-
-		}
-
-		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
-		    && (Channel != NewChannel)) {
-			/* Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection). */
-			/* In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results. */
-			AsicSwitchChannel(pAd, 1, FALSE);
-			AsicLockChannel(pAd, 1);
-			LinkDown(pAd, FALSE);
-			MlmeQueueInit(&pAd->Mlme.Queue);
-			BssTableInit(&pAd->ScanTab);
-			RTMPusecDelay(1000000);	/* use delay to prevent STA do reassoc */
-
-			/* channel sanity check */
-			for (index = 0; index < pAd->ChannelListNum; index++) {
-				if (pAd->ChannelList[index].Channel ==
-				    NewChannel) {
-					pAd->ScanTab.BssEntry[Bssidx].Channel =
-					    NewChannel;
-					pAd->CommonCfg.Channel = NewChannel;
-					AsicSwitchChannel(pAd,
-							  pAd->CommonCfg.
-							  Channel, FALSE);
-					AsicLockChannel(pAd,
-							pAd->CommonCfg.Channel);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("PeerBeacon - STA receive channel switch announcement IE (New Channel =%d)\n",
-						  NewChannel));
-					break;
-				}
-			}
-
-			if (index >= pAd->ChannelListNum) {
-				DBGPRINT_ERR("PeerBeacon(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum);
-			}
-		}
-		/* if the ssid matched & bssid unmatched, we should select the bssid with large value. */
-		/* This might happened when two STA start at the same time */
-		if ((!is_my_bssid) && ADHOC_ON(pAd)) {
-			int i;
-
-			/* Add the safeguard against the mismatch of adhoc wep status */
-			if (pAd->StaCfg.WepStatus !=
-			    pAd->ScanTab.BssEntry[Bssidx].WepStatus) {
-				return;
-			}
-			/* collapse into the ADHOC network which has bigger BSSID value. */
-			for (i = 0; i < 6; i++) {
-				if (Bssid[i] > pAd->CommonCfg.Bssid[i]) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						("SYNC - merge to the IBSS "
-							"with bigger BSSID="
-							"%pM\n", Bssid));
-					AsicDisableSync(pAd);
-					COPY_MAC_ADDR(pAd->CommonCfg.Bssid,
-						      Bssid);
-					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
-					MakeIbssBeacon(pAd);	/* re-build BEACON frame */
-					AsicEnableIbssSync(pAd);	/* copy BEACON frame to on-chip memory */
-					is_my_bssid = TRUE;
-					break;
-				} else if (Bssid[i] < pAd->CommonCfg.Bssid[i])
-					break;
-			}
-		}
-
-		NdisGetSystemUpTime(&Now);
-		pBss = &pAd->ScanTab.BssEntry[Bssidx];
-		pBss->Rssi = RealRssi;	/* lastest RSSI */
-		pBss->LastBeaconRxTime = Now;	/* last RX timestamp */
-
-		/* */
-		/* BEACON from my BSSID - either IBSS or INFRA network */
-		/* */
-		if (is_my_bssid) {
-			struct rt_rxwi RxWI;
-
-			pAd->StaCfg.DtimCount = DtimCount;
-			pAd->StaCfg.DtimPeriod = DtimPeriod;
-			pAd->StaCfg.LastBeaconRxTime = Now;
-
-			RxWI.RSSI0 = Elem->Rssi0;
-			RxWI.RSSI1 = Elem->Rssi1;
-			RxWI.RSSI2 = Elem->Rssi2;
-
-			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, &RxWI);
-			if (AironetCellPowerLimit != 0xFF) {
-				/* */
-				/* We get the Cisco (ccx) "TxPower Limit" required */
-				/* Changed to appropriate TxPower Limit for Ciso Compatible Extensions */
-				/* */
-				ChangeToCellPowerLimit(pAd,
-						       AironetCellPowerLimit);
-			} else {
-				/* */
-				/* AironetCellPowerLimit equal to 0xFF means the Cisco (ccx) "TxPower Limit" not exist. */
-				/* Used the default TX Power Percentage, that set from UI. */
-				/* */
-				pAd->CommonCfg.TxPowerPercentage =
-				    pAd->CommonCfg.TxPowerDefault;
-			}
-
-			if (ADHOC_ON(pAd) && (CAP_IS_IBSS_ON(CapabilityInfo))) {
-				u8 MaxSupportedRateIn500Kbps = 0;
-				u8 idx;
-				struct rt_mac_table_entry *pEntry;
-
-				/* supported rates array may not be sorted. sort it and find the maximum rate */
-				for (idx = 0; idx < SupRateLen; idx++) {
-					if (MaxSupportedRateIn500Kbps <
-					    (SupRate[idx] & 0x7f))
-						MaxSupportedRateIn500Kbps =
-						    SupRate[idx] & 0x7f;
-				}
-
-				for (idx = 0; idx < ExtRateLen; idx++) {
-					if (MaxSupportedRateIn500Kbps <
-					    (ExtRate[idx] & 0x7f))
-						MaxSupportedRateIn500Kbps =
-						    ExtRate[idx] & 0x7f;
-				}
-
-				/* look up the existing table */
-				pEntry = MacTableLookup(pAd, Addr2);
-
-				/* Ad-hoc mode is using MAC address as BA session. So we need to continuously find newly joined adhoc station by receiving beacon. */
-				/* To prevent always check this, we use wcid == RESERVED_WCID to recognize it as newly joined adhoc station. */
-				if ((ADHOC_ON(pAd)
-				     && (Elem->Wcid == RESERVED_WCID))
-				    || (pEntry
-					&&
-					((pEntry->LastBeaconRxTime +
-					  ADHOC_ENTRY_BEACON_LOST_TIME) <
-					 Now))) {
-					if (pEntry == NULL)
-						/* Another adhoc joining, add to our MAC table. */
-						pEntry =
-						    MacTableInsertEntry(pAd,
-									Addr2,
-									BSS0,
-									FALSE);
-
-					if (StaAddMacTableEntry(pAd,
-								pEntry,
-								MaxSupportedRateIn500Kbps,
-								&HtCapability,
-								HtCapabilityLen,
-								&AddHtInfo,
-								AddHtInfoLen,
-								CapabilityInfo)
-					    == FALSE) {
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("ADHOC - Add Entry failed.\n"));
-						return;
-					}
-
-					if (pEntry &&
-					    (Elem->Wcid == RESERVED_WCID)) {
-						idx = pAd->StaCfg.DefaultKeyId;
-						RTMP_STA_SECURITY_INFO_ADD(pAd,
-									   BSS0,
-									   idx,
-									   pEntry);
-					}
-				}
-
-				if (pEntry && pEntry->ValidAsCLI)
-					pEntry->LastBeaconRxTime = Now;
-
-				/* At least another peer in this IBSS, declare MediaState as CONNECTED */
-				if (!OPSTATUS_TEST_FLAG
-				    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-					OPSTATUS_SET_FLAG(pAd,
-							  fOP_STATUS_MEDIA_STATE_CONNECTED);
-
-					pAd->IndicateMediaState =
-					    NdisMediaStateConnected;
-					RTMP_IndicateMediaState(pAd);
-					pAd->ExtraInfo = GENERAL_LINK_UP;
-					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
-
-					/* 2003/03/12 - john */
-					/* Make sure this entry in "ScanTab" table, thus complies to Microsoft's policy that */
-					/* "site survey" result should always include the current connected network. */
-					/* */
-					Bssidx =
-					    BssTableSearch(&pAd->ScanTab, Bssid,
-							   Channel);
-					if (Bssidx == BSS_NOT_FOUND) {
-						Bssidx =
-						    BssTableSetEntry(pAd,
-								     &pAd->
-								     ScanTab,
-								     Bssid,
-								     Ssid,
-								     SsidLen,
-								     BssType,
-								     BeaconPeriod,
-								     &CfParm,
-								     AtimWin,
-								     CapabilityInfo,
-								     SupRate,
-								     SupRateLen,
-								     ExtRate,
-								     ExtRateLen,
-								     &HtCapability,
-								     &AddHtInfo,
-								     HtCapabilityLen,
-								     AddHtInfoLen,
-								     NewExtChannelOffset,
-								     Channel,
-								     RealRssi,
-								     TimeStamp,
-								     0,
-								     &EdcaParm,
-								     &QosCapability,
-								     &QbssLoad,
-								     LenVIE,
-								     pVIE);
-					}
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("ADHOC  fOP_STATUS_MEDIA_STATE_CONNECTED.\n"));
-				}
-			}
-
-			if (INFRA_ON(pAd)) {
-				BOOLEAN bUseShortSlot, bUseBGProtection;
-
-				/* decide to use/change to - */
-				/*      1. long slot (20 us) or short slot (9 us) time */
-				/*      2. turn on/off RTS/CTS and/or CTS-to-self protection */
-				/*      3. short preamble */
-
-				/*bUseShortSlot = pAd->CommonCfg.bUseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo); */
-				bUseShortSlot =
-				    CAP_IS_SHORT_SLOT(CapabilityInfo);
-				if (bUseShortSlot !=
-				    OPSTATUS_TEST_FLAG(pAd,
-						       fOP_STATUS_SHORT_SLOT_INUSED))
-					AsicSetSlotTime(pAd, bUseShortSlot);
-
-				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||	/* always use */
-				    ((pAd->CommonCfg.UseBGProtection == 0)
-				     && ERP_IS_USE_PROTECTION(Erp));
-
-				if (pAd->CommonCfg.Channel > 14)	/* always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP */
-					bUseBGProtection = FALSE;
-
-				if (bUseBGProtection !=
-				    OPSTATUS_TEST_FLAG(pAd,
-						       fOP_STATUS_BG_PROTECTION_INUSED))
-				{
-					if (bUseBGProtection) {
-						OPSTATUS_SET_FLAG(pAd,
-								  fOP_STATUS_BG_PROTECTION_INUSED);
-						AsicUpdateProtect(pAd,
-								  pAd->MlmeAux.
-								  AddHtInfo.
-								  AddHtInfo2.
-								  OperaionMode,
-								  (OFDMSETPROTECT
-								   |
-								   CCKSETPROTECT
-								   |
-								   ALLN_SETPROTECT),
-								  FALSE,
-								  (pAd->MlmeAux.
-								   AddHtInfo.
-								   AddHtInfo2.
-								   NonGfPresent
-								   == 1));
-					} else {
-						OPSTATUS_CLEAR_FLAG(pAd,
-								    fOP_STATUS_BG_PROTECTION_INUSED);
-						AsicUpdateProtect(pAd,
-								  pAd->MlmeAux.
-								  AddHtInfo.
-								  AddHtInfo2.
-								  OperaionMode,
-								  (OFDMSETPROTECT
-								   |
-								   CCKSETPROTECT
-								   |
-								   ALLN_SETPROTECT),
-								  TRUE,
-								  (pAd->MlmeAux.
-								   AddHtInfo.
-								   AddHtInfo2.
-								   NonGfPresent
-								   == 1));
-					}
-
-					DBGPRINT(RT_DEBUG_WARN,
-						 ("SYNC - AP changed B/G protection to %d\n",
-						  bUseBGProtection));
-				}
-				/* check Ht protection mode. and adhere to the Non-GF device indication by AP. */
-				if ((AddHtInfoLen != 0) &&
-				    ((AddHtInfo.AddHtInfo2.OperaionMode !=
-				      pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-				      OperaionMode)
-				     || (AddHtInfo.AddHtInfo2.NonGfPresent !=
-					 pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					 NonGfPresent))) {
-					pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					    NonGfPresent =
-					    AddHtInfo.AddHtInfo2.NonGfPresent;
-					pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					    OperaionMode =
-					    AddHtInfo.AddHtInfo2.OperaionMode;
-					if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.
-					    NonGfPresent == 1) {
-						AsicUpdateProtect(pAd,
-								  pAd->MlmeAux.
-								  AddHtInfo.
-								  AddHtInfo2.
-								  OperaionMode,
-								  ALLN_SETPROTECT,
-								  FALSE, TRUE);
-					} else
-						AsicUpdateProtect(pAd,
-								  pAd->MlmeAux.
-								  AddHtInfo.
-								  AddHtInfo2.
-								  OperaionMode,
-								  ALLN_SETPROTECT,
-								  FALSE, FALSE);
-
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("SYNC - AP changed N OperaionMode to %d\n",
-						  pAd->MlmeAux.AddHtInfo.
-						  AddHtInfo2.OperaionMode));
-				}
-
-				if (OPSTATUS_TEST_FLAG
-				    (pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)
-				    && ERP_IS_USE_BARKER_PREAMBLE(Erp)) {
-					MlmeSetTxPreamble(pAd,
-							  Rt802_11PreambleLong);
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("SYNC - AP forced to use long preamble\n"));
-				}
-
-				if (OPSTATUS_TEST_FLAG
-				    (pAd, fOP_STATUS_WMM_INUSED)
-				    && (EdcaParm.bValid == TRUE)
-				    && (EdcaParm.EdcaUpdateCount !=
-					pAd->CommonCfg.APEdcaParm.
-					EdcaUpdateCount)) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("SYNC - AP change EDCA parameters(from %d to %d)\n",
-						  pAd->CommonCfg.APEdcaParm.
-						  EdcaUpdateCount,
-						  EdcaParm.EdcaUpdateCount));
-					AsicSetEdcaParm(pAd, &EdcaParm);
-				}
-				/* copy QOS related information */
-				NdisMoveMemory(&pAd->CommonCfg.APQbssLoad,
-					       &QbssLoad,
-					       sizeof(struct rt_qbss_load_parm));
-				NdisMoveMemory(&pAd->CommonCfg.APQosCapability,
-					       &QosCapability,
-					       sizeof(struct rt_qos_capability_parm));
-			}
-			/* only INFRASTRUCTURE mode support power-saving feature */
-			if ((INFRA_ON(pAd) && (pAd->StaCfg.Psm == PWR_SAVE))
-			    || (pAd->CommonCfg.bAPSDForcePowerSave)) {
-				u8 FreeNumber;
-				/*  1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL */
-				/*  2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE */
-				/*  3. we have outgoing frames in TxRing or MgmtRing, better stay AWAKE */
-				/*  4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE */
-				/*  5. otherwise, put PHY back to sleep to save battery. */
-				if (MessageToMe) {
-#ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG
-					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
-						/* Restore to correct BBP R3 value */
-						if (pAd->Antenna.field.RxPath >
-						    1)
-							RTMP_BBP_IO_WRITE8_BY_REG_ID
-							    (pAd, BBP_R3,
-							     pAd->StaCfg.BBPR3);
-						/* Turn clk to 80Mhz. */
-					}
-#endif /* RTMP_MAC_PCI // */
-					if (pAd->CommonCfg.bAPSDCapable
-					    && pAd->CommonCfg.APEdcaParm.
-					    bAPSDCapable
-					    && pAd->CommonCfg.bAPSDAC_BE
-					    && pAd->CommonCfg.bAPSDAC_BK
-					    && pAd->CommonCfg.bAPSDAC_VI
-					    && pAd->CommonCfg.bAPSDAC_VO) {
-						pAd->CommonCfg.
-						    bNeedSendTriggerFrame =
-						    TRUE;
-					} else
-						RTMP_PS_POLL_ENQUEUE(pAd);
-				} else if (BcastFlag && (DtimCount == 0)
-					   && OPSTATUS_TEST_FLAG(pAd,
-								 fOP_STATUS_RECEIVE_DTIM))
-				{
-#ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG
-					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
-						if (pAd->Antenna.field.RxPath >
-						    1)
-							RTMP_BBP_IO_WRITE8_BY_REG_ID
-							    (pAd, BBP_R3,
-							     pAd->StaCfg.BBPR3);
-					}
-#endif /* RTMP_MAC_PCI // */
-				} else
-				    if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)
-					|| (pAd->TxSwQueue[QID_AC_BE].Number !=
-					    0)
-					|| (pAd->TxSwQueue[QID_AC_VI].Number !=
-					    0)
-					|| (pAd->TxSwQueue[QID_AC_VO].Number !=
-					    0)
-					||
-					(RTMPFreeTXDRequest
-					 (pAd, QID_AC_BK, TX_RING_SIZE - 1,
-					  &FreeNumber) != NDIS_STATUS_SUCCESS)
-					||
-					(RTMPFreeTXDRequest
-					 (pAd, QID_AC_BE, TX_RING_SIZE - 1,
-					  &FreeNumber) != NDIS_STATUS_SUCCESS)
-					||
-					(RTMPFreeTXDRequest
-					 (pAd, QID_AC_VI, TX_RING_SIZE - 1,
-					  &FreeNumber) != NDIS_STATUS_SUCCESS)
-					||
-					(RTMPFreeTXDRequest
-					 (pAd, QID_AC_VO, TX_RING_SIZE - 1,
-					  &FreeNumber) != NDIS_STATUS_SUCCESS)
-					||
-					(RTMPFreeTXDRequest
-					 (pAd, QID_MGMT, MGMT_RING_SIZE - 1,
-					  &FreeNumber) !=
-					 NDIS_STATUS_SUCCESS)) {
-					/* TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme */
-					/* can we cheat here (i.e. just check MGMT & AC_BE) for better performance? */
-#ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG
-					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
-						if (pAd->Antenna.field.RxPath >
-						    1)
-							RTMP_BBP_IO_WRITE8_BY_REG_ID
-							    (pAd, BBP_R3,
-							     pAd->StaCfg.BBPR3);
-					}
-#endif /* RTMP_MAC_PCI // */
-				} else {
-					if ((pAd->CommonCfg.
-					     bACMAPSDTr[QID_AC_VO])
-					    || (pAd->CommonCfg.
-						bACMAPSDTr[QID_AC_VI])
-					    || (pAd->CommonCfg.
-						bACMAPSDTr[QID_AC_BK])
-					    || (pAd->CommonCfg.
-						bACMAPSDTr[QID_AC_BE])) {
-						/*
-						   WMM Spec v1.0 3.6.2.4,
-						   The WMM STA shall remain awake until it receives a
-						   QoS Data or Null frame addressed to it, with the
-						   EOSP subfield in QoS Control field set to 1.
-
-						   So we can not sleep here or we will suffer a case:
-
-						   PS Management Frame -->
-						   Trigger frame -->
-						   Beacon (TIM=0) (Beacon is closer to Trig frame) -->
-						   Station goes to sleep -->
-						   AP delivery queued UAPSD packets -->
-						   Station can NOT receive the reply
-
-						   Maybe we need a timeout timer to avoid that we do
-						   NOT receive the EOSP frame.
-
-						   We can not use More Data to check if SP is ended
-						   due to MaxSPLength.
-						 */
-					} else {
-						u16 NextDtim = DtimCount;
-
-						if (NextDtim == 0)
-							NextDtim = DtimPeriod;
-
-						TbttNumToNextWakeUp =
-						    pAd->StaCfg.
-						    DefaultListenCount;
-						if (OPSTATUS_TEST_FLAG
-						    (pAd,
-						     fOP_STATUS_RECEIVE_DTIM)
-						    && (TbttNumToNextWakeUp >
-							NextDtim))
-							TbttNumToNextWakeUp =
-							    NextDtim;
-
-						if (!OPSTATUS_TEST_FLAG
-						    (pAd, fOP_STATUS_DOZE)) {
-							/* Set a flag to go to sleep . Then after parse this RxDoneInterrupt, will go to sleep mode. */
-							pAd->
-							    ThisTbttNumToNextWakeUp
-							    =
-							    TbttNumToNextWakeUp;
-							AsicSleepThenAutoWakeup
-							    (pAd,
-							     pAd->
-							     ThisTbttNumToNextWakeUp);
-						}
-					}
-				}
-			}
-		}
-		/* not my BSSID, ignore it */
-	}
-	/* sanity check fail, ignore this frame */
-}
-
-/*
-	==========================================================================
-	Description:
-		Receive PROBE REQ from remote peer when operating in IBSS mode
-	==========================================================================
- */
-void PeerProbeReqAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 Addr2[MAC_ADDR_LEN];
-	char Ssid[MAX_LEN_OF_SSID];
-	u8 SsidLen;
-	u8 HtLen, AddHtLen, NewExtLen;
-	struct rt_header_802_11 ProbeRspHdr;
-	int NStatus;
-	u8 *pOutBuffer = NULL;
-	unsigned long FrameLen = 0;
-	LARGE_INTEGER FakeTimestamp;
-	u8 DsLen = 1, IbssLen = 2;
-	u8 LocalErpIe[3] = { IE_ERP, 1, 0 };
-	BOOLEAN Privacy;
-	u16 CapabilityInfo;
-	u8 RSNIe = IE_WPA;
-
-	if (!ADHOC_ON(pAd))
-		return;
-
-	if (PeerProbeReqSanity
-	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, Ssid, &SsidLen)) {
-		if ((SsidLen == 0)
-		    || SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
-				  pAd->CommonCfg.SsidLen)) {
-			/* allocate and send out ProbeRsp frame */
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-			if (NStatus != NDIS_STATUS_SUCCESS)
-				return;
-
-			/*pAd->StaCfg.AtimWin = 0;  // ?????? */
-
-			Privacy =
-			    (pAd->StaCfg.WepStatus ==
-			     Ndis802_11Encryption1Enabled)
-			    || (pAd->StaCfg.WepStatus ==
-				Ndis802_11Encryption2Enabled)
-			    || (pAd->StaCfg.WepStatus ==
-				Ndis802_11Encryption3Enabled);
-			CapabilityInfo =
-			    CAP_GENERATE(0, 1, Privacy,
-					 (pAd->CommonCfg.TxPreamble ==
-					  Rt802_11PreambleShort), 0, 0);
-
-			MakeOutgoingFrame(pOutBuffer, &FrameLen,
-					  sizeof(struct rt_header_802_11), &ProbeRspHdr,
-					  TIMESTAMP_LEN, &FakeTimestamp,
-					  2, &pAd->CommonCfg.BeaconPeriod,
-					  2, &CapabilityInfo,
-					  1, &SsidIe,
-					  1, &pAd->CommonCfg.SsidLen,
-					  pAd->CommonCfg.SsidLen,
-					  pAd->CommonCfg.Ssid, 1, &SupRateIe, 1,
-					  &pAd->StaActive.SupRateLen,
-					  pAd->StaActive.SupRateLen,
-					  pAd->StaActive.SupRate, 1, &DsIe, 1,
-					  &DsLen, 1, &pAd->CommonCfg.Channel, 1,
-					  &IbssIe, 1, &IbssLen, 2,
-					  &pAd->StaActive.AtimWin, END_OF_ARGS);
-
-			if (pAd->StaActive.ExtRateLen) {
-				unsigned long tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-						  3, LocalErpIe,
-						  1, &ExtRateIe,
-						  1, &pAd->StaActive.ExtRateLen,
-						  pAd->StaActive.ExtRateLen,
-						  &pAd->StaActive.ExtRate,
-						  END_OF_ARGS);
-				FrameLen += tmp;
-			}
-			/* If adhoc secruity is set for WPA-None, append the cipher suite IE */
-			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
-				unsigned long tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-						  1, &RSNIe,
-						  1, &pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSN_IE,
-						  END_OF_ARGS);
-				FrameLen += tmp;
-			}
-
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
-				unsigned long TmpLen;
-				u8 BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
-				HtLen = sizeof(pAd->CommonCfg.HtCapability);
-				AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
-				NewExtLen = 1;
-				/*New extension channel offset IE is included in Beacon, Probe Rsp or channel Switch Announcement Frame */
-				if (pAd->bBroadComHT == TRUE) {
-					MakeOutgoingFrame(pOutBuffer + FrameLen,
-							  &TmpLen, 1, &WpaIe, 4,
-							  &BROADCOM[0],
-							  pAd->MlmeAux.
-							  HtCapabilityLen,
-							  &pAd->MlmeAux.
-							  HtCapability,
-							  END_OF_ARGS);
-				} else {
-					MakeOutgoingFrame(pOutBuffer + FrameLen,
-							  &TmpLen, 1, &HtCapIe,
-							  1, &HtLen,
-							  sizeof
-							  (struct rt_ht_capability_ie),
-							  &pAd->CommonCfg.
-							  HtCapability, 1,
-							  &AddHtInfoIe, 1,
-							  &AddHtLen,
-							  sizeof
-							  (struct rt_add_ht_info_ie),
-							  &pAd->CommonCfg.
-							  AddHTInfo, 1,
-							  &NewExtChanIe, 1,
-							  &NewExtLen,
-							  sizeof
-							  (struct rt_new_ext_chan_ie),
-							  &pAd->CommonCfg.
-							  NewExtChanOffset,
-							  END_OF_ARGS);
-				}
-				FrameLen += TmpLen;
-			}
-
-			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-			MlmeFreeMemory(pAd, pOutBuffer);
-		}
-	}
-}
-
-void BeaconTimeoutAtJoinAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BeaconTimeoutAtJoinAction\n"));
-	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-	Status = MLME_REJ_TIMEOUT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-		Scan timeout procedure. basically add channel index by 1 and rescan
-	==========================================================================
- */
-void ScanTimeoutAction(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
-
-	/* Only one channel scanned for CISCO beacon request */
-	if ((pAd->MlmeAux.ScanType == SCAN_CISCO_ACTIVE) ||
-	    (pAd->MlmeAux.ScanType == SCAN_CISCO_PASSIVE) ||
-	    (pAd->MlmeAux.ScanType == SCAN_CISCO_NOISE) ||
-	    (pAd->MlmeAux.ScanType == SCAN_CISCO_CHANNEL_LOAD))
-		pAd->MlmeAux.Channel = 0;
-
-	/* this routine will stop if pAd->MlmeAux.Channel == 0 */
-	ScanNextChannel(pAd);
-}
-
-/*
-	==========================================================================
-	Description:
-	==========================================================================
- */
-void InvalidStateWhenScan(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("AYNC - InvalidStateWhenScan(state=%ld). Reset SYNC machine\n",
-		  pAd->Mlme.SyncMachine.CurrState));
-	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-	==========================================================================
- */
-void InvalidStateWhenJoin(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("InvalidStateWhenJoin(state=%ld). Reset SYNC machine\n",
-		  pAd->Mlme.SyncMachine.CurrState));
-	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-	==========================================================================
- */
-void InvalidStateWhenStart(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u16 Status;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("InvalidStateWhenStart(state=%ld). Reset SYNC machine\n",
-		  pAd->Mlme.SyncMachine.CurrState));
-	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
-	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
-}
-
-/*
-	==========================================================================
-	Description:
-
-	IRQL = DISPATCH_LEVEL
-
-	==========================================================================
- */
-void EnqueuePsPoll(struct rt_rtmp_adapter *pAd)
-{
-
-	if (pAd->StaCfg.WindowsPowerMode == Ndis802_11PowerModeLegacy_PSP)
-		pAd->PsPollFrame.FC.PwrMgmt = PWR_SAVE;
-	MiniportMMRequest(pAd, 0, (u8 *)& pAd->PsPollFrame,
-			  sizeof(struct rt_pspoll_frame));
-}
-
-/*
-	==========================================================================
-	Description:
-	==========================================================================
- */
-void EnqueueProbeRequest(struct rt_rtmp_adapter *pAd)
-{
-	int NState;
-	u8 *pOutBuffer;
-	unsigned long FrameLen = 0;
-	struct rt_header_802_11 Hdr80211;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("force out a ProbeRequest ...\n"));
-
-	NState = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
-	if (NState == NDIS_STATUS_SUCCESS) {
-		MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0,
-				 BROADCAST_ADDR, BROADCAST_ADDR);
-
-		/* this ProbeRequest explicitly specify SSID to reduce unwanted ProbeResponse */
-		MakeOutgoingFrame(pOutBuffer, &FrameLen,
-				  sizeof(struct rt_header_802_11), &Hdr80211,
-				  1, &SsidIe,
-				  1, &pAd->CommonCfg.SsidLen,
-				  pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid,
-				  1, &SupRateIe,
-				  1, &pAd->StaActive.SupRateLen,
-				  pAd->StaActive.SupRateLen,
-				  pAd->StaActive.SupRate, END_OF_ARGS);
-		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-		MlmeFreeMemory(pAd, pOutBuffer);
-	}
-
-}
-
-BOOLEAN ScanRunning(struct rt_rtmp_adapter *pAd)
-{
-	return (pAd->Mlme.SyncMachine.CurrState == SCAN_LISTEN) ? TRUE : FALSE;
-}
diff --git a/drivers/staging/rt2860/sta/wpa.c b/drivers/staging/rt2860/sta/wpa.c
deleted file mode 100644
index ff34832..0000000
--- a/drivers/staging/rt2860/sta/wpa.c
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	wpa.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Jan	Lee		03-07-22		Initial
-	Paul Lin		03-11-28		Modify for supplicant
-	Justin P. Mattock	11/07/2010		Fix typos
-*/
-#include "../rt_config.h"
-
-void inc_byte_array(u8 * counter, int len);
-
-/*
-	========================================================================
-
-	Routine Description:
-		Process MIC error indication and record MIC error timer.
-
-	Arguments:
-		pAd 	Pointer to our adapter
-		pWpaKey 		Pointer to the WPA key structure
-
-	Return Value:
-		None
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-void RTMPReportMicError(struct rt_rtmp_adapter *pAd, struct rt_cipher_key *pWpaKey)
-{
-	unsigned long Now;
-	u8 unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1 : 0);
-
-	/* Record Last MIC error time and count */
-	NdisGetSystemUpTime(&Now);
-	if (pAd->StaCfg.MicErrCnt == 0) {
-		pAd->StaCfg.MicErrCnt++;
-		pAd->StaCfg.LastMicErrorTime = Now;
-		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
-	} else if (pAd->StaCfg.MicErrCnt == 1) {
-		if ((pAd->StaCfg.LastMicErrorTime + (60 * OS_HZ)) < Now) {
-			/* Update Last MIC error time, this did not violate two MIC errors within 60 seconds */
-			pAd->StaCfg.LastMicErrorTime = Now;
-		} else {
-
-			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd,
-						      IW_COUNTER_MEASURES_EVENT_FLAG,
-						      pAd->MacTab.
-						      Content[BSSID_WCID].Addr,
-						      BSS0, 0);
-
-			pAd->StaCfg.LastMicErrorTime = Now;
-			/* Violate MIC error counts, MIC countermeasures kicks in */
-			pAd->StaCfg.MicErrCnt++;
-			/* We shall block all reception */
-			/* We shall clean all Tx ring and disassociate from AP after next EAPOL frame */
-			/* */
-			/* No necessary to clean all Tx ring, on RTMPHardTransmit will stop sending non-802.1X EAPOL packets */
-			/* if pAd->StaCfg.MicErrCnt greater than 2. */
-			/* */
-			/* RTMPRingCleanUp(pAd, QID_AC_BK); */
-			/* RTMPRingCleanUp(pAd, QID_AC_BE); */
-			/* RTMPRingCleanUp(pAd, QID_AC_VI); */
-			/* RTMPRingCleanUp(pAd, QID_AC_VO); */
-			/* RTMPRingCleanUp(pAd, QID_HCCA); */
-		}
-	} else {
-		/* MIC error count >= 2 */
-		/* This should not happen */
-		;
-	}
-	MlmeEnqueue(pAd,
-		    MLME_CNTL_STATE_MACHINE,
-		    OID_802_11_MIC_FAILURE_REPORT_FRAME, 1, &unicastKey);
-
-	if (pAd->StaCfg.MicErrCnt == 2) {
-		RTMPSetTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, 100);
-	}
-}
-
-#define	LENGTH_EAP_H    4
-/* If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)). */
-int WpaCheckEapCode(struct rt_rtmp_adapter *pAd,
-		    u8 *pFrame, u16 FrameLen, u16 OffSet)
-{
-
-	u8 *pData;
-	int result = 0;
-
-	if (FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H)
-		return result;
-
-	pData = pFrame + OffSet;	/* skip offset bytes */
-
-	if (*(pData + 1) == EAPPacket)	/* 802.1x header - Packet Type */
-	{
-		result = *(pData + 4);	/* EAP header - Code */
-	}
-
-	return result;
-}
-
-void WpaSendMicFailureToWpaSupplicant(struct rt_rtmp_adapter *pAd, IN BOOLEAN bUnicast)
-{
-	char custom[IW_CUSTOM_MAX] = { 0 };
-
-	sprintf(custom, "MLME-MICHAELMICFAILURE.indication");
-	if (bUnicast)
-		sprintf(custom, "%s unicast", custom);
-
-	RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, -1, NULL, (u8 *)custom,
-				strlen(custom));
-
-	return;
-}
-
-void WpaMicFailureReportFrame(struct rt_rtmp_adapter *pAd, struct rt_mlme_queue_elem *Elem)
-{
-	u8 *pOutBuffer = NULL;
-	u8 Header802_3[14];
-	unsigned long FrameLen = 0;
-	struct rt_eapol_packet Packet;
-	u8 Mic[16];
-	BOOLEAN bUnicast;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("WpaMicFailureReportFrame ----->\n"));
-
-	bUnicast = (Elem->Msg[0] == 1 ? TRUE : FALSE);
-	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
-
-	/* init 802.3 header and Fill Packet */
-	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid,
-			  pAd->CurrentAddress, EAPOL);
-
-	NdisZeroMemory(&Packet, sizeof(Packet));
-	Packet.ProVer = EAPOL_VER;
-	Packet.ProType = EAPOLKey;
-
-	Packet.KeyDesc.Type = WPA1_KEY_DESC;
-
-	/* Request field presented */
-	Packet.KeyDesc.KeyInfo.Request = 1;
-
-	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
-		Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
-	} else			/* TKIP */
-	{
-		Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
-	}
-
-	Packet.KeyDesc.KeyInfo.KeyType = (bUnicast ? PAIRWISEKEY : GROUPKEY);
-
-	/* KeyMic field presented */
-	Packet.KeyDesc.KeyInfo.KeyMic = 1;
-
-	/* Error field presented */
-	Packet.KeyDesc.KeyInfo.Error = 1;
-
-	/* Update packet length after decide Key data payload */
-	SET_u16_TO_ARRARY(Packet.Body_Len, LEN_EAPOL_KEY_MSG)
-	    /* Key Replay Count */
-	    NdisMoveMemory(Packet.KeyDesc.ReplayCounter,
-			   pAd->StaCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
-	inc_byte_array(pAd->StaCfg.ReplayCounter, 8);
-
-	/* Convert to little-endian format. */
-	*((u16 *) & Packet.KeyDesc.KeyInfo) =
-	    cpu2le16(*((u16 *) & Packet.KeyDesc.KeyInfo));
-
-	MlmeAllocateMemory(pAd, (u8 **) & pOutBuffer);	/* allocate memory */
-	if (pOutBuffer == NULL) {
-		return;
-	}
-	/* Prepare EAPOL frame for MIC calculation */
-	/* Be careful, only EAPOL frame is counted for MIC calculation */
-	MakeOutgoingFrame(pOutBuffer, &FrameLen,
-			  CONV_ARRARY_TO_u16(Packet.Body_Len) + 4, &Packet,
-			  END_OF_ARGS);
-
-	/* Prepare and Fill MIC value */
-	NdisZeroMemory(Mic, sizeof(Mic));
-	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {	/* AES */
-		u8 digest[20] = { 0 };
-		HMAC_SHA1(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
-			  digest, SHA1_DIGEST_SIZE);
-		NdisMoveMemory(Mic, digest, LEN_KEY_DESC_MIC);
-	} else {		/* TKIP */
-		HMAC_MD5(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
-			 Mic, MD5_DIGEST_SIZE);
-	}
-	NdisMoveMemory(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
-
-	/* copy frame to Tx ring and send MIC failure report frame to authenticator */
-	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID],
-			  Header802_3, LENGTH_802_3,
-			  (u8 *)& Packet,
-			  CONV_ARRARY_TO_u16(Packet.Body_Len) + 4, FALSE);
-
-	MlmeFreeMemory(pAd, (u8 *)pOutBuffer);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("WpaMicFailureReportFrame <-----\n"));
-}
-
-/** from wpa_supplicant
- * inc_byte_array - Increment arbitrary length byte array by one
- * @counter: Pointer to byte array
- * @len: Length of the counter in bytes
- *
- * This function increments the last byte of the counter by one and continues
- * rolling over to more significant bytes if the byte was incremented from
- * 0xff to 0x00.
- */
-void inc_byte_array(u8 * counter, int len)
-{
-	int pos = len - 1;
-	while (pos >= 0) {
-		counter[pos]++;
-		if (counter[pos] != 0)
-			break;
-		pos--;
-	}
-}
-
-void WpaDisassocApAndBlockAssoc(void *SystemSpecific1,
-				void *FunctionContext,
-				void *SystemSpecific2,
-				void *SystemSpecific3)
-{
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)FunctionContext;
-	struct rt_mlme_disassoc_req DisassocReq;
-
-	/* disassoc from current AP first */
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("RTMPReportMicError - disassociate with current AP after sending second continuous EAPOL frame\n"));
-	DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
-			 REASON_MIC_FAILURE);
-	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-		    sizeof(struct rt_mlme_disassoc_req), &DisassocReq);
-
-	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-	pAd->StaCfg.bBlockAssoc = TRUE;
-}
-
-void WpaStaPairwiseKeySetting(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_cipher_key *pSharedKey;
-	struct rt_mac_table_entry *pEntry;
-
-	pEntry = &pAd->MacTab.Content[BSSID_WCID];
-
-	/* Pairwise key shall use key#0 */
-	pSharedKey = &pAd->SharedKey[BSS0][0];
-
-	NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
-
-	/* Prepare pair-wise key information into shared key table */
-	NdisZeroMemory(pSharedKey, sizeof(struct rt_cipher_key));
-	pSharedKey->KeyLen = LEN_TKIP_EK;
-	NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
-	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48],
-		       LEN_TKIP_RXMICK);
-	NdisMoveMemory(pSharedKey->TxMic,
-		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
-
-	/* Decide its ChiperAlg */
-	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-		pSharedKey->CipherAlg = CIPHER_TKIP;
-	else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
-		pSharedKey->CipherAlg = CIPHER_AES;
-	else
-		pSharedKey->CipherAlg = CIPHER_NONE;
-
-	/* Update these related information to struct rt_mac_table_entry */
-	NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
-		       LEN_TKIP_EK);
-	NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48],
-		       LEN_TKIP_RXMICK);
-	NdisMoveMemory(pEntry->PairwiseKey.TxMic,
-		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
-	pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
-
-	/* Update pairwise key information to ASIC Shared Key Table */
-	AsicAddSharedKeyEntry(pAd,
-			      BSS0,
-			      0,
-			      pSharedKey->CipherAlg,
-			      pSharedKey->Key,
-			      pSharedKey->TxMic, pSharedKey->RxMic);
-
-	/* Update ASIC WCID attribute table and IVEIV table */
-	RTMPAddWcidAttributeEntry(pAd, BSS0, 0, pSharedKey->CipherAlg, pEntry);
-	STA_PORT_SECURED(pAd);
-	pAd->IndicateMediaState = NdisMediaStateConnected;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("%s : AID(%d) port secured\n", __func__, pEntry->Aid));
-
-}
-
-void WpaStaGroupKeySetting(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_cipher_key *pSharedKey;
-
-	pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
-
-	/* Prepare pair-wise key information into shared key table */
-	NdisZeroMemory(pSharedKey, sizeof(struct rt_cipher_key));
-	pSharedKey->KeyLen = LEN_TKIP_EK;
-	NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
-	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16],
-		       LEN_TKIP_RXMICK);
-	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
-		       LEN_TKIP_TXMICK);
-
-	/* Update Shared Key CipherAlg */
-	pSharedKey->CipherAlg = CIPHER_NONE;
-	if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
-		pSharedKey->CipherAlg = CIPHER_TKIP;
-	else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
-		pSharedKey->CipherAlg = CIPHER_AES;
-	else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled)
-		pSharedKey->CipherAlg = CIPHER_WEP64;
-	else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled)
-		pSharedKey->CipherAlg = CIPHER_WEP128;
-
-	/* Update group key information to ASIC Shared Key Table */
-	AsicAddSharedKeyEntry(pAd,
-			      BSS0,
-			      pAd->StaCfg.DefaultKeyId,
-			      pSharedKey->CipherAlg,
-			      pSharedKey->Key,
-			      pSharedKey->TxMic, pSharedKey->RxMic);
-
-	/* Update ASIC WCID attribute table and IVEIV table */
-	RTMPAddWcidAttributeEntry(pAd,
-				  BSS0,
-				  pAd->StaCfg.DefaultKeyId,
-				  pSharedKey->CipherAlg, NULL);
-
-}
diff --git a/drivers/staging/rt2860/sta_ioctl.c b/drivers/staging/rt2860/sta_ioctl.c
deleted file mode 100644
index 49b1013..0000000
--- a/drivers/staging/rt2860/sta_ioctl.c
+++ /dev/null
@@ -1,2912 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-    Module Name:
-    sta_ioctl.c
-
-    Abstract:
-    IOCTL related subroutines
-
-    Revision History:
-    	Who        		 When          What
-    --------    ----------    ----------------------------------------------
-   	Rory Chen   		01-03-2003    	created
-	Rory Chen   		02-14-2005    	modify to support RT61
-	Justin P. Mattock	11/07/2010	Fix typos
-*/
-
-#include	"rt_config.h"
-
-#ifdef DBG
-extern unsigned long RTDebugLevel;
-#endif
-
-#define NR_WEP_KEYS 				4
-#define WEP_SMALL_KEY_LEN 			(40/8)
-#define WEP_LARGE_KEY_LEN 			(104/8)
-
-#define GROUP_KEY_NO                4
-
-extern u8 CipherWpa2Template[];
-
-struct PACKED rt_version_info {
-	u8 DriverVersionW;
-	u8 DriverVersionX;
-	u8 DriverVersionY;
-	u8 DriverVersionZ;
-	u32 DriverBuildYear;
-	u32 DriverBuildMonth;
-	u32 DriverBuildDay;
-};
-
-static __s32 ralinkrate[] = { 2, 4, 11, 22,	/* CCK */
-	12, 18, 24, 36, 48, 72, 96, 108,	/* OFDM */
-	13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	/* 20MHz, 800ns GI, MCS: 0 ~ 15 */
-	39, 78, 117, 156, 234, 312, 351, 390,	/* 20MHz, 800ns GI, MCS: 16 ~ 23 */
-	27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,	/* 40MHz, 800ns GI, MCS: 0 ~ 15 */
-	81, 162, 243, 324, 486, 648, 729, 810,	/* 40MHz, 800ns GI, MCS: 16 ~ 23 */
-	14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	/* 20MHz, 400ns GI, MCS: 0 ~ 15 */
-	43, 87, 130, 173, 260, 317, 390, 433,	/* 20MHz, 400ns GI, MCS: 16 ~ 23 */
-	30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,	/* 40MHz, 400ns GI, MCS: 0 ~ 15 */
-	90, 180, 270, 360, 540, 720, 810, 900
-};
-
-int Set_SSID_Proc(struct rt_rtmp_adapter *pAdapter, char *arg);
-
-int Set_NetworkType_Proc(struct rt_rtmp_adapter *pAdapter, char *arg);
-
-void RTMPAddKey(struct rt_rtmp_adapter *pAd, struct rt_ndis_802_11_key *pKey)
-{
-	unsigned long KeyIdx;
-	struct rt_mac_table_entry *pEntry;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPAddKey ------>\n"));
-
-	if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-		if (pKey->KeyIndex & 0x80000000) {
-			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
-				NdisZeroMemory(pAd->StaCfg.PMK, 32);
-				NdisMoveMemory(pAd->StaCfg.PMK,
-					       pKey->KeyMaterial,
-					       pKey->KeyLength);
-				goto end;
-			}
-			/* Update PTK */
-			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
-				       sizeof(struct rt_cipher_key));
-			pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key,
-				       pKey->KeyMaterial, LEN_TKIP_EK);
-
-			if (pAd->StaCfg.PairCipher ==
-			    Ndis802_11Encryption2Enabled) {
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK,
-					       LEN_TKIP_TXMICK);
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK +
-					       LEN_TKIP_TXMICK,
-					       LEN_TKIP_RXMICK);
-			} else {
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK,
-					       LEN_TKIP_TXMICK);
-				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK +
-					       LEN_TKIP_TXMICK,
-					       LEN_TKIP_RXMICK);
-			}
-
-			/* Decide its ChiperAlg */
-			if (pAd->StaCfg.PairCipher ==
-			    Ndis802_11Encryption2Enabled)
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-			else if (pAd->StaCfg.PairCipher ==
-				 Ndis802_11Encryption3Enabled)
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-			else
-				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
-
-			/* Update these related information to struct rt_mac_table_entry */
-			pEntry = &pAd->MacTab.Content[BSSID_WCID];
-			NdisMoveMemory(pEntry->PairwiseKey.Key,
-				       pAd->SharedKey[BSS0][0].Key,
-				       LEN_TKIP_EK);
-			NdisMoveMemory(pEntry->PairwiseKey.RxMic,
-				       pAd->SharedKey[BSS0][0].RxMic,
-				       LEN_TKIP_RXMICK);
-			NdisMoveMemory(pEntry->PairwiseKey.TxMic,
-				       pAd->SharedKey[BSS0][0].TxMic,
-				       LEN_TKIP_TXMICK);
-			pEntry->PairwiseKey.CipherAlg =
-			    pAd->SharedKey[BSS0][0].CipherAlg;
-
-			/* Update pairwise key information to ASIC Shared Key Table */
-			AsicAddSharedKeyEntry(pAd,
-					      BSS0,
-					      0,
-					      pAd->SharedKey[BSS0][0].CipherAlg,
-					      pAd->SharedKey[BSS0][0].Key,
-					      pAd->SharedKey[BSS0][0].TxMic,
-					      pAd->SharedKey[BSS0][0].RxMic);
-
-			/* Update ASIC WCID attribute table and IVEIV table */
-			RTMPAddWcidAttributeEntry(pAd,
-						  BSS0,
-						  0,
-						  pAd->SharedKey[BSS0][0].
-						  CipherAlg, pEntry);
-
-			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2) {
-				/* set 802.1x port control */
-				/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-				STA_PORT_SECURED(pAd);
-
-				/* Indicate Connected for GUI */
-				pAd->IndicateMediaState =
-				    NdisMediaStateConnected;
-			}
-		} else {
-			/* Update GTK */
-			pAd->StaCfg.DefaultKeyId = (pKey->KeyIndex & 0xFF);
-			NdisZeroMemory(&pAd->
-				       SharedKey[BSS0][pAd->StaCfg.
-						       DefaultKeyId],
-				       sizeof(struct rt_cipher_key));
-			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen =
-			    LEN_TKIP_EK;
-			NdisMoveMemory(pAd->
-				       SharedKey[BSS0][pAd->StaCfg.
-						       DefaultKeyId].Key,
-				       pKey->KeyMaterial, LEN_TKIP_EK);
-
-			if (pAd->StaCfg.GroupCipher ==
-			    Ndis802_11Encryption2Enabled) {
-				NdisMoveMemory(pAd->
-					       SharedKey[BSS0][pAd->StaCfg.
-							       DefaultKeyId].
-					       RxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK,
-					       LEN_TKIP_TXMICK);
-				NdisMoveMemory(pAd->
-					       SharedKey[BSS0][pAd->StaCfg.
-							       DefaultKeyId].
-					       TxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK +
-					       LEN_TKIP_TXMICK,
-					       LEN_TKIP_RXMICK);
-			} else {
-				NdisMoveMemory(pAd->
-					       SharedKey[BSS0][pAd->StaCfg.
-							       DefaultKeyId].
-					       TxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK,
-					       LEN_TKIP_TXMICK);
-				NdisMoveMemory(pAd->
-					       SharedKey[BSS0][pAd->StaCfg.
-							       DefaultKeyId].
-					       RxMic,
-					       pKey->KeyMaterial + LEN_TKIP_EK +
-					       LEN_TKIP_TXMICK,
-					       LEN_TKIP_RXMICK);
-			}
-
-			/* Update Shared Key CipherAlg */
-			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
-			    CipherAlg = CIPHER_NONE;
-			if (pAd->StaCfg.GroupCipher ==
-			    Ndis802_11Encryption2Enabled)
-				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
-				    CipherAlg = CIPHER_TKIP;
-			else if (pAd->StaCfg.GroupCipher ==
-				 Ndis802_11Encryption3Enabled)
-				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
-				    CipherAlg = CIPHER_AES;
-
-			/* Update group key information to ASIC Shared Key Table */
-			AsicAddSharedKeyEntry(pAd,
-					      BSS0,
-					      pAd->StaCfg.DefaultKeyId,
-					      pAd->SharedKey[BSS0][pAd->StaCfg.
-								   DefaultKeyId].
-					      CipherAlg,
-					      pAd->SharedKey[BSS0][pAd->StaCfg.
-								   DefaultKeyId].
-					      Key,
-					      pAd->SharedKey[BSS0][pAd->StaCfg.
-								   DefaultKeyId].
-					      TxMic,
-					      pAd->SharedKey[BSS0][pAd->StaCfg.
-								   DefaultKeyId].
-					      RxMic);
-
-			/* Update ASIC WCID attribute table and IVEIV table */
-			RTMPAddWcidAttributeEntry(pAd,
-						  BSS0,
-						  pAd->StaCfg.DefaultKeyId,
-						  pAd->SharedKey[BSS0][pAd->
-								       StaCfg.
-								       DefaultKeyId].
-						  CipherAlg, NULL);
-
-			/* set 802.1x port control */
-			/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-			STA_PORT_SECURED(pAd);
-
-			/* Indicate Connected for GUI */
-			pAd->IndicateMediaState = NdisMediaStateConnected;
-		}
-	} else			/* dynamic WEP from wpa_supplicant */
-	{
-		u8 CipherAlg;
-		u8 *Key;
-
-		if (pKey->KeyLength == 32)
-			goto end;
-
-		KeyIdx = pKey->KeyIndex & 0x0fffffff;
-
-		if (KeyIdx < 4) {
-			/* it is a default shared key, for Pairwise key setting */
-			if (pKey->KeyIndex & 0x80000000) {
-				pEntry = MacTableLookup(pAd, pKey->BSSID);
-
-				if (pEntry) {
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("RTMPAddKey: Set Pair-wise Key\n"));
-
-					/* set key material and key length */
-					pEntry->PairwiseKey.KeyLen =
-					    (u8)pKey->KeyLength;
-					NdisMoveMemory(pEntry->PairwiseKey.Key,
-						       &pKey->KeyMaterial,
-						       pKey->KeyLength);
-
-					/* set Cipher type */
-					if (pKey->KeyLength == 5)
-						pEntry->PairwiseKey.CipherAlg =
-						    CIPHER_WEP64;
-					else
-						pEntry->PairwiseKey.CipherAlg =
-						    CIPHER_WEP128;
-
-					/* Add Pair-wise key to Asic */
-					AsicAddPairwiseKeyEntry(pAd,
-								pEntry->Addr,
-								(u8)pEntry->
-								Aid,
-								&pEntry->
-								PairwiseKey);
-
-					/* update WCID attribute table and IVEIV table for this entry */
-					RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,	/* The value may be not zero */
-								  pEntry->
-								  PairwiseKey.
-								  CipherAlg,
-								  pEntry);
-
-				}
-			} else {
-				/* Default key for tx (shared key) */
-				pAd->StaCfg.DefaultKeyId = (u8)KeyIdx;
-
-				/* set key material and key length */
-				pAd->SharedKey[BSS0][KeyIdx].KeyLen =
-				    (u8)pKey->KeyLength;
-				NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key,
-					       &pKey->KeyMaterial,
-					       pKey->KeyLength);
-
-				/* Set Ciper type */
-				if (pKey->KeyLength == 5)
-					pAd->SharedKey[BSS0][KeyIdx].CipherAlg =
-					    CIPHER_WEP64;
-				else
-					pAd->SharedKey[BSS0][KeyIdx].CipherAlg =
-					    CIPHER_WEP128;
-
-				CipherAlg =
-				    pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
-				Key = pAd->SharedKey[BSS0][KeyIdx].Key;
-
-				/* Set Group key material to Asic */
-				AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx,
-						      CipherAlg, Key, NULL,
-						      NULL);
-
-				/* Update WCID attribute table and IVEIV table for this group key table */
-				RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,
-							  CipherAlg, NULL);
-
-			}
-		}
-	}
-end:
-	return;
-}
-
-char *rtstrchr(const char *s, int c)
-{
-	for (; *s != (char)c; ++s)
-		if (*s == '\0')
-			return NULL;
-	return (char *)s;
-}
-
-/*
-This is required for LinEX2004/kernel2.6.7 to provide iwlist scanning function
-*/
-
-int
-rt_ioctl_giwname(struct net_device *dev,
-		 struct iw_request_info *info, char *name, char *extra)
-{
-	strncpy(name, "Ralink STA", IFNAMSIZ);
-	/* RT2870 2.1.0.0 uses "RT2870 Wireless" */
-	/* RT3090 2.1.0.0 uses "RT2860 Wireless" */
-	return 0;
-}
-
-int rt_ioctl_siwfreq(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_freq *freq, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	int chan = -1;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (freq->e > 1)
-		return -EINVAL;
-
-	if ((freq->e == 0) && (freq->m <= 1000))
-		chan = freq->m;	/* Setting by channel number */
-	else
-		MAP_KHZ_TO_CHANNEL_ID((freq->m / 100), chan);	/* Setting by frequency - search the table , like 2.412G, 2.422G, */
-
-	if (ChannelSanity(pAdapter, chan) == TRUE) {
-		pAdapter->CommonCfg.Channel = chan;
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("==>rt_ioctl_siwfreq::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n",
-			  SIOCSIWFREQ, pAdapter->CommonCfg.Channel));
-	} else
-		return -EINVAL;
-
-	return 0;
-}
-
-int rt_ioctl_giwfreq(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_freq *freq, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	u8 ch;
-	unsigned long m = 2412000;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	ch = pAdapter->CommonCfg.Channel;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==>rt_ioctl_giwfreq  %d\n", ch));
-
-	MAP_CHANNEL_ID_TO_KHZ(ch, m);
-	freq->m = m * 100;
-	freq->e = 1;
-	return 0;
-}
-
-int rt_ioctl_siwmode(struct net_device *dev,
-		     struct iw_request_info *info, __u32 * mode, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	switch (*mode) {
-	case IW_MODE_ADHOC:
-		Set_NetworkType_Proc(pAdapter, "Adhoc");
-		break;
-	case IW_MODE_INFRA:
-		Set_NetworkType_Proc(pAdapter, "Infra");
-		break;
-	case IW_MODE_MONITOR:
-		Set_NetworkType_Proc(pAdapter, "Monitor");
-		break;
-	default:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("===>rt_ioctl_siwmode::SIOCSIWMODE (unknown %d)\n",
-			  *mode));
-		return -EINVAL;
-	}
-
-	/* Reset Ralink supplicant to not use, it will be set to start when UI set PMK key */
-	pAdapter->StaCfg.WpaState = SS_NOTUSE;
-
-	return 0;
-}
-
-int rt_ioctl_giwmode(struct net_device *dev,
-		     struct iw_request_info *info, __u32 * mode, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	if (ADHOC_ON(pAdapter))
-		*mode = IW_MODE_ADHOC;
-	else if (INFRA_ON(pAdapter))
-		*mode = IW_MODE_INFRA;
-	else if (MONITOR_ON(pAdapter)) {
-		*mode = IW_MODE_MONITOR;
-	} else
-		*mode = IW_MODE_AUTO;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("==>rt_ioctl_giwmode(mode=%d)\n", *mode));
-	return 0;
-}
-
-int rt_ioctl_siwsens(struct net_device *dev,
-		     struct iw_request_info *info, char *name, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	return 0;
-}
-
-int rt_ioctl_giwsens(struct net_device *dev,
-		     struct iw_request_info *info, char *name, char *extra)
-{
-	return 0;
-}
-
-int rt_ioctl_giwrange(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	struct iw_range *range = (struct iw_range *)extra;
-	u16 val;
-	int i;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===>rt_ioctl_giwrange\n"));
-	data->length = sizeof(struct iw_range);
-	memset(range, 0, sizeof(struct iw_range));
-
-	range->txpower_capa = IW_TXPOW_DBM;
-
-	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter)) {
-		range->min_pmp = 1 * 1024;
-		range->max_pmp = 65535 * 1024;
-		range->min_pmt = 1 * 1024;
-		range->max_pmt = 1000 * 1024;
-		range->pmp_flags = IW_POWER_PERIOD;
-		range->pmt_flags = IW_POWER_TIMEOUT;
-		range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |
-		    IW_POWER_UNICAST_R | IW_POWER_ALL_R;
-	}
-
-	range->we_version_compiled = WIRELESS_EXT;
-	range->we_version_source = 14;
-
-	range->retry_capa = IW_RETRY_LIMIT;
-	range->retry_flags = IW_RETRY_LIMIT;
-	range->min_retry = 0;
-	range->max_retry = 255;
-
-	range->num_channels = pAdapter->ChannelListNum;
-
-	val = 0;
-	for (i = 1; i <= range->num_channels; i++) {
-		u32 m = 2412000;
-		range->freq[val].i = pAdapter->ChannelList[i - 1].Channel;
-		MAP_CHANNEL_ID_TO_KHZ(pAdapter->ChannelList[i - 1].Channel, m);
-		range->freq[val].m = m * 100;	/* OS_HZ */
-
-		range->freq[val].e = 1;
-		val++;
-		if (val == IW_MAX_FREQUENCIES)
-			break;
-	}
-	range->num_frequency = val;
-
-	range->max_qual.qual = 100;	/* what is correct max? This was not
-					 * documented exactly. At least
-					 * 69 has been observed. */
-	range->max_qual.level = 0;	/* dB */
-	range->max_qual.noise = 0;	/* dB */
-
-	/* What would be suitable values for "average/typical" qual? */
-	range->avg_qual.qual = 20;
-	range->avg_qual.level = -60;
-	range->avg_qual.noise = -95;
-	range->sensitivity = 3;
-
-	range->max_encoding_tokens = NR_WEP_KEYS;
-	range->num_encoding_sizes = 2;
-	range->encoding_size[0] = 5;
-	range->encoding_size[1] = 13;
-
-	range->min_rts = 0;
-	range->max_rts = 2347;
-	range->min_frag = 256;
-	range->max_frag = 2346;
-
-	/* IW_ENC_CAPA_* bit field */
-	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
-	    IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
-
-	return 0;
-}
-
-int rt_ioctl_siwap(struct net_device *dev,
-		   struct iw_request_info *info,
-		   struct sockaddr *ap_addr, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	NDIS_802_11_MAC_ADDRESS Bssid;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
-		RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MLME busy, reset MLME state machine!\n"));
-	}
-	/* tell CNTL state machine to call NdisMSetInformationComplete() after completing */
-	/* this request, because this request is initiated by NDIS. */
-	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-	/* Prevent to connect AP again in STAMlmePeriodicExec */
-	pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
-
-	memcpy(Bssid, ap_addr->sa_data, MAC_ADDR_LEN);
-	MlmeEnqueue(pAdapter,
-		    MLME_CNTL_STATE_MACHINE,
-		    OID_802_11_BSSID,
-		    sizeof(NDIS_802_11_MAC_ADDRESS), (void *) & Bssid);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCSIWAP %pM\n", Bssid));
-
-	return 0;
-}
-
-int rt_ioctl_giwap(struct net_device *dev,
-		   struct iw_request_info *info,
-		   struct sockaddr *ap_addr, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter)) {
-		ap_addr->sa_family = ARPHRD_ETHER;
-		memcpy(ap_addr->sa_data, &pAdapter->CommonCfg.Bssid, ETH_ALEN);
-	}
-	/* Add for RT2870 */
-	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
-		ap_addr->sa_family = ARPHRD_ETHER;
-		memcpy(ap_addr->sa_data, &pAdapter->MlmeAux.Bssid, ETH_ALEN);
-	} else {
-		DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCGIWAP(=EMPTY)\n"));
-		return -ENOTCONN;
-	}
-
-	return 0;
-}
-
-/*
- * Units are in db above the noise floor. That means the
- * rssi values reported in the tx/rx descriptors in the
- * driver are the SNR expressed in db.
- *
- * If you assume that the noise floor is -95, which is an
- * excellent assumption 99.5 % of the time, then you can
- * derive the absolute signal level (i.e. -95 + rssi).
- * There are some other slight factors to take into account
- * depending on whether the rssi measurement is from 11b,
- * 11g, or 11a.   These differences are at most 2db and
- * can be documented.
- *
- * NB: various calculations are based on the orinoco/wavelan
- *     drivers for compatibility
- */
-static void set_quality(struct rt_rtmp_adapter *pAdapter,
-			struct iw_quality *iq, signed char rssi)
-{
-	__u8 ChannelQuality;
-
-	/* Normalize Rssi */
-	if (rssi >= -50)
-		ChannelQuality = 100;
-	else if (rssi >= -80)	/* between -50 ~ -80dbm */
-		ChannelQuality = (__u8) (24 + ((rssi + 80) * 26) / 10);
-	else if (rssi >= -90)	/* between -80 ~ -90dbm */
-		ChannelQuality = (__u8) ((rssi + 90) * 26) / 10;
-	else
-		ChannelQuality = 0;
-
-	iq->qual = (__u8) ChannelQuality;
-
-	iq->level = (__u8) (rssi);
-	iq->noise = (pAdapter->BbpWriteLatch[66] > pAdapter->BbpTuning.FalseCcaUpperThreshold) ? ((__u8) pAdapter->BbpTuning.FalseCcaUpperThreshold) : ((__u8) pAdapter->BbpWriteLatch[66]);	/* noise level (dBm) */
-	iq->noise += 256 - 143;
-	iq->updated = pAdapter->iw_stats.qual.updated;
-}
-
-int rt_ioctl_iwaplist(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	struct sockaddr addr[IW_MAX_AP];
-	struct iw_quality qual[IW_MAX_AP];
-	int i;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		data->length = 0;
-		return 0;
-		/*return -ENETDOWN; */
-	}
-
-	for (i = 0; i < IW_MAX_AP; i++) {
-		if (i >= pAdapter->ScanTab.BssNr)
-			break;
-		addr[i].sa_family = ARPHRD_ETHER;
-		memcpy(addr[i].sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid,
-		       MAC_ADDR_LEN);
-		set_quality(pAdapter, &qual[i],
-			    pAdapter->ScanTab.BssEntry[i].Rssi);
-	}
-	data->length = i;
-	memcpy(extra, &addr, i * sizeof(addr[0]));
-	data->flags = 1;	/* signal quality present (sort of) */
-	memcpy(extra + i * sizeof(addr[0]), &qual, i * sizeof(qual[i]));
-
-	return 0;
-}
-
-int rt_ioctl_siwscan(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_point *data, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	unsigned long Now;
-	int Status = NDIS_STATUS_SUCCESS;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (MONITOR_ON(pAdapter)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Driver is in Monitor Mode now!\n"));
-		return -EINVAL;
-	}
-
-	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
-		pAdapter->StaCfg.WpaSupplicantScanCount++;
-	}
-
-	pAdapter->StaCfg.bScanReqIsFromWebUI = TRUE;
-	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		return NDIS_STATUS_SUCCESS;
-	do {
-		Now = jiffies;
-
-		if ((pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE)
-		    && (pAdapter->StaCfg.WpaSupplicantScanCount > 3)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("WpaSupplicantScanCount > 3\n"));
-			Status = NDIS_STATUS_SUCCESS;
-			break;
-		}
-
-		if ((OPSTATUS_TEST_FLAG
-		     (pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED))
-		    && ((pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
-			|| (pAdapter->StaCfg.AuthMode ==
-			    Ndis802_11AuthModeWPAPSK))
-		    && (pAdapter->StaCfg.PortSecured ==
-			WPA_802_1X_PORT_NOT_SECURED)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n"));
-			Status = NDIS_STATUS_SUCCESS;
-			break;
-		}
-
-		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
-			RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MLME busy, reset MLME state machine!\n"));
-		}
-		/* tell CNTL state machine to call NdisMSetInformationComplete() after completing */
-		/* this request, because this request is initiated by NDIS. */
-		pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-		/* Reset allowed scan retries */
-		pAdapter->StaCfg.ScanCnt = 0;
-		pAdapter->StaCfg.LastScanTime = Now;
-
-		MlmeEnqueue(pAdapter,
-			    MLME_CNTL_STATE_MACHINE,
-			    OID_802_11_BSSID_LIST_SCAN, 0, NULL);
-
-		Status = NDIS_STATUS_SUCCESS;
-		RTMP_MLME_HANDLER(pAdapter);
-	} while (0);
-	return NDIS_STATUS_SUCCESS;
-}
-
-int rt_ioctl_giwscan(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_point *data, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	int i = 0;
-	char *current_ev = extra, *previous_ev = extra;
-	char *end_buf;
-	char *current_val;
-	char custom[MAX_CUSTOM_LEN] = { 0 };
-	struct iw_event iwe;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
-		/*
-		 * Still scanning, indicate the caller should try again.
-		 */
-		return -EAGAIN;
-	}
-
-	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
-		pAdapter->StaCfg.WpaSupplicantScanCount = 0;
-	}
-
-	if (pAdapter->ScanTab.BssNr == 0) {
-		data->length = 0;
-		return 0;
-	}
-
-	if (data->length > 0)
-		end_buf = extra + data->length;
-	else
-		end_buf = extra + IW_SCAN_MAX_DATA;
-
-	for (i = 0; i < pAdapter->ScanTab.BssNr; i++) {
-		if (current_ev >= end_buf) {
-			return -E2BIG;
-		}
-		/*MAC address */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWAP;
-		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
-		memcpy(iwe.u.ap_addr.sa_data,
-		       &pAdapter->ScanTab.BssEntry[i].Bssid, ETH_ALEN);
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_ADDR_LEN);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*
-		   Protocol:
-		   it will show scanned AP's WirelessMode.
-		   it might be
-		   802.11a
-		   802.11a/n
-		   802.11g/n
-		   802.11b/g/n
-		   802.11g
-		   802.11b/g
-		 */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWNAME;
-
-		{
-			struct rt_bss_entry *pBssEntry = &pAdapter->ScanTab.BssEntry[i];
-			BOOLEAN isGonly = FALSE;
-			int rateCnt = 0;
-
-			if (pBssEntry->Channel > 14) {
-				if (pBssEntry->HtCapabilityLen != 0)
-					strcpy(iwe.u.name, "802.11a/n");
-				else
-					strcpy(iwe.u.name, "802.11a");
-			} else {
-				/*
-				   if one of non B mode rate is set supported rate, it means G only.
-				 */
-				for (rateCnt = 0;
-				     rateCnt < pBssEntry->SupRateLen;
-				     rateCnt++) {
-					/*
-					   6Mbps(140) 9Mbps(146) and >=12Mbps(152) are supported rate, it means G only.
-					 */
-					if (pBssEntry->SupRate[rateCnt] == 140
-					    || pBssEntry->SupRate[rateCnt] ==
-					    146
-					    || pBssEntry->SupRate[rateCnt] >=
-					    152)
-						isGonly = TRUE;
-				}
-
-				for (rateCnt = 0;
-				     rateCnt < pBssEntry->ExtRateLen;
-				     rateCnt++) {
-					if (pBssEntry->ExtRate[rateCnt] == 140
-					    || pBssEntry->ExtRate[rateCnt] ==
-					    146
-					    || pBssEntry->ExtRate[rateCnt] >=
-					    152)
-						isGonly = TRUE;
-				}
-
-				if (pBssEntry->HtCapabilityLen != 0) {
-					if (isGonly == TRUE)
-						strcpy(iwe.u.name, "802.11g/n");
-					else
-						strcpy(iwe.u.name,
-						       "802.11b/g/n");
-				} else {
-					if (isGonly == TRUE)
-						strcpy(iwe.u.name, "802.11g");
-					else {
-						if (pBssEntry->SupRateLen == 4
-						    && pBssEntry->ExtRateLen ==
-						    0)
-							strcpy(iwe.u.name,
-							       "802.11b");
-						else
-							strcpy(iwe.u.name,
-							       "802.11b/g");
-					}
-				}
-			}
-		}
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_ADDR_LEN);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*ESSID */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWESSID;
-		iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].SsidLen;
-		iwe.u.data.flags = 1;
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-					 (char *)pAdapter->ScanTab.
-					 BssEntry[i].Ssid);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*Network Type */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWMODE;
-		if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11IBSS) {
-			iwe.u.mode = IW_MODE_ADHOC;
-		} else if (pAdapter->ScanTab.BssEntry[i].BssType ==
-			   Ndis802_11Infrastructure) {
-			iwe.u.mode = IW_MODE_INFRA;
-		} else {
-			iwe.u.mode = IW_MODE_AUTO;
-		}
-		iwe.len = IW_EV_UINT_LEN;
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_UINT_LEN);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*Channel and Frequency */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWFREQ;
-		iwe.u.freq.m = pAdapter->ScanTab.BssEntry[i].Channel;
-		iwe.u.freq.e = 0;
-		iwe.u.freq.i = 0;
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_FREQ_LEN);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*Add quality statistics */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVQUAL;
-		iwe.u.qual.level = 0;
-		iwe.u.qual.noise = 0;
-		set_quality(pAdapter, &iwe.u.qual,
-			    pAdapter->ScanTab.BssEntry[i].Rssi);
-		current_ev =
-		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
-					 IW_EV_QUAL_LEN);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*Encyption key */
-		/*================================ */
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = SIOCGIWENCODE;
-		if (CAP_IS_PRIVACY_ON
-		    (pAdapter->ScanTab.BssEntry[i].CapabilityInfo))
-			iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-		else
-			iwe.u.data.flags = IW_ENCODE_DISABLED;
-
-		previous_ev = current_ev;
-		current_ev =
-		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
-					 (char *)pAdapter->
-					 SharedKey[BSS0][(iwe.u.data.
-							  flags &
-							  IW_ENCODE_INDEX) -
-							 1].Key);
-		if (current_ev == previous_ev)
-			return -E2BIG;
-
-		/*Bit Rate */
-		/*================================ */
-		if (pAdapter->ScanTab.BssEntry[i].SupRateLen) {
-			u8 tmpRate =
-			    pAdapter->ScanTab.BssEntry[i].SupRate[pAdapter->
-								  ScanTab.
-								  BssEntry[i].
-								  SupRateLen -
-								  1];
-			memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = SIOCGIWRATE;
-			current_val = current_ev + IW_EV_LCP_LEN;
-			if (tmpRate == 0x82)
-				iwe.u.bitrate.value = 1 * 1000000;
-			else if (tmpRate == 0x84)
-				iwe.u.bitrate.value = 2 * 1000000;
-			else if (tmpRate == 0x8B)
-				iwe.u.bitrate.value = 5.5 * 1000000;
-			else if (tmpRate == 0x96)
-				iwe.u.bitrate.value = 11 * 1000000;
-			else
-				iwe.u.bitrate.value = (tmpRate / 2) * 1000000;
-
-			if (tmpRate == 0x6c
-			    && pAdapter->ScanTab.BssEntry[i].HtCapabilityLen >
-			    0) {
-				int rate_count = ARRAY_SIZE(ralinkrate);
-				struct rt_ht_cap_info capInfo =
-				    pAdapter->ScanTab.BssEntry[i].HtCapability.
-				    HtCapInfo;
-				int shortGI =
-				    capInfo.ChannelWidth ? capInfo.
-				    ShortGIfor40 : capInfo.ShortGIfor20;
-				int maxMCS =
-				    pAdapter->ScanTab.BssEntry[i].HtCapability.
-				    MCSSet[1] ? 15 : 7;
-				int rate_index =
-				    12 + ((u8)capInfo.ChannelWidth * 24) +
-				    ((u8)shortGI * 48) + ((u8)maxMCS);
-
-				if (rate_index < 0)
-					rate_index = 0;
-				if (rate_index >= rate_count)
-					rate_index = rate_count - 1;
-				iwe.u.bitrate.value =
-				    ralinkrate[rate_index] * 500000;
-			}
-
-			iwe.u.bitrate.disabled = 0;
-			current_val = iwe_stream_add_value(info, current_ev,
-							   current_val, end_buf,
-							   &iwe,
-							   IW_EV_PARAM_LEN);
-
-			if ((current_val - current_ev) > IW_EV_LCP_LEN)
-				current_ev = current_val;
-			else
-				return -E2BIG;
-		}
-		/*WPA IE */
-		if (pAdapter->ScanTab.BssEntry[i].WpaIE.IELen > 0) {
-			memset(&iwe, 0, sizeof(iwe));
-			memset(&custom[0], 0, MAX_CUSTOM_LEN);
-			memcpy(custom,
-			       &(pAdapter->ScanTab.BssEntry[i].WpaIE.IE[0]),
-			       pAdapter->ScanTab.BssEntry[i].WpaIE.IELen);
-			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length =
-			    pAdapter->ScanTab.BssEntry[i].WpaIE.IELen;
-			current_ev =
-			    iwe_stream_add_point(info, current_ev, end_buf,
-						 &iwe, custom);
-			if (current_ev == previous_ev)
-				return -E2BIG;
-		}
-		/*WPA2 IE */
-		if (pAdapter->ScanTab.BssEntry[i].RsnIE.IELen > 0) {
-			memset(&iwe, 0, sizeof(iwe));
-			memset(&custom[0], 0, MAX_CUSTOM_LEN);
-			memcpy(custom,
-			       &(pAdapter->ScanTab.BssEntry[i].RsnIE.IE[0]),
-			       pAdapter->ScanTab.BssEntry[i].RsnIE.IELen);
-			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length =
-			    pAdapter->ScanTab.BssEntry[i].RsnIE.IELen;
-			current_ev =
-			    iwe_stream_add_point(info, current_ev, end_buf,
-						 &iwe, custom);
-			if (current_ev == previous_ev)
-				return -E2BIG;
-		}
-	}
-
-	data->length = current_ev - extra;
-	pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
-	DBGPRINT(RT_DEBUG_ERROR,
-		 ("===>rt_ioctl_giwscan. %d(%d) BSS returned, data->length = %d\n",
-		  i, pAdapter->ScanTab.BssNr, data->length));
-	return 0;
-}
-
-int rt_ioctl_siwessid(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *essid)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (data->flags) {
-		char *pSsidString = NULL;
-
-		/* Includes null character. */
-		if (data->length > (IW_ESSID_MAX_SIZE + 1))
-			return -E2BIG;
-
-		pSsidString = kmalloc(MAX_LEN_OF_SSID + 1, MEM_ALLOC_FLAG);
-		if (pSsidString) {
-			NdisZeroMemory(pSsidString, MAX_LEN_OF_SSID + 1);
-			NdisMoveMemory(pSsidString, essid, data->length);
-			if (Set_SSID_Proc(pAdapter, pSsidString) == FALSE)
-				return -EINVAL;
-		} else
-			return -ENOMEM;
-	} else {
-		/* ANY ssid */
-		if (Set_SSID_Proc(pAdapter, "") == FALSE)
-			return -EINVAL;
-	}
-	return 0;
-}
-
-int rt_ioctl_giwessid(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *essid)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	data->flags = 1;
-	if (MONITOR_ON(pAdapter)) {
-		data->length = 0;
-		return 0;
-	}
-
-	if (OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("MediaState is connected\n"));
-		data->length = pAdapter->CommonCfg.SsidLen;
-		memcpy(essid, pAdapter->CommonCfg.Ssid,
-		       pAdapter->CommonCfg.SsidLen);
-	}
-#ifdef RTMP_MAC_USB
-	/* Add for RT2870 */
-	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
-		data->length = pAdapter->CommonCfg.SsidLen;
-		memcpy(essid, pAdapter->CommonCfg.Ssid,
-		       pAdapter->CommonCfg.SsidLen);
-	}
-#endif /* RTMP_MAC_USB // */
-	else {			/*the ANY ssid was specified */
-		data->length = 0;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MediaState is not connected, ess\n"));
-	}
-
-	return 0;
-
-}
-
-int rt_ioctl_siwnickn(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *nickname)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (data->length > IW_ESSID_MAX_SIZE)
-		return -EINVAL;
-
-	memset(pAdapter->nickname, 0, IW_ESSID_MAX_SIZE + 1);
-	memcpy(pAdapter->nickname, nickname, data->length);
-
-	return 0;
-}
-
-int rt_ioctl_giwnickn(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct iw_point *data, char *nickname)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	if (data->length > strlen((char *)pAdapter->nickname) + 1)
-		data->length = strlen((char *)pAdapter->nickname) + 1;
-	if (data->length > 0) {
-		memcpy(nickname, pAdapter->nickname, data->length - 1);
-		nickname[data->length - 1] = '\0';
-	}
-	return 0;
-}
-
-int rt_ioctl_siwrts(struct net_device *dev,
-		    struct iw_request_info *info,
-		    struct iw_param *rts, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	u16 val;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (rts->disabled)
-		val = MAX_RTS_THRESHOLD;
-	else if (rts->value < 0 || rts->value > MAX_RTS_THRESHOLD)
-		return -EINVAL;
-	else if (rts->value == 0)
-		val = MAX_RTS_THRESHOLD;
-	else
-		val = rts->value;
-
-	if (val != pAdapter->CommonCfg.RtsThreshold)
-		pAdapter->CommonCfg.RtsThreshold = val;
-
-	return 0;
-}
-
-int rt_ioctl_giwrts(struct net_device *dev,
-		    struct iw_request_info *info,
-		    struct iw_param *rts, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	rts->value = pAdapter->CommonCfg.RtsThreshold;
-	rts->disabled = (rts->value == MAX_RTS_THRESHOLD);
-	rts->fixed = 1;
-
-	return 0;
-}
-
-int rt_ioctl_siwfrag(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_param *frag, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	u16 val;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (frag->disabled)
-		val = MAX_FRAG_THRESHOLD;
-	else if (frag->value >= MIN_FRAG_THRESHOLD
-		 && frag->value <= MAX_FRAG_THRESHOLD)
-		val = __cpu_to_le16(frag->value & ~0x1);	/* even numbers only */
-	else if (frag->value == 0)
-		val = MAX_FRAG_THRESHOLD;
-	else
-		return -EINVAL;
-
-	pAdapter->CommonCfg.FragmentThreshold = val;
-	return 0;
-}
-
-int rt_ioctl_giwfrag(struct net_device *dev,
-		     struct iw_request_info *info,
-		     struct iw_param *frag, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	frag->value = pAdapter->CommonCfg.FragmentThreshold;
-	frag->disabled = (frag->value == MAX_FRAG_THRESHOLD);
-	frag->fixed = 1;
-
-	return 0;
-}
-
-#define MAX_WEP_KEY_SIZE 13
-#define MIN_WEP_KEY_SIZE 5
-int rt_ioctl_siwencode(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct iw_point *erq, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if ((erq->length == 0) && (erq->flags & IW_ENCODE_DISABLED)) {
-		pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-		pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-		pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-		pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-		goto done;
-	} else if (erq->flags & IW_ENCODE_RESTRICTED
-		   || erq->flags & IW_ENCODE_OPEN) {
-		/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-		STA_PORT_SECURED(pAdapter);
-		pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
-		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
-		pAdapter->StaCfg.WepStatus = Ndis802_11WEPEnabled;
-		pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-		if (erq->flags & IW_ENCODE_RESTRICTED)
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeShared;
-		else
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-	}
-
-	if (erq->length > 0) {
-		int keyIdx = (erq->flags & IW_ENCODE_INDEX) - 1;
-		/* Check the size of the key */
-		if (erq->length > MAX_WEP_KEY_SIZE) {
-			return -EINVAL;
-		}
-		/* Check key index */
-		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("==>rt_ioctl_siwencode::Wrong keyIdx=%d! Using default key instead (%d)\n",
-				  keyIdx, pAdapter->StaCfg.DefaultKeyId));
-
-			/*Using default key */
-			keyIdx = pAdapter->StaCfg.DefaultKeyId;
-		} else
-			pAdapter->StaCfg.DefaultKeyId = keyIdx;
-
-		NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, 16);
-
-		if (erq->length == MAX_WEP_KEY_SIZE) {
-			pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
-			    MAX_WEP_KEY_SIZE;
-			pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
-			    CIPHER_WEP128;
-		} else if (erq->length == MIN_WEP_KEY_SIZE) {
-			pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
-			    MIN_WEP_KEY_SIZE;
-			pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
-			    CIPHER_WEP64;
-		} else
-			/* Disable the key */
-			pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
-
-		/* Check if the key is not marked as invalid */
-		if (!(erq->flags & IW_ENCODE_NOKEY)) {
-			/* Copy the key in the driver */
-			NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
-				       extra, erq->length);
-		}
-	} else {
-		/* Do we want to just set the transmit key index ? */
-		int index = (erq->flags & IW_ENCODE_INDEX) - 1;
-		if ((index >= 0) && (index < 4)) {
-			pAdapter->StaCfg.DefaultKeyId = index;
-		} else
-			/* Don't complain if the mode is only changed */
-		if (!(erq->flags & IW_ENCODE_MODE))
-			return -EINVAL;
-	}
-
-done:
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==>rt_ioctl_siwencode::erq->flags=%x\n", erq->flags));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==>rt_ioctl_siwencode::AuthMode=%x\n",
-		  pAdapter->StaCfg.AuthMode));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",
-		  pAdapter->StaCfg.DefaultKeyId,
-		  pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
-		  KeyLen));
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("==>rt_ioctl_siwencode::WepStatus=%x\n",
-		  pAdapter->StaCfg.WepStatus));
-	return 0;
-}
-
-int
-rt_ioctl_giwencode(struct net_device *dev,
-		   struct iw_request_info *info,
-		   struct iw_point *erq, char *key)
-{
-	int kid;
-	struct rt_rtmp_adapter *pAdapter = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	kid = erq->flags & IW_ENCODE_INDEX;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("===>rt_ioctl_giwencode %d\n", erq->flags & IW_ENCODE_INDEX));
-
-	if (pAdapter->StaCfg.WepStatus == Ndis802_11WEPDisabled) {
-		erq->length = 0;
-		erq->flags = IW_ENCODE_DISABLED;
-	} else if ((kid > 0) && (kid <= 4)) {
-		/* copy wep key */
-		erq->flags = kid;	/* NB: base 1 */
-		if (erq->length > pAdapter->SharedKey[BSS0][kid - 1].KeyLen)
-			erq->length = pAdapter->SharedKey[BSS0][kid - 1].KeyLen;
-		memcpy(key, pAdapter->SharedKey[BSS0][kid - 1].Key,
-		       erq->length);
-		/*if ((kid == pAdapter->PortCfg.DefaultKeyId)) */
-		/*erq->flags |= IW_ENCODE_ENABLED; */	/* XXX */
-		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
-		else
-			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
-
-	} else if (kid == 0) {
-		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
-		else
-			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
-		erq->length =
-		    pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
-		    KeyLen;
-		memcpy(key,
-		       pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
-		       Key, erq->length);
-		/* copy default key ID */
-		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
-		else
-			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
-		erq->flags = pAdapter->StaCfg.DefaultKeyId + 1;	/* NB: base 1 */
-		erq->flags |= IW_ENCODE_ENABLED;	/* XXX */
-	}
-
-	return 0;
-
-}
-
-void getBaInfo(struct rt_rtmp_adapter *pAd, char *pOutBuf)
-{
-	int i, j;
-	struct rt_ba_ori_entry *pOriBAEntry;
-	struct rt_ba_rec_entry *pRecBAEntry;
-
-	for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++) {
-		struct rt_mac_table_entry *pEntry = &pAd->MacTab.Content[i];
-		if (((pEntry->ValidAsCLI || pEntry->ValidAsApCli)
-		     && (pEntry->Sst == SST_ASSOC))
-		    || (pEntry->ValidAsWDS) || (pEntry->ValidAsMesh)) {
-			sprintf(pOutBuf + strlen(pOutBuf), "\n%pM (Aid = %d) "
-				"(AP) -\n", pEntry->Addr, pEntry->Aid);
-
-			sprintf(pOutBuf, "%s[Recipient]\n", pOutBuf);
-			for (j = 0; j < NUM_OF_TID; j++) {
-				if (pEntry->BARecWcidArray[j] != 0) {
-					pRecBAEntry =
-					    &pAd->BATable.BARecEntry[pEntry->
-								     BARecWcidArray
-								     [j]];
-					sprintf(pOutBuf + strlen(pOutBuf),
-						"TID=%d, BAWinSize=%d, LastIndSeq=%d, ReorderingPkts=%d\n",
-						j, pRecBAEntry->BAWinSize,
-						pRecBAEntry->LastIndSeq,
-						pRecBAEntry->list.qlen);
-				}
-			}
-			sprintf(pOutBuf, "%s\n", pOutBuf);
-
-			sprintf(pOutBuf, "%s[Originator]\n", pOutBuf);
-			for (j = 0; j < NUM_OF_TID; j++) {
-				if (pEntry->BAOriWcidArray[j] != 0) {
-					pOriBAEntry =
-					    &pAd->BATable.BAOriEntry[pEntry->
-								     BAOriWcidArray
-								     [j]];
-					sprintf(pOutBuf + strlen(pOutBuf),
-						"TID=%d, BAWinSize=%d, StartSeq=%d, CurTxSeq=%d\n",
-						j, pOriBAEntry->BAWinSize,
-						pOriBAEntry->Sequence,
-						pEntry->TxSeq[j]);
-				}
-			}
-			sprintf(pOutBuf, "%s\n\n", pOutBuf);
-		}
-		if (strlen(pOutBuf) > (IW_PRIV_SIZE_MASK - 30))
-			break;
-	}
-
-	return;
-}
-
-int rt_ioctl_siwmlme(struct net_device *dev,
-		     struct iw_request_info *info,
-		     union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-	struct iw_mlme *pMlme = (struct iw_mlme *)wrqu->data.pointer;
-	struct rt_mlme_queue_elem MsgElem;
-	struct rt_mlme_disassoc_req DisAssocReq;
-	struct rt_mlme_deauth_req DeAuthReq;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("====> %s\n", __func__));
-
-	if (pMlme == NULL)
-		return -EINVAL;
-
-	switch (pMlme->cmd) {
-#ifdef IW_MLME_DEAUTH
-	case IW_MLME_DEAUTH:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("====> %s - IW_MLME_DEAUTH\n", __func__));
-		COPY_MAC_ADDR(DeAuthReq.Addr, pAd->CommonCfg.Bssid);
-		DeAuthReq.Reason = pMlme->reason_code;
-		MsgElem.MsgLen = sizeof(struct rt_mlme_deauth_req);
-		NdisMoveMemory(MsgElem.Msg, &DeAuthReq,
-			       sizeof(struct rt_mlme_deauth_req));
-		MlmeDeauthReqAction(pAd, &MsgElem);
-		if (INFRA_ON(pAd)) {
-			LinkDown(pAd, FALSE);
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		}
-		break;
-#endif /* IW_MLME_DEAUTH // */
-#ifdef IW_MLME_DISASSOC
-	case IW_MLME_DISASSOC:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("====> %s - IW_MLME_DISASSOC\n", __func__));
-		COPY_MAC_ADDR(DisAssocReq.Addr, pAd->CommonCfg.Bssid);
-		DisAssocReq.Reason = pMlme->reason_code;
-
-		MsgElem.Machine = ASSOC_STATE_MACHINE;
-		MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
-		MsgElem.MsgLen = sizeof(struct rt_mlme_disassoc_req);
-		NdisMoveMemory(MsgElem.Msg, &DisAssocReq,
-			       sizeof(struct rt_mlme_disassoc_req));
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
-		MlmeDisassocReqAction(pAd, &MsgElem);
-		break;
-#endif /* IW_MLME_DISASSOC // */
-	default:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("====> %s - Unknow Command\n", __func__));
-		break;
-	}
-
-	return 0;
-}
-
-int rt_ioctl_siwauth(struct net_device *dev,
-		     struct iw_request_info *info,
-		     union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	struct iw_param *param = &wrqu->param;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-	switch (param->flags & IW_AUTH_INDEX) {
-	case IW_AUTH_WPA_VERSION:
-		if (param->value == IW_AUTH_WPA_VERSION_WPA) {
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
-			if (pAdapter->StaCfg.BssType == BSS_ADHOC)
-				pAdapter->StaCfg.AuthMode =
-				    Ndis802_11AuthModeWPANone;
-		} else if (param->value == IW_AUTH_WPA_VERSION_WPA2)
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_CIPHER_PAIRWISE:
-		if (param->value == IW_AUTH_CIPHER_NONE) {
-			pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-			pAdapter->StaCfg.OrigWepStatus =
-			    pAdapter->StaCfg.WepStatus;
-			pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-		} else if (param->value == IW_AUTH_CIPHER_WEP40 ||
-			   param->value == IW_AUTH_CIPHER_WEP104) {
-			pAdapter->StaCfg.WepStatus = Ndis802_11WEPEnabled;
-			pAdapter->StaCfg.OrigWepStatus =
-			    pAdapter->StaCfg.WepStatus;
-			pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
-			pAdapter->StaCfg.IEEE8021X = FALSE;
-		} else if (param->value == IW_AUTH_CIPHER_TKIP) {
-			pAdapter->StaCfg.WepStatus =
-			    Ndis802_11Encryption2Enabled;
-			pAdapter->StaCfg.OrigWepStatus =
-			    pAdapter->StaCfg.WepStatus;
-			pAdapter->StaCfg.PairCipher =
-			    Ndis802_11Encryption2Enabled;
-		} else if (param->value == IW_AUTH_CIPHER_CCMP) {
-			pAdapter->StaCfg.WepStatus =
-			    Ndis802_11Encryption3Enabled;
-			pAdapter->StaCfg.OrigWepStatus =
-			    pAdapter->StaCfg.WepStatus;
-			pAdapter->StaCfg.PairCipher =
-			    Ndis802_11Encryption3Enabled;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_CIPHER_PAIRWISE - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_CIPHER_GROUP:
-		if (param->value == IW_AUTH_CIPHER_NONE) {
-			pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-		} else if (param->value == IW_AUTH_CIPHER_WEP40 ||
-			   param->value == IW_AUTH_CIPHER_WEP104) {
-			pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
-		} else if (param->value == IW_AUTH_CIPHER_TKIP) {
-			pAdapter->StaCfg.GroupCipher =
-			    Ndis802_11Encryption2Enabled;
-		} else if (param->value == IW_AUTH_CIPHER_CCMP) {
-			pAdapter->StaCfg.GroupCipher =
-			    Ndis802_11Encryption3Enabled;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_CIPHER_GROUP - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_KEY_MGMT:
-		if (param->value == IW_AUTH_KEY_MGMT_802_1X) {
-			if (pAdapter->StaCfg.AuthMode ==
-			    Ndis802_11AuthModeWPAPSK) {
-				pAdapter->StaCfg.AuthMode =
-				    Ndis802_11AuthModeWPA;
-				pAdapter->StaCfg.IEEE8021X = FALSE;
-			} else if (pAdapter->StaCfg.AuthMode ==
-				   Ndis802_11AuthModeWPA2PSK) {
-				pAdapter->StaCfg.AuthMode =
-				    Ndis802_11AuthModeWPA2;
-				pAdapter->StaCfg.IEEE8021X = FALSE;
-			} else
-				/* WEP 1x */
-				pAdapter->StaCfg.IEEE8021X = TRUE;
-		} else if (param->value == 0) {
-			/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-			STA_PORT_SECURED(pAdapter);
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_KEY_MGMT - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		break;
-	case IW_AUTH_PRIVACY_INVOKED:
-		/*if (param->value == 0)
-		   {
-		   pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-		   pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-		   pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-		   pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-		   pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-		   } */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_PRIVACY_INVOKED - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_DROP_UNENCRYPTED:
-		if (param->value != 0)
-			pAdapter->StaCfg.PortSecured =
-			    WPA_802_1X_PORT_NOT_SECURED;
-		else {
-			/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-			STA_PORT_SECURED(pAdapter);
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_80211_AUTH_ALG:
-		if (param->value & IW_AUTH_ALG_SHARED_KEY) {
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeShared;
-		} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-		} else
-			return -EINVAL;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_80211_AUTH_ALG - param->value = %d!\n",
-			  __func__, param->value));
-		break;
-	case IW_AUTH_WPA_ENABLED:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::IW_AUTH_WPA_ENABLED - Driver supports WPA!(param->value = %d)\n",
-			  __func__, param->value));
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-int rt_ioctl_giwauth(struct net_device *dev,
-		     struct iw_request_info *info,
-		     union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	struct iw_param *param = &wrqu->param;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	switch (param->flags & IW_AUTH_INDEX) {
-	case IW_AUTH_DROP_UNENCRYPTED:
-		param->value =
-		    (pAdapter->StaCfg.WepStatus ==
-		     Ndis802_11WEPDisabled) ? 0 : 1;
-		break;
-
-	case IW_AUTH_80211_AUTH_ALG:
-		param->value =
-		    (pAdapter->StaCfg.AuthMode ==
-		     Ndis802_11AuthModeShared) ? IW_AUTH_ALG_SHARED_KEY :
-		    IW_AUTH_ALG_OPEN_SYSTEM;
-		break;
-
-	case IW_AUTH_WPA_ENABLED:
-		param->value =
-		    (pAdapter->StaCfg.AuthMode >=
-		     Ndis802_11AuthModeWPA) ? 1 : 0;
-		break;
-
-	default:
-		return -EOPNOTSUPP;
-	}
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("rt_ioctl_giwauth::param->value = %d!\n", param->value));
-	return 0;
-}
-
-void fnSetCipherKey(struct rt_rtmp_adapter *pAdapter,
-		    int keyIdx,
-		    u8 CipherAlg,
-		    IN BOOLEAN bGTK, IN struct iw_encode_ext *ext)
-{
-	NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx], sizeof(struct rt_cipher_key));
-	pAdapter->SharedKey[BSS0][keyIdx].KeyLen = LEN_TKIP_EK;
-	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, ext->key,
-		       LEN_TKIP_EK);
-	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].TxMic,
-		       ext->key + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].RxMic,
-		       ext->key + LEN_TKIP_EK + LEN_TKIP_TXMICK,
-		       LEN_TKIP_RXMICK);
-	pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CipherAlg;
-
-	/* Update group key information to ASIC Shared Key Table */
-	AsicAddSharedKeyEntry(pAdapter,
-			      BSS0,
-			      keyIdx,
-			      pAdapter->SharedKey[BSS0][keyIdx].CipherAlg,
-			      pAdapter->SharedKey[BSS0][keyIdx].Key,
-			      pAdapter->SharedKey[BSS0][keyIdx].TxMic,
-			      pAdapter->SharedKey[BSS0][keyIdx].RxMic);
-
-	if (bGTK)
-		/* Update ASIC WCID attribute table and IVEIV table */
-		RTMPAddWcidAttributeEntry(pAdapter,
-					  BSS0,
-					  keyIdx,
-					  pAdapter->SharedKey[BSS0][keyIdx].
-					  CipherAlg, NULL);
-	else
-		/* Update ASIC WCID attribute table and IVEIV table */
-		RTMPAddWcidAttributeEntry(pAdapter,
-					  BSS0,
-					  keyIdx,
-					  pAdapter->SharedKey[BSS0][keyIdx].
-					  CipherAlg,
-					  &pAdapter->MacTab.
-					  Content[BSSID_WCID]);
-}
-
-int rt_ioctl_siwencodeext(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAdapter = NULL;
-	struct iw_point *encoding = &wrqu->encoding;
-	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-	int keyIdx, alg = ext->alg;
-
-	GET_PAD_FROM_NET_DEV(pAdapter, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if (encoding->flags & IW_ENCODE_DISABLED) {
-		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
-		/* set BSSID wcid entry of the Pair-wise Key table as no-security mode */
-		AsicRemovePairwiseKeyEntry(pAdapter, BSS0, BSSID_WCID);
-		pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
-		pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_NONE;
-		AsicRemoveSharedKeyEntry(pAdapter, 0, (u8)keyIdx);
-		NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx],
-			       sizeof(struct rt_cipher_key));
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("%s::Remove all keys!(encoding->flags = %x)\n",
-			  __func__, encoding->flags));
-	} else {
-		/* Get Key Index and convet to our own defined key index */
-		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
-		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS))
-			return -EINVAL;
-
-		if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
-			pAdapter->StaCfg.DefaultKeyId = keyIdx;
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s::DefaultKeyId = %d\n", __func__,
-				  pAdapter->StaCfg.DefaultKeyId));
-		}
-
-		switch (alg) {
-		case IW_ENCODE_ALG_NONE:
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s::IW_ENCODE_ALG_NONE\n", __func__));
-			break;
-		case IW_ENCODE_ALG_WEP:
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s::IW_ENCODE_ALG_WEP - ext->key_len = %d, keyIdx = %d\n",
-				  __func__, ext->key_len, keyIdx));
-			if (ext->key_len == MAX_WEP_KEY_SIZE) {
-				pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
-				    MAX_WEP_KEY_SIZE;
-				pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
-				    CIPHER_WEP128;
-			} else if (ext->key_len == MIN_WEP_KEY_SIZE) {
-				pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
-				    MIN_WEP_KEY_SIZE;
-				pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
-				    CIPHER_WEP64;
-			} else
-				return -EINVAL;
-
-			NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
-				       16);
-			NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
-				       ext->key, ext->key_len);
-			if (pAdapter->StaCfg.GroupCipher ==
-			    Ndis802_11GroupWEP40Enabled
-			    || pAdapter->StaCfg.GroupCipher ==
-			    Ndis802_11GroupWEP104Enabled) {
-				/* Set Group key material to Asic */
-				AsicAddSharedKeyEntry(pAdapter, BSS0, keyIdx,
-						      pAdapter->
-						      SharedKey[BSS0][keyIdx].
-						      CipherAlg,
-						      pAdapter->
-						      SharedKey[BSS0][keyIdx].
-						      Key, NULL, NULL);
-
-				/* Update WCID attribute table and IVEIV table for this group key table */
-				RTMPAddWcidAttributeEntry(pAdapter, BSS0,
-							  keyIdx,
-							  pAdapter->
-							  SharedKey[BSS0]
-							  [keyIdx].CipherAlg,
-							  NULL);
-
-				STA_PORT_SECURED(pAdapter);
-
-				/* Indicate Connected for GUI */
-				pAdapter->IndicateMediaState =
-				    NdisMediaStateConnected;
-			}
-			break;
-		case IW_ENCODE_ALG_TKIP:
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("%s::IW_ENCODE_ALG_TKIP - keyIdx = %d, ext->key_len = %d\n",
-				  __func__, keyIdx, ext->key_len));
-			if (ext->key_len == 32) {
-				if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
-					fnSetCipherKey(pAdapter, keyIdx,
-						       CIPHER_TKIP, FALSE, ext);
-					if (pAdapter->StaCfg.AuthMode >=
-					    Ndis802_11AuthModeWPA2) {
-						/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-						STA_PORT_SECURED(pAdapter);
-						pAdapter->IndicateMediaState =
-						    NdisMediaStateConnected;
-					}
-				} else if (ext->
-					   ext_flags & IW_ENCODE_EXT_GROUP_KEY)
-				{
-					fnSetCipherKey(pAdapter, keyIdx,
-						       CIPHER_TKIP, TRUE, ext);
-
-					/* set 802.1x port control */
-					/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-					STA_PORT_SECURED(pAdapter);
-					pAdapter->IndicateMediaState =
-					    NdisMediaStateConnected;
-				}
-			} else
-				return -EINVAL;
-			break;
-		case IW_ENCODE_ALG_CCMP:
-			if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
-				fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES,
-					       FALSE, ext);
-				if (pAdapter->StaCfg.AuthMode >=
-				    Ndis802_11AuthModeWPA2)
-					/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-					STA_PORT_SECURED(pAdapter);
-				pAdapter->IndicateMediaState =
-				    NdisMediaStateConnected;
-			} else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
-				fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES,
-					       TRUE, ext);
-
-				/* set 802.1x port control */
-				/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
-				STA_PORT_SECURED(pAdapter);
-				pAdapter->IndicateMediaState =
-				    NdisMediaStateConnected;
-			}
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-int
-rt_ioctl_giwencodeext(struct net_device *dev,
-		      struct iw_request_info *info,
-		      union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-	char *pKey = NULL;
-	struct iw_point *encoding = &wrqu->encoding;
-	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-	int idx, max_key_len;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_giwencodeext\n"));
-
-	max_key_len = encoding->length - sizeof(*ext);
-	if (max_key_len < 0)
-		return -EINVAL;
-
-	idx = encoding->flags & IW_ENCODE_INDEX;
-	if (idx) {
-		if (idx < 1 || idx > 4)
-			return -EINVAL;
-		idx--;
-
-		if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-		    (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled)) {
-			if (idx != pAd->StaCfg.DefaultKeyId) {
-				ext->key_len = 0;
-				return 0;
-			}
-		}
-	} else
-		idx = pAd->StaCfg.DefaultKeyId;
-
-	encoding->flags = idx + 1;
-	memset(ext, 0, sizeof(*ext));
-
-	ext->key_len = 0;
-	switch (pAd->StaCfg.WepStatus) {
-	case Ndis802_11WEPDisabled:
-		ext->alg = IW_ENCODE_ALG_NONE;
-		encoding->flags |= IW_ENCODE_DISABLED;
-		break;
-	case Ndis802_11WEPEnabled:
-		ext->alg = IW_ENCODE_ALG_WEP;
-		if (pAd->SharedKey[BSS0][idx].KeyLen > max_key_len)
-			return -E2BIG;
-		else {
-			ext->key_len = pAd->SharedKey[BSS0][idx].KeyLen;
-			pKey = (char *)& (pAd->SharedKey[BSS0][idx].Key[0]);
-		}
-		break;
-	case Ndis802_11Encryption2Enabled:
-	case Ndis802_11Encryption3Enabled:
-		if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
-			ext->alg = IW_ENCODE_ALG_TKIP;
-		else
-			ext->alg = IW_ENCODE_ALG_CCMP;
-
-		if (max_key_len < 32)
-			return -E2BIG;
-		else {
-			ext->key_len = 32;
-			pKey = (char *)& pAd->StaCfg.PMK[0];
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (ext->key_len && pKey) {
-		encoding->flags |= IW_ENCODE_ENABLED;
-		memcpy(ext->key, pKey, ext->key_len);
-	}
-
-	return 0;
-}
-
-int rt_ioctl_siwgenie(struct net_device *dev,
-		      struct iw_request_info *info,
-		      union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_siwgenie\n"));
-	pAd->StaCfg.bRSN_IE_FromWpaSupplicant = FALSE;
-	if (wrqu->data.length > MAX_LEN_OF_RSNIE ||
-	    (wrqu->data.length && extra == NULL))
-		return -EINVAL;
-
-	if (wrqu->data.length) {
-		pAd->StaCfg.RSNIE_Len = wrqu->data.length;
-		NdisMoveMemory(&pAd->StaCfg.RSN_IE[0], extra,
-			       pAd->StaCfg.RSNIE_Len);
-		pAd->StaCfg.bRSN_IE_FromWpaSupplicant = TRUE;
-	} else {
-		pAd->StaCfg.RSNIE_Len = 0;
-		NdisZeroMemory(&pAd->StaCfg.RSN_IE[0], MAX_LEN_OF_RSNIE);
-	}
-
-	return 0;
-}
-
-int rt_ioctl_giwgenie(struct net_device *dev,
-		      struct iw_request_info *info,
-		      union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	if ((pAd->StaCfg.RSNIE_Len == 0) ||
-	    (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)) {
-		wrqu->data.length = 0;
-		return 0;
-	}
-
-	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
-		if (wrqu->data.length < pAd->StaCfg.RSNIE_Len)
-			return -E2BIG;
-
-		wrqu->data.length = pAd->StaCfg.RSNIE_Len;
-		memcpy(extra, &pAd->StaCfg.RSN_IE[0], pAd->StaCfg.RSNIE_Len);
-	} else {
-		u8 RSNIe = IE_WPA;
-
-		if (wrqu->data.length < (pAd->StaCfg.RSNIE_Len + 2))	/* ID, Len */
-			return -E2BIG;
-		wrqu->data.length = pAd->StaCfg.RSNIE_Len + 2;
-
-		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
-		    (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
-			RSNIe = IE_RSN;
-
-		extra[0] = (char)RSNIe;
-		extra[1] = pAd->StaCfg.RSNIE_Len;
-		memcpy(extra + 2, &pAd->StaCfg.RSN_IE[0],
-		       pAd->StaCfg.RSNIE_Len);
-	}
-
-	return 0;
-}
-
-int rt_ioctl_siwpmksa(struct net_device *dev,
-		      struct iw_request_info *info,
-		      union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-	struct iw_pmksa *pPmksa = (struct iw_pmksa *)wrqu->data.pointer;
-	int CachedIdx = 0, idx = 0;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	if (pPmksa == NULL)
-		return -EINVAL;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_siwpmksa\n"));
-	switch (pPmksa->cmd) {
-	case IW_PMKSA_FLUSH:
-		NdisZeroMemory(pAd->StaCfg.SavedPMK,
-			       sizeof(struct rt_bssid_info) * PMKID_NO);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("rt_ioctl_siwpmksa - IW_PMKSA_FLUSH\n"));
-		break;
-	case IW_PMKSA_REMOVE:
-		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
-		     CachedIdx++) {
-			/* compare the BSSID */
-			if (NdisEqualMemory
-			    (pPmksa->bssid.sa_data,
-			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
-			     MAC_ADDR_LEN)) {
-				NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].
-					       BSSID, MAC_ADDR_LEN);
-				NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].
-					       PMKID, 16);
-				for (idx = CachedIdx;
-				     idx < (pAd->StaCfg.SavedPMKNum - 1);
-				     idx++) {
-					NdisMoveMemory(&pAd->StaCfg.
-						       SavedPMK[idx].BSSID[0],
-						       &pAd->StaCfg.
-						       SavedPMK[idx +
-								1].BSSID[0],
-						       MAC_ADDR_LEN);
-					NdisMoveMemory(&pAd->StaCfg.
-						       SavedPMK[idx].PMKID[0],
-						       &pAd->StaCfg.
-						       SavedPMK[idx +
-								1].PMKID[0],
-						       16);
-				}
-				pAd->StaCfg.SavedPMKNum--;
-				break;
-			}
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("rt_ioctl_siwpmksa - IW_PMKSA_REMOVE\n"));
-		break;
-	case IW_PMKSA_ADD:
-		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
-		     CachedIdx++) {
-			/* compare the BSSID */
-			if (NdisEqualMemory
-			    (pPmksa->bssid.sa_data,
-			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
-			     MAC_ADDR_LEN))
-				break;
-		}
-
-		/* Found, replace it */
-		if (CachedIdx < PMKID_NO) {
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("Update PMKID, idx = %d\n", CachedIdx));
-			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
-				       BSSID[0], pPmksa->bssid.sa_data,
-				       MAC_ADDR_LEN);
-			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
-				       PMKID[0], pPmksa->pmkid, 16);
-			pAd->StaCfg.SavedPMKNum++;
-		}
-		/* Not found, replace the last one */
-		else {
-			/* Randomly replace one */
-			CachedIdx = (pPmksa->bssid.sa_data[5] % PMKID_NO);
-			DBGPRINT(RT_DEBUG_OFF,
-				 ("Update PMKID, idx = %d\n", CachedIdx));
-			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
-				       BSSID[0], pPmksa->bssid.sa_data,
-				       MAC_ADDR_LEN);
-			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
-				       PMKID[0], pPmksa->pmkid, 16);
-		}
-
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("rt_ioctl_siwpmksa - IW_PMKSA_ADD\n"));
-		break;
-	default:
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("rt_ioctl_siwpmksa - Unknown Command!\n"));
-		break;
-	}
-
-	return 0;
-}
-
-int rt_ioctl_siwrate(struct net_device *dev,
-		     struct iw_request_info *info,
-		     union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-	u32 rate = wrqu->bitrate.value, fixed = wrqu->bitrate.fixed;
-
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("rt_ioctl_siwrate::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("rt_ioctl_siwrate::(rate = %d, fixed = %d)\n", rate, fixed));
-	/* rate = -1 => auto rate
-	   rate = X, fixed = 1 => (fixed rate X)
-	 */
-	if (rate == -1) {
-		/*Auto Rate */
-		pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
-		if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
-		    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <=
-		     MODE_OFDM))
-			RTMPSetDesiredRates(pAd, -1);
-
-		SetCommonHT(pAd);
-	} else {
-		if (fixed) {
-			pAd->StaCfg.bAutoTxRateSwitch = FALSE;
-			if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
-			    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.
-			     MODE <= MODE_OFDM))
-				RTMPSetDesiredRates(pAd, rate);
-			else {
-				pAd->StaCfg.DesiredTransmitSetting.field.MCS =
-				    MCS_AUTO;
-				SetCommonHT(pAd);
-			}
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("rt_ioctl_siwrate::(HtMcs=%d)\n",
-				  pAd->StaCfg.DesiredTransmitSetting.field.
-				  MCS));
-		} else {
-			/* TODO: rate = X, fixed = 0 => (rates <= X) */
-			return -EOPNOTSUPP;
-		}
-	}
-
-	return 0;
-}
-
-int rt_ioctl_giwrate(struct net_device *dev,
-		     struct iw_request_info *info,
-		     union iwreq_data *wrqu, char *extra)
-{
-	struct rt_rtmp_adapter *pAd = NULL;
-	int rate_index = 0, rate_count = 0;
-	HTTRANSMIT_SETTING ht_setting;
-/* Remove to global variable
-    __s32 ralinkrate[] =
-	{2,  4,   11,  22, // CCK
-	12, 18,   24,  36, 48, 72, 96, 108, // OFDM
-	13, 26,   39,  52,  78, 104, 117, 130, 26,  52,  78, 104, 156, 208, 234, 260, // 20MHz, 800ns GI, MCS: 0 ~ 15
-	39, 78,  117, 156, 234, 312, 351, 390,										  // 20MHz, 800ns GI, MCS: 16 ~ 23
-	27, 54,   81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, // 40MHz, 800ns GI, MCS: 0 ~ 15
-	81, 162, 243, 324, 486, 648, 729, 810,										  // 40MHz, 800ns GI, MCS: 16 ~ 23
-	14, 29,   43,  57,  87, 115, 130, 144, 29, 59,   87, 115, 173, 230, 260, 288, // 20MHz, 400ns GI, MCS: 0 ~ 15
-	43, 87,  130, 173, 260, 317, 390, 433,										  // 20MHz, 400ns GI, MCS: 16 ~ 23
-	30, 60,   90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, // 40MHz, 400ns GI, MCS: 0 ~ 15
-	90, 180, 270, 360, 540, 720, 810, 900};										  // 40MHz, 400ns GI, MCS: 16 ~ 23
-*/
-	GET_PAD_FROM_NET_DEV(pAd, dev);
-
-	rate_count = ARRAY_SIZE(ralinkrate);
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		return -ENETDOWN;
-	}
-
-	if ((pAd->StaCfg.bAutoTxRateSwitch == FALSE) &&
-	    (INFRA_ON(pAd)) &&
-	    ((pAd->CommonCfg.PhyMode <= PHY_11G)
-	     || (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <=
-		 MODE_OFDM)))
-		ht_setting.word = pAd->StaCfg.HTPhyMode.word;
-	else
-		ht_setting.word =
-		    pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
-
-	if (ht_setting.field.MODE >= MODE_HTMIX) {
-/*      rate_index = 12 + ((u8)ht_setting.field.BW *16) + ((u8)ht_setting.field.ShortGI *32) + ((u8)ht_setting.field.MCS); */
-		rate_index =
-		    12 + ((u8)ht_setting.field.BW * 24) +
-		    ((u8)ht_setting.field.ShortGI * 48) +
-		    ((u8)ht_setting.field.MCS);
-	} else if (ht_setting.field.MODE == MODE_OFDM)
-		rate_index = (u8)(ht_setting.field.MCS) + 4;
-	else if (ht_setting.field.MODE == MODE_CCK)
-		rate_index = (u8)(ht_setting.field.MCS);
-
-	if (rate_index < 0)
-		rate_index = 0;
-
-	if (rate_index >= rate_count)
-		rate_index = rate_count - 1;
-
-	wrqu->bitrate.value = ralinkrate[rate_index] * 500000;
-	wrqu->bitrate.disabled = 0;
-
-	return 0;
-}
-
-static const iw_handler rt_handler[] = {
-	(iw_handler) NULL,	/* SIOCSIWCOMMIT */
-	(iw_handler) rt_ioctl_giwname,	/* SIOCGIWNAME   */
-	(iw_handler) NULL,	/* SIOCSIWNWID   */
-	(iw_handler) NULL,	/* SIOCGIWNWID   */
-	(iw_handler) rt_ioctl_siwfreq,	/* SIOCSIWFREQ   */
-	(iw_handler) rt_ioctl_giwfreq,	/* SIOCGIWFREQ   */
-	(iw_handler) rt_ioctl_siwmode,	/* SIOCSIWMODE   */
-	(iw_handler) rt_ioctl_giwmode,	/* SIOCGIWMODE   */
-	(iw_handler) NULL,	/* SIOCSIWSENS   */
-	(iw_handler) NULL,	/* SIOCGIWSENS   */
-	(iw_handler) NULL /* not used */ ,	/* SIOCSIWRANGE  */
-	(iw_handler) rt_ioctl_giwrange,	/* SIOCGIWRANGE  */
-	(iw_handler) NULL /* not used */ ,	/* SIOCSIWPRIV   */
-	(iw_handler) NULL /* kernel code */ ,	/* SIOCGIWPRIV   */
-	(iw_handler) NULL /* not used */ ,	/* SIOCSIWSTATS  */
-	(iw_handler) rt28xx_get_wireless_stats /* kernel code */ ,	/* SIOCGIWSTATS  */
-	(iw_handler) NULL,	/* SIOCSIWSPY    */
-	(iw_handler) NULL,	/* SIOCGIWSPY    */
-	(iw_handler) NULL,	/* SIOCSIWTHRSPY */
-	(iw_handler) NULL,	/* SIOCGIWTHRSPY */
-	(iw_handler) rt_ioctl_siwap,	/* SIOCSIWAP     */
-	(iw_handler) rt_ioctl_giwap,	/* SIOCGIWAP     */
-	(iw_handler) rt_ioctl_siwmlme,	/* SIOCSIWMLME   */
-	(iw_handler) rt_ioctl_iwaplist,	/* SIOCGIWAPLIST */
-	(iw_handler) rt_ioctl_siwscan,	/* SIOCSIWSCAN   */
-	(iw_handler) rt_ioctl_giwscan,	/* SIOCGIWSCAN   */
-	(iw_handler) rt_ioctl_siwessid,	/* SIOCSIWESSID  */
-	(iw_handler) rt_ioctl_giwessid,	/* SIOCGIWESSID  */
-	(iw_handler) rt_ioctl_siwnickn,	/* SIOCSIWNICKN  */
-	(iw_handler) rt_ioctl_giwnickn,	/* SIOCGIWNICKN  */
-	(iw_handler) NULL,	/* -- hole --    */
-	(iw_handler) NULL,	/* -- hole --    */
-	(iw_handler) rt_ioctl_siwrate,	/* SIOCSIWRATE   */
-	(iw_handler) rt_ioctl_giwrate,	/* SIOCGIWRATE   */
-	(iw_handler) rt_ioctl_siwrts,	/* SIOCSIWRTS    */
-	(iw_handler) rt_ioctl_giwrts,	/* SIOCGIWRTS    */
-	(iw_handler) rt_ioctl_siwfrag,	/* SIOCSIWFRAG   */
-	(iw_handler) rt_ioctl_giwfrag,	/* SIOCGIWFRAG   */
-	(iw_handler) NULL,	/* SIOCSIWTXPOW  */
-	(iw_handler) NULL,	/* SIOCGIWTXPOW  */
-	(iw_handler) NULL,	/* SIOCSIWRETRY  */
-	(iw_handler) NULL,	/* SIOCGIWRETRY  */
-	(iw_handler) rt_ioctl_siwencode,	/* SIOCSIWENCODE */
-	(iw_handler) rt_ioctl_giwencode,	/* SIOCGIWENCODE */
-	(iw_handler) NULL,	/* SIOCSIWPOWER  */
-	(iw_handler) NULL,	/* SIOCGIWPOWER  */
-	(iw_handler) NULL,	/* -- hole -- */
-	(iw_handler) NULL,	/* -- hole -- */
-	(iw_handler) rt_ioctl_siwgenie,	/* SIOCSIWGENIE  */
-	(iw_handler) rt_ioctl_giwgenie,	/* SIOCGIWGENIE  */
-	(iw_handler) rt_ioctl_siwauth,	/* SIOCSIWAUTH   */
-	(iw_handler) rt_ioctl_giwauth,	/* SIOCGIWAUTH   */
-	(iw_handler) rt_ioctl_siwencodeext,	/* SIOCSIWENCODEEXT */
-	(iw_handler) rt_ioctl_giwencodeext,	/* SIOCGIWENCODEEXT */
-	(iw_handler) rt_ioctl_siwpmksa,	/* SIOCSIWPMKSA  */
-};
-
-const struct iw_handler_def rt28xx_iw_handler_def = {
-	.standard = (iw_handler *) rt_handler,
-	.num_standard = sizeof(rt_handler) / sizeof(iw_handler),
-#if IW_HANDLER_VERSION >= 7
-	.get_wireless_stats = rt28xx_get_wireless_stats,
-#endif
-};
-
-int rt28xx_sta_ioctl(IN struct net_device *net_dev,
-		     IN OUT struct ifreq *rq, int cmd)
-{
-	struct os_cookie *pObj;
-	struct rt_rtmp_adapter *pAd = NULL;
-	struct iwreq *wrq = (struct iwreq *)rq;
-	BOOLEAN StateMachineTouched = FALSE;
-	int Status = NDIS_STATUS_SUCCESS;
-
-	GET_PAD_FROM_NET_DEV(pAd, net_dev);
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	/*check if the interface is down */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-			return -ENETDOWN;
-		}
-	}
-
-	{			/* determine this ioctl command is coming from which interface. */
-		pObj->ioctl_if_type = INT_MAIN;
-		pObj->ioctl_if = MAIN_MBSSID;
-	}
-
-	switch (cmd) {
-	case SIOCGIFHWADDR:
-		DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCGIFHWADDR\n"));
-		memcpy(wrq->u.name, pAd->CurrentAddress, ETH_ALEN);
-		break;
-	case SIOCGIWNAME:
-		{
-			char *name = &wrq->u.name[0];
-			rt_ioctl_giwname(net_dev, NULL, name, NULL);
-			break;
-		}
-	case SIOCGIWESSID:	/*Get ESSID */
-		{
-			struct iw_point *essid = &wrq->u.essid;
-			rt_ioctl_giwessid(net_dev, NULL, essid, essid->pointer);
-			break;
-		}
-	case SIOCSIWESSID:	/*Set ESSID */
-		{
-			struct iw_point *essid = &wrq->u.essid;
-			rt_ioctl_siwessid(net_dev, NULL, essid, essid->pointer);
-			break;
-		}
-	case SIOCSIWNWID:	/* set network id (the cell) */
-	case SIOCGIWNWID:	/* get network id */
-		Status = -EOPNOTSUPP;
-		break;
-	case SIOCSIWFREQ:	/*set channel/frequency (Hz) */
-		{
-			struct iw_freq *freq = &wrq->u.freq;
-			rt_ioctl_siwfreq(net_dev, NULL, freq, NULL);
-			break;
-		}
-	case SIOCGIWFREQ:	/* get channel/frequency (Hz) */
-		{
-			struct iw_freq *freq = &wrq->u.freq;
-			rt_ioctl_giwfreq(net_dev, NULL, freq, NULL);
-			break;
-		}
-	case SIOCSIWNICKN:	/*set node name/nickname */
-		{
-			/*struct iw_point *data=&wrq->u.data; */
-			/*rt_ioctl_siwnickn(net_dev, NULL, data, NULL); */
-			break;
-		}
-	case SIOCGIWNICKN:	/*get node name/nickname */
-		{
-			struct iw_point *erq = NULL;
-			erq = &wrq->u.data;
-			erq->length = strlen((char *)pAd->nickname);
-			Status =
-			    copy_to_user(erq->pointer, pAd->nickname,
-					 erq->length);
-			if (Status)
-				Status = -EFAULT;
-			break;
-		}
-	case SIOCGIWRATE:	/*get default bit rate (bps) */
-		rt_ioctl_giwrate(net_dev, NULL, &wrq->u, NULL);
-		break;
-	case SIOCSIWRATE:	/*set default bit rate (bps) */
-		rt_ioctl_siwrate(net_dev, NULL, &wrq->u, NULL);
-		break;
-	case SIOCGIWRTS:	/* get RTS/CTS threshold (bytes) */
-		{
-			struct iw_param *rts = &wrq->u.rts;
-			rt_ioctl_giwrts(net_dev, NULL, rts, NULL);
-			break;
-		}
-	case SIOCSIWRTS:	/*set RTS/CTS threshold (bytes) */
-		{
-			struct iw_param *rts = &wrq->u.rts;
-			rt_ioctl_siwrts(net_dev, NULL, rts, NULL);
-			break;
-		}
-	case SIOCGIWFRAG:	/*get fragmentation thr (bytes) */
-		{
-			struct iw_param *frag = &wrq->u.frag;
-			rt_ioctl_giwfrag(net_dev, NULL, frag, NULL);
-			break;
-		}
-	case SIOCSIWFRAG:	/*set fragmentation thr (bytes) */
-		{
-			struct iw_param *frag = &wrq->u.frag;
-			rt_ioctl_siwfrag(net_dev, NULL, frag, NULL);
-			break;
-		}
-	case SIOCGIWENCODE:	/*get encoding token & mode */
-		{
-			struct iw_point *erq = &wrq->u.encoding;
-			if (erq)
-				rt_ioctl_giwencode(net_dev, NULL, erq,
-						   erq->pointer);
-			break;
-		}
-	case SIOCSIWENCODE:	/*set encoding token & mode */
-		{
-			struct iw_point *erq = &wrq->u.encoding;
-			if (erq)
-				rt_ioctl_siwencode(net_dev, NULL, erq,
-						   erq->pointer);
-			break;
-		}
-	case SIOCGIWAP:	/*get access point MAC addresses */
-		{
-			struct sockaddr *ap_addr = &wrq->u.ap_addr;
-			rt_ioctl_giwap(net_dev, NULL, ap_addr,
-				       ap_addr->sa_data);
-			break;
-		}
-	case SIOCSIWAP:	/*set access point MAC addresses */
-		{
-			struct sockaddr *ap_addr = &wrq->u.ap_addr;
-			rt_ioctl_siwap(net_dev, NULL, ap_addr,
-				       ap_addr->sa_data);
-			break;
-		}
-	case SIOCGIWMODE:	/*get operation mode */
-		{
-			__u32 *mode = &wrq->u.mode;
-			rt_ioctl_giwmode(net_dev, NULL, mode, NULL);
-			break;
-		}
-	case SIOCSIWMODE:	/*set operation mode */
-		{
-			__u32 *mode = &wrq->u.mode;
-			rt_ioctl_siwmode(net_dev, NULL, mode, NULL);
-			break;
-		}
-	case SIOCGIWSENS:	/*get sensitivity (dBm) */
-	case SIOCSIWSENS:	/*set sensitivity (dBm) */
-	case SIOCGIWPOWER:	/*get Power Management settings */
-	case SIOCSIWPOWER:	/*set Power Management settings */
-	case SIOCGIWTXPOW:	/*get transmit power (dBm) */
-	case SIOCSIWTXPOW:	/*set transmit power (dBm) */
-	case SIOCGIWRANGE:	/*Get range of parameters */
-	case SIOCGIWRETRY:	/*get retry limits and lifetime */
-	case SIOCSIWRETRY:	/*set retry limits and lifetime */
-	case RT_PRIV_IOCTL:
-	case RT_PRIV_IOCTL_EXT:
-	case RTPRIV_IOCTL_SET:
-	case RTPRIV_IOCTL_GSITESURVEY:
-	case SIOCGIWPRIV:
-		Status = -EOPNOTSUPP;
-		break;
-	case SIOCETHTOOL:
-		break;
-	default:
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("IOCTL::unknown IOCTL's cmd = 0x%08x\n", cmd));
-		Status = -EOPNOTSUPP;
-		break;
-	}
-
-	if (StateMachineTouched)	/* Upper layer sent a MLME-related operations */
-		RTMP_MLME_HANDLER(pAd);
-
-	return Status;
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set SSID
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int Set_SSID_Proc(struct rt_rtmp_adapter *pAdapter, char *arg)
-{
-	struct rt_ndis_802_11_ssid Ssid, *pSsid = NULL;
-	BOOLEAN StateMachineTouched = FALSE;
-	int success = TRUE;
-
-	if (strlen(arg) <= MAX_LEN_OF_SSID) {
-		NdisZeroMemory(&Ssid, sizeof(struct rt_ndis_802_11_ssid));
-		if (strlen(arg) != 0) {
-			NdisMoveMemory(Ssid.Ssid, arg, strlen(arg));
-			Ssid.SsidLength = strlen(arg);
-		} else		/*ANY ssid */
-		{
-			Ssid.SsidLength = 0;
-			memcpy(Ssid.Ssid, "", 0);
-			pAdapter->StaCfg.BssType = BSS_INFRA;
-			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-			pAdapter->StaCfg.WepStatus =
-			    Ndis802_11EncryptionDisabled;
-		}
-		pSsid = &Ssid;
-
-		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
-			RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("MLME busy, reset MLME state machine!\n"));
-		}
-
-		if ((pAdapter->StaCfg.WpaPassPhraseLen >= 8) &&
-		    (pAdapter->StaCfg.WpaPassPhraseLen <= 64)) {
-			char passphrase_str[65] = { 0 };
-			u8 keyMaterial[40];
-
-			RTMPMoveMemory(passphrase_str,
-				       pAdapter->StaCfg.WpaPassPhrase,
-				       pAdapter->StaCfg.WpaPassPhraseLen);
-			RTMPZeroMemory(pAdapter->StaCfg.PMK, 32);
-			if (pAdapter->StaCfg.WpaPassPhraseLen == 64) {
-				AtoH((char *)pAdapter->StaCfg.WpaPassPhrase,
-				     pAdapter->StaCfg.PMK, 32);
-			} else {
-				PasswordHash((char *)pAdapter->StaCfg.
-					     WpaPassPhrase, Ssid.Ssid,
-					     Ssid.SsidLength, keyMaterial);
-				NdisMoveMemory(pAdapter->StaCfg.PMK,
-					       keyMaterial, 32);
-			}
-		}
-
-		pAdapter->MlmeAux.CurrReqIsFromNdis = TRUE;
-		pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
-		pAdapter->bConfigChanged = TRUE;
-
-		MlmeEnqueue(pAdapter,
-			    MLME_CNTL_STATE_MACHINE,
-			    OID_802_11_SSID,
-			    sizeof(struct rt_ndis_802_11_ssid), (void *) pSsid);
-
-		StateMachineTouched = TRUE;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Set_SSID_Proc::(Len=%d,Ssid=%s)\n", Ssid.SsidLength,
-			  Ssid.Ssid));
-	} else
-		success = FALSE;
-
-	if (StateMachineTouched)	/* Upper layer sent a MLME-related operations */
-		RTMP_MLME_HANDLER(pAdapter);
-
-	return success;
-}
-
-/*
-    ==========================================================================
-    Description:
-        Set Network Type(Infrastructure/Adhoc mode)
-    Return:
-        TRUE if all parameters are OK, FALSE otherwise
-    ==========================================================================
-*/
-int Set_NetworkType_Proc(struct rt_rtmp_adapter *pAdapter, char *arg)
-{
-	u32 Value = 0;
-
-	if (strcmp(arg, "Adhoc") == 0) {
-		if (pAdapter->StaCfg.BssType != BSS_ADHOC) {
-			/* Config has changed */
-			pAdapter->bConfigChanged = TRUE;
-			if (MONITOR_ON(pAdapter)) {
-				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
-						STANORMAL);
-				RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
-				Value &= (~0x80);
-				RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value);
-				OPSTATUS_CLEAR_FLAG(pAdapter,
-						    fOP_STATUS_MEDIA_STATE_CONNECTED);
-				pAdapter->StaCfg.bAutoReconnect = TRUE;
-				LinkDown(pAdapter, FALSE);
-			}
-			if (INFRA_ON(pAdapter)) {
-				/*BOOLEAN Cancelled; */
-				/* Set the AutoReconnectSsid to prevent it from reconnecting to the old SSID */
-				/* Since calling this indicates users don't want to connect to that SSID anymore. */
-				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
-				NdisZeroMemory(pAdapter->MlmeAux.
-					       AutoReconnectSsid,
-					       pAdapter->MlmeAux.
-					       AutoReconnectSsidLen);
-
-				LinkDown(pAdapter, FALSE);
-
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n"));
-			}
-		}
-		pAdapter->StaCfg.BssType = BSS_ADHOC;
-		pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("===>Set_NetworkType_Proc::(AD-HOC)\n"));
-	} else if (strcmp(arg, "Infra") == 0) {
-		if (pAdapter->StaCfg.BssType != BSS_INFRA) {
-			/* Config has changed */
-			pAdapter->bConfigChanged = TRUE;
-			if (MONITOR_ON(pAdapter)) {
-				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
-						STANORMAL);
-				RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
-				Value &= (~0x80);
-				RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value);
-				OPSTATUS_CLEAR_FLAG(pAdapter,
-						    fOP_STATUS_MEDIA_STATE_CONNECTED);
-				pAdapter->StaCfg.bAutoReconnect = TRUE;
-				LinkDown(pAdapter, FALSE);
-			}
-			if (ADHOC_ON(pAdapter)) {
-				/* Set the AutoReconnectSsid to prevent it from reconnecting to the old SSID */
-				/* Since calling this indicates users don't want to connect to that SSID anymore. */
-				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
-				NdisZeroMemory(pAdapter->MlmeAux.
-					       AutoReconnectSsid,
-					       pAdapter->MlmeAux.
-					       AutoReconnectSsidLen);
-
-				LinkDown(pAdapter, FALSE);
-			}
-		}
-		pAdapter->StaCfg.BssType = BSS_INFRA;
-		pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("===>Set_NetworkType_Proc::(INFRA)\n"));
-	} else if (strcmp(arg, "Monitor") == 0) {
-		u8 bbpValue = 0;
-		BCN_TIME_CFG_STRUC csr;
-		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_INFRA_ON);
-		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_ADHOC_ON);
-		OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED);
-		/* disable all periodic state machine */
-		pAdapter->StaCfg.bAutoReconnect = FALSE;
-		/* reset all mlme state machine */
-		RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("fOP_STATUS_MEDIA_STATE_CONNECTED \n"));
-		if (pAdapter->CommonCfg.CentralChannel == 0) {
-			if (pAdapter->CommonCfg.PhyMode == PHY_11AN_MIXED)
-				pAdapter->CommonCfg.CentralChannel = 36;
-			else
-				pAdapter->CommonCfg.CentralChannel = 6;
-		} else
-			N_ChannelCheck(pAdapter);
-
-		if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
-		    pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
-		    pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA ==
-		    EXTCHA_ABOVE) {
-			/* 40MHz ,control channel at lower */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
-						    &bbpValue);
-			bbpValue &= (~0x18);
-			bbpValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
-						     bbpValue);
-			pAdapter->CommonCfg.BBPCurrentBW = BW_40;
-			/*  RX : control channel at lower */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3,
-						    &bbpValue);
-			bbpValue &= (~0x20);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3,
-						     bbpValue);
-
-			RTMP_IO_READ32(pAdapter, TX_BAND_CFG, &Value);
-			Value &= 0xfffffffe;
-			RTMP_IO_WRITE32(pAdapter, TX_BAND_CFG, Value);
-			pAdapter->CommonCfg.CentralChannel =
-			    pAdapter->CommonCfg.Channel + 2;
-			AsicSwitchChannel(pAdapter,
-					  pAdapter->CommonCfg.CentralChannel,
-					  FALSE);
-			AsicLockChannel(pAdapter,
-					pAdapter->CommonCfg.CentralChannel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
-				  pAdapter->CommonCfg.Channel,
-				  pAdapter->CommonCfg.CentralChannel));
-		} else if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED
-			   && pAdapter->CommonCfg.RegTransmitSetting.field.BW ==
-			   BW_40
-			   && pAdapter->CommonCfg.RegTransmitSetting.field.
-			   EXTCHA == EXTCHA_BELOW) {
-			/* 40MHz ,control channel at upper */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
-						    &bbpValue);
-			bbpValue &= (~0x18);
-			bbpValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
-						     bbpValue);
-			pAdapter->CommonCfg.BBPCurrentBW = BW_40;
-			RTMP_IO_READ32(pAdapter, TX_BAND_CFG, &Value);
-			Value |= 0x1;
-			RTMP_IO_WRITE32(pAdapter, TX_BAND_CFG, Value);
-
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3,
-						    &bbpValue);
-			bbpValue |= (0x20);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3,
-						     bbpValue);
-			pAdapter->CommonCfg.CentralChannel =
-			    pAdapter->CommonCfg.Channel - 2;
-			AsicSwitchChannel(pAdapter,
-					  pAdapter->CommonCfg.CentralChannel,
-					  FALSE);
-			AsicLockChannel(pAdapter,
-					pAdapter->CommonCfg.CentralChannel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
-				  pAdapter->CommonCfg.Channel,
-				  pAdapter->CommonCfg.CentralChannel));
-		} else {
-			/* 20MHz */
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
-						    &bbpValue);
-			bbpValue &= (~0x18);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
-						     bbpValue);
-			pAdapter->CommonCfg.BBPCurrentBW = BW_20;
-			AsicSwitchChannel(pAdapter, pAdapter->CommonCfg.Channel,
-					  FALSE);
-			AsicLockChannel(pAdapter, pAdapter->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("BW_20, Channel(%d)\n",
-				  pAdapter->CommonCfg.Channel));
-		}
-		/* Enable Rx with promiscuous reception */
-		RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG, 0x3);
-		/* ASIC supports sniffer function with replacing RSSI with timestamp. */
-		/*RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value); */
-		/*Value |= (0x80); */
-		/*RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value); */
-		/* disable sync */
-		RTMP_IO_READ32(pAdapter, BCN_TIME_CFG, &csr.word);
-		csr.field.bBeaconGen = 0;
-		csr.field.bTBTTEnable = 0;
-		csr.field.TsfSyncMode = 0;
-		RTMP_IO_WRITE32(pAdapter, BCN_TIME_CFG, csr.word);
-
-		pAdapter->StaCfg.BssType = BSS_MONITOR;
-		pAdapter->net_dev->type = ARPHRD_IEEE80211_PRISM;	/*ARPHRD_IEEE80211; // IEEE80211 */
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("===>Set_NetworkType_Proc::(MONITOR)\n"));
-	}
-	/* Reset Ralink supplicant to not use, it will be set to start when UI set PMK key */
-	pAdapter->StaCfg.WpaState = SS_NOTUSE;
-
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("Set_NetworkType_Proc::(NetworkType=%d)\n",
-		  pAdapter->StaCfg.BssType));
-
-	return TRUE;
-}
diff --git a/drivers/staging/rt2860/usb_main_dev.c b/drivers/staging/rt2860/usb_main_dev.c
deleted file mode 100644
index 322bf49..0000000
--- a/drivers/staging/rt2860/usb_main_dev.c
+++ /dev/null
@@ -1,927 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************/
-
-#include "rt_config.h"
-
-/* Following information will be show when you run 'modinfo' */
-/* If you have a solution for the bug in current version of driver, please e-mail me. */
-/* Otherwise post to the forum at ralinktech's web site(www.ralinktech.com) and let all users help you. */
-MODULE_AUTHOR("Paul Lin <paul_lin@ralinktech.com>");
-MODULE_DESCRIPTION("RT2870/RT3070 Wireless Lan Linux Driver");
-MODULE_LICENSE("GPL");
-#ifdef MODULE_VERSION
-MODULE_VERSION(STA_DRIVER_VERSION);
-#endif
-
-/* module table */
-struct usb_device_id rtusb_usb_id[] = {
-#ifdef RT2870
-	{USB_DEVICE(0x148F, 0x2770)},	/* Ralink */
-	{USB_DEVICE(0x148F, 0x2870)},	/* Ralink */
-	{USB_DEVICE(0x07B8, 0x2870)},	/* AboCom */
-	{USB_DEVICE(0x07B8, 0x2770)},	/* AboCom */
-	{USB_DEVICE(0x0DF6, 0x0039)},	/* Sitecom 2770 */
-	{USB_DEVICE(0x0DF6, 0x003F)},	/* Sitecom 2770 */
-	{USB_DEVICE(0x083A, 0x7512)},	/* Arcadyan 2770 */
-	{USB_DEVICE(0x0789, 0x0162)},	/* Logitec 2870 */
-	{USB_DEVICE(0x0789, 0x0163)},	/* Logitec 2870 */
-	{USB_DEVICE(0x0789, 0x0164)},	/* Logitec 2870 */
-	{USB_DEVICE(0x177f, 0x0302)},	/* lsusb */
-	{USB_DEVICE(0x0B05, 0x1731)},	/* Asus */
-	{USB_DEVICE(0x0B05, 0x1732)},	/* Asus */
-	{USB_DEVICE(0x0B05, 0x1742)},	/* Asus */
-	{USB_DEVICE(0x0DF6, 0x0017)},	/* Sitecom */
-	{USB_DEVICE(0x0DF6, 0x002B)},	/* Sitecom */
-	{USB_DEVICE(0x0DF6, 0x002C)},	/* Sitecom */
-	{USB_DEVICE(0x0DF6, 0x002D)},	/* Sitecom */
-	{USB_DEVICE(0x14B2, 0x3C06)},	/* Conceptronic */
-	{USB_DEVICE(0x14B2, 0x3C28)},	/* Conceptronic */
-	{USB_DEVICE(0x2019, 0xED06)},	/* Planex Communications, Inc. */
-	{USB_DEVICE(0x07D1, 0x3C09)},	/* D-Link */
-	{USB_DEVICE(0x07D1, 0x3C11)},	/* D-Link */
-	{USB_DEVICE(0x14B2, 0x3C07)},	/* AL */
-	{USB_DEVICE(0x050D, 0x8053)},	/* Belkin */
-	{USB_DEVICE(0x050D, 0x825B)},	/* Belkin */
-	{USB_DEVICE(0x050D, 0x935A)},	/* Belkin F6D4050 v1 */
-	{USB_DEVICE(0x050D, 0x935B)},	/* Belkin F6D4050 v2 */
-	{USB_DEVICE(0x14B2, 0x3C23)},	/* Airlink */
-	{USB_DEVICE(0x14B2, 0x3C27)},	/* Airlink */
-	{USB_DEVICE(0x07AA, 0x002F)},	/* Corega */
-	{USB_DEVICE(0x07AA, 0x003C)},	/* Corega */
-	{USB_DEVICE(0x07AA, 0x003F)},	/* Corega */
-	{USB_DEVICE(0x1044, 0x800B)},	/* Gigabyte */
-	{USB_DEVICE(0x15A9, 0x0006)},	/* Sparklan */
-	{USB_DEVICE(0x083A, 0xB522)},	/* SMC */
-	{USB_DEVICE(0x083A, 0xA618)},	/* SMC */
-	{USB_DEVICE(0x083A, 0x8522)},	/* Arcadyan */
-	{USB_DEVICE(0x083A, 0x7522)},	/* Arcadyan */
-	{USB_DEVICE(0x0CDE, 0x0022)},	/* ZCOM */
-	{USB_DEVICE(0x0586, 0x3416)},	/* Zyxel */
-	{USB_DEVICE(0x0586, 0x341a)},	/* Zyxel NWD-270N */
-	{USB_DEVICE(0x0CDE, 0x0025)},	/* Zyxel */
-	{USB_DEVICE(0x1740, 0x9701)},	/* EnGenius */
-	{USB_DEVICE(0x1740, 0x9702)},	/* EnGenius */
-	{USB_DEVICE(0x0471, 0x200f)},	/* Philips */
-	{USB_DEVICE(0x14B2, 0x3C25)},	/* Draytek */
-	{USB_DEVICE(0x13D3, 0x3247)},	/* AzureWave */
-	{USB_DEVICE(0x083A, 0x6618)},	/* Accton */
-	{USB_DEVICE(0x15c5, 0x0008)},	/* Amit */
-	{USB_DEVICE(0x0E66, 0x0001)},	/* Hawking */
-	{USB_DEVICE(0x0E66, 0x0003)},	/* Hawking */
-	{USB_DEVICE(0x129B, 0x1828)},	/* Siemens */
-	{USB_DEVICE(0x157E, 0x300E)},	/* U-Media */
-	{USB_DEVICE(0x050d, 0x805c)},
-	{USB_DEVICE(0x050d, 0x815c)},
-	{USB_DEVICE(0x1482, 0x3C09)},	/* Abocom */
-	{USB_DEVICE(0x14B2, 0x3C09)},	/* Alpha */
-	{USB_DEVICE(0x04E8, 0x2018)},	/* samsung linkstick2 */
-	{USB_DEVICE(0x1690, 0x0740)},	/* Askey */
-	{USB_DEVICE(0x5A57, 0x0280)},	/* Zinwell */
-	{USB_DEVICE(0x5A57, 0x0282)},	/* Zinwell */
-	{USB_DEVICE(0x7392, 0x7718)},
-	{USB_DEVICE(0x7392, 0x7717)},
-	{USB_DEVICE(0x0411, 0x016f)},	/* MelCo.,Inc. WLI-UC-G301N */
-	{USB_DEVICE(0x1737, 0x0070)},	/* Linksys WUSB100 */
-	{USB_DEVICE(0x1737, 0x0071)},	/* Linksys WUSB600N */
-	{USB_DEVICE(0x1737, 0x0078)},	/* Linksys WUSB100v2 */
-	{USB_DEVICE(0x0411, 0x00e8)},	/* Buffalo WLI-UC-G300N */
-	{USB_DEVICE(0x050d, 0x815c)},	/* Belkin F5D8053 */
-	{USB_DEVICE(0x100D, 0x9031)},	/* Motorola 2770 */
-#endif /* RT2870 // */
-#ifdef RT3070
-	{USB_DEVICE(0x148F, 0x3070)},	/* Ralink 3070 */
-	{USB_DEVICE(0x148F, 0x3071)},	/* Ralink 3071 */
-	{USB_DEVICE(0x148F, 0x3072)},	/* Ralink 3072 */
-	{USB_DEVICE(0x0DB0, 0x3820)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DB0, 0x871C)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DB0, 0x822C)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DB0, 0x871B)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DB0, 0x822B)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DF6, 0x003E)},	/* Sitecom 3070 */
-	{USB_DEVICE(0x0DF6, 0x0042)},	/* Sitecom 3072 */
-	{USB_DEVICE(0x0DF6, 0x0048)},	/* Sitecom 3070 */
-	{USB_DEVICE(0x0DF6, 0x0047)},	/* Sitecom 3071 */
-	{USB_DEVICE(0x14B2, 0x3C12)},	/* AL 3070 */
-	{USB_DEVICE(0x18C5, 0x0012)},	/* Corega 3070 */
-	{USB_DEVICE(0x083A, 0x7511)},	/* Arcadyan 3070 */
-	{USB_DEVICE(0x083A, 0xA701)},	/* SMC 3070 */
-	{USB_DEVICE(0x083A, 0xA702)},	/* SMC 3072 */
-	{USB_DEVICE(0x1740, 0x9703)},	/* EnGenius 3070 */
-	{USB_DEVICE(0x1740, 0x9705)},	/* EnGenius 3071 */
-	{USB_DEVICE(0x1740, 0x9706)},	/* EnGenius 3072 */
-	{USB_DEVICE(0x1740, 0x9707)},	/* EnGenius 3070 */
-	{USB_DEVICE(0x1740, 0x9708)},	/* EnGenius 3071 */
-	{USB_DEVICE(0x1740, 0x9709)},	/* EnGenius 3072 */
-	{USB_DEVICE(0x13D3, 0x3273)},	/* AzureWave 3070 */
-	{USB_DEVICE(0x13D3, 0x3305)},	/* AzureWave 3070*/
-	{USB_DEVICE(0x1044, 0x800D)},	/* Gigabyte GN-WB32L 3070 */
-	{USB_DEVICE(0x2019, 0xAB25)},	/* Planex Communications, Inc. RT3070 */
-	{USB_DEVICE(0x07B8, 0x3070)},	/* AboCom 3070 */
-	{USB_DEVICE(0x07B8, 0x3071)},	/* AboCom 3071 */
-	{USB_DEVICE(0x07B8, 0x3072)},	/* Abocom 3072 */
-	{USB_DEVICE(0x7392, 0x7711)},	/* Edimax 3070 */
-	{USB_DEVICE(0x1A32, 0x0304)},	/* Quanta 3070 */
-	{USB_DEVICE(0x1EDA, 0x2310)},	/* AirTies 3070 */
-	{USB_DEVICE(0x07D1, 0x3C0A)},	/* D-Link 3072 */
-	{USB_DEVICE(0x07D1, 0x3C0D)},	/* D-Link 3070 */
-	{USB_DEVICE(0x07D1, 0x3C0E)},	/* D-Link 3070 */
-	{USB_DEVICE(0x07D1, 0x3C0F)},	/* D-Link 3070 */
-	{USB_DEVICE(0x07D1, 0x3C16)},	/* D-Link 3070 */
-	{USB_DEVICE(0x07D1, 0x3C17)},	/* D-Link 8070 */
-	{USB_DEVICE(0x1D4D, 0x000C)},	/* Pegatron Corporation 3070 */
-	{USB_DEVICE(0x1D4D, 0x000E)},	/* Pegatron Corporation 3070 */
-	{USB_DEVICE(0x5A57, 0x5257)},	/* Zinwell 3070 */
-	{USB_DEVICE(0x5A57, 0x0283)},	/* Zinwell 3072 */
-	{USB_DEVICE(0x04BB, 0x0945)},	/* I-O DATA 3072 */
-	{USB_DEVICE(0x04BB, 0x0947)},	/* I-O DATA 3070 */
-	{USB_DEVICE(0x04BB, 0x0948)},	/* I-O DATA 3072 */
-	{USB_DEVICE(0x203D, 0x1480)},	/* Encore 3070 */
-	{USB_DEVICE(0x20B8, 0x8888)},	/* PARA INDUSTRIAL 3070 */
-	{USB_DEVICE(0x0B05, 0x1784)},	/* Asus 3072 */
-	{USB_DEVICE(0x203D, 0x14A9)},	/* Encore 3070*/
-	{USB_DEVICE(0x0DB0, 0x899A)},	/* MSI 3070*/
-	{USB_DEVICE(0x0DB0, 0x3870)},	/* MSI 3070*/
-	{USB_DEVICE(0x0DB0, 0x870A)},	/* MSI 3070*/
-	{USB_DEVICE(0x0DB0, 0x6899)},	/* MSI 3070 */
-	{USB_DEVICE(0x0DB0, 0x3822)},	/* MSI 3070 */
-	{USB_DEVICE(0x0DB0, 0x3871)},	/* MSI 3070 */
-	{USB_DEVICE(0x0DB0, 0x871A)},	/* MSI 3070 */
-	{USB_DEVICE(0x0DB0, 0x822A)},	/* MSI 3070 */
-	{USB_DEVICE(0x0DB0, 0x3821)},	/* Ralink 3070 */
-	{USB_DEVICE(0x0DB0, 0x821A)},	/* Ralink 3070 */
-	{USB_DEVICE(0x083A, 0xA703)},	/* IO-MAGIC */
-	{USB_DEVICE(0x13D3, 0x3307)},	/* Azurewave */
-	{USB_DEVICE(0x13D3, 0x3321)},	/* Azurewave */
-	{USB_DEVICE(0x07FA, 0x7712)},	/* Edimax */
-	{USB_DEVICE(0x0789, 0x0166)},	/* Edimax */
-	{USB_DEVICE(0x148F, 0x2070)},	/* Edimax */
-#endif /* RT3070 // */
-	{USB_DEVICE(0x1737, 0x0077)},	/* Linksys WUSB54GC-EU v3 */
-	{USB_DEVICE(0x2001, 0x3C09)},	/* D-Link */
-	{USB_DEVICE(0x2001, 0x3C0A)},	/* D-Link 3072 */
-	{USB_DEVICE(0x2019, 0xED14)},	/* Planex Communications, Inc. */
-	{USB_DEVICE(0x0411, 0x015D)},	/* Buffalo Airstation WLI-UC-GN */
-	{}			/* Terminating entry */
-};
-
-int const rtusb_usb_id_len =
-    sizeof(rtusb_usb_id) / sizeof(struct usb_device_id);
-
-MODULE_DEVICE_TABLE(usb, rtusb_usb_id);
-
-static void rt2870_disconnect(struct usb_device *dev, struct rt_rtmp_adapter *pAd);
-
-static int __devinit rt2870_probe(IN struct usb_interface *intf,
-				  IN struct usb_device *usb_dev,
-				  IN const struct usb_device_id *dev_id,
-				  struct rt_rtmp_adapter **ppAd);
-
-#ifndef PF_NOFREEZE
-#define PF_NOFREEZE  0
-#endif
-
-extern int rt28xx_close(IN struct net_device *net_dev);
-extern int rt28xx_open(struct net_device *net_dev);
-
-static BOOLEAN USBDevConfigInit(IN struct usb_device *dev,
-				IN struct usb_interface *intf,
-				struct rt_rtmp_adapter *pAd);
-
-/*
-========================================================================
-Routine Description:
-    Check the chipset vendor/product ID.
-
-Arguments:
-    _dev_p				Point to the PCI or USB device
-
-Return Value:
-    TRUE				Check ok
-	FALSE				Check fail
-
-Note:
-========================================================================
-*/
-BOOLEAN RT28XXChipsetCheck(IN void *_dev_p)
-{
-	struct usb_interface *intf = (struct usb_interface *)_dev_p;
-	struct usb_device *dev_p = interface_to_usbdev(intf);
-	u32 i;
-
-	for (i = 0; i < rtusb_usb_id_len; i++) {
-		if (dev_p->descriptor.idVendor == rtusb_usb_id[i].idVendor &&
-		    dev_p->descriptor.idProduct == rtusb_usb_id[i].idProduct) {
-			printk(KERN_INFO "rt2870: idVendor = 0x%x, idProduct = 0x%x\n",
-			       dev_p->descriptor.idVendor,
-			       dev_p->descriptor.idProduct);
-			break;
-		}
-	}
-
-	if (i == rtusb_usb_id_len) {
-		printk(KERN_ERR "rt2870: Error! Device Descriptor not matching!\n");
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/**************************************************************************/
-/**************************************************************************/
-/*tested for kernel 2.6series */
-/**************************************************************************/
-/**************************************************************************/
-
-#ifdef CONFIG_PM
-static int rt2870_suspend(struct usb_interface *intf, pm_message_t state);
-static int rt2870_resume(struct usb_interface *intf);
-#endif /* CONFIG_PM // */
-
-static BOOLEAN USBDevConfigInit(IN struct usb_device *dev,
-				IN struct usb_interface *intf,
-				struct rt_rtmp_adapter *pAd)
-{
-	struct usb_host_interface *iface_desc;
-	unsigned long BulkOutIdx;
-	u32 i;
-
-	/* get the active interface descriptor */
-	iface_desc = intf->cur_altsetting;
-
-	/* get # of enpoints  */
-	pAd->NumberOfPipes = iface_desc->desc.bNumEndpoints;
-	DBGPRINT(RT_DEBUG_TRACE,
-		 ("NumEndpoints=%d\n", iface_desc->desc.bNumEndpoints));
-
-	/* Configure Pipes */
-	BulkOutIdx = 0;
-
-	for (i = 0; i < pAd->NumberOfPipes; i++) {
-		if ((iface_desc->endpoint[i].desc.bmAttributes ==
-		     USB_ENDPOINT_XFER_BULK) &&
-		    ((iface_desc->endpoint[i].desc.bEndpointAddress &
-		      USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)) {
-			pAd->BulkInEpAddr =
-			    iface_desc->endpoint[i].desc.bEndpointAddress;
-			pAd->BulkInMaxPacketSize =
-			    le2cpu16(iface_desc->endpoint[i].desc.
-				     wMaxPacketSize);
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("BULK IN MaxPacketSize = %d\n",
-				      pAd->BulkInMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("EP address = 0x%2x\n",
-				      iface_desc->endpoint[i].desc.
-				      bEndpointAddress));
-		} else
-		    if ((iface_desc->endpoint[i].desc.bmAttributes ==
-			 USB_ENDPOINT_XFER_BULK)
-			&&
-			((iface_desc->endpoint[i].desc.
-			  bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
-			 USB_DIR_OUT)) {
-			/* there are 6 bulk out EP. EP6 highest priority. */
-			/* EP1-4 is EDCA.  EP5 is HCCA. */
-			pAd->BulkOutEpAddr[BulkOutIdx++] =
-			    iface_desc->endpoint[i].desc.bEndpointAddress;
-			pAd->BulkOutMaxPacketSize =
-			    le2cpu16(iface_desc->endpoint[i].desc.
-				     wMaxPacketSize);
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("BULK OUT MaxPacketSize = %d\n",
-				      pAd->BulkOutMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				     ("EP address = 0x%2x  \n",
-				      iface_desc->endpoint[i].desc.
-				      bEndpointAddress));
-		}
-	}
-
-	if (!(pAd->BulkInEpAddr && pAd->BulkOutEpAddr[0])) {
-		printk
-		    (KERN_ERR "%s: Could not find both bulk-in and bulk-out endpoints\n",
-		     __FUNCTION__);
-		return FALSE;
-	}
-
-	pAd->config = &dev->config->desc;
-	usb_set_intfdata(intf, pAd);
-
-	return TRUE;
-
-}
-
-static int __devinit rtusb_probe(struct usb_interface *intf,
-		       const struct usb_device_id *id)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct usb_device *dev;
-	int rv;
-
-	dev = interface_to_usbdev(intf);
-	dev = usb_get_dev(dev);
-
-	rv = rt2870_probe(intf, dev, id, &pAd);
-	if (rv != 0)
-		usb_put_dev(dev);
-
-	return rv;
-}
-
-static void rtusb_disconnect(struct usb_interface *intf)
-{
-	struct usb_device *dev = interface_to_usbdev(intf);
-	struct rt_rtmp_adapter *pAd;
-
-	pAd = usb_get_intfdata(intf);
-	usb_set_intfdata(intf, NULL);
-
-	rt2870_disconnect(dev, pAd);
-}
-
-struct usb_driver rtusb_driver = {
-	.name = "rt2870",
-	.probe = rtusb_probe,
-	.disconnect = rtusb_disconnect,
-	.id_table = rtusb_usb_id,
-
-#ifdef CONFIG_PM
-suspend:rt2870_suspend,
-resume:rt2870_resume,
-#endif
-};
-
-#ifdef CONFIG_PM
-
-void RT2870RejectPendingPackets(struct rt_rtmp_adapter *pAd)
-{
-	/* clear PS packets */
-	/* clear TxSw packets */
-}
-
-static int rt2870_suspend(struct usb_interface *intf, pm_message_t state)
-{
-	struct net_device *net_dev;
-	struct rt_rtmp_adapter *pAd = usb_get_intfdata(intf);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2870_suspend()\n"));
-	net_dev = pAd->net_dev;
-	netif_device_detach(net_dev);
-
-	pAd->PM_FlgSuspend = 1;
-	if (netif_running(net_dev)) {
-		RTUSBCancelPendingBulkInIRP(pAd);
-		RTUSBCancelPendingBulkOutIRP(pAd);
-	}
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2870_suspend()\n"));
-	return 0;
-}
-
-static int rt2870_resume(struct usb_interface *intf)
-{
-	struct net_device *net_dev;
-	struct rt_rtmp_adapter *pAd = usb_get_intfdata(intf);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2870_resume()\n"));
-
-	pAd->PM_FlgSuspend = 0;
-	net_dev = pAd->net_dev;
-	netif_device_attach(net_dev);
-	netif_start_queue(net_dev);
-	netif_carrier_on(net_dev);
-	netif_wake_queue(net_dev);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2870_resume()\n"));
-	return 0;
-}
-#endif /* CONFIG_PM // */
-
-/* Init driver module */
-int __init rtusb_init(void)
-{
-	printk(KERN_DEBUG "rtusb init --->\n");
-	return usb_register(&rtusb_driver);
-}
-
-/* Deinit driver module */
-void __exit rtusb_exit(void)
-{
-	usb_deregister(&rtusb_driver);
-	printk(KERN_DEBUG "<--- rtusb exit\n");
-}
-
-module_init(rtusb_init);
-module_exit(rtusb_exit);
-
-/*---------------------------------------------------------------------	*/
-/* function declarations												*/
-/*---------------------------------------------------------------------	*/
-
-/*
-========================================================================
-Routine Description:
-    MLME kernel thread.
-
-Arguments:
-	*Context			the pAd, driver control block pointer
-
-Return Value:
-    0					close the thread
-
-Note:
-========================================================================
-*/
-int MlmeThread(IN void *Context)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_rtmp_os_task *pTask;
-	int status;
-	status = 0;
-
-	pTask = Context;
-	pAd = pTask->priv;
-
-	RtmpOSTaskCustomize(pTask);
-
-	while (!pTask->task_killed) {
-#ifdef KTHREAD_SUPPORT
-		RTMP_WAIT_EVENT_INTERRUPTIBLE(pAd, pTask);
-#else
-		RTMP_SEM_EVENT_WAIT(&(pTask->taskSema), status);
-
-		/* unlock the device pointers */
-		if (status != 0) {
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-			break;
-		}
-#endif
-
-		/* lock the device pointers , need to check if required */
-		/*down(&(pAd->usbdev_semaphore)); */
-
-		if (!pAd->PM_FlgSuspend)
-			MlmeHandler(pAd);
-	}
-
-	/* notify the exit routine that we're actually exiting now
-	 *
-	 * complete()/wait_for_completion() is similar to up()/down(),
-	 * except that complete() is safe in the case where the structure
-	 * is getting deleted in a parallel mode of execution (i.e. just
-	 * after the down() -- that's necessary for the thread-shutdown
-	 * case.
-	 *
-	 * complete_and_exit() goes even further than this -- it is safe in
-	 * the case that the thread of the caller is going away (not just
-	 * the structure) -- this is necessary for the module-remove case.
-	 * This is important in preemption kernels, which transfer the flow
-	 * of execution immediately upon a complete().
-	 */
-	DBGPRINT(RT_DEBUG_TRACE, ("<---%s\n", __FUNCTION__));
-#ifndef KTHREAD_SUPPORT
-	pTask->taskPID = THREAD_PID_INIT_VALUE;
-	complete_and_exit(&pTask->taskComplete, 0);
-#endif
-	return 0;
-
-}
-
-/*
-========================================================================
-Routine Description:
-    USB command kernel thread.
-
-Arguments:
-	*Context			the pAd, driver control block pointer
-
-Return Value:
-    0					close the thread
-
-Note:
-========================================================================
-*/
-int RTUSBCmdThread(IN void *Context)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_rtmp_os_task *pTask;
-	int status;
-	status = 0;
-
-	pTask = Context;
-	pAd = pTask->priv;
-
-	RtmpOSTaskCustomize(pTask);
-
-	NdisAcquireSpinLock(&pAd->CmdQLock);
-	pAd->CmdQ.CmdQState = RTMP_TASK_STAT_RUNNING;
-	NdisReleaseSpinLock(&pAd->CmdQLock);
-
-	while (pAd && pAd->CmdQ.CmdQState == RTMP_TASK_STAT_RUNNING) {
-#ifdef KTHREAD_SUPPORT
-		RTMP_WAIT_EVENT_INTERRUPTIBLE(pAd, pTask);
-#else
-		/* lock the device pointers */
-		RTMP_SEM_EVENT_WAIT(&(pTask->taskSema), status);
-
-		if (status != 0) {
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
-			break;
-		}
-#endif
-
-		if (pAd->CmdQ.CmdQState == RTMP_TASK_STAT_STOPED)
-			break;
-
-		if (!pAd->PM_FlgSuspend)
-			CMDHandler(pAd);
-	}
-
-	if (pAd && !pAd->PM_FlgSuspend) {	/* Clear the CmdQElements. */
-		struct rt_cmdqelmt *pCmdQElmt = NULL;
-
-		NdisAcquireSpinLock(&pAd->CmdQLock);
-		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
-		while (pAd->CmdQ.size) {
-			RTUSBDequeueCmd(&pAd->CmdQ, &pCmdQElmt);
-			if (pCmdQElmt) {
-				if (pCmdQElmt->CmdFromNdis == TRUE) {
-					if (pCmdQElmt->buffer != NULL)
-						os_free_mem(pAd,
-							    pCmdQElmt->buffer);
-					os_free_mem(pAd, (u8 *)pCmdQElmt);
-				} else {
-					if ((pCmdQElmt->buffer != NULL)
-					    && (pCmdQElmt->bufferlength != 0))
-						os_free_mem(pAd,
-							    pCmdQElmt->buffer);
-					os_free_mem(pAd, (u8 *)pCmdQElmt);
-				}
-			}
-		}
-
-		NdisReleaseSpinLock(&pAd->CmdQLock);
-	}
-	/* notify the exit routine that we're actually exiting now
-	 *
-	 * complete()/wait_for_completion() is similar to up()/down(),
-	 * except that complete() is safe in the case where the structure
-	 * is getting deleted in a parallel mode of execution (i.e. just
-	 * after the down() -- that's necessary for the thread-shutdown
-	 * case.
-	 *
-	 * complete_and_exit() goes even further than this -- it is safe in
-	 * the case that the thread of the caller is going away (not just
-	 * the structure) -- this is necessary for the module-remove case.
-	 * This is important in preemption kernels, which transfer the flow
-	 * of execution immediately upon a complete().
-	 */
-	DBGPRINT(RT_DEBUG_TRACE, ("<---RTUSBCmdThread\n"));
-
-#ifndef KTHREAD_SUPPORT
-	pTask->taskPID = THREAD_PID_INIT_VALUE;
-	complete_and_exit(&pTask->taskComplete, 0);
-#endif
-	return 0;
-
-}
-
-void RTUSBWatchDog(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	int idx;
-	unsigned long irqFlags;
-	PURB pUrb;
-	BOOLEAN needDumpSeq = FALSE;
-	u32 MACValue;
-	u32 TxRxQ_Pcnt;
-
-	idx = 0;
-	RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
-	if ((MACValue & 0xff) != 0) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("TX QUEUE 0 Not EMPTY(Value=0x%0x)!\n",
-			  MACValue));
-		RTMP_IO_WRITE32(pAd, PBF_CFG, 0xf40012);
-		while ((MACValue & 0xff) != 0 && (idx++ < 10)) {
-			RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
-			RTMPusecDelay(1);
-		}
-		RTMP_IO_WRITE32(pAd, PBF_CFG, 0xf40006);
-	}
-
-	if (pAd->watchDogRxOverFlowCnt >= 2) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("Maybe the Rx Bulk-In hanged! Cancel the pending Rx bulks request!\n"));
-		if ((!RTMP_TEST_FLAG
-		     (pAd,
-		      (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-		       fRTMP_ADAPTER_BULKIN_RESET |
-		       fRTMP_ADAPTER_HALT_IN_PROGRESS |
-		       fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("Call CMDTHREAD_RESET_BULK_IN to cancel the pending Rx Bulk!\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN,
-						NULL, 0);
-			needDumpSeq = TRUE;
-		}
-		pAd->watchDogRxOverFlowCnt = 0;
-	}
-
-	RTUSBReadMACRegister(pAd, 0x438, &TxRxQ_Pcnt);
-
-	for (idx = 0; idx < NUM_OF_TX_RING; idx++) {
-		pUrb = NULL;
-
-		RTMP_IRQ_LOCK(&pAd->BulkOutLock[idx], irqFlags);
-		if ((pAd->BulkOutPending[idx] == TRUE)
-		    && pAd->watchDogTxPendingCnt) {
-			int actual_length = 0, transfer_buffer_length = 0;
-			BOOLEAN isDataPacket = FALSE;
-			pAd->watchDogTxPendingCnt[idx]++;
-
-			if ((pAd->watchDogTxPendingCnt[idx] > 2) &&
-			    (!RTMP_TEST_FLAG
-			     (pAd,
-			      (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-			       fRTMP_ADAPTER_HALT_IN_PROGRESS |
-			       fRTMP_ADAPTER_NIC_NOT_EXIST |
-			       fRTMP_ADAPTER_BULKOUT_RESET)))
-			    ) {
-				/* FIXME: Following code just support single bulk out. If you wanna support multiple bulk out. Modify it! */
-				pHTTXContext =
-				    (struct rt_ht_tx_context *)(&pAd->TxContext[idx]);
-				if (pHTTXContext->IRPPending) {	/* Check TxContext. */
-					pUrb = pHTTXContext->pUrb;
-
-					actual_length = pUrb->actual_length;
-					transfer_buffer_length =
-					    pUrb->transfer_buffer_length;
-					isDataPacket = TRUE;
-				} else if (idx == MGMTPIPEIDX) {
-					struct rt_tx_context *pMLMEContext, *pNULLContext,
-					    *pPsPollContext;
-
-					/*Check MgmtContext. */
-					pMLMEContext =
-					    (struct rt_tx_context *)(pAd->MgmtRing.
-							   Cell[pAd->MgmtRing.
-								TxDmaIdx].
-							   AllocVa);
-					pPsPollContext =
-					    (struct rt_tx_context *)(&pAd->PsPollContext);
-					pNULLContext =
-					    (struct rt_tx_context *)(&pAd->NullContext);
-
-					if (pMLMEContext->IRPPending) {
-						ASSERT(pMLMEContext->
-						       IRPPending);
-						pUrb = pMLMEContext->pUrb;
-					} else if (pNULLContext->IRPPending) {
-						ASSERT(pNULLContext->
-						       IRPPending);
-						pUrb = pNULLContext->pUrb;
-					} else if (pPsPollContext->IRPPending) {
-						ASSERT(pPsPollContext->
-						       IRPPending);
-						pUrb = pPsPollContext->pUrb;
-					}
-				}
-
-				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx],
-						irqFlags);
-
-				printk(KERN_INFO "%d:%lu LTL=%d , TL=%d L:%d\n",
-				       idx, pAd->watchDogTxPendingCnt[idx],
-				       pAd->TransferedLength[idx],
-				       actual_length, transfer_buffer_length);
-
-				if (pUrb) {
-					if ((isDataPacket
-					     && pAd->TransferedLength[idx] ==
-					     actual_length
-					     && pAd->TransferedLength[idx] <
-					     transfer_buffer_length
-					     && actual_length != 0
-/*                                      && TxRxQ_Pcnt==0 */
-					     && pAd->watchDogTxPendingCnt[idx] >
-					     3)
-					    || isDataPacket == FALSE
-					    || pAd->watchDogTxPendingCnt[idx] >
-					    6) {
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("Maybe the Tx Bulk-Out hanged! Cancel the pending Tx bulks request of idx(%d)!\n",
-							  idx));
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("Unlink the pending URB!\n"));
-						/* unlink it now */
-						RTUSB_UNLINK_URB(pUrb);
-						/* Sleep 200 microseconds to give cancellation time to work */
-						/*RTMPusecDelay(200); */
-						needDumpSeq = TRUE;
-					}
-				} else {
-					DBGPRINT(RT_DEBUG_ERROR,
-						 ("Unknown bulkOut URB maybe hanged!\n"));
-				}
-			} else {
-				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx],
-						irqFlags);
-			}
-
-			if (isDataPacket == TRUE)
-				pAd->TransferedLength[idx] = actual_length;
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
-		}
-	}
-
-	/* For Sigma debug, dump the ba_reordering sequence. */
-	if ((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0)) {
-		u16 Idx;
-		struct rt_ba_rec_entry *pBAEntry = NULL;
-		u8 count = 0;
-		struct reordering_mpdu *mpdu_blk;
-
-		Idx = pAd->MacTab.Content[BSSID_WCID].BARecWcidArray[0];
-
-		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-		if ((pBAEntry->list.qlen > 0) && (pBAEntry->list.next != NULL)) {
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("NICUpdateRawCounters():The Queueing pkt in reordering buffer:\n"));
-			NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-			mpdu_blk = pBAEntry->list.next;
-			while (mpdu_blk) {
-				DBGPRINT(RT_DEBUG_TRACE,
-					 ("\t%d:Seq-%d, bAMSDU-%d!\n", count,
-					  mpdu_blk->Sequence,
-					  mpdu_blk->bAMSDU));
-				mpdu_blk = mpdu_blk->next;
-				count++;
-			}
-
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("\npBAEntry->LastIndSeq=%d!\n",
-				  pBAEntry->LastIndSeq));
-			NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-		}
-	}
-}
-
-/*
-========================================================================
-Routine Description:
-    Release allocated resources.
-
-Arguments:
-    *dev				Point to the PCI or USB device
-	pAd					driver control block pointer
-
-Return Value:
-    None
-
-Note:
-========================================================================
-*/
-static void rt2870_disconnect(struct usb_device *dev, struct rt_rtmp_adapter *pAd)
-{
-	DBGPRINT(RT_DEBUG_ERROR,
-		 ("rtusb_disconnect: unregister usbnet usb-%s-%s\n",
-		  dev->bus->bus_name, dev->devpath));
-	if (!pAd) {
-		usb_put_dev(dev);
-		printk(KERN_ERR "rtusb_disconnect: pAd == NULL!\n");
-		return;
-	}
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
-
-	/* for debug, wait to show some messages to /proc system */
-	udelay(1);
-
-	RtmpPhyNetDevExit(pAd, pAd->net_dev);
-
-	/* FIXME: Shall we need following delay and flush the schedule?? */
-	udelay(1);
-	flush_scheduled_work();
-	udelay(1);
-
-	/* free the root net_device */
-	RtmpOSNetDevFree(pAd->net_dev);
-
-	RtmpRaDevCtrlExit(pAd);
-
-	/* release a use of the usb device structure */
-	usb_put_dev(dev);
-	udelay(1);
-
-	DBGPRINT(RT_DEBUG_ERROR, (" RTUSB disconnect successfully\n"));
-}
-
-static int __devinit rt2870_probe(IN struct usb_interface *intf,
-				  IN struct usb_device *usb_dev,
-				  IN const struct usb_device_id *dev_id,
-				  struct rt_rtmp_adapter **ppAd)
-{
-	struct net_device *net_dev = NULL;
-	struct rt_rtmp_adapter *pAd = (struct rt_rtmp_adapter *)NULL;
-	int status, rv;
-	void *handle;
-	struct rt_rtmp_os_netdev_op_hook netDevHook;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===>rt2870_probe()!\n"));
-
-	/* Check chipset vendor/product ID */
-	/*if (RT28XXChipsetCheck(_dev_p) == FALSE) */
-	/*      goto err_out; */
-
-/*RtmpDevInit============================================= */
-	/* Allocate struct rt_rtmp_adapter adapter structure */
-	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
-	if (handle == NULL) {
-		printk
-		    ("rt2870_probe(): Allocate memory for os handle failed!\n");
-		return -ENOMEM;
-	}
-	((struct os_cookie *)handle)->pUsb_Dev = usb_dev;
-
-	rv = RTMPAllocAdapterBlock(handle, &pAd);
-	if (rv != NDIS_STATUS_SUCCESS) {
-		kfree(handle);
-		goto err_out;
-	}
-/*USBDevInit============================================== */
-	if (USBDevConfigInit(usb_dev, intf, pAd) == FALSE)
-		goto err_out_free_radev;
-
-	RtmpRaDevCtrlInit(pAd, RTMP_DEV_INF_USB);
-
-/*NetDevInit============================================== */
-	net_dev = RtmpPhyNetDevInit(pAd, &netDevHook);
-	if (net_dev == NULL)
-		goto err_out_free_radev;
-
-	/* Here are the net_device structure with usb specific parameters. 
-	 * for supporting Network Manager.
-	 * Set the sysfs physical device reference for the network logical device if set prior to registration will
-	 * cause a symlink during initialization.
-	 */
-	SET_NETDEV_DEV(net_dev, &(usb_dev->dev));
-
-	pAd->StaCfg.OriDevType = net_dev->type;
-
-/*All done, it's time to register the net device to linux kernel. */
-	/* Register this device */
-	status = RtmpOSNetDevAttach(net_dev, &netDevHook);
-	if (status != 0)
-		goto err_out_free_netdev;
-
-#ifdef KTHREAD_SUPPORT
-	init_waitqueue_head(&pAd->mlmeTask.kthread_q);
-	init_waitqueue_head(&pAd->timerTask.kthread_q);
-	init_waitqueue_head(&pAd->cmdQTask.kthread_q);
-#endif
-
-	*ppAd = pAd;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<===rt2870_probe()!\n"));
-
-	return 0;
-
-	/* --------------------------- ERROR HANDLE --------------------------- */
-err_out_free_netdev:
-	RtmpOSNetDevFree(net_dev);
-
-err_out_free_radev:
-	RTMPFreeAdapter(pAd);
-
-err_out:
-	*ppAd = NULL;
-
-	return -1;
-
-}
diff --git a/drivers/staging/rt2860/wpa.h b/drivers/staging/rt2860/wpa.h
deleted file mode 100644
index a7796d3..0000000
--- a/drivers/staging/rt2860/wpa.h
+++ /dev/null
@@ -1,390 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	wpa.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name			Date			Modification logs
-	Justin P. Mattock	11/07/2010		Fix a typo
-*/
-
-#ifndef	__WPA_H__
-#define	__WPA_H__
-
-/* EAPOL Key descriptor frame format related length */
-#define LEN_KEY_DESC_NONCE			32
-#define LEN_KEY_DESC_IV				16
-#define LEN_KEY_DESC_RSC			8
-#define LEN_KEY_DESC_ID				8
-#define LEN_KEY_DESC_REPLAY			8
-#define LEN_KEY_DESC_MIC			16
-
-/* The length is the EAPoL-Key frame except key data field. */
-/* Please refer to 802.11i-2004 ,Figure 43u in p.78 */
-#define LEN_EAPOL_KEY_MSG			(sizeof(struct rt_key_descripter) - MAX_LEN_OF_RSNIE)
-
-/* EAP Code Type. */
-#define EAP_CODE_REQUEST	1
-#define EAP_CODE_RESPONSE	2
-#define EAP_CODE_SUCCESS    3
-#define EAP_CODE_FAILURE    4
-
-/* EAPOL frame Protocol Version */
-#define	EAPOL_VER					1
-#define	EAPOL_VER2					2
-
-/* EAPOL-KEY Descriptor Type */
-#define	WPA1_KEY_DESC				0xfe
-#define WPA2_KEY_DESC               0x02
-
-/* Key Descriptor Version of Key Information */
-#define	DESC_TYPE_TKIP				1
-#define	DESC_TYPE_AES				2
-
-#define LEN_MSG1_2WAY               0x7f
-#define MAX_LEN_OF_EAP_HS           256
-
-#define LEN_MASTER_KEY				32
-
-/* EAPOL EK, MK */
-#define LEN_EAP_EK					16
-#define LEN_EAP_MICK				16
-#define LEN_EAP_KEY					((LEN_EAP_EK)+(LEN_EAP_MICK))
-/* TKIP key related */
-#define LEN_PMKID					16
-#define LEN_TKIP_EK					16
-#define LEN_TKIP_RXMICK				8
-#define LEN_TKIP_TXMICK				8
-#define LEN_AES_EK					16
-#define LEN_AES_KEY					LEN_AES_EK
-#define LEN_TKIP_KEY				((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
-#define TKIP_AP_TXMICK_OFFSET		((LEN_EAP_KEY)+(LEN_TKIP_EK))
-#define TKIP_AP_RXMICK_OFFSET		(TKIP_AP_TXMICK_OFFSET+LEN_TKIP_TXMICK)
-#define TKIP_GTK_LENGTH				((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
-#define LEN_PTK						((LEN_EAP_KEY)+(LEN_TKIP_KEY))
-#define MIN_LEN_OF_GTK				5
-#define LEN_PMK						32
-#define LEN_PMK_NAME				16
-#define LEN_NONCE					32
-
-/* RSN IE Length definition */
-#define MAX_LEN_OF_RSNIE		255
-#define MIN_LEN_OF_RSNIE         	8
-
-#define KEY_LIFETIME				3600
-
-/*EAP Packet Type */
-#define	EAPPacket		0
-#define	EAPOLStart		1
-#define	EAPOLLogoff		2
-#define	EAPOLKey		3
-#define	EAPOLASFAlert	4
-#define	EAPTtypeMax		5
-
-#define	EAPOL_MSG_INVALID	0
-#define	EAPOL_PAIR_MSG_1	1
-#define	EAPOL_PAIR_MSG_2	2
-#define	EAPOL_PAIR_MSG_3	3
-#define	EAPOL_PAIR_MSG_4	4
-#define	EAPOL_GROUP_MSG_1	5
-#define	EAPOL_GROUP_MSG_2	6
-
-#define PAIRWISEKEY					1
-#define GROUPKEY					0
-
-/* Retry timer counter initial value */
-#define PEER_MSG1_RETRY_TIMER_CTR           0
-#define PEER_MSG3_RETRY_TIMER_CTR           10
-#define GROUP_MSG1_RETRY_TIMER_CTR          20
-
-/*#ifdef CONFIG_AP_SUPPORT */
-/* WPA mechanism retry timer interval */
-#define PEER_MSG1_RETRY_EXEC_INTV           1000	/* 1 sec */
-#define PEER_MSG3_RETRY_EXEC_INTV           3000	/* 3 sec */
-#define GROUP_KEY_UPDATE_EXEC_INTV          1000	/* 1 sec */
-#define PEER_GROUP_KEY_UPDATE_INIV			2000	/* 2 sec */
-
-#define ENQUEUE_EAPOL_START_TIMER			200	/* 200 ms */
-
-/* group rekey interval */
-#define TIME_REKEY                          0
-#define PKT_REKEY                           1
-#define DISABLE_REKEY                       2
-#define MAX_REKEY                           2
-
-#define MAX_REKEY_INTER                     0x3ffffff
-/*#endif // CONFIG_AP_SUPPORT // */
-
-#define GROUP_SUITE					0
-#define PAIRWISE_SUITE				1
-#define AKM_SUITE					2
-#define PMKID_LIST					3
-
-#define EAPOL_START_DISABLE					0
-#define EAPOL_START_PSK						1
-#define EAPOL_START_1X						2
-
-#define MIX_CIPHER_WPA_TKIP_ON(x)       (((x) & 0x08) != 0)
-#define MIX_CIPHER_WPA_AES_ON(x)        (((x) & 0x04) != 0)
-#define MIX_CIPHER_WPA2_TKIP_ON(x)      (((x) & 0x02) != 0)
-#define MIX_CIPHER_WPA2_AES_ON(x)       (((x) & 0x01) != 0)
-
-#ifndef ROUND_UP
-#define ROUND_UP(__x, __y) \
-	(((unsigned long)((__x)+((__y)-1))) & ((unsigned long)~((__y)-1)))
-#endif
-
-#define	SET_u16_TO_ARRARY(_V, _LEN)		\
-{											\
-	_V[0] = (_LEN & 0xFF00) >> 8;			\
-	_V[1] = (_LEN & 0xFF);					\
-}
-
-#define	INC_u16_TO_ARRARY(_V, _LEN)			\
-{												\
-	u16	var_len;							\
-												\
-	var_len = (_V[0]<<8) | (_V[1]);				\
-	var_len += _LEN;							\
-												\
-	_V[0] = (var_len & 0xFF00) >> 8;			\
-	_V[1] = (var_len & 0xFF);					\
-}
-
-#define	CONV_ARRARY_TO_u16(_V)	((_V[0]<<8) | (_V[1]))
-
-#define	ADD_ONE_To_64BIT_VAR(_V)		\
-{										\
-	u8	cnt = LEN_KEY_DESC_REPLAY;	\
-	do									\
-	{									\
-		cnt--;							\
-		_V[cnt]++;						\
-		if (cnt == 0)					\
-			break;						\
-	}while (_V[cnt] == 0);				\
-}
-
-#define IS_WPA_CAPABILITY(a)       (((a) >= Ndis802_11AuthModeWPA) && ((a) <= Ndis802_11AuthModeWPA1PSKWPA2PSK))
-
-/* EAPOL Key Information definition within Key descriptor format */
-struct PACKED rt_key_info {
-	u8 KeyMic:1;
-	u8 Secure:1;
-	u8 Error:1;
-	u8 Request:1;
-	u8 EKD_DL:1;		/* EKD for AP; DL for STA */
-	u8 Rsvd:3;
-	u8 KeyDescVer:3;
-	u8 KeyType:1;
-	u8 KeyIndex:2;
-	u8 Install:1;
-	u8 KeyAck:1;
-};
-
-/* EAPOL Key descriptor format */
-struct PACKED rt_key_descripter {
-	u8 Type;
-	struct rt_key_info KeyInfo;
-	u8 KeyLength[2];
-	u8 ReplayCounter[LEN_KEY_DESC_REPLAY];
-	u8 KeyNonce[LEN_KEY_DESC_NONCE];
-	u8 KeyIv[LEN_KEY_DESC_IV];
-	u8 KeyRsc[LEN_KEY_DESC_RSC];
-	u8 KeyId[LEN_KEY_DESC_ID];
-	u8 KeyMic[LEN_KEY_DESC_MIC];
-	u8 KeyDataLen[2];
-	u8 KeyData[MAX_LEN_OF_RSNIE];
-};
-
-struct PACKED rt_eapol_packet {
-	u8 ProVer;
-	u8 ProType;
-	u8 Body_Len[2];
-	struct rt_key_descripter KeyDesc;
-};
-
-/*802.11i D10 page 83 */
-struct PACKED rt_gtk_encap {
-	u8 Kid:2;
-	u8 tx:1;
-	u8 rsv:5;
-	u8 rsv1;
-	u8 GTK[TKIP_GTK_LENGTH];
-};
-
-struct PACKED rt_kde_encap {
-	u8 Type;
-	u8 Len;
-	u8 OUI[3];
-	u8 DataType;
-	struct rt_gtk_encap GTKEncap;
-};
-
-/* For WPA1 */
-struct PACKED rt_rsnie {
-	u8 oui[4];
-	u16 version;
-	u8 mcast[4];
-	u16 ucount;
-	struct PACKED {
-		u8 oui[4];
-	} ucast[1];
-};
-
-/* For WPA2 */
-struct PACKED rt_rsnie2 {
-	u16 version;
-	u8 mcast[4];
-	u16 ucount;
-	struct PACKED {
-		u8 oui[4];
-	} ucast[1];
-};
-
-/* AKM Suite */
-struct PACKED rt_rsnie_auth {
-	u16 acount;
-	struct PACKED {
-		u8 oui[4];
-	} auth[1];
-};
-
-typedef union PACKED _RSN_CAPABILITIES {
-	struct PACKED {
-		u16 PreAuth:1;
-		u16 No_Pairwise:1;
-		u16 PTKSA_R_Counter:2;
-		u16 GTKSA_R_Counter:2;
-		u16 Rsvd:10;
-	} field;
-	u16 word;
-} RSN_CAPABILITIES, *PRSN_CAPABILITIES;
-
-struct PACKED rt_eap_hdr {
-	u8 ProVer;
-	u8 ProType;
-	u8 Body_Len[2];
-	u8 code;
-	u8 identifier;
-	u8 length[2];	/* including code and identifier, followed by length-2 octets of data */
-};
-
-/* For supplicant state machine states. 802.11i Draft 4.1, p. 97 */
-/* We simplified it */
-typedef enum _WpaState {
-	SS_NOTUSE,		/* 0 */
-	SS_START,		/* 1 */
-	SS_WAIT_MSG_3,		/* 2 */
-	SS_WAIT_GROUP,		/* 3 */
-	SS_FINISH,		/* 4 */
-	SS_KEYUPDATE,		/* 5 */
-} WPA_STATE;
-
-/* */
-/*      The definition of the cipher combination */
-/* */
-/*       bit3   bit2  bit1   bit0 */
-/*      +------------+------------+ */
-/*      |         WPA    |         WPA2   | */
-/*      +------+-----+------+-----+ */
-/*      | TKIP | AES | TKIP | AES | */
-/*      |       0  |  1  |   1  |  0  | -> 0x06 */
-/*      |       0  |  1  |   1  |  1  | -> 0x07 */
-/*      |       1  |  0  |   0  |  1  | -> 0x09 */
-/*      |       1  |  0  |   1  |  1  | -> 0x0B */
-/*      |       1  |  1  |   0  |  1  | -> 0x0D */
-/*      |       1  |  1  |   1  |  0  | -> 0x0E */
-/*      |       1  |  1  |   1  |  1  | -> 0x0F */
-/*      +------+-----+------+-----+ */
-/* */
-typedef enum _WpaMixPairCipher {
-	MIX_CIPHER_NOTUSE = 0x00,
-	WPA_NONE_WPA2_TKIPAES = 0x03,	/* WPA2-TKIPAES */
-	WPA_AES_WPA2_TKIP = 0x06,
-	WPA_AES_WPA2_TKIPAES = 0x07,
-	WPA_TKIP_WPA2_AES = 0x09,
-	WPA_TKIP_WPA2_TKIPAES = 0x0B,
-	WPA_TKIPAES_WPA2_NONE = 0x0C,	/* WPA-TKIPAES */
-	WPA_TKIPAES_WPA2_AES = 0x0D,
-	WPA_TKIPAES_WPA2_TKIP = 0x0E,
-	WPA_TKIPAES_WPA2_TKIPAES = 0x0F,
-} WPA_MIX_PAIR_CIPHER;
-
-struct PACKED rt_rsn_ie_header {
-	u8 Eid;
-	u8 Length;
-	u16 Version;		/* Little endian format */
-};
-
-/* Cipher suite selector types */
-struct PACKED rt_cipher_suite_struct {
-	u8 Oui[3];
-	u8 Type;
-};
-
-/* Authentication and Key Management suite selector */
-struct PACKED rt_akm_suite {
-	u8 Oui[3];
-	u8 Type;
-};
-
-/* RSN capability */
-struct PACKED rt_rsn_capability {
-	u16 Rsv:10;
-	u16 GTKSAReplayCnt:2;
-	u16 PTKSAReplayCnt:2;
-	u16 NoPairwise:1;
-	u16 PreAuth:1;
-};
-
-/*========================================
-	The prototype is defined in cmm_wpa.c
-  ========================================*/
-BOOLEAN WpaMsgTypeSubst(u8 EAPType, int *MsgType);
-
-void PRF(u8 *key, int key_len, u8 *prefix, int prefix_len,
-	 u8 *data, int data_len, u8 *output, int len);
-
-int PasswordHash(char *password,
-		 unsigned char *ssid, int ssidlength, unsigned char *output);
-
-u8 *GetSuiteFromRSNIE(u8 *rsnie, u32 rsnie_len, u8 type, u8 *count);
-
-void WpaShowAllsuite(u8 *rsnie, u32 rsnie_len);
-
-void RTMPInsertRSNIE(u8 *pFrameBuf,
-		     unsigned long *pFrameLen,
-		     u8 *rsnie_ptr,
-		     u8 rsnie_len,
-		     u8 *pmkid_ptr, u8 pmkid_len);
-
-#endif
diff --git a/drivers/staging/rt2870/Kconfig b/drivers/staging/rt2870/Kconfig
deleted file mode 100644
index e988680..0000000
--- a/drivers/staging/rt2870/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-config RT2870
-	tristate "Ralink 2870/3070 wireless support"
-	depends on USB && (X86 || ARM) && WLAN
-	select WIRELESS_EXT
-	select WEXT_PRIV
-	select CRC_CCITT
-	select FW_LOADER
-	---help---
-	  This is an experimental driver for the Ralink xx70 wireless chips.
diff --git a/drivers/staging/rt2870/Makefile b/drivers/staging/rt2870/Makefile
deleted file mode 100644
index b499910..0000000
--- a/drivers/staging/rt2870/Makefile
+++ /dev/null
@@ -1,55 +0,0 @@
-#
-obj-$(CONFIG_RT2870)	+= rt2870sta.o
-
-# TODO: all of these should be removed
-ccflags-y := -DLINUX -DAGGREGATION_SUPPORT -DPIGGYBACK_SUPPORT -DWMM_SUPPORT
-ccflags-y += -DRTMP_MAC_USB -DRTMP_USB_SUPPORT -DRT2870 -DRTMP_TIMER_TASK_SUPPORT
-ccflags-y += -DRTMP_RF_RW_SUPPORT -DRTMP_EFUSE_SUPPORT -DRT30xx -DRT3070
-ccflags-y += -DDBG
-
-rt2870sta-y :=		\
-	common/crypt_md5.o	\
-	common/crypt_sha2.o	\
-	common/crypt_hmac.o	\
-	common/mlme.o		\
-	common/cmm_wep.o	\
-	common/action.o		\
-	common/cmm_data.o	\
-	common/rtmp_init.o	\
-	common/cmm_tkip.o	\
-	common/cmm_aes.o	\
-	common/cmm_sync.o	\
-	common/eeprom.o		\
-	common/cmm_sanity.o	\
-	common/cmm_info.o	\
-	common/cmm_cfg.o	\
-	common/cmm_wpa.o	\
-	common/dfs.o		\
-	common/spectrum.o	\
-	common/rtmp_timer.o	\
-	common/rt_channel.o	\
-	common/cmm_asic.o	\
-	sta/assoc.o		\
-	sta/auth.o		\
-	sta/auth_rsp.o		\
-	sta/sync.o		\
-	sta/sanity.o		\
-	sta/rtmp_data.o		\
-	sta/connect.o		\
-	sta/wpa.o		\
-	rt_linux.o		\
-	rt_main_dev.o		\
-	sta_ioctl.o		\
-	common/ba_action.o	\
-	usb_main_dev.o		\
-	rt_usb.o		\
-	common/cmm_mac_usb.o	\
-	common/rtusb_io.o	\
-	common/rtusb_bulk.o	\
-	common/rtusb_data.o	\
-	common/cmm_data_usb.o	\
-	common/rtmp_mcu.o	\
-	common/ee_efuse.o	\
-	chips/rt30xx.o		\
-	common/rt_rf.o		\
-	chips/rt3070.o
diff --git a/drivers/staging/rt2870/TODO b/drivers/staging/rt2870/TODO
deleted file mode 100644
index 2df1bfe..0000000
--- a/drivers/staging/rt2870/TODO
+++ /dev/null
@@ -1,17 +0,0 @@
-I'm hesitant to add a TODO file here, as the wireless developers would
-really have people help them out on the "clean" rt2870 driver that can
-be found at the http://rt2x00.serialmonkey.com/ site.
-
-But, if you wish to clean up this driver instead, here's a short list of
-things that need to be done to get it into a more mergable shape:
-
-TODO:
-	- checkpatch.pl clean
-	- sparse clean
-	- port to in-kernel 80211 stack and common rt2x00 infrastructure
-	- remove reading from /etc/ config files
-	- review by the wireless developer community
-
-Please send any patches or complaints about this driver to Greg
-Kroah-Hartman <greg@kroah.com> and don't bother the upstream wireless
-kernel developers about it, they want nothing to do with it.
diff --git a/drivers/staging/rt2870/aironet.h b/drivers/staging/rt2870/aironet.h
deleted file mode 100644
index ae62597..0000000
--- a/drivers/staging/rt2870/aironet.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/aironet.h"
diff --git a/drivers/staging/rt2870/ap.h b/drivers/staging/rt2870/ap.h
deleted file mode 100644
index fe04b5f..0000000
--- a/drivers/staging/rt2870/ap.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/ap.h"
diff --git a/drivers/staging/rt2870/chips/rt3070.c b/drivers/staging/rt2870/chips/rt3070.c
deleted file mode 100644
index 3a6db5e..0000000
--- a/drivers/staging/rt2870/chips/rt3070.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/chips/rt3070.c"
diff --git a/drivers/staging/rt2870/chips/rt30xx.c b/drivers/staging/rt2870/chips/rt30xx.c
deleted file mode 100644
index 6c56b84..0000000
--- a/drivers/staging/rt2870/chips/rt30xx.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/chips/rt30xx.c"
diff --git a/drivers/staging/rt2870/chlist.h b/drivers/staging/rt2870/chlist.h
deleted file mode 100644
index 3199958..0000000
--- a/drivers/staging/rt2870/chlist.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/chlist.h"
diff --git a/drivers/staging/rt2870/common/acction.c b/drivers/staging/rt2870/common/acction.c
deleted file mode 100644
index fd806c3..0000000
--- a/drivers/staging/rt2870/common/acction.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/action.c"
diff --git a/drivers/staging/rt2870/common/action.c b/drivers/staging/rt2870/common/action.c
deleted file mode 100644
index fd806c3..0000000
--- a/drivers/staging/rt2870/common/action.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/action.c"
diff --git a/drivers/staging/rt2870/common/action.h b/drivers/staging/rt2870/common/action.h
deleted file mode 100644
index 9a18955..0000000
--- a/drivers/staging/rt2870/common/action.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/action.h"
diff --git a/drivers/staging/rt2870/common/ba_action.c b/drivers/staging/rt2870/common/ba_action.c
deleted file mode 100644
index a9e6a09..0000000
--- a/drivers/staging/rt2870/common/ba_action.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/ba_action.c"
diff --git a/drivers/staging/rt2870/common/cmm_aes.c b/drivers/staging/rt2870/common/cmm_aes.c
deleted file mode 100644
index 15d6a14..0000000
--- a/drivers/staging/rt2870/common/cmm_aes.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_aes.c"
diff --git a/drivers/staging/rt2870/common/cmm_asic.c b/drivers/staging/rt2870/common/cmm_asic.c
deleted file mode 100644
index 38de817..0000000
--- a/drivers/staging/rt2870/common/cmm_asic.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_asic.c"
diff --git a/drivers/staging/rt2870/common/cmm_cfg.c b/drivers/staging/rt2870/common/cmm_cfg.c
deleted file mode 100644
index 6b2bdd7..0000000
--- a/drivers/staging/rt2870/common/cmm_cfg.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_cfg.c"
diff --git a/drivers/staging/rt2870/common/cmm_data.c b/drivers/staging/rt2870/common/cmm_data.c
deleted file mode 100644
index df775c3..0000000
--- a/drivers/staging/rt2870/common/cmm_data.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_data.c"
diff --git a/drivers/staging/rt2870/common/cmm_data_usb.c b/drivers/staging/rt2870/common/cmm_data_usb.c
deleted file mode 100644
index 704675f..0000000
--- a/drivers/staging/rt2870/common/cmm_data_usb.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_data_usb.c"
diff --git a/drivers/staging/rt2870/common/cmm_info.c b/drivers/staging/rt2870/common/cmm_info.c
deleted file mode 100644
index 226187e..0000000
--- a/drivers/staging/rt2870/common/cmm_info.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_info.c"
diff --git a/drivers/staging/rt2870/common/cmm_mac_usb.c b/drivers/staging/rt2870/common/cmm_mac_usb.c
deleted file mode 100644
index b26af4a..0000000
--- a/drivers/staging/rt2870/common/cmm_mac_usb.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_mac_usb.c"
diff --git a/drivers/staging/rt2870/common/cmm_profile.c b/drivers/staging/rt2870/common/cmm_profile.c
deleted file mode 100644
index 9926e45..0000000
--- a/drivers/staging/rt2870/common/cmm_profile.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_profile.c"
diff --git a/drivers/staging/rt2870/common/cmm_sanity.c b/drivers/staging/rt2870/common/cmm_sanity.c
deleted file mode 100644
index cb33521..0000000
--- a/drivers/staging/rt2870/common/cmm_sanity.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_sanity.c"
diff --git a/drivers/staging/rt2870/common/cmm_sync.c b/drivers/staging/rt2870/common/cmm_sync.c
deleted file mode 100644
index 5e7221d..0000000
--- a/drivers/staging/rt2870/common/cmm_sync.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_sync.c"
diff --git a/drivers/staging/rt2870/common/cmm_tkip.c b/drivers/staging/rt2870/common/cmm_tkip.c
deleted file mode 100644
index f73c71b..0000000
--- a/drivers/staging/rt2870/common/cmm_tkip.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_tkip.c"
diff --git a/drivers/staging/rt2870/common/cmm_wep.c b/drivers/staging/rt2870/common/cmm_wep.c
deleted file mode 100644
index 5f68107..0000000
--- a/drivers/staging/rt2870/common/cmm_wep.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_wep.c"
diff --git a/drivers/staging/rt2870/common/cmm_wpa.c b/drivers/staging/rt2870/common/cmm_wpa.c
deleted file mode 100644
index 04a54bb..0000000
--- a/drivers/staging/rt2870/common/cmm_wpa.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/cmm_wpa.c"
diff --git a/drivers/staging/rt2870/common/crypt_hmac.c b/drivers/staging/rt2870/common/crypt_hmac.c
deleted file mode 100644
index 24d84e7..0000000
--- a/drivers/staging/rt2870/common/crypt_hmac.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/crypt_hmac.c"
diff --git a/drivers/staging/rt2870/common/crypt_md5.c b/drivers/staging/rt2870/common/crypt_md5.c
deleted file mode 100644
index 457a2ca..0000000
--- a/drivers/staging/rt2870/common/crypt_md5.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/crypt_md5.c"
diff --git a/drivers/staging/rt2870/common/crypt_sha2.c b/drivers/staging/rt2870/common/crypt_sha2.c
deleted file mode 100644
index 07ffb30..0000000
--- a/drivers/staging/rt2870/common/crypt_sha2.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/crypt_sha2.c"
diff --git a/drivers/staging/rt2870/common/dfs.c b/drivers/staging/rt2870/common/dfs.c
deleted file mode 100644
index ac2da4c..0000000
--- a/drivers/staging/rt2870/common/dfs.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/dfs.c"
diff --git a/drivers/staging/rt2870/common/ee_efuse.c b/drivers/staging/rt2870/common/ee_efuse.c
deleted file mode 100644
index 0e34e65..0000000
--- a/drivers/staging/rt2870/common/ee_efuse.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/ee_efuse.c"
diff --git a/drivers/staging/rt2870/common/eeprom.c b/drivers/staging/rt2870/common/eeprom.c
deleted file mode 100644
index def0965..0000000
--- a/drivers/staging/rt2870/common/eeprom.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/eeprom.c"
diff --git a/drivers/staging/rt2870/common/md5.c b/drivers/staging/rt2870/common/md5.c
deleted file mode 100644
index 195645c..0000000
--- a/drivers/staging/rt2870/common/md5.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/md5.c"
diff --git a/drivers/staging/rt2870/common/mlme.c b/drivers/staging/rt2870/common/mlme.c
deleted file mode 100644
index f88040a..0000000
--- a/drivers/staging/rt2870/common/mlme.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/mlme.c"
diff --git a/drivers/staging/rt2870/common/rt_channel.c b/drivers/staging/rt2870/common/rt_channel.c
deleted file mode 100644
index c8ceb4c..0000000
--- a/drivers/staging/rt2870/common/rt_channel.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rt_channel.c"
diff --git a/drivers/staging/rt2870/common/rt_rf.c b/drivers/staging/rt2870/common/rt_rf.c
deleted file mode 100644
index b81cff3..0000000
--- a/drivers/staging/rt2870/common/rt_rf.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rt_rf.c"
diff --git a/drivers/staging/rt2870/common/rtmp_init.c b/drivers/staging/rt2870/common/rtmp_init.c
deleted file mode 100644
index eef10ef..0000000
--- a/drivers/staging/rt2870/common/rtmp_init.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rtmp_init.c"
diff --git a/drivers/staging/rt2870/common/rtmp_mcu.c b/drivers/staging/rt2870/common/rtmp_mcu.c
deleted file mode 100644
index 20b7f13..0000000
--- a/drivers/staging/rt2870/common/rtmp_mcu.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rtmp_mcu.c"
diff --git a/drivers/staging/rt2870/common/rtmp_timer.c b/drivers/staging/rt2870/common/rtmp_timer.c
deleted file mode 100644
index fd4aedc..0000000
--- a/drivers/staging/rt2870/common/rtmp_timer.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rtmp_timer.c"
diff --git a/drivers/staging/rt2870/common/rtmp_tkip.c b/drivers/staging/rt2870/common/rtmp_tkip.c
deleted file mode 100644
index 240bf67..0000000
--- a/drivers/staging/rt2870/common/rtmp_tkip.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rtmp_tkip.c"
diff --git a/drivers/staging/rt2870/common/rtmp_wep.c b/drivers/staging/rt2870/common/rtmp_wep.c
deleted file mode 100644
index ae255ad..0000000
--- a/drivers/staging/rt2870/common/rtmp_wep.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/rtmp_wep.c"
diff --git a/drivers/staging/rt2870/common/rtusb_bulk.c b/drivers/staging/rt2870/common/rtusb_bulk.c
deleted file mode 100644
index 679b802..0000000
--- a/drivers/staging/rt2870/common/rtusb_bulk.c
+++ /dev/null
@@ -1,1232 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtusb_bulk.c
-
-	Abstract:
-
-	Revision History:
-	Who			When		What
-	--------	----------	----------------------------------------------
-	Name		Date		Modification logs
-	Paul Lin	06-25-2004	created
-
-*/
-
-#ifdef RTMP_MAC_USB
-
-#include "../rt_config.h"
-/* Match total 6 bulkout endpoint to corresponding queue. */
-u8 EpToQueue[6] =
-    { FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_MGMT };
-
-/*static BOOLEAN SingleBulkOut = FALSE; */
-
-void RTUSB_FILL_BULK_URB(struct urb *pUrb,
-			 struct usb_device *pUsb_Dev,
-			 unsigned int bulkpipe,
-			 void *pTransferBuf,
-			 int BufSize, usb_complete_t Complete, void *pContext)
-{
-
-	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize,
-			  (usb_complete_t) Complete, pContext);
-
-}
-
-void RTUSBInitTxDesc(struct rt_rtmp_adapter *pAd,
-		     struct rt_tx_context *pTxContext,
-		     u8 BulkOutPipeId, IN usb_complete_t Func)
-{
-	PURB pUrb;
-	u8 *pSrc = NULL;
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pUrb = pTxContext->pUrb;
-	ASSERT(pUrb);
-
-	/* Store BulkOut PipeId */
-	pTxContext->BulkOutPipeId = BulkOutPipeId;
-
-	if (pTxContext->bAggregatible) {
-		pSrc = &pTxContext->TransferBuffer->Aggregation[2];
-	} else {
-		pSrc =
-		    (u8 *)pTxContext->TransferBuffer->field.WirelessPacket;
-	}
-
-	/*Initialize a tx bulk urb */
-	RTUSB_FILL_BULK_URB(pUrb,
-			    pObj->pUsb_Dev,
-			    usb_sndbulkpipe(pObj->pUsb_Dev,
-					    pAd->BulkOutEpAddr[BulkOutPipeId]),
-			    pSrc, pTxContext->BulkOutSize, Func, pTxContext);
-
-	if (pTxContext->bAggregatible)
-		pUrb->transfer_dma =
-		    (pTxContext->data_dma + TX_BUFFER_NORMSIZE + 2);
-	else
-		pUrb->transfer_dma = pTxContext->data_dma;
-
-	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-}
-
-void RTUSBInitHTTxDesc(struct rt_rtmp_adapter *pAd,
-		       struct rt_ht_tx_context *pTxContext,
-		       u8 BulkOutPipeId,
-		       unsigned long BulkOutSize, IN usb_complete_t Func)
-{
-	PURB pUrb;
-	u8 *pSrc = NULL;
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pUrb = pTxContext->pUrb;
-	ASSERT(pUrb);
-
-	/* Store BulkOut PipeId */
-	pTxContext->BulkOutPipeId = BulkOutPipeId;
-
-	pSrc =
-	    &pTxContext->TransferBuffer->field.WirelessPacket[pTxContext->
-							      NextBulkOutPosition];
-
-	/*Initialize a tx bulk urb */
-	RTUSB_FILL_BULK_URB(pUrb,
-			    pObj->pUsb_Dev,
-			    usb_sndbulkpipe(pObj->pUsb_Dev,
-					    pAd->BulkOutEpAddr[BulkOutPipeId]),
-			    pSrc, BulkOutSize, Func, pTxContext);
-
-	pUrb->transfer_dma =
-	    (pTxContext->data_dma + pTxContext->NextBulkOutPosition);
-	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-}
-
-void RTUSBInitRxDesc(struct rt_rtmp_adapter *pAd, struct rt_rx_context *pRxContext)
-{
-	PURB pUrb;
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-	unsigned long RX_bulk_size;
-
-	pUrb = pRxContext->pUrb;
-	ASSERT(pUrb);
-
-	if (pAd->BulkInMaxPacketSize == 64)
-		RX_bulk_size = 4096;
-	else
-		RX_bulk_size = MAX_RXBULK_SIZE;
-
-	/*Initialize a rx bulk urb */
-	RTUSB_FILL_BULK_URB(pUrb,
-			    pObj->pUsb_Dev,
-			    usb_rcvbulkpipe(pObj->pUsb_Dev, pAd->BulkInEpAddr),
-			    &(pRxContext->
-			      TransferBuffer[pAd->NextRxBulkInPosition]),
-			    RX_bulk_size - (pAd->NextRxBulkInPosition),
-			    (usb_complete_t) RTUSBBulkRxComplete,
-			    (void *)pRxContext);
-
-	pUrb->transfer_dma = pRxContext->data_dma + pAd->NextRxBulkInPosition;
-	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-
-#define BULK_OUT_LOCK(pLock, IrqFlags)	\
-		if (1 /*!(in_interrupt() & 0xffff0000)*/)	\
-			RTMP_IRQ_LOCK((pLock), IrqFlags);
-
-#define BULK_OUT_UNLOCK(pLock, IrqFlags)	\
-		if (1 /*!(in_interrupt() & 0xffff0000)*/)	\
-			RTMP_IRQ_UNLOCK((pLock), IrqFlags);
-
-void RTUSBBulkOutDataPacket(struct rt_rtmp_adapter *pAd,
-			    u8 BulkOutPipeId, u8 Index)
-{
-
-	struct rt_ht_tx_context *pHTTXContext;
-	PURB pUrb;
-	int ret = 0;
-	struct rt_txinfo *pTxInfo, *pLastTxInfo = NULL;
-	struct rt_txwi *pTxWI;
-	unsigned long TmpBulkEndPos, ThisBulkSize;
-	unsigned long IrqFlags = 0, IrqFlags2 = 0;
-	u8 *pWirelessPkt, *pAppendant;
-	BOOLEAN bTxQLastRound = FALSE;
-	u8 allzero[4] = { 0x0, 0x0, 0x0, 0x0 };
-
-	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	if ((pAd->BulkOutPending[BulkOutPipeId] == TRUE)
-	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
-		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-		return;
-	}
-	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
-
-	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-	    ) {
-		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-		return;
-	}
-	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-
-	pHTTXContext = &(pAd->TxContext[BulkOutPipeId]);
-
-	BULK_OUT_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
-	if ((pHTTXContext->ENextBulkOutPosition ==
-	     pHTTXContext->CurWritePosition)
-	    || ((pHTTXContext->ENextBulkOutPosition - 8) ==
-		pHTTXContext->CurWritePosition)) {
-		BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId],
-				IrqFlags2);
-
-		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-
-		/* Clear Data flag */
-		RTUSB_CLEAR_BULK_FLAG(pAd,
-				      (fRTUSB_BULK_OUT_DATA_FRAG <<
-				       BulkOutPipeId));
-		RTUSB_CLEAR_BULK_FLAG(pAd,
-				      (fRTUSB_BULK_OUT_DATA_NORMAL <<
-				       BulkOutPipeId));
-
-		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-		return;
-	}
-	/* Clear Data flag */
-	RTUSB_CLEAR_BULK_FLAG(pAd,
-			      (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
-	RTUSB_CLEAR_BULK_FLAG(pAd,
-			      (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
-
-	/*DBGPRINT(RT_DEBUG_TRACE,("BulkOut-B:I=0x%lx, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", in_interrupt(), */
-	/*                                                      pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, */
-	/*                                                      pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad)); */
-	pHTTXContext->NextBulkOutPosition = pHTTXContext->ENextBulkOutPosition;
-	ThisBulkSize = 0;
-	TmpBulkEndPos = pHTTXContext->NextBulkOutPosition;
-	pWirelessPkt = &pHTTXContext->TransferBuffer->field.WirelessPacket[0];
-
-	if ((pHTTXContext->bCopySavePad == TRUE)) {
-		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero, 4)) {
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("e1, allzero : %x  %x  %x  %x  %x  %x  %x  %x \n",
-				      pHTTXContext->SavedPad[0],
-				      pHTTXContext->SavedPad[1],
-				      pHTTXContext->SavedPad[2],
-				      pHTTXContext->SavedPad[3]
-				      , pHTTXContext->SavedPad[4],
-				      pHTTXContext->SavedPad[5],
-				      pHTTXContext->SavedPad[6],
-				      pHTTXContext->SavedPad[7]));
-		}
-		NdisMoveMemory(&pWirelessPkt[TmpBulkEndPos],
-			       pHTTXContext->SavedPad, 8);
-		pHTTXContext->bCopySavePad = FALSE;
-		if (pAd->bForcePrintTX == TRUE)
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("RTUSBBulkOutDataPacket --> COPY PAD. CurWrite = %ld, NextBulk = %ld.   ENextBulk = %ld.\n",
-				  pHTTXContext->CurWritePosition,
-				  pHTTXContext->NextBulkOutPosition,
-				  pHTTXContext->ENextBulkOutPosition));
-	}
-
-	do {
-		pTxInfo = (struct rt_txinfo *)&pWirelessPkt[TmpBulkEndPos];
-		pTxWI =
-			(struct rt_txwi *)&pWirelessPkt[TmpBulkEndPos + TXINFO_SIZE];
-
-		if (pAd->bForcePrintTX == TRUE)
-			DBGPRINT(RT_DEBUG_TRACE,
-				 ("RTUSBBulkOutDataPacket AMPDU = %d.\n",
-				  pTxWI->AMPDU));
-
-		/* add by Iverson, limit BulkOut size to 4k to pass WMM b mode 2T1R test items */
-		/*if ((ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
-		if ((ThisBulkSize != 0) && (pTxWI->PHYMODE == MODE_CCK)) {
-			if (((ThisBulkSize & 0xffff8000) != 0)
-			    || ((ThisBulkSize & 0x1000) == 0x1000)) {
-				/* Limit BulkOut size to about 4k bytes. */
-				pHTTXContext->ENextBulkOutPosition =
-				    TmpBulkEndPos;
-				break;
-			} else
-			    if (((pAd->BulkOutMaxPacketSize < 512)
-				 && ((ThisBulkSize & 0xfffff800) !=
-				     0))
-				/*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
-				) {
-				/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
-				/* For performance in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
-				pHTTXContext->ENextBulkOutPosition =
-				    TmpBulkEndPos;
-				break;
-			}
-		}
-		/* end Iverson */
-		else {
-			if (((ThisBulkSize & 0xffff8000) != 0) || ((ThisBulkSize & 0x6000) == 0x6000)) {	/* Limit BulkOut size to about 24k bytes. */
-				pHTTXContext->ENextBulkOutPosition =
-				    TmpBulkEndPos;
-				break;
-			} else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize & 0xfffff800) != 0)) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */) {	/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
-				/* For performance in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
-				pHTTXContext->ENextBulkOutPosition =
-				    TmpBulkEndPos;
-				break;
-			}
-		}
-
-		if (TmpBulkEndPos == pHTTXContext->CurWritePosition) {
-			pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
-			break;
-		}
-
-		if (pTxInfo->QSEL != FIFO_EDCA) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("%s(): ====> pTxInfo->QueueSel(%d)!= FIFO_EDCA!!!!\n",
-				  __func__, pTxInfo->QSEL));
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("\tCWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n",
-				  pHTTXContext->CurWritePosition,
-				  pHTTXContext->NextBulkOutPosition,
-				  pHTTXContext->ENextBulkOutPosition,
-				  pHTTXContext->bCopySavePad));
-			hex_dump("Wrong QSel Pkt:",
-				 (u8 *)&pWirelessPkt[TmpBulkEndPos],
-				 (pHTTXContext->CurWritePosition -
-				  pHTTXContext->NextBulkOutPosition));
-		}
-
-		if (pTxInfo->USBDMATxPktLen <= 8) {
-			BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId],
-					IrqFlags2);
-			DBGPRINT(RT_DEBUG_ERROR /*RT_DEBUG_TRACE */ ,
-				 ("e2, USBDMATxPktLen==0, Size=%ld, bCSPad=%d, CWPos=%ld, NBPos=%ld, CWRPos=%ld!\n",
-				  pHTTXContext->BulkOutSize,
-				  pHTTXContext->bCopySavePad,
-				  pHTTXContext->CurWritePosition,
-				  pHTTXContext->NextBulkOutPosition,
-				  pHTTXContext->CurWriteRealPos));
-			{
-				DBGPRINT_RAW(RT_DEBUG_ERROR /*RT_DEBUG_TRACE */
-					     ,
-					     ("%x  %x  %x  %x  %x  %x  %x  %x \n",
-					      pHTTXContext->SavedPad[0],
-					      pHTTXContext->SavedPad[1],
-					      pHTTXContext->SavedPad[2],
-					      pHTTXContext->SavedPad[3]
-					      , pHTTXContext->SavedPad[4],
-					      pHTTXContext->SavedPad[5],
-					      pHTTXContext->SavedPad[6],
-					      pHTTXContext->SavedPad[7]));
-			}
-			pAd->bForcePrintTX = TRUE;
-			BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId],
-				      IrqFlags);
-			pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId],
-					IrqFlags);
-			/*DBGPRINT(RT_DEBUG_LOUD,("Out:pTxInfo->USBDMATxPktLen=%d!\n", pTxInfo->USBDMATxPktLen)); */
-			return;
-		}
-		/* Increase Total transmit byte counter */
-		pAd->RalinkCounters.OneSecTransmittedByteCount +=
-		    pTxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.TransmittedByteCount +=
-		    pTxWI->MPDUtotalByteCount;
-
-		pLastTxInfo = pTxInfo;
-
-		/* Make sure we use EDCA QUEUE. */
-		pTxInfo->QSEL = FIFO_EDCA;
-		ThisBulkSize += (pTxInfo->USBDMATxPktLen + 4);
-		TmpBulkEndPos += (pTxInfo->USBDMATxPktLen + 4);
-
-		if (TmpBulkEndPos != pHTTXContext->CurWritePosition)
-			pTxInfo->USBDMANextVLD = 1;
-
-		if (pTxInfo->SwUseLastRound == 1) {
-			if (pHTTXContext->CurWritePosition == 8)
-				pTxInfo->USBDMANextVLD = 0;
-			pTxInfo->SwUseLastRound = 0;
-
-			bTxQLastRound = TRUE;
-			pHTTXContext->ENextBulkOutPosition = 8;
-
-			break;
-		}
-
-	} while (TRUE);
-
-	/* adjust the pTxInfo->USBDMANextVLD value of last pTxInfo. */
-	if (pLastTxInfo)
-		pLastTxInfo->USBDMANextVLD = 0;
-
-	/*
-	   We need to copy SavedPad when following condition matched!
-	   1. Not the last round of the TxQueue and
-	   2. any match of following cases:
-	   (1). The End Position of this bulk out is reach to the Currenct Write position and
-	   the TxInfo and related header already write to the CurWritePosition.
-	   =>(ENextBulkOutPosition == CurWritePosition) && (CurWriteRealPos > CurWritePosition)
-
-	   (2). The EndPosition of the bulk out is not reach to the Current Write Position.
-	   =>(ENextBulkOutPosition != CurWritePosition)
-	 */
-	if ((bTxQLastRound == FALSE) &&
-	    (((pHTTXContext->ENextBulkOutPosition ==
-	       pHTTXContext->CurWritePosition)
-	      && (pHTTXContext->CurWriteRealPos >
-		  pHTTXContext->CurWritePosition))
-	     || (pHTTXContext->ENextBulkOutPosition !=
-		 pHTTXContext->CurWritePosition))
-	    ) {
-		NdisMoveMemory(pHTTXContext->SavedPad,
-			       &pWirelessPkt[pHTTXContext->
-					     ENextBulkOutPosition], 8);
-		pHTTXContext->bCopySavePad = TRUE;
-		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero, 4)) {
-			u8 *pBuf = &pHTTXContext->SavedPad[0];
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("WARNING-Zero-3:%02x%02x%02x%02x%02x%02x%02x%02x,CWPos=%ld, CWRPos=%ld, bCW=%d, NBPos=%ld, TBPos=%ld, TBSize=%ld\n",
-				      pBuf[0], pBuf[1], pBuf[2], pBuf[3],
-				      pBuf[4], pBuf[5], pBuf[6], pBuf[7],
-				      pHTTXContext->CurWritePosition,
-				      pHTTXContext->CurWriteRealPos,
-				      pHTTXContext->bCurWriting,
-				      pHTTXContext->NextBulkOutPosition,
-				      TmpBulkEndPos, ThisBulkSize));
-
-			pBuf = &pWirelessPkt[pHTTXContext->CurWritePosition];
-			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("\tCWPos=%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				      pBuf[0], pBuf[1], pBuf[2], pBuf[3],
-				      pBuf[4], pBuf[5], pBuf[6], pBuf[7]));
-		}
-		/*DBGPRINT(RT_DEBUG_LOUD,("ENPos==CWPos=%ld, CWRPos=%ld, bCSPad=%d!\n", pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->bCopySavePad)); */
-	}
-
-	if (pAd->bForcePrintTX == TRUE)
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("BulkOut-A:Size=%ld, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n",
-			  ThisBulkSize, pHTTXContext->CurWritePosition,
-			  pHTTXContext->NextBulkOutPosition,
-			  pHTTXContext->ENextBulkOutPosition,
-			  pHTTXContext->bCopySavePad));
-	/*DBGPRINT(RT_DEBUG_LOUD,("BulkOut-A:Size=%ld, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, bLRound=%d!\n", ThisBulkSize, pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad, bTxQLastRound)); */
-
-	/* USB DMA engine requires to pad extra 4 bytes. This pad doesn't count into real bulkoutsize. */
-	pAppendant = &pWirelessPkt[TmpBulkEndPos];
-	NdisZeroMemory(pAppendant, 8);
-	ThisBulkSize += 4;
-	pHTTXContext->LastOne = TRUE;
-	if ((ThisBulkSize % pAd->BulkOutMaxPacketSize) == 0)
-		ThisBulkSize += 4;
-	pHTTXContext->BulkOutSize = ThisBulkSize;
-
-	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 1;
-	BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
-
-	/* Init Tx context descriptor */
-	RTUSBInitHTTxDesc(pAd, pHTTXContext, BulkOutPipeId, ThisBulkSize,
-			  (usb_complete_t) RTUSBBulkOutDataPacketComplete);
-
-	pUrb = pHTTXContext->pUrb;
-	ret = RTUSB_SUBMIT_URB(pUrb);
-	if (ret != 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTUSBBulkOutDataPacket: Submit Tx URB failed %d\n",
-			  ret));
-
-		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-		pAd->watchDogTxPendingCnt[BulkOutPipeId] = 0;
-		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-
-		return;
-	}
-
-	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	pHTTXContext->IRPPending = TRUE;
-	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	pAd->BulkOutReq++;
-
-}
-
-void RTUSBBulkOutDataPacketComplete(struct urb *pUrb, struct pt_regs * pt_regs)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	struct rt_rtmp_adapter *pAd;
-	struct os_cookie *pObj;
-	u8 BulkOutPipeId;
-
-	pHTTXContext = (struct rt_ht_tx_context *)pUrb->context;
-	pAd = pHTTXContext->pAd;
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	/* Store BulkOut PipeId */
-	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
-	pAd->BulkOutDataOneSecCount++;
-
-	switch (BulkOutPipeId) {
-	case 0:
-		pObj->ac0_dma_done_task.data = (unsigned long)pUrb;
-		tasklet_hi_schedule(&pObj->ac0_dma_done_task);
-		break;
-	case 1:
-		pObj->ac1_dma_done_task.data = (unsigned long)pUrb;
-		tasklet_hi_schedule(&pObj->ac1_dma_done_task);
-		break;
-	case 2:
-		pObj->ac2_dma_done_task.data = (unsigned long)pUrb;
-		tasklet_hi_schedule(&pObj->ac2_dma_done_task);
-		break;
-	case 3:
-		pObj->ac3_dma_done_task.data = (unsigned long)pUrb;
-		tasklet_hi_schedule(&pObj->ac3_dma_done_task);
-		break;
-	}
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note: NULL frame use BulkOutPipeId = 0
-
-	========================================================================
-*/
-void RTUSBBulkOutNullFrame(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_tx_context *pNullContext = &(pAd->NullContext);
-	PURB pUrb;
-	int ret = 0;
-	unsigned long IrqFlags;
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	if ((pAd->BulkOutPending[0] == TRUE)
-	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-		return;
-	}
-	pAd->BulkOutPending[0] = TRUE;
-	pAd->watchDogTxPendingCnt[0] = 1;
-	pNullContext->IRPPending = TRUE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-	/* Increase Total transmit byte counter */
-	pAd->RalinkCounters.TransmittedByteCount += pNullContext->BulkOutSize;
-
-	/* Clear Null frame bulk flag */
-	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
-
-	/* Init Tx context descriptor */
-	RTUSBInitTxDesc(pAd, pNullContext, 0,
-			(usb_complete_t) RTUSBBulkOutNullFrameComplete);
-
-	pUrb = pNullContext->pUrb;
-	ret = RTUSB_SUBMIT_URB(pUrb);
-	if (ret != 0) {
-		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-		pAd->BulkOutPending[0] = FALSE;
-		pAd->watchDogTxPendingCnt[0] = 0;
-		pNullContext->IRPPending = FALSE;
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTUSBBulkOutNullFrame: Submit Tx URB failed %d\n",
-			  ret));
-		return;
-	}
-
-}
-
-/* NULL frame use BulkOutPipeId = 0 */
-void RTUSBBulkOutNullFrameComplete(struct urb *pUrb, struct pt_regs * pt_regs)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pNullContext;
-	int Status;
-	struct os_cookie *pObj;
-
-	pNullContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pNullContext->pAd;
-	Status = pUrb->status;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-	pObj->null_frame_complete_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->null_frame_complete_task);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note: MLME use BulkOutPipeId = 0
-
-	========================================================================
-*/
-void RTUSBBulkOutMLMEPacket(struct rt_rtmp_adapter *pAd, u8 Index)
-{
-	struct rt_tx_context *pMLMEContext;
-	PURB pUrb;
-	int ret = 0;
-	unsigned long IrqFlags;
-
-	pMLMEContext =
-	    (struct rt_tx_context *)pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa;
-	pUrb = pMLMEContext->pUrb;
-
-	if ((pAd->MgmtRing.TxSwFreeIdx >= MGMT_RING_SIZE) ||
-	    (pMLMEContext->InUse == FALSE) ||
-	    (pMLMEContext->bWaitingBulkOut == FALSE)) {
-
-		/* Clear MLME bulk flag */
-		RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-
-		return;
-	}
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-	if ((pAd->BulkOutPending[MGMTPIPEIDX] == TRUE)
-	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-		return;
-	}
-
-	pAd->BulkOutPending[MGMTPIPEIDX] = TRUE;
-	pAd->watchDogTxPendingCnt[MGMTPIPEIDX] = 1;
-	pMLMEContext->IRPPending = TRUE;
-	pMLMEContext->bWaitingBulkOut = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-	/* Increase Total transmit byte counter */
-	pAd->RalinkCounters.TransmittedByteCount += pMLMEContext->BulkOutSize;
-
-	/* Clear MLME bulk flag */
-	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-
-	/* Init Tx context descriptor */
-	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX,
-			(usb_complete_t) RTUSBBulkOutMLMEPacketComplete);
-
-	/*For mgmt urb buffer, because we use sk_buff, so we need to notify the USB controller do dma mapping. */
-	pUrb->transfer_dma = 0;
-	pUrb->transfer_flags &= (~URB_NO_TRANSFER_DMA_MAP);
-
-	pUrb = pMLMEContext->pUrb;
-	ret = RTUSB_SUBMIT_URB(pUrb);
-	if (ret != 0) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTUSBBulkOutMLMEPacket: Submit MLME URB failed %d\n",
-			  ret));
-		RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-		pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
-		pAd->watchDogTxPendingCnt[MGMTPIPEIDX] = 0;
-		pMLMEContext->IRPPending = FALSE;
-		pMLMEContext->bWaitingBulkOut = TRUE;
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-		return;
-	}
-	/*DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutMLMEPacket \n")); */
-/*      printk("<---RTUSBBulkOutMLMEPacket,Cpu=%d!, Dma=%d, SwIdx=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx); */
-}
-
-void RTUSBBulkOutMLMEPacketComplete(struct urb *pUrb, struct pt_regs * pt_regs)
-{
-	struct rt_tx_context *pMLMEContext;
-	struct rt_rtmp_adapter *pAd;
-	int Status;
-	struct os_cookie *pObj;
-	int index;
-
-	/*DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacketComplete\n")); */
-	pMLMEContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pMLMEContext->pAd;
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-	Status = pUrb->status;
-	index = pMLMEContext->SelfIdx;
-
-	pObj->mgmt_dma_done_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note: PsPoll use BulkOutPipeId = 0
-
-	========================================================================
-*/
-void RTUSBBulkOutPsPoll(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_tx_context *pPsPollContext = &(pAd->PsPollContext);
-	PURB pUrb;
-	int ret = 0;
-	unsigned long IrqFlags;
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	if ((pAd->BulkOutPending[0] == TRUE)
-	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-		return;
-	}
-	pAd->BulkOutPending[0] = TRUE;
-	pAd->watchDogTxPendingCnt[0] = 1;
-	pPsPollContext->IRPPending = TRUE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-	/* Clear PS-Poll bulk flag */
-	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);
-
-	/* Init Tx context descriptor */
-	RTUSBInitTxDesc(pAd, pPsPollContext, MGMTPIPEIDX,
-			(usb_complete_t) RTUSBBulkOutPsPollComplete);
-
-	pUrb = pPsPollContext->pUrb;
-	ret = RTUSB_SUBMIT_URB(pUrb);
-	if (ret != 0) {
-		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-		pAd->BulkOutPending[0] = FALSE;
-		pAd->watchDogTxPendingCnt[0] = 0;
-		pPsPollContext->IRPPending = FALSE;
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTUSBBulkOutPsPoll: Submit Tx URB failed %d\n",
-			  ret));
-		return;
-	}
-
-}
-
-/* PS-Poll frame use BulkOutPipeId = 0 */
-void RTUSBBulkOutPsPollComplete(struct urb *pUrb, struct pt_regs * pt_regs)
-{
-	struct rt_rtmp_adapter *pAd;
-	struct rt_tx_context *pPsPollContext;
-	int Status;
-	struct os_cookie *pObj;
-
-	pPsPollContext = (struct rt_tx_context *)pUrb->context;
-	pAd = pPsPollContext->pAd;
-	Status = pUrb->status;
-
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-	pObj->pspoll_frame_complete_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->pspoll_frame_complete_task);
-}
-
-void DoBulkIn(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rx_context *pRxContext;
-	PURB pUrb;
-	int ret = 0;
-	unsigned long IrqFlags;
-
-	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
-	if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE)
-	    || (pRxContext->InUse == TRUE)) {
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-		return;
-	}
-	pRxContext->InUse = TRUE;
-	pRxContext->IRPPending = TRUE;
-	pAd->PendingRx++;
-	pAd->BulkInReq++;
-	RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-	/* Init Rx context descriptor */
-	NdisZeroMemory(pRxContext->TransferBuffer, pRxContext->BulkInOffset);
-	RTUSBInitRxDesc(pAd, pRxContext);
-
-	pUrb = pRxContext->pUrb;
-	ret = RTUSB_SUBMIT_URB(pUrb);
-	if (ret != 0) {	/* fail */
-
-		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-		pRxContext->InUse = FALSE;
-		pRxContext->IRPPending = FALSE;
-		pAd->PendingRx--;
-		pAd->BulkInReq--;
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("RTUSBBulkReceive: Submit Rx URB failed %d\n", ret));
-	} else {		/* success */
-		ASSERT((pRxContext->InUse == pRxContext->IRPPending));
-		/*printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex); */
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	USB_RxPacket initializes a URB and uses the Rx IRP to submit it
-	to USB. It checks if an Rx Descriptor is available and passes the
-	the coresponding buffer to be filled. If no descriptor is available
-	fails the request. When setting the completion routine we pass our
-	Adapter Object as Context.
-
-	Arguments:
-
-	Return Value:
-		TRUE			found matched tuple cache
-		FALSE			no matched found
-
-	Note:
-
-	========================================================================
-*/
-#define fRTMP_ADAPTER_NEED_STOP_RX		\
-		(fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_HALT_IN_PROGRESS |	\
-		 fRTMP_ADAPTER_RADIO_OFF | fRTMP_ADAPTER_RESET_IN_PROGRESS | \
-		 fRTMP_ADAPTER_REMOVE_IN_PROGRESS | fRTMP_ADAPTER_BULKIN_RESET)
-
-#define fRTMP_ADAPTER_NEED_STOP_HANDLE_RX	\
-		(fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_HALT_IN_PROGRESS |	\
-		 fRTMP_ADAPTER_RADIO_OFF | fRTMP_ADAPTER_RESET_IN_PROGRESS | \
-		 fRTMP_ADAPTER_REMOVE_IN_PROGRESS)
-
-void RTUSBBulkReceive(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rx_context *pRxContext;
-	unsigned long IrqFlags;
-
-	/* sanity check */
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_HANDLE_RX))
-		return;
-
-	while (1) {
-
-		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-		pRxContext = &(pAd->RxContext[pAd->NextRxBulkInReadIndex]);
-		if (((pRxContext->InUse == FALSE)
-		     && (pRxContext->Readable == TRUE))
-		    && (pRxContext->bRxHandling == FALSE)) {
-			pRxContext->bRxHandling = TRUE;
-			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-			/* read RxContext, Since not */
-			STARxDoneInterruptHandle(pAd, TRUE);
-
-			/* Finish to handle this bulkIn buffer. */
-			RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-			pRxContext->BulkInOffset = 0;
-			pRxContext->Readable = FALSE;
-			pRxContext->bRxHandling = FALSE;
-			pAd->ReadPosition = 0;
-			pAd->TransferBufferLength = 0;
-			INC_RING_INDEX(pAd->NextRxBulkInReadIndex,
-				       RX_RING_SIZE);
-			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-		} else {
-			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-			break;
-		}
-	}
-
-	if (!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_RX)))
-		DoBulkIn(pAd);
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		This routine process Rx Irp and call rx complete function.
-
-	Arguments:
-		DeviceObject	Pointer to the device object for next lower
-						device. DeviceObject passed in here belongs to
-						the next lower driver in the stack because we
-						were invoked via IoCallDriver in USB_RxPacket
-						AND it is not OUR device object
-	  Irp				Ptr to completed IRP
-	  Context			Ptr to our Adapter object (context specified
-						in IoSetCompletionRoutine
-
-	Return Value:
-		Always returns STATUS_MORE_PROCESSING_REQUIRED
-
-	Note:
-		Always returns STATUS_MORE_PROCESSING_REQUIRED
-	========================================================================
-*/
-void RTUSBBulkRxComplete(struct urb *pUrb, struct pt_regs *pt_regs)
-{
-	/* use a receive tasklet to handle received packets; */
-	/* or sometimes hardware IRQ will be disabled here, so we can not */
-	/* use spin_lock_bh()/spin_unlock_bh() after IRQ is disabled. :< */
-	struct rt_rx_context *pRxContext;
-	struct rt_rtmp_adapter *pAd;
-	struct os_cookie *pObj;
-
-	pRxContext = (struct rt_rx_context *)pUrb->context;
-	pAd = pRxContext->pAd;
-	pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	pObj->rx_done_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->rx_done_task);
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBKickBulkOut(struct rt_rtmp_adapter *pAd)
-{
-	/* BulkIn Reset will reset whole USB PHY. So we need to make sure fRTMP_ADAPTER_BULKIN_RESET not flaged. */
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)
-	    ) {
-		/* 2. PS-Poll frame is next */
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL))
-			RTUSBBulkOutPsPoll(pAd);
-		/* 5. Mlme frame is next */
-		else if ((RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME)) ||
-			 (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE)) {
-			RTUSBBulkOutMLMEPacket(pAd, pAd->MgmtRing.TxDmaIdx);
-		}
-		/* 6. Data frame normal is next */
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL)) {
-			if (((!RTMP_TEST_FLAG
-			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-			     ||
-			     (!OPSTATUS_TEST_FLAG
-			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-			    )) {
-				RTUSBBulkOutDataPacket(pAd, 0,
-						       pAd->
-						       NextBulkOutIndex[0]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2)) {
-			if (((!RTMP_TEST_FLAG
-			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-			     ||
-			     (!OPSTATUS_TEST_FLAG
-			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-			    )) {
-				RTUSBBulkOutDataPacket(pAd, 1,
-						       pAd->
-						       NextBulkOutIndex[1]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3)) {
-			if (((!RTMP_TEST_FLAG
-			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-			     ||
-			     (!OPSTATUS_TEST_FLAG
-			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-			    )) {
-				RTUSBBulkOutDataPacket(pAd, 2,
-						       pAd->
-						       NextBulkOutIndex[2]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4)) {
-			if (((!RTMP_TEST_FLAG
-			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-			     ||
-			     (!OPSTATUS_TEST_FLAG
-			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-			    )) {
-				RTUSBBulkOutDataPacket(pAd, 3,
-						       pAd->
-						       NextBulkOutIndex[3]);
-			}
-		}
-		/* 7. Null frame is the last */
-		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL)) {
-			if (!RTMP_TEST_FLAG
-			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
-				RTUSBBulkOutNullFrame(pAd);
-			}
-		}
-		/* 8. No data available */
-		else
-			;
-	}
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	Call from Reset action after BulkOut failed.
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBCleanUpDataBulkOutQueue(struct rt_rtmp_adapter *pAd)
-{
-	u8 Idx;
-	struct rt_ht_tx_context *pTxContext;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("--->CleanUpDataBulkOutQueue\n"));
-
-	for (Idx = 0; Idx < 4; Idx++) {
-		pTxContext = &pAd->TxContext[Idx];
-
-		pTxContext->CurWritePosition = pTxContext->NextBulkOutPosition;
-		pTxContext->LastOne = FALSE;
-		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
-		pAd->BulkOutPending[Idx] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("<---CleanUpDataBulkOutQueue\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBCleanUpMLMEBulkOutQueue(struct rt_rtmp_adapter *pAd)
-{
-	DBGPRINT(RT_DEBUG_TRACE, ("--->CleanUpMLMEBulkOutQueue\n"));
-	DBGPRINT(RT_DEBUG_TRACE, ("<---CleanUpMLMEBulkOutQueue\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBCancelPendingIRPs(struct rt_rtmp_adapter *pAd)
-{
-	RTUSBCancelPendingBulkInIRP(pAd);
-	RTUSBCancelPendingBulkOutIRP(pAd);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBCancelPendingBulkInIRP(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_rx_context *pRxContext;
-	u32 i;
-
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->RTUSBCancelPendingBulkInIRP\n"));
-	for (i = 0; i < (RX_RING_SIZE); i++) {
-		pRxContext = &(pAd->RxContext[i]);
-		if (pRxContext->IRPPending == TRUE) {
-			RTUSB_UNLINK_URB(pRxContext->pUrb);
-			pRxContext->IRPPending = FALSE;
-			pRxContext->InUse = FALSE;
-			/*NdisInterlockedDecrement(&pAd->PendingRx); */
-			/*pAd->PendingRx--; */
-		}
-	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RTUSBCancelPendingBulkInIRP\n"));
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBCancelPendingBulkOutIRP(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_ht_tx_context *pHTTXContext;
-	struct rt_tx_context *pMLMEContext;
-	struct rt_tx_context *pBeaconContext;
-	struct rt_tx_context *pNullContext;
-	struct rt_tx_context *pPsPollContext;
-	struct rt_tx_context *pRTSContext;
-	u32 i, Idx;
-/*      unsigned int            IrqFlags; */
-/*      spinlock_t          *pLock; */
-/*      BOOLEAN                         *pPending; */
-
-/*      pLock = &pAd->BulkOutLock[MGMTPIPEIDX]; */
-/*      pPending = &pAd->BulkOutPending[MGMTPIPEIDX]; */
-
-	for (Idx = 0; Idx < 4; Idx++) {
-		pHTTXContext = &(pAd->TxContext[Idx]);
-
-		if (pHTTXContext->IRPPending == TRUE) {
-
-			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
-			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
-			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
-			/* */
-
-			RTUSB_UNLINK_URB(pHTTXContext->pUrb);
-
-			/* Sleep 200 microseconds to give cancellation time to work */
-			RTMPusecDelay(200);
-		}
-
-		pAd->BulkOutPending[Idx] = FALSE;
-	}
-
-	/*RTMP_IRQ_LOCK(pLock, IrqFlags); */
-	for (i = 0; i < MGMT_RING_SIZE; i++) {
-		pMLMEContext = (struct rt_tx_context *)pAd->MgmtRing.Cell[i].AllocVa;
-		if (pMLMEContext && (pMLMEContext->IRPPending == TRUE)) {
-
-			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
-			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
-			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
-			/* */
-
-			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
-			pMLMEContext->IRPPending = FALSE;
-
-			/* Sleep 200 microsecs to give cancellation time to work */
-			RTMPusecDelay(200);
-		}
-	}
-	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
-	/*RTMP_IRQ_UNLOCK(pLock, IrqFlags); */
-
-	for (i = 0; i < BEACON_RING_SIZE; i++) {
-		pBeaconContext = &(pAd->BeaconContext[i]);
-
-		if (pBeaconContext->IRPPending == TRUE) {
-
-			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
-			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
-			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
-			/* */
-
-			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
-
-			/* Sleep 200 microsecs to give cancellation time to work */
-			RTMPusecDelay(200);
-		}
-	}
-
-	pNullContext = &(pAd->NullContext);
-	if (pNullContext->IRPPending == TRUE)
-		RTUSB_UNLINK_URB(pNullContext->pUrb);
-
-	pRTSContext = &(pAd->RTSContext);
-	if (pRTSContext->IRPPending == TRUE)
-		RTUSB_UNLINK_URB(pRTSContext->pUrb);
-
-	pPsPollContext = &(pAd->PsPollContext);
-	if (pPsPollContext->IRPPending == TRUE)
-		RTUSB_UNLINK_URB(pPsPollContext->pUrb);
-
-	for (Idx = 0; Idx < 4; Idx++) {
-		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
-		pAd->BulkOutPending[Idx] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
-	}
-}
-
-#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2870/common/rtusb_data.c b/drivers/staging/rt2870/common/rtusb_data.c
deleted file mode 100644
index 5b72bcd..0000000
--- a/drivers/staging/rt2870/common/rtusb_data.c
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtusb_data.c
-
-	Abstract:
-	Ralink USB driver Tx/Rx functions.
-
-	Revision History:
-	Who         When          What
-	--------    ----------    ----------------------------------------------
-	Jan            03-25-2006    created
-
-*/
-
-#ifdef RTMP_MAC_USB
-
-#include "../rt_config.h"
-
-extern u8 Phy11BGNextRateUpward[];	/* defined in mlme.c */
-extern u8 EpToQueue[];
-
-void REPORT_AMSDU_FRAMES_TO_LLC(struct rt_rtmp_adapter *pAd,
-				u8 *pData, unsigned long DataSize)
-{
-	void *pPacket;
-	u32 nMSDU;
-	struct sk_buff *pSkb;
-
-	nMSDU = 0;
-	/* allocate a rx packet */
-	pSkb = dev_alloc_skb(RX_BUFFER_AGGRESIZE);
-	pPacket = (void *)OSPKT_TO_RTPKT(pSkb);
-	if (pSkb) {
-
-		/* convert 802.11 to 802.3 packet */
-		pSkb->dev = get_netdev_from_bssid(pAd, BSS0);
-		RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-		deaggregate_AMSDU_announce(pAd, pPacket, pData, DataSize);
-	} else {
-		DBGPRINT(RT_DEBUG_ERROR, ("Can't allocate skb\n"));
-	}
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		This subroutine will scan through releative ring descriptor to find
-		out available free ring descriptor and compare with request size.
-
-	Arguments:
-		pAd	Pointer	to our adapter
-		RingType	Selected Ring
-
-	Return Value:
-		NDIS_STATUS_FAILURE		Not enough free descriptor
-		NDIS_STATUS_SUCCESS		Enough free descriptor
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBFreeDescriptorRequest(struct rt_rtmp_adapter *pAd,
-				       u8 BulkOutPipeId,
-				       u32 NumberRequired)
-{
-/*      u8                   FreeNumber = 0; */
-/*      u32                    Index; */
-	int Status = NDIS_STATUS_FAILURE;
-	unsigned long IrqFlags;
-	struct rt_ht_tx_context *pHTTXContext;
-
-	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->CurWritePosition < pHTTXContext->NextBulkOutPosition)
-	    &&
-	    ((pHTTXContext->CurWritePosition + NumberRequired +
-	      LOCAL_TXBUF_SIZE) > pHTTXContext->NextBulkOutPosition)) {
-
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
-				     BulkOutPipeId));
-	} else if ((pHTTXContext->CurWritePosition == 8)
-		   && (pHTTXContext->NextBulkOutPosition <
-		       (NumberRequired + LOCAL_TXBUF_SIZE))) {
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
-				     BulkOutPipeId));
-	} else if (pHTTXContext->bCurWriting == TRUE) {
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBFreeD c3 --> QueIdx=%d, CWPos=%ld, NBOutPos=%ld!\n",
-			  BulkOutPipeId, pHTTXContext->CurWritePosition,
-			  pHTTXContext->NextBulkOutPosition));
-		RTUSB_SET_BULK_FLAG(pAd,
-				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
-				     BulkOutPipeId));
-	} else {
-		Status = NDIS_STATUS_SUCCESS;
-	}
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-
-	return Status;
-}
-
-int RTUSBFreeDescriptorRelease(struct rt_rtmp_adapter *pAd,
-				       u8 BulkOutPipeId)
-{
-	unsigned long IrqFlags;
-	struct rt_ht_tx_context *pHTTXContext;
-
-	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	pHTTXContext->bCurWriting = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-BOOLEAN RTUSBNeedQueueBackForAgg(struct rt_rtmp_adapter *pAd, u8 BulkOutPipeId)
-{
-	unsigned long IrqFlags;
-	struct rt_ht_tx_context *pHTTXContext;
-	BOOLEAN needQueBack = FALSE;
-
-	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
-
-	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->IRPPending ==
-	     TRUE) /*&& (pAd->TxSwQueue[BulkOutPipeId].Number == 0) */) {
-		if ((pHTTXContext->CurWritePosition <
-		     pHTTXContext->ENextBulkOutPosition)
-		    &&
-		    (((pHTTXContext->ENextBulkOutPosition +
-		       MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT)
-		     || (pHTTXContext->CurWritePosition >
-			 MAX_AGGREGATION_SIZE))) {
-			needQueBack = TRUE;
-		} else
-		    if ((pHTTXContext->CurWritePosition >
-			 pHTTXContext->ENextBulkOutPosition)
-			&&
-			((pHTTXContext->ENextBulkOutPosition +
-			  MAX_AGGREGATION_SIZE) <
-			 pHTTXContext->CurWritePosition)) {
-			needQueBack = TRUE;
-		}
-	}
-	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-
-	return needQueBack;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBRejectPendingPackets(struct rt_rtmp_adapter *pAd)
-{
-	u8 Index;
-	struct rt_queue_entry *pEntry;
-	void *pPacket;
-	struct rt_queue_header *pQueue;
-
-	for (Index = 0; Index < 4; Index++) {
-		NdisAcquireSpinLock(&pAd->TxSwQueueLock[Index]);
-		while (pAd->TxSwQueue[Index].Head != NULL) {
-			pQueue = (struct rt_queue_header *)&(pAd->TxSwQueue[Index]);
-			pEntry = RemoveHeadQueue(pQueue);
-			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-		}
-		NdisReleaseSpinLock(&pAd->TxSwQueueLock[Index]);
-
-	}
-
-}
-
-/*
-	========================================================================
-
-	Routine	Description:
-		Calculates the duration which is required to transmit out frames
-	with given size and specified rate.
-
-	Arguments:
-		pTxD		Pointer to transmit descriptor
-		Ack			Setting for Ack requirement bit
-		Fragment	Setting for Fragment bit
-		RetryMode	Setting for retry mode
-		Ifs			Setting for IFS gap
-		Rate		Setting for transmit rate
-		Service		Setting for service
-		Length		Frame length
-		TxPreamble  Short or Long preamble when using CCK rates
-		QueIdx - 0-3, according to 802.11e/d4.4 June/2003
-
-	Return Value:
-		None
-
-	IRQL = PASSIVE_LEVEL
-	IRQL = DISPATCH_LEVEL
-
-	========================================================================
-*/
-
-void RTMPWriteTxInfo(struct rt_rtmp_adapter *pAd,
-		     struct rt_txinfo *pTxInfo,
-		     u16 USBDMApktLen,
-		     IN BOOLEAN bWiv,
-		     u8 QueueSel, u8 NextValid, u8 TxBurst)
-{
-	pTxInfo->USBDMATxPktLen = USBDMApktLen;
-	pTxInfo->QSEL = QueueSel;
-	if (QueueSel != FIFO_EDCA)
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("====> QueueSel != FIFO_EDCA<============\n"));
-	pTxInfo->USBDMANextVLD = FALSE;	/*NextValid;  // Need to check with Jan about this. */
-	pTxInfo->USBDMATxburst = TxBurst;
-	pTxInfo->WIV = bWiv;
-	pTxInfo->SwUseLastRound = 0;
-	pTxInfo->rsv = 0;
-	pTxInfo->rsv2 = 0;
-}
-
-#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2870/common/rtusb_io.c b/drivers/staging/rt2870/common/rtusb_io.c
deleted file mode 100644
index 7d2f7e0..0000000
--- a/drivers/staging/rt2870/common/rtusb_io.c
+++ /dev/null
@@ -1,2104 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	rtusb_io.c
-
-	Abstract:
-
-	Revision History:
-	Who			When	    What
-	--------	----------  ----------------------------------------------
-	Name		Date	    Modification logs
-	Paul Lin    06-25-2004  created
-*/
-
-#ifdef RTMP_MAC_USB
-
-#include "../rt_config.h"
-
-/*
-	========================================================================
-
-	Routine Description: NIC initialization complete
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-
-static int RTUSBFirmwareRun(struct rt_rtmp_adapter *pAd)
-{
-	int Status;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x01, 0x8, 0, NULL, 0);
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Write Firmware to NIC.
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBFirmwareWrite(struct rt_rtmp_adapter *pAd,
-		       const u8 *pFwImage, unsigned long FwLen)
-{
-	u32 MacReg;
-	int Status;
-/*      unsigned long           i; */
-	u16 writeLen;
-
-	Status = RTUSBReadMACRegister(pAd, MAC_CSR0, &MacReg);
-
-	writeLen = FwLen;
-	RTUSBMultiWrite(pAd, FIRMWARE_IMAGE_BASE, pFwImage, writeLen);
-
-	Status = RTUSBWriteMACRegister(pAd, 0x7014, 0xffffffff);
-	Status = RTUSBWriteMACRegister(pAd, 0x701c, 0xffffffff);
-	Status = RTUSBFirmwareRun(pAd);
-
-	/*2008/11/28:KH add to fix the dead rf frequency offset bug<-- */
-	RTMPusecDelay(10000);
-	RTUSBWriteMACRegister(pAd, H2M_MAILBOX_CSR, 0);
-	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00);	/*reset rf by MCU supported by new firmware */
-	/*2008/11/28:KH add to fix the dead rf frequency offset bug--> */
-
-	return Status;
-}
-
-int RTUSBVenderReset(struct rt_rtmp_adapter *pAd)
-{
-	int Status;
-	DBGPRINT_RAW(RT_DEBUG_ERROR, ("-->RTUSBVenderReset\n"));
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x01, 0x1, 0, NULL, 0);
-
-	DBGPRINT_RAW(RT_DEBUG_ERROR, ("<--RTUSBVenderReset\n"));
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Read various length data from RT2573
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBMultiRead(struct rt_rtmp_adapter *pAd,
-			u16 Offset, u8 *pData, u16 length)
-{
-	int Status;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     (USBD_TRANSFER_DIRECTION_IN |
-				      USBD_SHORT_TRANSFER_OK),
-				     DEVICE_VENDOR_REQUEST_IN, 0x7, 0, Offset,
-				     pData, length);
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Write various length data to RT2573
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBMultiWrite_OneByte(struct rt_rtmp_adapter *pAd,
-			    u16 Offset, const u8 *pData)
-{
-	int Status;
-
-	/* TODO: In 2870, use this funciton carefully cause it's not stable. */
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x6, 0, Offset, (u8 *)pData, 1);
-
-	return Status;
-}
-
-int RTUSBMultiWrite(struct rt_rtmp_adapter *pAd,
-		    u16 Offset, const u8 *pData, u16 length)
-{
-	int Status;
-
-	u16 index = 0, Value;
-	const u8 *pSrc = pData;
-	u16 resude = 0;
-
-	resude = length % 2;
-	length += resude;
-	do {
-		Value = (u16)(*pSrc | (*(pSrc + 1) << 8));
-		Status = RTUSBSingleWrite(pAd, Offset + index, Value);
-		index += 2;
-		length -= 2;
-		pSrc = pSrc + 2;
-	} while (length > 0);
-
-	return Status;
-}
-
-int RTUSBSingleWrite(struct rt_rtmp_adapter *pAd,
-			  u16 Offset, u16 Value)
-{
-	int Status;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x2, Value, Offset, NULL, 0);
-
-	return Status;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description: Read 32-bit MAC register
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBReadMACRegister(struct rt_rtmp_adapter *pAd,
-			      u16 Offset, u32 *pValue)
-{
-	int Status = 0;
-	u32 localVal;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     (USBD_TRANSFER_DIRECTION_IN |
-				      USBD_SHORT_TRANSFER_OK),
-				     DEVICE_VENDOR_REQUEST_IN, 0x7, 0, Offset,
-				     &localVal, 4);
-
-	*pValue = le2cpu32(localVal);
-
-	if (Status < 0)
-		*pValue = 0xffffffff;
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Write 32-bit MAC register
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBWriteMACRegister(struct rt_rtmp_adapter *pAd,
-			       u16 Offset, u32 Value)
-{
-	int Status;
-	u32 localVal;
-
-	localVal = Value;
-
-	Status = RTUSBSingleWrite(pAd, Offset, (u16)(localVal & 0xffff));
-	Status =
-	    RTUSBSingleWrite(pAd, Offset + 2,
-			     (u16)((localVal & 0xffff0000) >> 16));
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Read 8-bit BBP register
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBReadBBPRegister(struct rt_rtmp_adapter *pAd,
-			      u8 Id, u8 *pValue)
-{
-	BBP_CSR_CFG_STRUC BbpCsr;
-	u32 i = 0;
-	int status;
-
-	/* Verify the busy condition */
-	do {
-		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if (status >= 0) {
-			if (!(BbpCsr.field.Busy == BUSY))
-				break;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBReadBBPRegister(BBP_CSR_CFG_1):retry count=%d!\n",
-			  i));
-		i++;
-	} while ((i < RETRY_LIMIT)
-		 && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
-
-	if ((i == RETRY_LIMIT)
-	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		/* */
-		/* Read failed then Return Default value. */
-		/* */
-		*pValue = pAd->BbpWriteLatch[Id];
-
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("Retry count exhausted or device removed!!!\n"));
-		return STATUS_UNSUCCESSFUL;
-	}
-	/* Prepare for write material */
-	BbpCsr.word = 0;
-	BbpCsr.field.fRead = 1;
-	BbpCsr.field.Busy = 1;
-	BbpCsr.field.RegNum = Id;
-	RTUSBWriteMACRegister(pAd, BBP_CSR_CFG, BbpCsr.word);
-
-	i = 0;
-	/* Verify the busy condition */
-	do {
-		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if (status >= 0) {
-			if (!(BbpCsr.field.Busy == BUSY)) {
-				*pValue = (u8)BbpCsr.field.Value;
-				break;
-			}
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBReadBBPRegister(BBP_CSR_CFG_2):retry count=%d!\n",
-			  i));
-		i++;
-	} while ((i < RETRY_LIMIT)
-		 && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
-
-	if ((i == RETRY_LIMIT)
-	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		/* */
-		/* Read failed then Return Default value. */
-		/* */
-		*pValue = pAd->BbpWriteLatch[Id];
-
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("Retry count exhausted or device removed!!!\n"));
-		return STATUS_UNSUCCESSFUL;
-	}
-
-	return STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Write 8-bit BBP register
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBWriteBBPRegister(struct rt_rtmp_adapter *pAd,
-			       u8 Id, u8 Value)
-{
-	BBP_CSR_CFG_STRUC BbpCsr;
-	u32 i = 0;
-	int status;
-	/* Verify the busy condition */
-	do {
-		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if (status >= 0) {
-			if (!(BbpCsr.field.Busy == BUSY))
-				break;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBWriteBBPRegister(BBP_CSR_CFG):retry count=%d!\n",
-			  i));
-		i++;
-	} while ((i < RETRY_LIMIT)
-	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
-
-	if ((i == RETRY_LIMIT)
-	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("Retry count exhausted or device removed!!!\n"));
-		return STATUS_UNSUCCESSFUL;
-	}
-	/* Prepare for write material */
-	BbpCsr.word = 0;
-	BbpCsr.field.fRead = 0;
-	BbpCsr.field.Value = Value;
-	BbpCsr.field.Busy = 1;
-	BbpCsr.field.RegNum = Id;
-	RTUSBWriteMACRegister(pAd, BBP_CSR_CFG, BbpCsr.word);
-
-	pAd->BbpWriteLatch[Id] = Value;
-
-	return STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description: Write RF register through MAC
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBWriteRFRegister(struct rt_rtmp_adapter *pAd, u32 Value)
-{
-	PHY_CSR4_STRUC PhyCsr4;
-	u32 i = 0;
-	int status;
-
-	NdisZeroMemory(&PhyCsr4, sizeof(PHY_CSR4_STRUC));
-	do {
-		status = RTUSBReadMACRegister(pAd, RF_CSR_CFG0, &PhyCsr4.word);
-		if (status >= 0) {
-			if (!(PhyCsr4.field.Busy))
-				break;
-		}
-		DBGPRINT(RT_DEBUG_TRACE,
-			 ("RTUSBWriteRFRegister(RF_CSR_CFG0):retry count=%d!\n",
-			  i));
-		i++;
-	} while ((i < RETRY_LIMIT)
-	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
-
-	if ((i == RETRY_LIMIT)
-	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR,
-			     ("Retry count exhausted or device removed!!!\n"));
-		return STATUS_UNSUCCESSFUL;
-	}
-
-	RTUSBWriteMACRegister(pAd, RF_CSR_CFG0, Value);
-
-	return STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBReadEEPROM(struct rt_rtmp_adapter *pAd,
-			 u16 Offset, u8 *pData, u16 length)
-{
-	int Status = STATUS_SUCCESS;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     (USBD_TRANSFER_DIRECTION_IN |
-				      USBD_SHORT_TRANSFER_OK),
-				     DEVICE_VENDOR_REQUEST_IN, 0x9, 0, Offset,
-				     pData, length);
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBWriteEEPROM(struct rt_rtmp_adapter *pAd,
-			  u16 Offset, u8 *pData, u16 length)
-{
-	int Status = STATUS_SUCCESS;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x8, 0, Offset, pData, length);
-
-	return Status;
-}
-
-int RTUSBReadEEPROM16(struct rt_rtmp_adapter *pAd,
-			   u16 offset, u16 *pData)
-{
-	int status;
-	u16 localData;
-
-	status = RTUSBReadEEPROM(pAd, offset, (u8 *)(&localData), 2);
-	if (status == STATUS_SUCCESS)
-		*pData = le2cpu16(localData);
-
-	return status;
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBPutToSleep(struct rt_rtmp_adapter *pAd)
-{
-	u32 value;
-
-	/* Timeout 0x40 x 50us */
-	value = (SLEEPCID << 16) + (OWNERMCU << 24) + (0x40 << 8) + 1;
-	RTUSBWriteMACRegister(pAd, 0x7010, value);
-	RTUSBWriteMACRegister(pAd, 0x404, 0x30);
-	/*RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS); */
-	DBGPRINT_RAW(RT_DEBUG_ERROR, ("Sleep Mailbox testvalue %x\n", value));
-
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBWakeUp(struct rt_rtmp_adapter *pAd)
-{
-	int Status;
-
-	Status = RTUSB_VendorRequest(pAd,
-				     USBD_TRANSFER_DIRECTION_OUT,
-				     DEVICE_VENDOR_REQUEST_OUT,
-				     0x01, 0x09, 0, NULL, 0);
-
-	return Status;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBInitializeCmdQ(struct rt_cmdq *cmdq)
-{
-	cmdq->head = NULL;
-	cmdq->tail = NULL;
-	cmdq->size = 0;
-	cmdq->CmdQState = RTMP_TASK_STAT_INITED;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBEnqueueCmdFromNdis(struct rt_rtmp_adapter *pAd,
-				    IN NDIS_OID Oid,
-				    IN BOOLEAN SetInformation,
-				    void *pInformationBuffer,
-				    u32 InformationBufferLength)
-{
-	int status;
-	struct rt_cmdqelmt *cmdqelmt = NULL;
-	struct rt_rtmp_os_task *pTask = &pAd->cmdQTask;
-
-#ifdef KTHREAD_SUPPORT
-	if (pTask->kthread_task == NULL)
-#else
-	CHECK_PID_LEGALITY(pTask->taskPID) {
-	}
-	else
-#endif
-	return NDIS_STATUS_RESOURCES;
-
-	status = os_alloc_mem(pAd, (u8 **) (&cmdqelmt), sizeof(struct rt_cmdqelmt));
-	if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt == NULL))
-		return NDIS_STATUS_RESOURCES;
-
-	cmdqelmt->buffer = NULL;
-	if (pInformationBuffer != NULL) {
-		status =
-		    os_alloc_mem(pAd, (u8 **) & cmdqelmt->buffer,
-				 InformationBufferLength);
-		if ((status != NDIS_STATUS_SUCCESS)
-		    || (cmdqelmt->buffer == NULL)) {
-			kfree(cmdqelmt);
-			return NDIS_STATUS_RESOURCES;
-		} else {
-			NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer,
-				       InformationBufferLength);
-			cmdqelmt->bufferlength = InformationBufferLength;
-		}
-	} else
-		cmdqelmt->bufferlength = 0;
-
-	cmdqelmt->command = Oid;
-	cmdqelmt->CmdFromNdis = TRUE;
-	if (SetInformation == TRUE)
-		cmdqelmt->SetOperation = TRUE;
-	else
-		cmdqelmt->SetOperation = FALSE;
-
-	NdisAcquireSpinLock(&pAd->CmdQLock);
-	if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT) {
-		EnqueueCmd((&pAd->CmdQ), cmdqelmt);
-		status = NDIS_STATUS_SUCCESS;
-	} else {
-		status = NDIS_STATUS_FAILURE;
-	}
-	NdisReleaseSpinLock(&pAd->CmdQLock);
-
-	if (status == NDIS_STATUS_FAILURE) {
-		if (cmdqelmt->buffer)
-			os_free_mem(pAd, cmdqelmt->buffer);
-		os_free_mem(pAd, cmdqelmt);
-	} else
-		RTUSBCMDUp(pAd);
-
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-int RTUSBEnqueueInternalCmd(struct rt_rtmp_adapter *pAd,
-				    IN NDIS_OID Oid,
-				    void *pInformationBuffer,
-				    u32 InformationBufferLength)
-{
-	int status;
-	struct rt_cmdqelmt *cmdqelmt = NULL;
-
-	status = os_alloc_mem(pAd, (u8 **) & cmdqelmt, sizeof(struct rt_cmdqelmt));
-	if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt == NULL))
-		return NDIS_STATUS_RESOURCES;
-	NdisZeroMemory(cmdqelmt, sizeof(struct rt_cmdqelmt));
-
-	if (InformationBufferLength > 0) {
-		status =
-		    os_alloc_mem(pAd, (u8 **) & cmdqelmt->buffer,
-				 InformationBufferLength);
-		if ((status != NDIS_STATUS_SUCCESS)
-		    || (cmdqelmt->buffer == NULL)) {
-			os_free_mem(pAd, cmdqelmt);
-			return NDIS_STATUS_RESOURCES;
-		} else {
-			NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer,
-				       InformationBufferLength);
-			cmdqelmt->bufferlength = InformationBufferLength;
-		}
-	} else {
-		cmdqelmt->buffer = NULL;
-		cmdqelmt->bufferlength = 0;
-	}
-
-	cmdqelmt->command = Oid;
-	cmdqelmt->CmdFromNdis = FALSE;
-
-	if (cmdqelmt != NULL) {
-		NdisAcquireSpinLock(&pAd->CmdQLock);
-		if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT) {
-			EnqueueCmd((&pAd->CmdQ), cmdqelmt);
-			status = NDIS_STATUS_SUCCESS;
-		} else {
-			status = NDIS_STATUS_FAILURE;
-		}
-		NdisReleaseSpinLock(&pAd->CmdQLock);
-
-		if (status == NDIS_STATUS_FAILURE) {
-			if (cmdqelmt->buffer)
-				os_free_mem(pAd, cmdqelmt->buffer);
-			os_free_mem(pAd, cmdqelmt);
-		} else
-			RTUSBCMDUp(pAd);
-	}
-	return NDIS_STATUS_SUCCESS;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	IRQL =
-
-	Note:
-
-	========================================================================
-*/
-void RTUSBDequeueCmd(struct rt_cmdq *cmdq, struct rt_cmdqelmt * * pcmdqelmt)
-{
-	*pcmdqelmt = cmdq->head;
-
-	if (*pcmdqelmt != NULL) {
-		cmdq->head = cmdq->head->next;
-		cmdq->size--;
-		if (cmdq->size == 0)
-			cmdq->tail = NULL;
-	}
-}
-
-/*
-    ========================================================================
-	  usb_control_msg - Builds a control urb, sends it off and waits for completion
-	  @dev: pointer to the usb device to send the message to
-	  @pipe: endpoint "pipe" to send the message to
-	  @request: USB message request value
-	  @requesttype: USB message request type value
-	  @value: USB message value
-	  @index: USB message index value
-	  @data: pointer to the data to send
-	  @size: length in bytes of the data to send
-	  @timeout: time in jiffies to wait for the message to complete before
-			  timing out (if 0 the wait is forever)
-	  Context: !in_interrupt ()
-
-	  This function sends a simple control message to a specified endpoint
-	  and waits for the message to complete, or timeout.
-	  If successful, it returns the number of bytes transferred, otherwise a negative error number.
-
-	 Don't use this function from within an interrupt context, like a
-	  bottom half handler.	If you need an asynchronous message, or need to send
-	  a message from within interrupt context, use usb_submit_urb()
-	  If a thread in your driver uses this call, make sure your disconnect()
-	  method can wait for it to complete.  Since you don't have a handle on
-	  the URB used, you can't cancel the request.
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-int RTUSB_VendorRequest(struct rt_rtmp_adapter *pAd,
-			     u32 TransferFlags,
-			     u8 RequestType,
-			     u8 Request,
-			     u16 Value,
-			     u16 Index,
-			     void *TransferBuffer,
-			     u32 TransferBufferLength)
-{
-	int ret = 0;
-	struct os_cookie *pObj = (struct os_cookie *)pAd->OS_Cookie;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("device disconnected\n"));
-		return -1;
-	} else if (in_interrupt()) {
-		DBGPRINT(RT_DEBUG_ERROR,
-			 ("in_interrupt, RTUSB_VendorRequest Request%02x Value%04x Offset%04x\n",
-			  Request, Value, Index));
-
-		return -1;
-	} else {
-#define MAX_RETRY_COUNT  10
-
-		int retryCount = 0;
-		void *tmpBuf = TransferBuffer;
-
-		ret = down_interruptible(&(pAd->UsbVendorReq_semaphore));
-		if (pAd->UsbVendorReqBuf) {
-			ASSERT(TransferBufferLength < MAX_PARAM_BUFFER_SIZE);
-
-			tmpBuf = (void *)pAd->UsbVendorReqBuf;
-			NdisZeroMemory(pAd->UsbVendorReqBuf,
-				       TransferBufferLength);
-
-			if (RequestType == DEVICE_VENDOR_REQUEST_OUT)
-				NdisMoveMemory(tmpBuf, TransferBuffer,
-					       TransferBufferLength);
-		}
-
-		do {
-			if (RequestType == DEVICE_VENDOR_REQUEST_OUT)
-				ret =
-				    usb_control_msg(pObj->pUsb_Dev,
-						    usb_sndctrlpipe(pObj->
-								    pUsb_Dev,
-								    0), Request,
-						    RequestType, Value, Index,
-						    tmpBuf,
-						    TransferBufferLength,
-						    CONTROL_TIMEOUT_JIFFIES);
-			else if (RequestType == DEVICE_VENDOR_REQUEST_IN)
-				ret =
-				    usb_control_msg(pObj->pUsb_Dev,
-						    usb_rcvctrlpipe(pObj->
-								    pUsb_Dev,
-								    0), Request,
-						    RequestType, Value, Index,
-						    tmpBuf,
-						    TransferBufferLength,
-						    CONTROL_TIMEOUT_JIFFIES);
-			else {
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("vendor request direction is failed\n"));
-				ret = -1;
-			}
-
-			retryCount++;
-			if (ret < 0) {
-				DBGPRINT(RT_DEBUG_OFF, ("#\n"));
-				RTMPusecDelay(5000);
-			}
-		} while ((ret < 0) && (retryCount < MAX_RETRY_COUNT));
-
-		if ((pAd->UsbVendorReqBuf)
-		    && (RequestType == DEVICE_VENDOR_REQUEST_IN))
-			NdisMoveMemory(TransferBuffer, tmpBuf,
-				       TransferBufferLength);
-		up(&(pAd->UsbVendorReq_semaphore));
-
-		if (ret < 0) {
-			DBGPRINT(RT_DEBUG_ERROR,
-				 ("RTUSB_VendorRequest failed(%d),TxFlags=0x%x, ReqType=%s, Req=0x%x, Index=0x%x\n",
-				  ret, TransferFlags,
-				  (RequestType ==
-				   DEVICE_VENDOR_REQUEST_OUT ? "OUT" : "IN"),
-				  Request, Index));
-			if (Request == 0x2)
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("\tRequest Value=0x%04x!\n", Value));
-
-			if ((TransferBuffer != NULL)
-			    && (TransferBufferLength > 0))
-				hex_dump("Failed TransferBuffer value",
-					 TransferBuffer, TransferBufferLength);
-		}
-
-	}
-
-	if (ret != -1)
-		return STATUS_SUCCESS;
-	else
-		return STATUS_UNSUCCESSFUL;
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-	  Creates an IRP to submite an IOCTL_INTERNAL_USB_RESET_PORT
-	  synchronously. Callers of this function must be running at
-	  PASSIVE LEVEL.
-
-	Arguments:
-
-	Return Value:
-
-	Note:
-
-	========================================================================
-*/
-int RTUSB_ResetDevice(struct rt_rtmp_adapter *pAd)
-{
-	int Status = TRUE;
-
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->USB_ResetDevice\n"));
-	/*RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS); */
-	return Status;
-}
-
-void CMDHandler(struct rt_rtmp_adapter *pAd)
-{
-	struct rt_cmdqelmt *cmdqelmt;
-	u8 *pData;
-	int NdisStatus = NDIS_STATUS_SUCCESS;
-/*      unsigned long                   Now = 0; */
-	int ntStatus;
-/*      unsigned long   IrqFlags; */
-
-	while (pAd && pAd->CmdQ.size > 0) {
-		NdisStatus = NDIS_STATUS_SUCCESS;
-
-		NdisAcquireSpinLock(&pAd->CmdQLock);
-		RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
-		NdisReleaseSpinLock(&pAd->CmdQLock);
-
-		if (cmdqelmt == NULL)
-			break;
-
-		pData = cmdqelmt->buffer;
-
-		if (!
-		    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
-		     || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))) {
-			switch (cmdqelmt->command) {
-			case CMDTHREAD_CHECK_GPIO:
-				{
-					u32 data;
-
-					{
-						/* Read GPIO pin2 as Hardware controlled radio state */
-
-						RTUSBReadMACRegister(pAd,
-								     GPIO_CTRL_CFG,
-								     &data);
-
-						if (data & 0x04) {
-							pAd->StaCfg.bHwRadio =
-							    TRUE;
-						} else {
-							pAd->StaCfg.bHwRadio =
-							    FALSE;
-						}
-
-						if (pAd->StaCfg.bRadio !=
-						    (pAd->StaCfg.bHwRadio
-						     && pAd->StaCfg.bSwRadio)) {
-							pAd->StaCfg.bRadio =
-							    (pAd->StaCfg.
-							     bHwRadio
-							     && pAd->StaCfg.
-							     bSwRadio);
-							if (pAd->StaCfg.
-							    bRadio == TRUE) {
-								DBGPRINT_RAW
-								    (RT_DEBUG_ERROR,
-								     ("!!! Radio On !!!\n"));
-
-								MlmeRadioOn
-								    (pAd);
-								/* Update extra information */
-								pAd->ExtraInfo =
-								    EXTRA_INFO_CLEAR;
-							} else {
-								DBGPRINT_RAW
-								    (RT_DEBUG_ERROR,
-								     ("!!! Radio Off !!!\n"));
-
-								MlmeRadioOff
-								    (pAd);
-								/* Update extra information */
-								pAd->ExtraInfo =
-								    HW_RADIO_OFF;
-							}
-						}
-					}
-				}
-				break;
-
-			case CMDTHREAD_QKERIODIC_EXECUT:
-				{
-					StaQuickResponeForRateUpExec(NULL, pAd,
-								     NULL,
-								     NULL);
-				}
-				break;
-
-			case CMDTHREAD_RESET_BULK_OUT:
-				{
-					u32 MACValue;
-					u8 Index;
-					int ret = 0;
-					struct rt_ht_tx_context *pHTTXContext;
-/*                                              struct rt_rtmp_tx_ring *pTxRing; */
-					unsigned long IrqFlags;
-
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("CmdThread : CMDTHREAD_RESET_BULK_OUT(ResetPipeid=0x%0x)===>\n",
-						      pAd->bulkResetPipeid));
-					/* All transfers must be aborted or cancelled before attempting to reset the pipe. */
-					/*RTUSBCancelPendingBulkOutIRP(pAd); */
-					/* Wait 10ms to let previous packet that are already in HW FIFO to clear. by MAXLEE 12-25-2007 */
-					Index = 0;
-					do {
-						RTUSBReadMACRegister(pAd,
-								     TXRXQ_PCNT,
-								     &MACValue);
-						if ((MACValue & 0xf00000
-						     /*0x800000 */) == 0)
-							break;
-						Index++;
-						RTMPusecDelay(10000);
-					} while (Index < 100);
-					MACValue = 0;
-					RTUSBReadMACRegister(pAd, USB_DMA_CFG,
-							     &MACValue);
-					/* To prevent Read Register error, we 2nd check the validity. */
-					if ((MACValue & 0xc00000) == 0)
-						RTUSBReadMACRegister(pAd,
-								     USB_DMA_CFG,
-								     &MACValue);
-					/* To prevent Read Register error, we 3rd check the validity. */
-					if ((MACValue & 0xc00000) == 0)
-						RTUSBReadMACRegister(pAd,
-								     USB_DMA_CFG,
-								     &MACValue);
-					MACValue |= 0x80000;
-					RTUSBWriteMACRegister(pAd, USB_DMA_CFG,
-							      MACValue);
-
-					/* Wait 1ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007 */
-					RTMPusecDelay(1000);
-
-					MACValue &= (~0x80000);
-					RTUSBWriteMACRegister(pAd, USB_DMA_CFG,
-							      MACValue);
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("\tSet 0x2a0 bit19. Clear USB DMA TX path\n"));
-
-					/* Wait 5ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007 */
-					/*RTMPusecDelay(5000); */
-
-					if ((pAd->
-					     bulkResetPipeid &
-					     BULKOUT_MGMT_RESET_FLAG) ==
-					    BULKOUT_MGMT_RESET_FLAG) {
-						RTMP_CLEAR_FLAG(pAd,
-								fRTMP_ADAPTER_BULKOUT_RESET);
-						if (pAd->MgmtRing.TxSwFreeIdx <
-						    MGMT_RING_SIZE
-						    /* pMLMEContext->bWaitingBulkOut == TRUE */
-						    ) {
-							RTUSB_SET_BULK_FLAG(pAd,
-									    fRTUSB_BULK_OUT_MLME);
-						}
-						RTUSBKickBulkOut(pAd);
-
-						DBGPRINT_RAW(RT_DEBUG_TRACE,
-							     ("\tTX MGMT RECOVER Done!\n"));
-					} else {
-						pHTTXContext =
-						    &(pAd->
-						      TxContext[pAd->
-								bulkResetPipeid]);
-						/*NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
-						RTMP_INT_LOCK(&pAd->
-							      BulkOutLock[pAd->
-									  bulkResetPipeid],
-							      IrqFlags);
-						if (pAd->
-						    BulkOutPending[pAd->
-								   bulkResetPipeid]
-						    == FALSE) {
-							pAd->
-							    BulkOutPending[pAd->
-									   bulkResetPipeid]
-							    = TRUE;
-							pHTTXContext->
-							    IRPPending = TRUE;
-							pAd->
-							    watchDogTxPendingCnt
-							    [pAd->
-							     bulkResetPipeid] =
-							    1;
-
-							/* no matter what, clean the flag */
-							RTMP_CLEAR_FLAG(pAd,
-									fRTMP_ADAPTER_BULKOUT_RESET);
-
-							/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
-							RTMP_INT_UNLOCK(&pAd->
-									BulkOutLock
-									[pAd->
-									 bulkResetPipeid],
-									IrqFlags);
-							{
-								RTUSBInitHTTxDesc
-								    (pAd,
-								     pHTTXContext,
-								     pAd->
-								     bulkResetPipeid,
-								     pHTTXContext->
-								     BulkOutSize,
-								     (usb_complete_t)
-								     RTUSBBulkOutDataPacketComplete);
-
-								ret = RTUSB_SUBMIT_URB
-								     (pHTTXContext->
-								      pUrb);
-								if (ret != 0) {
-									RTMP_INT_LOCK
-									    (&pAd->
-									     BulkOutLock
-									     [pAd->
-									      bulkResetPipeid],
-									     IrqFlags);
-									pAd->
-									    BulkOutPending
-									    [pAd->
-									     bulkResetPipeid]
-									    =
-									    FALSE;
-									pHTTXContext->
-									    IRPPending
-									    =
-									    FALSE;
-									pAd->
-									    watchDogTxPendingCnt
-									    [pAd->
-									     bulkResetPipeid]
-									    = 0;
-									RTMP_INT_UNLOCK
-									    (&pAd->
-									     BulkOutLock
-									     [pAd->
-									      bulkResetPipeid],
-									     IrqFlags);
-
-									DBGPRINT
-									    (RT_DEBUG_ERROR,
-									     ("CmdThread : CMDTHREAD_RESET_BULK_OUT: Submit Tx URB failed %d\n",
-									      ret));
-								} else {
-									RTMP_IRQ_LOCK
-									    (&pAd->
-									     BulkOutLock
-									     [pAd->
-									      bulkResetPipeid],
-									     IrqFlags);
-									DBGPRINT_RAW
-									    (RT_DEBUG_TRACE,
-									     ("\tCMDTHREAD_RESET_BULK_OUT: TxContext[%d]:CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, pending=%d!\n",
-									      pAd->
-									      bulkResetPipeid,
-									      pHTTXContext->
-									      CurWritePosition,
-									      pHTTXContext->
-									      NextBulkOutPosition,
-									      pHTTXContext->
-									      ENextBulkOutPosition,
-									      pHTTXContext->
-									      bCopySavePad,
-									      pAd->
-									      BulkOutPending
-									      [pAd->
-									       bulkResetPipeid]));
-									DBGPRINT_RAW
-									    (RT_DEBUG_TRACE,
-									     ("\t\tBulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n",
-									      pAd->
-									      BulkOutReq,
-									      pAd->
-									      BulkOutComplete,
-									      pAd->
-									      BulkOutCompleteOther));
-									RTMP_IRQ_UNLOCK
-									    (&pAd->
-									     BulkOutLock
-									     [pAd->
-									      bulkResetPipeid],
-									     IrqFlags);
-									DBGPRINT_RAW
-									    (RT_DEBUG_TRACE,
-									     ("\tCMDTHREAD_RESET_BULK_OUT: Submit Tx DATA URB for failed BulkReq(0x%lx) Done, status=%d!\n",
-									      pAd->
-									      bulkResetReq
-									      [pAd->
-									       bulkResetPipeid],
-									      pHTTXContext->
-									      pUrb->
-									      status));
-
-								}
-							}
-						} else {
-							/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
-							/*RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags); */
-
-							DBGPRINT_RAW
-							    (RT_DEBUG_ERROR,
-							     ("CmdThread : TX DATA RECOVER FAIL for BulkReq(0x%lx) because BulkOutPending[%d] is TRUE!\n",
-							      pAd->
-							      bulkResetReq[pAd->
-									   bulkResetPipeid],
-							      pAd->
-							      bulkResetPipeid));
-							if (pAd->
-							    bulkResetPipeid ==
-							    0) {
-								u8
-								    pendingContext
-								    = 0;
-								struct rt_ht_tx_context *
-								    pHTTXContext
-								    =
-								    (struct rt_ht_tx_context *)
-								    (&pAd->
-								     TxContext
-								     [pAd->
-								      bulkResetPipeid]);
-								struct rt_tx_context *
-								    pMLMEContext
-								    =
-								    (struct rt_tx_context *)
-								    (pAd->
-								     MgmtRing.
-								     Cell[pAd->
-									  MgmtRing.
-									  TxDmaIdx].
-								     AllocVa);
-								struct rt_tx_context *
-								    pNULLContext
-								    =
-								    (struct rt_tx_context *)
-								    (&pAd->
-								     PsPollContext);
-								struct rt_tx_context *
-								    pPsPollContext
-								    =
-								    (struct rt_tx_context *)
-								    (&pAd->
-								     NullContext);
-
-								if (pHTTXContext->IRPPending)
-									pendingContext
-									    |=
-									    1;
-								else if
-								    (pMLMEContext->
-								     IRPPending)
-									pendingContext
-									    |=
-									    2;
-								else if
-								    (pNULLContext->
-								     IRPPending)
-									pendingContext
-									    |=
-									    4;
-								else if
-								    (pPsPollContext->
-								     IRPPending)
-									pendingContext
-									    |=
-									    8;
-								else
-									pendingContext
-									    = 0;
-
-								DBGPRINT_RAW
-								    (RT_DEBUG_ERROR,
-								     ("\tTX Occupied by %d!\n",
-								      pendingContext));
-							}
-							/* no matter what, clean the flag */
-							RTMP_CLEAR_FLAG(pAd,
-									fRTMP_ADAPTER_BULKOUT_RESET);
-
-							RTMP_INT_UNLOCK(&pAd->
-									BulkOutLock
-									[pAd->
-									 bulkResetPipeid],
-									IrqFlags);
-
-							RTUSB_SET_BULK_FLAG(pAd,
-									    (fRTUSB_BULK_OUT_DATA_NORMAL
-									     <<
-									     pAd->
-									     bulkResetPipeid));
-						}
-
-						RTMPDeQueuePacket(pAd, FALSE,
-								  NUM_OF_TX_RING,
-								  MAX_TX_PROCESS);
-						/*RTUSBKickBulkOut(pAd); */
-					}
-
-				}
-				/*
-				   // Don't cancel BULKIN.
-				   while ((atomic_read(&pAd->PendingRx) > 0) &&
-				   (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-				   {
-				   if (atomic_read(&pAd->PendingRx) > 0)
-				   {
-				   DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkIn IRP Pending!!cancel it!\n"));
-				   RTUSBCancelPendingBulkInIRP(pAd);
-				   }
-				   RTMPusecDelay(100000);
-				   }
-
-				   if ((atomic_read(&pAd->PendingRx) == 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
-				   {
-				   u8        i;
-				   RTUSBRxPacket(pAd);
-				   pAd->NextRxBulkInReadIndex = 0;      // Next Rx Read index
-				   pAd->NextRxBulkInIndex               = 0;    // Rx Bulk pointer
-				   for (i = 0; i < (RX_RING_SIZE); i++)
-				   {
-				   struct rt_rx_context *pRxContext = &(pAd->RxContext[i]);
-
-				   pRxContext->pAd      = pAd;
-				   pRxContext->InUse            = FALSE;
-				   pRxContext->IRPPending       = FALSE;
-				   pRxContext->Readable = FALSE;
-				   pRxContext->ReorderInUse = FALSE;
-
-				   }
-				   RTUSBBulkReceive(pAd);
-				   DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTUSBBulkReceive\n"));
-				   } */
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("CmdThread : CMDTHREAD_RESET_BULK_OUT<===\n"));
-				break;
-
-			case CMDTHREAD_RESET_BULK_IN:
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("CmdThread : CMDTHREAD_RESET_BULK_IN === >\n"));
-
-				/* All transfers must be aborted or cancelled before attempting to reset the pipe. */
-				{
-					u32 MACValue;
-					{
-						/*while ((atomic_read(&pAd->PendingRx) > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) */
-						if ((pAd->PendingRx > 0)
-						    &&
-						    (!RTMP_TEST_FLAG
-						     (pAd,
-						      fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-							DBGPRINT_RAW
-							    (RT_DEBUG_ERROR,
-							     ("BulkIn IRP Pending!!!\n"));
-							RTUSBCancelPendingBulkInIRP
-							    (pAd);
-							RTMPusecDelay(100000);
-							pAd->PendingRx = 0;
-						}
-					}
-					/* Wait 10ms before reading register. */
-					RTMPusecDelay(10000);
-					ntStatus =
-					    RTUSBReadMACRegister(pAd, MAC_CSR0,
-								 &MACValue);
-
-					if ((NT_SUCCESS(ntStatus) == TRUE) &&
-					    (!(RTMP_TEST_FLAG
-					       (pAd,
-						(fRTMP_ADAPTER_RESET_IN_PROGRESS
-						 | fRTMP_ADAPTER_RADIO_OFF |
-						 fRTMP_ADAPTER_HALT_IN_PROGRESS
-						 |
-						 fRTMP_ADAPTER_NIC_NOT_EXIST)))))
-					{
-						u8 i;
-
-						if (RTMP_TEST_FLAG
-						    (pAd,
-						     (fRTMP_ADAPTER_RESET_IN_PROGRESS
-						      | fRTMP_ADAPTER_RADIO_OFF
-						      |
-						      fRTMP_ADAPTER_HALT_IN_PROGRESS
-						      |
-						      fRTMP_ADAPTER_NIC_NOT_EXIST)))
-							break;
-						pAd->NextRxBulkInPosition =
-						    pAd->RxContext[pAd->
-								   NextRxBulkInIndex].
-						    BulkInOffset;
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("BULK_IN_RESET: NBIIdx=0x%x,NBIRIdx=0x%x, BIRPos=0x%lx. BIReq=x%lx, BIComplete=0x%lx, BICFail0x%lx\n",
-							  pAd->
-							  NextRxBulkInIndex,
-							  pAd->
-							  NextRxBulkInReadIndex,
-							  pAd->
-							  NextRxBulkInPosition,
-							  pAd->BulkInReq,
-							  pAd->BulkInComplete,
-							  pAd->
-							  BulkInCompleteFail));
-						for (i = 0; i < RX_RING_SIZE;
-						     i++) {
-							DBGPRINT(RT_DEBUG_TRACE,
-								 ("\tRxContext[%d]: IRPPending=%d, InUse=%d, Readable=%d!\n",
-								  i,
-								  pAd->
-								  RxContext[i].
-								  IRPPending,
-								  pAd->
-								  RxContext[i].
-								  InUse,
-								  pAd->
-								  RxContext[i].
-								  Readable));
-						}
-						/*
-
-						   DBGPRINT_RAW(RT_DEBUG_ERROR, ("==========================================\n"));
-
-						   pAd->NextRxBulkInReadIndex = 0;      // Next Rx Read index
-						   pAd->NextRxBulkInIndex               = 0;    // Rx Bulk pointer
-						   for (i = 0; i < (RX_RING_SIZE); i++)
-						   {
-						   struct rt_rx_context *pRxContext = &(pAd->RxContext[i]);
-
-						   pRxContext->pAd      = pAd;
-						   pRxContext->InUse            = FALSE;
-						   pRxContext->IRPPending       = FALSE;
-						   pRxContext->Readable = FALSE;
-						   pRxContext->ReorderInUse = FALSE;
-
-						   } */
-						RTMP_CLEAR_FLAG(pAd,
-								fRTMP_ADAPTER_BULKIN_RESET);
-						for (i = 0;
-						     i <
-						     pAd->CommonCfg.
-						     NumOfBulkInIRP; i++) {
-							/*RTUSBBulkReceive(pAd); */
-							struct rt_rx_context *pRxContext;
-							PURB pUrb;
-							int ret = 0;
-							unsigned long IrqFlags;
-
-							RTMP_IRQ_LOCK(&pAd->
-								      BulkInLock,
-								      IrqFlags);
-							pRxContext =
-							    &(pAd->
-							      RxContext[pAd->
-									NextRxBulkInIndex]);
-							if ((pAd->PendingRx > 0)
-							    || (pRxContext->
-								Readable ==
-								TRUE)
-							    || (pRxContext->
-								InUse ==
-								TRUE)) {
-								RTMP_IRQ_UNLOCK
-								    (&pAd->
-								     BulkInLock,
-								     IrqFlags);
-								break;
-							}
-							pRxContext->InUse =
-							    TRUE;
-							pRxContext->IRPPending =
-							    TRUE;
-							pAd->PendingRx++;
-							pAd->BulkInReq++;
-							RTMP_IRQ_UNLOCK(&pAd->
-									BulkInLock,
-									IrqFlags);
-
-							/* Init Rx context descriptor */
-							RTUSBInitRxDesc(pAd,
-									pRxContext);
-							pUrb = pRxContext->pUrb;
-							ret = RTUSB_SUBMIT_URB(pUrb);
-							if (ret != 0) {	/* fail */
-
-								RTMP_IRQ_LOCK
-								    (&pAd->
-								     BulkInLock,
-								     IrqFlags);
-								pRxContext->
-								    InUse =
-								    FALSE;
-								pRxContext->
-								    IRPPending =
-								    FALSE;
-								pAd->
-								    PendingRx--;
-								pAd->
-								    BulkInReq--;
-								RTMP_IRQ_UNLOCK
-								    (&pAd->
-								     BulkInLock,
-								     IrqFlags);
-								DBGPRINT
-								    (RT_DEBUG_ERROR,
-								     ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB failed(%d), status=%d\n",
-								      ret,
-								      pUrb->
-								      status));
-							} else {	/* success */
-								/*DBGPRINT(RT_DEBUG_TRACE, ("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", */
-								/*                                                      pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex)); */
-								DBGPRINT_RAW
-								    (RT_DEBUG_TRACE,
-								     ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB Done, status=%d!\n",
-								      pUrb->
-								      status));
-								ASSERT((pRxContext->InUse == pRxContext->IRPPending));
-							}
-						}
-
-					} else {
-						/* Card must be removed */
-						if (NT_SUCCESS(ntStatus) !=
-						    TRUE) {
-							RTMP_SET_FLAG(pAd,
-								      fRTMP_ADAPTER_NIC_NOT_EXIST);
-							DBGPRINT_RAW
-							    (RT_DEBUG_ERROR,
-							     ("CMDTHREAD_RESET_BULK_IN: Read Register Failed!Card must be removed!!\n\n"));
-						} else {
-							DBGPRINT_RAW
-							    (RT_DEBUG_ERROR,
-							     ("CMDTHREAD_RESET_BULK_IN: Cannot do bulk in because flags(0x%lx) on !\n",
-							      pAd->Flags));
-						}
-					}
-				}
-				DBGPRINT_RAW(RT_DEBUG_TRACE,
-					     ("CmdThread : CMDTHREAD_RESET_BULK_IN <===\n"));
-				break;
-
-			case CMDTHREAD_SET_ASIC_WCID:
-				{
-					struct rt_set_asic_wcid SetAsicWcid;
-					u16 offset;
-					u32 MACValue, MACRValue = 0;
-					SetAsicWcid =
-					    *((struct rt_set_asic_wcid *)(pData));
-
-					if (SetAsicWcid.WCID >=
-					    MAX_LEN_OF_MAC_TABLE)
-						return;
-
-					offset =
-					    MAC_WCID_BASE +
-					    ((u8)SetAsicWcid.WCID) *
-					    HW_WCID_ENTRY_SIZE;
-
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("CmdThread : CMDTHREAD_SET_ASIC_WCID : WCID = %ld, SetTid  = %lx, DeleteTid = %lx.\n",
-						      SetAsicWcid.WCID,
-						      SetAsicWcid.SetTid,
-						      SetAsicWcid.DeleteTid));
-					MACValue =
-					    (pAd->MacTab.
-					     Content[SetAsicWcid.WCID].
-					     Addr[3] << 24) +
-					    (pAd->MacTab.
-					     Content[SetAsicWcid.WCID].
-					     Addr[2] << 16) +
-					    (pAd->MacTab.
-					     Content[SetAsicWcid.WCID].
-					     Addr[1] << 8) +
-					    (pAd->MacTab.
-					     Content[SetAsicWcid.WCID].Addr[0]);
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("1-MACValue= %x,\n",
-						      MACValue));
-					RTUSBWriteMACRegister(pAd, offset,
-							      MACValue);
-					/* Read bitmask */
-					RTUSBReadMACRegister(pAd, offset + 4,
-							     &MACRValue);
-					if (SetAsicWcid.DeleteTid != 0xffffffff)
-						MACRValue &=
-						    (~SetAsicWcid.DeleteTid);
-					if (SetAsicWcid.SetTid != 0xffffffff)
-						MACRValue |=
-						    (SetAsicWcid.SetTid);
-					MACRValue &= 0xffff0000;
-
-					MACValue =
-					    (pAd->MacTab.
-					     Content[SetAsicWcid.WCID].
-					     Addr[5] << 8) +
-					    pAd->MacTab.Content[SetAsicWcid.
-								WCID].Addr[4];
-					MACValue |= MACRValue;
-					RTUSBWriteMACRegister(pAd, offset + 4,
-							      MACValue);
-
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("2-MACValue= %x,\n",
-						      MACValue));
-				}
-				break;
-
-			case CMDTHREAD_SET_ASIC_WCID_CIPHER:
-				{
-					struct rt_set_asic_wcid_attri SetAsicWcidAttri;
-					u16 offset;
-					u32 MACRValue = 0;
-					SHAREDKEY_MODE_STRUC csr1;
-					SetAsicWcidAttri =
-					    *((struct rt_set_asic_wcid_attri *)
-					      (pData));
-
-					if (SetAsicWcidAttri.WCID >=
-					    MAX_LEN_OF_MAC_TABLE)
-						return;
-
-					offset =
-					    MAC_WCID_ATTRIBUTE_BASE +
-					    ((u8)SetAsicWcidAttri.WCID) *
-					    HW_WCID_ATTRI_SIZE;
-
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("Cmd : CMDTHREAD_SET_ASIC_WCID_CIPHER : WCID = %ld, Cipher = %lx.\n",
-						      SetAsicWcidAttri.WCID,
-						      SetAsicWcidAttri.Cipher));
-					/* Read bitmask */
-					RTUSBReadMACRegister(pAd, offset,
-							     &MACRValue);
-					MACRValue = 0;
-					MACRValue |=
-					    (((u8)SetAsicWcidAttri.
-					      Cipher) << 1);
-
-					RTUSBWriteMACRegister(pAd, offset,
-							      MACRValue);
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("2-offset = %x , MACValue= %x,\n",
-						      offset, MACRValue));
-
-					offset =
-					    PAIRWISE_IVEIV_TABLE_BASE +
-					    ((u8)SetAsicWcidAttri.WCID) *
-					    HW_IVEIV_ENTRY_SIZE;
-					MACRValue = 0;
-					if ((SetAsicWcidAttri.Cipher <=
-					     CIPHER_WEP128))
-						MACRValue |=
-						    (pAd->StaCfg.
-						     DefaultKeyId << 30);
-					else
-						MACRValue |= (0x20000000);
-					RTUSBWriteMACRegister(pAd, offset,
-							      MACRValue);
-					DBGPRINT_RAW(RT_DEBUG_TRACE,
-						     ("2-offset = %x , MACValue= %x,\n",
-						      offset, MACRValue));
-
-					/* */
-					/* Update cipher algorithm. WSTA always use BSS0 */
-					/* */
-					/* for adhoc mode only ,because wep status slow than add key, when use zero config */
-					if (pAd->StaCfg.BssType == BSS_ADHOC) {
-						offset =
-						    MAC_WCID_ATTRIBUTE_BASE;
-
-						RTUSBReadMACRegister(pAd,
-								     offset,
-								     &MACRValue);
-						MACRValue &= (~0xe);
-						MACRValue |=
-						    (((u8)SetAsicWcidAttri.
-						      Cipher) << 1);
-
-						RTUSBWriteMACRegister(pAd,
-								      offset,
-								      MACRValue);
-
-						/*Update group key cipher,,because wep status slow than add key, when use zero config */
-						RTUSBReadMACRegister(pAd,
-								     SHARED_KEY_MODE_BASE
-								     +
-								     4 * (0 /
-									  2),
-								     &csr1.
-								     word);
-
-						csr1.field.Bss0Key0CipherAlg =
-						    SetAsicWcidAttri.Cipher;
-						csr1.field.Bss0Key1CipherAlg =
-						    SetAsicWcidAttri.Cipher;
-
-						RTUSBWriteMACRegister(pAd,
-								      SHARED_KEY_MODE_BASE
-								      +
-								      4 * (0 /
-									   2),
-								      csr1.
-								      word);
-					}
-				}
-				break;
-
-/*Benson modified for USB interface, avoid in interrupt when write key, 20080724 --> */
-			case RT_CMD_SET_KEY_TABLE:	/*General call for AsicAddPairwiseKeyEntry() */
-				{
-					struct rt_add_pairwise_key_entry KeyInfo;
-					KeyInfo =
-					    *((struct rt_add_pairwise_key_entry *)
-					      (pData));
-					AsicAddPairwiseKeyEntry(pAd,
-								KeyInfo.MacAddr,
-								(u8)KeyInfo.
-								MacTabMatchWCID,
-								&KeyInfo.
-								CipherKey);
-				}
-				break;
-
-			case RT_CMD_SET_RX_WCID_TABLE:	/*General call for RTMPAddWcidAttributeEntry() */
-				{
-					struct rt_mac_table_entry *pEntry;
-					u8 KeyIdx = 0;
-					u8 CipherAlg = CIPHER_NONE;
-					u8 ApIdx = BSS0;
-
-					pEntry = (struct rt_mac_table_entry *)(pData);
-
-					RTMPAddWcidAttributeEntry(pAd,
-								  ApIdx,
-								  KeyIdx,
-								  CipherAlg,
-								  pEntry);
-				}
-				break;
-/*Benson modified for USB interface, avoid in interrupt when write key, 20080724 <-- */
-
-			case CMDTHREAD_SET_CLIENT_MAC_ENTRY:
-				{
-					struct rt_mac_table_entry *pEntry;
-					pEntry = (struct rt_mac_table_entry *)pData;
-
-					{
-						AsicRemovePairwiseKeyEntry(pAd,
-									   pEntry->
-									   apidx,
-									   (u8)
-									   pEntry->
-									   Aid);
-						if ((pEntry->AuthMode <=
-						     Ndis802_11AuthModeAutoSwitch)
-						    && (pEntry->WepStatus ==
-							Ndis802_11Encryption1Enabled))
-						{
-							u32 uIV = 1;
-							u8 *ptr;
-
-							ptr = (u8 *)& uIV;
-							*(ptr + 3) =
-							    (pAd->StaCfg.
-							     DefaultKeyId << 6);
-							AsicUpdateWCIDIVEIV(pAd,
-									    pEntry->
-									    Aid,
-									    uIV,
-									    0);
-							AsicUpdateWCIDAttribute
-							    (pAd, pEntry->Aid,
-							     BSS0,
-							     pAd->
-							     SharedKey[BSS0]
-							     [pAd->StaCfg.
-							      DefaultKeyId].
-							     CipherAlg, FALSE);
-						} else if (pEntry->AuthMode ==
-							   Ndis802_11AuthModeWPANone)
-						{
-							u32 uIV = 1;
-							u8 *ptr;
-
-							ptr = (u8 *)& uIV;
-							*(ptr + 3) =
-							    (pAd->StaCfg.
-							     DefaultKeyId << 6);
-							AsicUpdateWCIDIVEIV(pAd,
-									    pEntry->
-									    Aid,
-									    uIV,
-									    0);
-							AsicUpdateWCIDAttribute
-							    (pAd, pEntry->Aid,
-							     BSS0,
-							     pAd->
-							     SharedKey[BSS0]
-							     [pAd->StaCfg.
-							      DefaultKeyId].
-							     CipherAlg, FALSE);
-						} else {
-							/* */
-							/* Other case, disable engine. */
-							/* Don't worry WPA key, we will add WPA Key after 4-Way handshaking. */
-							/* */
-							u16 offset;
-							offset =
-							    MAC_WCID_ATTRIBUTE_BASE
-							    +
-							    (pEntry->Aid *
-							     HW_WCID_ATTRI_SIZE);
-							/* RX_PKEY_MODE:0 for no security; RX_KEY_TAB:0 for shared key table; BSS_IDX:0 */
-							RTUSBWriteMACRegister
-							    (pAd, offset, 0);
-						}
-					}
-
-					AsicUpdateRxWCIDTable(pAd, pEntry->Aid,
-							      pEntry->Addr);
-					DBGPRINT(RT_DEBUG_TRACE,
-						("UpdateRxWCIDTable(): Aid=%d, "
-							"Addr=%pM!\n",
-							pEntry->Aid,
-							pEntry->Addr));
-				}
-				break;
-
-/* add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
-			case CMDTHREAD_UPDATE_PROTECT:
-				{
-					AsicUpdateProtect(pAd, 0,
-							  (ALLN_SETPROTECT),
-							  TRUE, 0);
-				}
-				break;
-/* end johnli */
-
-			case OID_802_11_ADD_WEP:
-				{
-					u32 i;
-					u32 KeyIdx;
-					struct rt_ndis_802_11_wep *pWepKey;
-
-					DBGPRINT(RT_DEBUG_TRACE,
-						 ("CmdThread::OID_802_11_ADD_WEP  \n"));
-
-					pWepKey = (struct rt_ndis_802_11_wep *)pData;
-					KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
-
-					/* it is a shared key */
-					if ((KeyIdx >= 4)
-					    || ((pWepKey->KeyLength != 5)
-						&& (pWepKey->KeyLength !=
-						    13))) {
-						NdisStatus =
-						    NDIS_STATUS_INVALID_DATA;
-						DBGPRINT(RT_DEBUG_ERROR,
-							 ("CmdThread::OID_802_11_ADD_WEP, INVALID_DATA!!\n"));
-					} else {
-						u8 CipherAlg;
-						pAd->SharedKey[BSS0][KeyIdx].
-						    KeyLen =
-						    (u8)pWepKey->KeyLength;
-						NdisMoveMemory(pAd->
-							       SharedKey[BSS0]
-							       [KeyIdx].Key,
-							       &pWepKey->
-							       KeyMaterial,
-							       pWepKey->
-							       KeyLength);
-						CipherAlg =
-						    (pAd->
-						     SharedKey[BSS0][KeyIdx].
-						     KeyLen ==
-						     5) ? CIPHER_WEP64 :
-						    CIPHER_WEP128;
-
-						/* */
-						/* Change the WEP cipher to CKIP cipher if CKIP KP on. */
-						/* Funk UI or Meetinghouse UI will add ckip key from this path. */
-						/* */
-
-						if (pAd->OpMode == OPMODE_STA) {
-							pAd->MacTab.
-							    Content[BSSID_WCID].
-							    PairwiseKey.
-							    CipherAlg =
-							    pAd->
-							    SharedKey[BSS0]
-							    [KeyIdx].CipherAlg;
-							pAd->MacTab.
-							    Content[BSSID_WCID].
-							    PairwiseKey.KeyLen =
-							    pAd->
-							    SharedKey[BSS0]
-							    [KeyIdx].KeyLen;
-						}
-						pAd->SharedKey[BSS0][KeyIdx].
-						    CipherAlg = CipherAlg;
-						if (pWepKey->
-						    KeyIndex & 0x80000000) {
-							/* Default key for tx (shared key) */
-							u8 IVEIV[8];
-							u32 WCIDAttri, Value;
-							u16 offset, offset2;
-							NdisZeroMemory(IVEIV,
-								       8);
-							pAd->StaCfg.
-							    DefaultKeyId =
-							    (u8)KeyIdx;
-							/* Add BSSID to WCTable. because this is Tx wep key. */
-							/* WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:1=PAIRWISE KEY, BSSIdx is 0 */
-							WCIDAttri =
-							    (CipherAlg << 1) |
-							    SHAREDKEYTABLE;
-
-							offset =
-							    MAC_WCID_ATTRIBUTE_BASE
-							    +
-							    (BSSID_WCID *
-							     HW_WCID_ATTRI_SIZE);
-							RTUSBWriteMACRegister
-							    (pAd, offset,
-							     WCIDAttri);
-							/* 1. IV/EIV */
-							/* Specify key index to find shared key. */
-							IVEIV[3] = (u8)(KeyIdx << 6);	/*WEP Eiv bit off. groupkey index is not 0 */
-							offset =
-							    PAIRWISE_IVEIV_TABLE_BASE
-							    +
-							    (BSS0Mcast_WCID *
-							     HW_IVEIV_ENTRY_SIZE);
-							offset2 =
-							    PAIRWISE_IVEIV_TABLE_BASE
-							    +
-							    (BSSID_WCID *
-							     HW_IVEIV_ENTRY_SIZE);
-							for (i = 0; i < 8;) {
-								Value =
-								    IVEIV[i];
-								Value +=
-								    (IVEIV
-								     [i +
-								      1] << 8);
-								Value +=
-								    (IVEIV
-								     [i +
-								      2] << 16);
-								Value +=
-								    (IVEIV
-								     [i +
-								      3] << 24);
-								RTUSBWriteMACRegister
-								    (pAd,
-								     offset + i,
-								     Value);
-								RTUSBWriteMACRegister
-								    (pAd,
-								     offset2 +
-								     i, Value);
-								i += 4;
-							}
-
-							/* 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0 */
-							WCIDAttri =
-							    (pAd->
-							     SharedKey[BSS0]
-							     [KeyIdx].
-							     CipherAlg << 1) |
-							    SHAREDKEYTABLE;
-							offset =
-							    MAC_WCID_ATTRIBUTE_BASE
-							    +
-							    (BSS0Mcast_WCID *
-							     HW_WCID_ATTRI_SIZE);
-							DBGPRINT(RT_DEBUG_TRACE,
-								 ("BSS0Mcast_WCID : offset = %x, WCIDAttri = %x\n",
-								  offset,
-								  WCIDAttri));
-							RTUSBWriteMACRegister
-							    (pAd, offset,
-							     WCIDAttri);
-
-						}
-						AsicAddSharedKeyEntry(pAd, BSS0,
-								      (u8)
-								      KeyIdx,
-								      CipherAlg,
-								      pWepKey->
-								      KeyMaterial,
-								      NULL,
-								      NULL);
-						DBGPRINT(RT_DEBUG_TRACE,
-							 ("CmdThread::OID_802_11_ADD_WEP (KeyIdx=%d, Len=%d-byte)\n",
-							  KeyIdx,
-							  pWepKey->KeyLength));
-					}
-				}
-				break;
-
-			case CMDTHREAD_802_11_COUNTER_MEASURE:
-				break;
-
-			case CMDTHREAD_SET_GROUP_KEY:
-				WpaStaGroupKeySetting(pAd);
-				break;
-
-			case CMDTHREAD_SET_PAIRWISE_KEY:
-				WpaStaPairwiseKeySetting(pAd);
-				break;
-
-			case CMDTHREAD_SET_PSM_BIT:
-				{
-					u16 *pPsm = (u16 *) pData;
-					MlmeSetPsmBit(pAd, *pPsm);
-				}
-				break;
-			case CMDTHREAD_FORCE_WAKE_UP:
-				AsicForceWakeup(pAd, TRUE);
-				break;
-
-			default:
-				DBGPRINT(RT_DEBUG_ERROR,
-					 ("--> Control Thread !! ERROR !! Unknown(cmdqelmt->command=0x%x) !! \n",
-					  cmdqelmt->command));
-				break;
-			}
-		}
-
-		if (cmdqelmt->CmdFromNdis == TRUE) {
-			if (cmdqelmt->buffer != NULL)
-				os_free_mem(pAd, cmdqelmt->buffer);
-			os_free_mem(pAd, cmdqelmt);
-		} else {
-			if ((cmdqelmt->buffer != NULL)
-			    && (cmdqelmt->bufferlength != 0))
-				os_free_mem(pAd, cmdqelmt->buffer);
-			os_free_mem(pAd, cmdqelmt);
-		}
-	}			/* end of while */
-}
-
-#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2870/common/spectrum.c b/drivers/staging/rt2870/common/spectrum.c
deleted file mode 100644
index 1cf2c26..0000000
--- a/drivers/staging/rt2870/common/spectrum.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/common/spectrum.c"
diff --git a/drivers/staging/rt2870/dfs.h b/drivers/staging/rt2870/dfs.h
deleted file mode 100644
index 1fdbd7b..0000000
--- a/drivers/staging/rt2870/dfs.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/dfs.h"
diff --git a/drivers/staging/rt2870/md5.h b/drivers/staging/rt2870/md5.h
deleted file mode 100644
index d60cd05..0000000
--- a/drivers/staging/rt2870/md5.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/md5.h"
diff --git a/drivers/staging/rt2870/mlme.h b/drivers/staging/rt2870/mlme.h
deleted file mode 100644
index 58753ac..0000000
--- a/drivers/staging/rt2870/mlme.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/mlme.h"
diff --git a/drivers/staging/rt2870/oid.h b/drivers/staging/rt2870/oid.h
deleted file mode 100644
index 1223d81..0000000
--- a/drivers/staging/rt2870/oid.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/oid.h"
diff --git a/drivers/staging/rt2870/rt28xx.h b/drivers/staging/rt2870/rt28xx.h
deleted file mode 100644
index 29bad95..0000000
--- a/drivers/staging/rt2870/rt28xx.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt28xx.h"
diff --git a/drivers/staging/rt2870/rt_config.h b/drivers/staging/rt2870/rt_config.h
deleted file mode 100644
index 1f6d6ed..0000000
--- a/drivers/staging/rt2870/rt_config.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_config.h"
diff --git a/drivers/staging/rt2870/rt_linux.c b/drivers/staging/rt2870/rt_linux.c
deleted file mode 100644
index 88c697b..0000000
--- a/drivers/staging/rt2870/rt_linux.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_linux.c"
diff --git a/drivers/staging/rt2870/rt_linux.h b/drivers/staging/rt2870/rt_linux.h
deleted file mode 100644
index b2aeafb..0000000
--- a/drivers/staging/rt2870/rt_linux.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_linux.h"
diff --git a/drivers/staging/rt2870/rt_main_dev.c b/drivers/staging/rt2870/rt_main_dev.c
deleted file mode 100644
index 121e163..0000000
--- a/drivers/staging/rt2870/rt_main_dev.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_main_dev.c"
diff --git a/drivers/staging/rt2870/rt_profile.c b/drivers/staging/rt2870/rt_profile.c
deleted file mode 100644
index 15988c5..0000000
--- a/drivers/staging/rt2870/rt_profile.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_profile.c"
diff --git a/drivers/staging/rt2870/rt_usb.c b/drivers/staging/rt2870/rt_usb.c
deleted file mode 100644
index 5e02d4c..0000000
--- a/drivers/staging/rt2870/rt_usb.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rt_usb.c"
diff --git a/drivers/staging/rt2870/rtmp.h b/drivers/staging/rt2870/rtmp.h
deleted file mode 100644
index e5ef89f..0000000
--- a/drivers/staging/rt2870/rtmp.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rtmp.h"
diff --git a/drivers/staging/rt2870/rtmp_ckipmic.h b/drivers/staging/rt2870/rtmp_ckipmic.h
deleted file mode 100644
index 0e7f1df..0000000
--- a/drivers/staging/rt2870/rtmp_ckipmic.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rtmp_ckipmic.h"
diff --git a/drivers/staging/rt2870/rtmp_def.h b/drivers/staging/rt2870/rtmp_def.h
deleted file mode 100644
index 839d791..0000000
--- a/drivers/staging/rt2870/rtmp_def.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rtmp_def.h"
diff --git a/drivers/staging/rt2870/rtmp_type.h b/drivers/staging/rt2870/rtmp_type.h
deleted file mode 100644
index fbf97d0..0000000
--- a/drivers/staging/rt2870/rtmp_type.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/rtmp_type.h"
diff --git a/drivers/staging/rt2870/spectrum.h b/drivers/staging/rt2870/spectrum.h
deleted file mode 100644
index 8aa23a1..0000000
--- a/drivers/staging/rt2870/spectrum.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/spectrum.h"
diff --git a/drivers/staging/rt2870/spectrum_def.h b/drivers/staging/rt2870/spectrum_def.h
deleted file mode 100644
index a65f551..0000000
--- a/drivers/staging/rt2870/spectrum_def.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/spectrum_def.h"
diff --git a/drivers/staging/rt2870/sta/aironet.c b/drivers/staging/rt2870/sta/aironet.c
deleted file mode 100644
index 72b7f2e..0000000
--- a/drivers/staging/rt2870/sta/aironet.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/aironet.c"
diff --git a/drivers/staging/rt2870/sta/assoc.c b/drivers/staging/rt2870/sta/assoc.c
deleted file mode 100644
index 46564d7..0000000
--- a/drivers/staging/rt2870/sta/assoc.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/assoc.c"
diff --git a/drivers/staging/rt2870/sta/auth.c b/drivers/staging/rt2870/sta/auth.c
deleted file mode 100644
index 57632f9..0000000
--- a/drivers/staging/rt2870/sta/auth.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/auth.c"
diff --git a/drivers/staging/rt2870/sta/auth_rsp.c b/drivers/staging/rt2870/sta/auth_rsp.c
deleted file mode 100644
index 783e266..0000000
--- a/drivers/staging/rt2870/sta/auth_rsp.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/auth_rsp.c"
diff --git a/drivers/staging/rt2870/sta/connect.c b/drivers/staging/rt2870/sta/connect.c
deleted file mode 100644
index f6c7bbf..0000000
--- a/drivers/staging/rt2870/sta/connect.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/connect.c"
diff --git a/drivers/staging/rt2870/sta/rtmp_data.c b/drivers/staging/rt2870/sta/rtmp_data.c
deleted file mode 100644
index b67e069..0000000
--- a/drivers/staging/rt2870/sta/rtmp_data.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/rtmp_data.c"
diff --git a/drivers/staging/rt2870/sta/sanity.c b/drivers/staging/rt2870/sta/sanity.c
deleted file mode 100644
index f1f2333..0000000
--- a/drivers/staging/rt2870/sta/sanity.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/sanity.c"
diff --git a/drivers/staging/rt2870/sta/sync.c b/drivers/staging/rt2870/sta/sync.c
deleted file mode 100644
index 66c8772..0000000
--- a/drivers/staging/rt2870/sta/sync.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/sync.c"
diff --git a/drivers/staging/rt2870/sta/wpa.c b/drivers/staging/rt2870/sta/wpa.c
deleted file mode 100644
index 57a2eb2..0000000
--- a/drivers/staging/rt2870/sta/wpa.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../../rt2860/sta/wpa.c"
diff --git a/drivers/staging/rt2870/sta_ioctl.c b/drivers/staging/rt2870/sta_ioctl.c
deleted file mode 100644
index 3553a6c..0000000
--- a/drivers/staging/rt2870/sta_ioctl.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/sta_ioctl.c"
diff --git a/drivers/staging/rt2870/usb_main_dev.c b/drivers/staging/rt2870/usb_main_dev.c
deleted file mode 100644
index 6e63bc5..0000000
--- a/drivers/staging/rt2870/usb_main_dev.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/usb_main_dev.c"
diff --git a/drivers/staging/rt2870/wpa.h b/drivers/staging/rt2870/wpa.h
deleted file mode 100644
index 7125072..0000000
--- a/drivers/staging/rt2870/wpa.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "../rt2860/wpa.h"
-- 
1.7.5.4

